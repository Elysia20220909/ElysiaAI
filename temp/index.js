// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
	target = mod != null ? __create(__getProtoOf(mod)) : {};
	const to =
		isNodeMode || !mod || !mod.__esModule
			? __defProp(target, "default", { value: mod, enumerable: true })
			: target;
	for (let key of __getOwnPropNames(mod))
		if (!__hasOwnProp.call(to, key))
			__defProp(to, key, {
				get: () => mod[key],
				enumerable: true,
			});
	return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
	for (var name in all)
		__defProp(target, name, {
			get: all[name],
			enumerable: true,
			configurable: true,
			set: (newValue) => (all[name] = () => newValue),
		});
};
var __esm = (fn, res) => () => (fn && (res = fn((fn = 0))), res);
var __require = import.meta.require;

// node_modules/strtok3/lib/stream/Errors.js
var defaultMessages = "End-Of-Stream",
	EndOfStreamError,
	AbortError;
var init_Errors = __esm(() => {
	EndOfStreamError = class EndOfStreamError extends Error {
		constructor() {
			super(defaultMessages);
			this.name = "EndOfStreamError";
		}
	};
	AbortError = class AbortError extends Error {
		constructor(message = "The operation was aborted") {
			super(message);
			this.name = "AbortError";
		}
	};
});

// node_modules/strtok3/lib/stream/Deferred.js
class Deferred {
	constructor() {
		this.resolve = () => null;
		this.reject = () => null;
		this.promise = new Promise((resolve, reject) => {
			this.reject = reject;
			this.resolve = resolve;
		});
	}
}

// node_modules/strtok3/lib/stream/AbstractStreamReader.js
class AbstractStreamReader {
	constructor() {
		this.endOfStream = false;
		this.interrupted = false;
		this.peekQueue = [];
	}
	async peek(uint8Array, mayBeLess = false) {
		const bytesRead = await this.read(uint8Array, mayBeLess);
		this.peekQueue.push(uint8Array.subarray(0, bytesRead));
		return bytesRead;
	}
	async read(buffer, mayBeLess = false) {
		if (buffer.length === 0) {
			return 0;
		}
		let bytesRead = this.readFromPeekBuffer(buffer);
		if (!this.endOfStream) {
			bytesRead += await this.readRemainderFromStream(buffer.subarray(bytesRead), mayBeLess);
		}
		if (bytesRead === 0 && !mayBeLess) {
			throw new EndOfStreamError();
		}
		return bytesRead;
	}
	readFromPeekBuffer(buffer) {
		let remaining = buffer.length;
		let bytesRead = 0;
		while (this.peekQueue.length > 0 && remaining > 0) {
			const peekData = this.peekQueue.pop();
			if (!peekData) throw new Error("peekData should be defined");
			const lenCopy = Math.min(peekData.length, remaining);
			buffer.set(peekData.subarray(0, lenCopy), bytesRead);
			bytesRead += lenCopy;
			remaining -= lenCopy;
			if (lenCopy < peekData.length) {
				this.peekQueue.push(peekData.subarray(lenCopy));
			}
		}
		return bytesRead;
	}
	async readRemainderFromStream(buffer, mayBeLess) {
		let bytesRead = 0;
		while (bytesRead < buffer.length && !this.endOfStream) {
			if (this.interrupted) {
				throw new AbortError();
			}
			const chunkLen = await this.readFromStream(buffer.subarray(bytesRead), mayBeLess);
			if (chunkLen === 0) break;
			bytesRead += chunkLen;
		}
		if (!mayBeLess && bytesRead < buffer.length) {
			throw new EndOfStreamError();
		}
		return bytesRead;
	}
}
var init_AbstractStreamReader = __esm(() => {
	init_Errors();
});

// node_modules/strtok3/lib/stream/StreamReader.js
var StreamReader;
var init_StreamReader = __esm(() => {
	init_Errors();
	init_AbstractStreamReader();
	StreamReader = class StreamReader extends AbstractStreamReader {
		constructor(s) {
			super();
			this.s = s;
			this.deferred = null;
			if (!s.read || !s.once) {
				throw new Error("Expected an instance of stream.Readable");
			}
			this.s.once("end", () => {
				this.endOfStream = true;
				if (this.deferred) {
					this.deferred.resolve(0);
				}
			});
			this.s.once("error", (err) => this.reject(err));
			this.s.once("close", () => this.abort());
		}
		async readFromStream(buffer, mayBeLess) {
			if (buffer.length === 0) return 0;
			const readBuffer = this.s.read(buffer.length);
			if (readBuffer) {
				buffer.set(readBuffer);
				return readBuffer.length;
			}
			const request = {
				buffer,
				mayBeLess,
				deferred: new Deferred(),
			};
			this.deferred = request.deferred;
			this.s.once("readable", () => {
				this.readDeferred(request);
			});
			return request.deferred.promise;
		}
		readDeferred(request) {
			const readBuffer = this.s.read(request.buffer.length);
			if (readBuffer) {
				request.buffer.set(readBuffer);
				request.deferred.resolve(readBuffer.length);
				this.deferred = null;
			} else {
				this.s.once("readable", () => {
					this.readDeferred(request);
				});
			}
		}
		reject(err) {
			this.interrupted = true;
			if (this.deferred) {
				this.deferred.reject(err);
				this.deferred = null;
			}
		}
		async abort() {
			this.reject(new AbortError());
		}
		async close() {
			return this.abort();
		}
	};
});

// node_modules/strtok3/lib/stream/WebStreamReader.js
var WebStreamReader;
var init_WebStreamReader = __esm(() => {
	init_AbstractStreamReader();
	WebStreamReader = class WebStreamReader extends AbstractStreamReader {
		constructor(reader) {
			super();
			this.reader = reader;
		}
		async abort() {
			return this.close();
		}
		async close() {
			this.reader.releaseLock();
		}
	};
});

// node_modules/strtok3/lib/stream/WebStreamByobReader.js
var WebStreamByobReader;
var init_WebStreamByobReader = __esm(() => {
	init_WebStreamReader();
	WebStreamByobReader = class WebStreamByobReader extends WebStreamReader {
		async readFromStream(buffer, mayBeLess) {
			if (buffer.length === 0) return 0;
			const result = await this.reader.read(new Uint8Array(buffer.length), {
				min: mayBeLess ? undefined : buffer.length,
			});
			if (result.done) {
				this.endOfStream = result.done;
			}
			if (result.value) {
				buffer.set(result.value);
				return result.value.length;
			}
			return 0;
		}
	};
});

// node_modules/strtok3/lib/stream/WebStreamDefaultReader.js
var WebStreamDefaultReader;
var init_WebStreamDefaultReader = __esm(() => {
	init_Errors();
	init_AbstractStreamReader();
	WebStreamDefaultReader = class WebStreamDefaultReader extends AbstractStreamReader {
		constructor(reader) {
			super();
			this.reader = reader;
			this.buffer = null;
		}
		writeChunk(target, chunk) {
			const written = Math.min(chunk.length, target.length);
			target.set(chunk.subarray(0, written));
			if (written < chunk.length) {
				this.buffer = chunk.subarray(written);
			} else {
				this.buffer = null;
			}
			return written;
		}
		async readFromStream(buffer, mayBeLess) {
			if (buffer.length === 0) return 0;
			let totalBytesRead = 0;
			if (this.buffer) {
				totalBytesRead += this.writeChunk(buffer, this.buffer);
			}
			while (totalBytesRead < buffer.length && !this.endOfStream) {
				const result = await this.reader.read();
				if (result.done) {
					this.endOfStream = true;
					break;
				}
				if (result.value) {
					totalBytesRead += this.writeChunk(buffer.subarray(totalBytesRead), result.value);
				}
			}
			if (!mayBeLess && totalBytesRead === 0 && this.endOfStream) {
				throw new EndOfStreamError();
			}
			return totalBytesRead;
		}
		abort() {
			this.interrupted = true;
			return this.reader.cancel();
		}
		async close() {
			await this.abort();
			this.reader.releaseLock();
		}
	};
});

// node_modules/strtok3/lib/stream/WebStreamReaderFactory.js
function makeWebStreamReader(stream) {
	try {
		const reader = stream.getReader({ mode: "byob" });
		if (reader instanceof ReadableStreamDefaultReader) {
			return new WebStreamDefaultReader(reader);
		}
		return new WebStreamByobReader(reader);
	} catch (error) {
		if (error instanceof TypeError) {
			return new WebStreamDefaultReader(stream.getReader());
		}
		throw error;
	}
}
var init_WebStreamReaderFactory = __esm(() => {
	init_WebStreamByobReader();
	init_WebStreamDefaultReader();
});

// node_modules/strtok3/lib/stream/index.js
var init_stream = __esm(() => {
	init_Errors();
	init_StreamReader();
	init_WebStreamByobReader();
	init_WebStreamDefaultReader();
	init_WebStreamReaderFactory();
});

// node_modules/strtok3/lib/AbstractTokenizer.js
class AbstractTokenizer {
	constructor(options) {
		this.numBuffer = new Uint8Array(8);
		this.position = 0;
		this.onClose = options?.onClose;
		if (options?.abortSignal) {
			options.abortSignal.addEventListener("abort", () => {
				this.abort();
			});
		}
	}
	async readToken(token, position = this.position) {
		const uint8Array = new Uint8Array(token.len);
		const len = await this.readBuffer(uint8Array, { position });
		if (len < token.len) throw new EndOfStreamError();
		return token.get(uint8Array, 0);
	}
	async peekToken(token, position = this.position) {
		const uint8Array = new Uint8Array(token.len);
		const len = await this.peekBuffer(uint8Array, { position });
		if (len < token.len) throw new EndOfStreamError();
		return token.get(uint8Array, 0);
	}
	async readNumber(token) {
		const len = await this.readBuffer(this.numBuffer, { length: token.len });
		if (len < token.len) throw new EndOfStreamError();
		return token.get(this.numBuffer, 0);
	}
	async peekNumber(token) {
		const len = await this.peekBuffer(this.numBuffer, { length: token.len });
		if (len < token.len) throw new EndOfStreamError();
		return token.get(this.numBuffer, 0);
	}
	async ignore(length) {
		if (this.fileInfo.size !== undefined) {
			const bytesLeft = this.fileInfo.size - this.position;
			if (length > bytesLeft) {
				this.position += bytesLeft;
				return bytesLeft;
			}
		}
		this.position += length;
		return length;
	}
	async close() {
		await this.abort();
		await this.onClose?.();
	}
	normalizeOptions(uint8Array, options) {
		if (
			!this.supportsRandomAccess() &&
			options &&
			options.position !== undefined &&
			options.position < this.position
		) {
			throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
		}
		return {
			...{
				mayBeLess: false,
				offset: 0,
				length: uint8Array.length,
				position: this.position,
			},
			...options,
		};
	}
	abort() {
		return Promise.resolve();
	}
}
var init_AbstractTokenizer = __esm(() => {
	init_stream();
});

// node_modules/strtok3/lib/ReadStreamTokenizer.js
var maxBufferSize = 256000,
	ReadStreamTokenizer;
var init_ReadStreamTokenizer = __esm(() => {
	init_AbstractTokenizer();
	init_stream();
	ReadStreamTokenizer = class ReadStreamTokenizer extends AbstractTokenizer {
		constructor(streamReader, options) {
			super(options);
			this.streamReader = streamReader;
			this.fileInfo = options?.fileInfo ?? {};
		}
		async readBuffer(uint8Array, options) {
			const normOptions = this.normalizeOptions(uint8Array, options);
			const skipBytes = normOptions.position - this.position;
			if (skipBytes > 0) {
				await this.ignore(skipBytes);
				return this.readBuffer(uint8Array, options);
			}
			if (skipBytes < 0) {
				throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
			}
			if (normOptions.length === 0) {
				return 0;
			}
			const bytesRead = await this.streamReader.read(
				uint8Array.subarray(0, normOptions.length),
				normOptions.mayBeLess,
			);
			this.position += bytesRead;
			if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
				throw new EndOfStreamError();
			}
			return bytesRead;
		}
		async peekBuffer(uint8Array, options) {
			const normOptions = this.normalizeOptions(uint8Array, options);
			let bytesRead = 0;
			if (normOptions.position) {
				const skipBytes = normOptions.position - this.position;
				if (skipBytes > 0) {
					const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
					bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
					uint8Array.set(skipBuffer.subarray(skipBytes));
					return bytesRead - skipBytes;
				}
				if (skipBytes < 0) {
					throw new Error("Cannot peek from a negative offset in a stream");
				}
			}
			if (normOptions.length > 0) {
				try {
					bytesRead = await this.streamReader.peek(
						uint8Array.subarray(0, normOptions.length),
						normOptions.mayBeLess,
					);
				} catch (err) {
					if (options?.mayBeLess && err instanceof EndOfStreamError) {
						return 0;
					}
					throw err;
				}
				if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
					throw new EndOfStreamError();
				}
			}
			return bytesRead;
		}
		async ignore(length) {
			const bufSize = Math.min(maxBufferSize, length);
			const buf = new Uint8Array(bufSize);
			let totBytesRead = 0;
			while (totBytesRead < length) {
				const remaining = length - totBytesRead;
				const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
				if (bytesRead < 0) {
					return bytesRead;
				}
				totBytesRead += bytesRead;
			}
			return totBytesRead;
		}
		abort() {
			return this.streamReader.abort();
		}
		async close() {
			return this.streamReader.close();
		}
		supportsRandomAccess() {
			return false;
		}
	};
});

// node_modules/strtok3/lib/BufferTokenizer.js
var BufferTokenizer;
var init_BufferTokenizer = __esm(() => {
	init_stream();
	init_AbstractTokenizer();
	BufferTokenizer = class BufferTokenizer extends AbstractTokenizer {
		constructor(uint8Array, options) {
			super(options);
			this.uint8Array = uint8Array;
			this.fileInfo = { ...(options?.fileInfo ?? {}), ...{ size: uint8Array.length } };
		}
		async readBuffer(uint8Array, options) {
			if (options?.position) {
				this.position = options.position;
			}
			const bytesRead = await this.peekBuffer(uint8Array, options);
			this.position += bytesRead;
			return bytesRead;
		}
		async peekBuffer(uint8Array, options) {
			const normOptions = this.normalizeOptions(uint8Array, options);
			const bytes2read = Math.min(
				this.uint8Array.length - normOptions.position,
				normOptions.length,
			);
			if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
				throw new EndOfStreamError();
			}
			uint8Array.set(
				this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read),
			);
			return bytes2read;
		}
		close() {
			return super.close();
		}
		supportsRandomAccess() {
			return true;
		}
		setPosition(position) {
			this.position = position;
		}
	};
});

// node_modules/strtok3/lib/BlobTokenizer.js
var BlobTokenizer;
var init_BlobTokenizer = __esm(() => {
	init_stream();
	init_AbstractTokenizer();
	BlobTokenizer = class BlobTokenizer extends AbstractTokenizer {
		constructor(blob, options) {
			super(options);
			this.blob = blob;
			this.fileInfo = { ...(options?.fileInfo ?? {}), ...{ size: blob.size, mimeType: blob.type } };
		}
		async readBuffer(uint8Array, options) {
			if (options?.position) {
				this.position = options.position;
			}
			const bytesRead = await this.peekBuffer(uint8Array, options);
			this.position += bytesRead;
			return bytesRead;
		}
		async peekBuffer(buffer, options) {
			const normOptions = this.normalizeOptions(buffer, options);
			const bytes2read = Math.min(this.blob.size - normOptions.position, normOptions.length);
			if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
				throw new EndOfStreamError();
			}
			const arrayBuffer = await this.blob
				.slice(normOptions.position, normOptions.position + bytes2read)
				.arrayBuffer();
			buffer.set(new Uint8Array(arrayBuffer));
			return bytes2read;
		}
		close() {
			return super.close();
		}
		supportsRandomAccess() {
			return true;
		}
		setPosition(position) {
			this.position = position;
		}
	};
});

// node_modules/strtok3/lib/core.js
function fromStream(stream, options) {
	const streamReader = new StreamReader(stream);
	const _options = options ?? {};
	const chainedClose = _options.onClose;
	_options.onClose = async () => {
		await streamReader.close();
		if (chainedClose) {
			return chainedClose();
		}
	};
	return new ReadStreamTokenizer(streamReader, _options);
}
function fromWebStream(webStream, options) {
	const webStreamReader = makeWebStreamReader(webStream);
	const _options = options ?? {};
	const chainedClose = _options.onClose;
	_options.onClose = async () => {
		await webStreamReader.close();
		if (chainedClose) {
			return chainedClose();
		}
	};
	return new ReadStreamTokenizer(webStreamReader, _options);
}
function fromBuffer(uint8Array, options) {
	return new BufferTokenizer(uint8Array, options);
}
function fromBlob(blob, options) {
	return new BlobTokenizer(blob, options);
}
var init_core = __esm(() => {
	init_stream();
	init_ReadStreamTokenizer();
	init_BufferTokenizer();
	init_BlobTokenizer();
	init_stream();
	init_AbstractTokenizer();
});

// node_modules/strtok3/lib/FileTokenizer.js
import { open as fsOpen } from "fs/promises";
var FileTokenizer;
var init_FileTokenizer = __esm(() => {
	init_AbstractTokenizer();
	init_stream();
	FileTokenizer = class FileTokenizer extends AbstractTokenizer {
		static async fromFile(sourceFilePath) {
			const fileHandle = await fsOpen(sourceFilePath, "r");
			const stat = await fileHandle.stat();
			return new FileTokenizer(fileHandle, { fileInfo: { path: sourceFilePath, size: stat.size } });
		}
		constructor(fileHandle, options) {
			super(options);
			this.fileHandle = fileHandle;
			this.fileInfo = options.fileInfo;
		}
		async readBuffer(uint8Array, options) {
			const normOptions = this.normalizeOptions(uint8Array, options);
			this.position = normOptions.position;
			if (normOptions.length === 0) return 0;
			const res = await this.fileHandle.read(
				uint8Array,
				0,
				normOptions.length,
				normOptions.position,
			);
			this.position += res.bytesRead;
			if (res.bytesRead < normOptions.length && (!options || !options.mayBeLess)) {
				throw new EndOfStreamError();
			}
			return res.bytesRead;
		}
		async peekBuffer(uint8Array, options) {
			const normOptions = this.normalizeOptions(uint8Array, options);
			const res = await this.fileHandle.read(
				uint8Array,
				0,
				normOptions.length,
				normOptions.position,
			);
			if (!normOptions.mayBeLess && res.bytesRead < normOptions.length) {
				throw new EndOfStreamError();
			}
			return res.bytesRead;
		}
		async close() {
			await this.fileHandle.close();
			return super.close();
		}
		setPosition(position) {
			this.position = position;
		}
		supportsRandomAccess() {
			return true;
		}
	};
});

// node_modules/strtok3/lib/index.js
import { stat as fsStat } from "fs/promises";
async function fromStream2(stream, options) {
	const rst = fromStream(stream, options);
	if (stream.path) {
		const stat = await fsStat(stream.path);
		rst.fileInfo.path = stream.path;
		rst.fileInfo.size = stat.size;
	}
	return rst;
}
var fromFile;
var init_lib = __esm(() => {
	init_core();
	init_FileTokenizer();
	init_FileTokenizer();
	init_core();
	fromFile = FileTokenizer.fromFile;
});

// node_modules/ieee754/index.js
var init_ieee754 = __esm(() => {
	/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/@borewit/text-codec/lib/index.js
function textDecode(bytes, encoding = "utf-8") {
	switch (encoding.toLowerCase()) {
		case "utf-8":
		case "utf8":
			if (typeof globalThis.TextDecoder !== "undefined") {
				return new globalThis.TextDecoder("utf-8").decode(bytes);
			}
			return decodeUTF8(bytes);
		case "utf-16le":
			return decodeUTF16LE(bytes);
		case "ascii":
			return decodeASCII(bytes);
		case "latin1":
		case "iso-8859-1":
			return decodeLatin1(bytes);
		case "windows-1252":
			return decodeWindows1252(bytes);
		default:
			throw new RangeError(`Encoding '${encoding}' not supported`);
	}
}
function decodeUTF8(bytes) {
	let out = "";
	let i = 0;
	while (i < bytes.length) {
		const b1 = bytes[i++];
		if (b1 < 128) {
			out += String.fromCharCode(b1);
		} else if (b1 < 224) {
			const b2 = bytes[i++] & 63;
			out += String.fromCharCode(((b1 & 31) << 6) | b2);
		} else if (b1 < 240) {
			const b2 = bytes[i++] & 63;
			const b3 = bytes[i++] & 63;
			out += String.fromCharCode(((b1 & 15) << 12) | (b2 << 6) | b3);
		} else {
			const b2 = bytes[i++] & 63;
			const b3 = bytes[i++] & 63;
			const b4 = bytes[i++] & 63;
			let cp = ((b1 & 7) << 18) | (b2 << 12) | (b3 << 6) | b4;
			cp -= 65536;
			out += String.fromCharCode(55296 + ((cp >> 10) & 1023), 56320 + (cp & 1023));
		}
	}
	return out;
}
function decodeUTF16LE(bytes) {
	let out = "";
	for (let i = 0; i < bytes.length; i += 2) {
		out += String.fromCharCode(bytes[i] | (bytes[i + 1] << 8));
	}
	return out;
}
function decodeASCII(bytes) {
	return String.fromCharCode(...bytes.map((b) => b & 127));
}
function decodeLatin1(bytes) {
	return String.fromCharCode(...bytes);
}
function decodeWindows1252(bytes) {
	let out = "";
	for (const b of bytes) {
		if (b >= 128 && b <= 159 && WINDOWS_1252_EXTRA[b]) {
			out += WINDOWS_1252_EXTRA[b];
		} else {
			out += String.fromCharCode(b);
		}
	}
	return out;
}
var WINDOWS_1252_EXTRA, WINDOWS_1252_REVERSE;
var init_lib2 = __esm(() => {
	WINDOWS_1252_EXTRA = {
		128: "\u20AC",
		130: "\u201A",
		131: "\u0192",
		132: "\u201E",
		133: "\u2026",
		134: "\u2020",
		135: "\u2021",
		136: "\u02C6",
		137: "\u2030",
		138: "\u0160",
		139: "\u2039",
		140: "\u0152",
		142: "\u017D",
		145: "\u2018",
		146: "\u2019",
		147: "\u201C",
		148: "\u201D",
		149: "\u2022",
		150: "\u2013",
		151: "\u2014",
		152: "\u02DC",
		153: "\u2122",
		154: "\u0161",
		155: "\u203A",
		156: "\u0153",
		158: "\u017E",
		159: "\u0178",
	};
	WINDOWS_1252_REVERSE = {};
	for (const [code, char] of Object.entries(WINDOWS_1252_EXTRA)) {
		WINDOWS_1252_REVERSE[char] = Number.parseInt(code);
	}
});

// node_modules/token-types/lib/index.js
function dv(array) {
	return new DataView(array.buffer, array.byteOffset);
}

class StringType2 {
	constructor(len, encoding) {
		this.len = len;
		this.encoding = encoding;
	}
	get(data, offset = 0) {
		const bytes = data.subarray(offset, offset + this.len);
		return textDecode(bytes, this.encoding);
	}
}
var UINT8, UINT16_LE, UINT16_BE, UINT32_LE, UINT32_BE, INT32_BE, UINT64_LE;
var init_lib3 = __esm(() => {
	init_ieee754();
	init_lib2();
	UINT8 = {
		len: 1,
		get(array, offset) {
			return dv(array).getUint8(offset);
		},
		put(array, offset, value) {
			dv(array).setUint8(offset, value);
			return offset + 1;
		},
	};
	UINT16_LE = {
		len: 2,
		get(array, offset) {
			return dv(array).getUint16(offset, true);
		},
		put(array, offset, value) {
			dv(array).setUint16(offset, value, true);
			return offset + 2;
		},
	};
	UINT16_BE = {
		len: 2,
		get(array, offset) {
			return dv(array).getUint16(offset);
		},
		put(array, offset, value) {
			dv(array).setUint16(offset, value);
			return offset + 2;
		},
	};
	UINT32_LE = {
		len: 4,
		get(array, offset) {
			return dv(array).getUint32(offset, true);
		},
		put(array, offset, value) {
			dv(array).setUint32(offset, value, true);
			return offset + 4;
		},
	};
	UINT32_BE = {
		len: 4,
		get(array, offset) {
			return dv(array).getUint32(offset);
		},
		put(array, offset, value) {
			dv(array).setUint32(offset, value);
			return offset + 4;
		},
	};
	INT32_BE = {
		len: 4,
		get(array, offset) {
			return dv(array).getInt32(offset);
		},
		put(array, offset, value) {
			dv(array).setInt32(offset, value);
			return offset + 4;
		},
	};
	UINT64_LE = {
		len: 8,
		get(array, offset) {
			return dv(array).getBigUint64(offset, true);
		},
		put(array, offset, value) {
			dv(array).setBigUint64(offset, value, true);
			return offset + 8;
		},
	};
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;
	module.exports = function (val, options) {
		options = options || {};
		var type = typeof val;
		if (type === "string" && val.length > 0) {
			return parse2(val);
		} else if (type === "number" && isFinite(val)) {
			return options.long ? fmtLong(val) : fmtShort(val);
		}
		throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
	};
	function parse2(str) {
		str = String(str);
		if (str.length > 100) {
			return;
		}
		var match =
			/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
				str,
			);
		if (!match) {
			return;
		}
		var n = parseFloat(match[1]);
		var type = (match[2] || "ms").toLowerCase();
		switch (type) {
			case "years":
			case "year":
			case "yrs":
			case "yr":
			case "y":
				return n * y;
			case "weeks":
			case "week":
			case "w":
				return n * w;
			case "days":
			case "day":
			case "d":
				return n * d;
			case "hours":
			case "hour":
			case "hrs":
			case "hr":
			case "h":
				return n * h;
			case "minutes":
			case "minute":
			case "mins":
			case "min":
			case "m":
				return n * m;
			case "seconds":
			case "second":
			case "secs":
			case "sec":
			case "s":
				return n * s;
			case "milliseconds":
			case "millisecond":
			case "msecs":
			case "msec":
			case "ms":
				return n;
			default:
				return;
		}
	}
	function fmtShort(ms) {
		var msAbs = Math.abs(ms);
		if (msAbs >= d) {
			return Math.round(ms / d) + "d";
		}
		if (msAbs >= h) {
			return Math.round(ms / h) + "h";
		}
		if (msAbs >= m) {
			return Math.round(ms / m) + "m";
		}
		if (msAbs >= s) {
			return Math.round(ms / s) + "s";
		}
		return ms + "ms";
	}
	function fmtLong(ms) {
		var msAbs = Math.abs(ms);
		if (msAbs >= d) {
			return plural(ms, msAbs, d, "day");
		}
		if (msAbs >= h) {
			return plural(ms, msAbs, h, "hour");
		}
		if (msAbs >= m) {
			return plural(ms, msAbs, m, "minute");
		}
		if (msAbs >= s) {
			return plural(ms, msAbs, s, "second");
		}
		return ms + " ms";
	}
	function plural(ms, msAbs, n, name) {
		var isPlural = msAbs >= n * 1.5;
		return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
	}
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
	function setup(env) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = require_ms();
		createDebug.destroy = destroy;
		Object.keys(env).forEach((key) => {
			createDebug[key] = env[key];
		});
		createDebug.names = [];
		createDebug.skips = [];
		createDebug.formatters = {};
		function selectColor(namespace) {
			let hash2 = 0;
			for (let i = 0; i < namespace.length; i++) {
				hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
				hash2 |= 0;
			}
			return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;
			function debug(...args) {
				if (!debug.enabled) {
					return;
				}
				const self2 = debug;
				const curr = Number(new Date());
				const ms = curr - (prevTime || curr);
				self2.diff = ms;
				self2.prev = prevTime;
				self2.curr = curr;
				prevTime = curr;
				args[0] = createDebug.coerce(args[0]);
				if (typeof args[0] !== "string") {
					args.unshift("%O");
				}
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					if (match === "%%") {
						return "%";
					}
					index++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === "function") {
						const val = args[index];
						match = formatter.call(self2, val);
						args.splice(index, 1);
						index--;
					}
					return match;
				});
				createDebug.formatArgs.call(self2, args);
				const logFn = self2.log || createDebug.log;
				logFn.apply(self2, args);
			}
			debug.namespace = namespace;
			debug.useColors = createDebug.useColors();
			debug.color = createDebug.selectColor(namespace);
			debug.extend = extend;
			debug.destroy = createDebug.destroy;
			Object.defineProperty(debug, "enabled", {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) {
						return enableOverride;
					}
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}
					return enabledCache;
				},
				set: (v) => {
					enableOverride = v;
				},
			});
			if (typeof createDebug.init === "function") {
				createDebug.init(debug);
			}
			return debug;
		}
		function extend(namespace, delimiter) {
			const newDebug = createDebug(
				this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace,
			);
			newDebug.log = this.log;
			return newDebug;
		}
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;
			createDebug.names = [];
			createDebug.skips = [];
			const split = (typeof namespaces === "string" ? namespaces : "")
				.trim()
				.replace(/\s+/g, ",")
				.split(",")
				.filter(Boolean);
			for (const ns of split) {
				if (ns[0] === "-") {
					createDebug.skips.push(ns.slice(1));
				} else {
					createDebug.names.push(ns);
				}
			}
		}
		function matchesTemplate(search, template) {
			let searchIndex = 0;
			let templateIndex = 0;
			let starIndex = -1;
			let matchIndex = 0;
			while (searchIndex < search.length) {
				if (
					templateIndex < template.length &&
					(template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")
				) {
					if (template[templateIndex] === "*") {
						starIndex = templateIndex;
						matchIndex = searchIndex;
						templateIndex++;
					} else {
						searchIndex++;
						templateIndex++;
					}
				} else if (starIndex !== -1) {
					templateIndex = starIndex + 1;
					matchIndex++;
					searchIndex = matchIndex;
				} else {
					return false;
				}
			}
			while (templateIndex < template.length && template[templateIndex] === "*") {
				templateIndex++;
			}
			return templateIndex === template.length;
		}
		function disable() {
			const namespaces = [
				...createDebug.names,
				...createDebug.skips.map((namespace) => "-" + namespace),
			].join(",");
			createDebug.enable("");
			return namespaces;
		}
		function enabled(name) {
			for (const skip of createDebug.skips) {
				if (matchesTemplate(name, skip)) {
					return false;
				}
			}
			for (const ns of createDebug.names) {
				if (matchesTemplate(name, ns)) {
					return true;
				}
			}
			return false;
		}
		function coerce(val) {
			if (val instanceof Error) {
				return val.stack || val.message;
			}
			return val;
		}
		function destroy() {
			console.warn(
				"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
			);
		}
		createDebug.enable(createDebug.load());
		return createDebug;
	}
	module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = localstorage();
	exports.destroy = (() => {
		let warned = false;
		return () => {
			if (!warned) {
				warned = true;
				console.warn(
					"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
				);
			}
		};
	})();
	exports.colors = [
		"#0000CC",
		"#0000FF",
		"#0033CC",
		"#0033FF",
		"#0066CC",
		"#0066FF",
		"#0099CC",
		"#0099FF",
		"#00CC00",
		"#00CC33",
		"#00CC66",
		"#00CC99",
		"#00CCCC",
		"#00CCFF",
		"#3300CC",
		"#3300FF",
		"#3333CC",
		"#3333FF",
		"#3366CC",
		"#3366FF",
		"#3399CC",
		"#3399FF",
		"#33CC00",
		"#33CC33",
		"#33CC66",
		"#33CC99",
		"#33CCCC",
		"#33CCFF",
		"#6600CC",
		"#6600FF",
		"#6633CC",
		"#6633FF",
		"#66CC00",
		"#66CC33",
		"#9900CC",
		"#9900FF",
		"#9933CC",
		"#9933FF",
		"#99CC00",
		"#99CC33",
		"#CC0000",
		"#CC0033",
		"#CC0066",
		"#CC0099",
		"#CC00CC",
		"#CC00FF",
		"#CC3300",
		"#CC3333",
		"#CC3366",
		"#CC3399",
		"#CC33CC",
		"#CC33FF",
		"#CC6600",
		"#CC6633",
		"#CC9900",
		"#CC9933",
		"#CCCC00",
		"#CCCC33",
		"#FF0000",
		"#FF0033",
		"#FF0066",
		"#FF0099",
		"#FF00CC",
		"#FF00FF",
		"#FF3300",
		"#FF3333",
		"#FF3366",
		"#FF3399",
		"#FF33CC",
		"#FF33FF",
		"#FF6600",
		"#FF6633",
		"#FF9900",
		"#FF9933",
		"#FFCC00",
		"#FFCC33",
	];
	function useColors() {
		if (
			typeof window !== "undefined" &&
			window.process &&
			(window.process.type === "renderer" || window.process.__nwjs)
		) {
			return true;
		}
		if (
			typeof navigator !== "undefined" &&
			navigator.userAgent &&
			navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
		) {
			return false;
		}
		let m;
		return (
			(typeof document !== "undefined" &&
				document.documentElement &&
				document.documentElement.style &&
				document.documentElement.style.WebkitAppearance) ||
			(typeof window !== "undefined" &&
				window.console &&
				(window.console.firebug || (window.console.exception && window.console.table))) ||
			(typeof navigator !== "undefined" &&
				navigator.userAgent &&
				(m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) &&
				parseInt(m[1], 10) >= 31) ||
			(typeof navigator !== "undefined" &&
				navigator.userAgent &&
				navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
		);
	}
	function formatArgs(args) {
		args[0] =
			(this.useColors ? "%c" : "") +
			this.namespace +
			(this.useColors ? " %c" : " ") +
			args[0] +
			(this.useColors ? "%c " : " ") +
			"+" +
			module.exports.humanize(this.diff);
		if (!this.useColors) {
			return;
		}
		const c = "color: " + this.color;
		args.splice(1, 0, c, "color: inherit");
		let index = 0;
		let lastC = 0;
		args[0].replace(/%[a-zA-Z%]/g, (match) => {
			if (match === "%%") {
				return;
			}
			index++;
			if (match === "%c") {
				lastC = index;
			}
		});
		args.splice(lastC, 0, c);
	}
	exports.log = console.debug || console.log || (() => {});
	function save(namespaces) {
		try {
			if (namespaces) {
				exports.storage.setItem("debug", namespaces);
			} else {
				exports.storage.removeItem("debug");
			}
		} catch (error) {}
	}
	function load() {
		let r;
		try {
			r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
		} catch (error) {}
		if (!r && typeof process !== "undefined" && "env" in process) {
			r = process.env.DEBUG;
		}
		return r;
	}
	function localstorage() {
		try {
			return localStorage;
		} catch (error) {}
	}
	module.exports = require_common()(exports);
	var { formatters } = module.exports;
	formatters.j = function (v) {
		try {
			return JSON.stringify(v);
		} catch (error) {
			return "[UnexpectedJSONParseError]: " + error.message;
		}
	};
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
	module.exports = (flag, argv = process.argv) => {
		const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
		const position = argv.indexOf(prefix + flag);
		const terminatorPosition = argv.indexOf("--");
		return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
	};
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
	var os = __require("os");
	var tty = __require("tty");
	var hasFlag = require_has_flag();
	var { env } = process;
	var forceColor;
	if (
		hasFlag("no-color") ||
		hasFlag("no-colors") ||
		hasFlag("color=false") ||
		hasFlag("color=never")
	) {
		forceColor = 0;
	} else if (
		hasFlag("color") ||
		hasFlag("colors") ||
		hasFlag("color=true") ||
		hasFlag("color=always")
	) {
		forceColor = 1;
	}
	if ("FORCE_COLOR" in env) {
		if (env.FORCE_COLOR === "true") {
			forceColor = 1;
		} else if (env.FORCE_COLOR === "false") {
			forceColor = 0;
		} else {
			forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
		}
	}
	function translateLevel(level) {
		if (level === 0) {
			return false;
		}
		return {
			level,
			hasBasic: true,
			has256: level >= 2,
			has16m: level >= 3,
		};
	}
	function supportsColor(haveStream, streamIsTTY) {
		if (forceColor === 0) {
			return 0;
		}
		if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
			return 3;
		}
		if (hasFlag("color=256")) {
			return 2;
		}
		if (haveStream && !streamIsTTY && forceColor === undefined) {
			return 0;
		}
		const min = forceColor || 0;
		if (env.TERM === "dumb") {
			return min;
		}
		if (process.platform === "win32") {
			const osRelease = os.release().split(".");
			if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
				return Number(osRelease[2]) >= 14931 ? 3 : 2;
			}
			return 1;
		}
		if ("CI" in env) {
			if (
				["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some(
					(sign) => sign in env,
				) ||
				env.CI_NAME === "codeship"
			) {
				return 1;
			}
			return min;
		}
		if ("TEAMCITY_VERSION" in env) {
			return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
		}
		if (env.COLORTERM === "truecolor") {
			return 3;
		}
		if ("TERM_PROGRAM" in env) {
			const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
			switch (env.TERM_PROGRAM) {
				case "iTerm.app":
					return version >= 3 ? 3 : 2;
				case "Apple_Terminal":
					return 2;
			}
		}
		if (/-256(color)?$/i.test(env.TERM)) {
			return 2;
		}
		if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
			return 1;
		}
		if ("COLORTERM" in env) {
			return 1;
		}
		return min;
	}
	function getSupportLevel(stream) {
		const level = supportsColor(stream, stream && stream.isTTY);
		return translateLevel(level);
	}
	module.exports = {
		supportsColor: getSupportLevel,
		stdout: translateLevel(supportsColor(true, tty.isatty(1))),
		stderr: translateLevel(supportsColor(true, tty.isatty(2))),
	};
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
	var tty = __require("tty");
	var util = __require("util");
	exports.init = init;
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.destroy = util.deprecate(
		() => {},
		"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
	);
	exports.colors = [6, 2, 3, 4, 5, 1];
	try {
		const supportsColor = require_supports_color();
		if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
			exports.colors = [
				20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76,
				77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162,
				163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198,
				199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221,
			];
		}
	} catch (error) {}
	exports.inspectOpts = Object.keys(process.env)
		.filter((key) => {
			return /^debug_/i.test(key);
		})
		.reduce((obj, key) => {
			const prop = key
				.substring(6)
				.toLowerCase()
				.replace(/_([a-z])/g, (_, k) => {
					return k.toUpperCase();
				});
			let val = process.env[key];
			if (/^(yes|on|true|enabled)$/i.test(val)) {
				val = true;
			} else if (/^(no|off|false|disabled)$/i.test(val)) {
				val = false;
			} else if (val === "null") {
				val = null;
			} else {
				val = Number(val);
			}
			obj[prop] = val;
			return obj;
		}, {});
	function useColors() {
		return "colors" in exports.inspectOpts
			? Boolean(exports.inspectOpts.colors)
			: tty.isatty(process.stderr.fd);
	}
	function formatArgs(args) {
		const { namespace: name, useColors: useColors2 } = this;
		if (useColors2) {
			const c = this.color;
			const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
			const prefix = `  ${colorCode};1m${name} \x1B[0m`;
			args[0] =
				prefix +
				args[0]
					.split(
						`
`,
					)
					.join(
						`
` + prefix,
					);
			args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
		} else {
			args[0] = getDate() + name + " " + args[0];
		}
	}
	function getDate() {
		if (exports.inspectOpts.hideDate) {
			return "";
		}
		return new Date().toISOString() + " ";
	}
	function log(...args) {
		return process.stderr.write(
			util.formatWithOptions(exports.inspectOpts, ...args) +
				`
`,
		);
	}
	function save(namespaces) {
		if (namespaces) {
			process.env.DEBUG = namespaces;
		} else {
			delete process.env.DEBUG;
		}
	}
	function load() {
		return process.env.DEBUG;
	}
	function init(debug) {
		debug.inspectOpts = {};
		const keys = Object.keys(exports.inspectOpts);
		for (let i = 0; i < keys.length; i++) {
			debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
		}
	}
	module.exports = require_common()(exports);
	var { formatters } = module.exports;
	formatters.o = function (v) {
		this.inspectOpts.colors = this.useColors;
		return util
			.inspect(v, this.inspectOpts)
			.split(
				`
`,
			)
			.map((str) => str.trim())
			.join(" ");
	};
	formatters.O = function (v) {
		this.inspectOpts.colors = this.useColors;
		return util.inspect(v, this.inspectOpts);
	};
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
	if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
		module.exports = require_browser();
	} else {
		module.exports = require_node();
	}
});

// node_modules/@tokenizer/inflate/lib/ZipToken.js
var Signature, DataDescriptor, LocalFileHeaderToken, EndOfCentralDirectoryRecordToken, FileHeader;
var init_ZipToken = __esm(() => {
	init_lib3();
	Signature = {
		LocalFileHeader: 67324752,
		DataDescriptor: 134695760,
		CentralFileHeader: 33639248,
		EndOfCentralDirectory: 101010256,
	};
	DataDescriptor = {
		get(array) {
			return {
				signature: UINT32_LE.get(array, 0),
				compressedSize: UINT32_LE.get(array, 8),
				uncompressedSize: UINT32_LE.get(array, 12),
			};
		},
		len: 16,
	};
	LocalFileHeaderToken = {
		get(array) {
			const flags = UINT16_LE.get(array, 6);
			return {
				signature: UINT32_LE.get(array, 0),
				minVersion: UINT16_LE.get(array, 4),
				dataDescriptor: !!(flags & 8),
				compressedMethod: UINT16_LE.get(array, 8),
				compressedSize: UINT32_LE.get(array, 18),
				uncompressedSize: UINT32_LE.get(array, 22),
				filenameLength: UINT16_LE.get(array, 26),
				extraFieldLength: UINT16_LE.get(array, 28),
				filename: null,
			};
		},
		len: 30,
	};
	EndOfCentralDirectoryRecordToken = {
		get(array) {
			return {
				signature: UINT32_LE.get(array, 0),
				nrOfThisDisk: UINT16_LE.get(array, 4),
				nrOfThisDiskWithTheStart: UINT16_LE.get(array, 6),
				nrOfEntriesOnThisDisk: UINT16_LE.get(array, 8),
				nrOfEntriesOfSize: UINT16_LE.get(array, 10),
				sizeOfCd: UINT32_LE.get(array, 12),
				offsetOfStartOfCd: UINT32_LE.get(array, 16),
				zipFileCommentLength: UINT16_LE.get(array, 20),
			};
		},
		len: 22,
	};
	FileHeader = {
		get(array) {
			const flags = UINT16_LE.get(array, 8);
			return {
				signature: UINT32_LE.get(array, 0),
				minVersion: UINT16_LE.get(array, 6),
				dataDescriptor: !!(flags & 8),
				compressedMethod: UINT16_LE.get(array, 10),
				compressedSize: UINT32_LE.get(array, 20),
				uncompressedSize: UINT32_LE.get(array, 24),
				filenameLength: UINT16_LE.get(array, 28),
				extraFieldLength: UINT16_LE.get(array, 30),
				fileCommentLength: UINT16_LE.get(array, 32),
				relativeOffsetOfLocalHeader: UINT32_LE.get(array, 42),
				filename: null,
			};
		},
		len: 46,
	};
});

// node_modules/@tokenizer/inflate/lib/ZipHandler.js
function signatureToArray(signature) {
	const signatureBytes = new Uint8Array(UINT32_LE.len);
	UINT32_LE.put(signatureBytes, 0, signature);
	return signatureBytes;
}

class ZipHandler {
	constructor(tokenizer) {
		this.tokenizer = tokenizer;
		this.syncBuffer = new Uint8Array(syncBufferSize);
	}
	async isZip() {
		return (await this.peekSignature()) === Signature.LocalFileHeader;
	}
	peekSignature() {
		return this.tokenizer.peekToken(UINT32_LE);
	}
	async findEndOfCentralDirectoryLocator() {
		const randomReadTokenizer = this.tokenizer;
		const chunkLength = Math.min(16 * 1024, randomReadTokenizer.fileInfo.size);
		const buffer = this.syncBuffer.subarray(0, chunkLength);
		await this.tokenizer.readBuffer(buffer, {
			position: randomReadTokenizer.fileInfo.size - chunkLength,
		});
		for (let i = buffer.length - 4; i >= 0; i--) {
			if (
				buffer[i] === eocdSignatureBytes[0] &&
				buffer[i + 1] === eocdSignatureBytes[1] &&
				buffer[i + 2] === eocdSignatureBytes[2] &&
				buffer[i + 3] === eocdSignatureBytes[3]
			) {
				return randomReadTokenizer.fileInfo.size - chunkLength + i;
			}
		}
		return -1;
	}
	async readCentralDirectory() {
		if (!this.tokenizer.supportsRandomAccess()) {
			debug("Cannot reading central-directory without random-read support");
			return;
		}
		debug("Reading central-directory...");
		const pos = this.tokenizer.position;
		const offset = await this.findEndOfCentralDirectoryLocator();
		if (offset > 0) {
			debug("Central-directory 32-bit signature found");
			const eocdHeader = await this.tokenizer.readToken(EndOfCentralDirectoryRecordToken, offset);
			const files = [];
			this.tokenizer.setPosition(eocdHeader.offsetOfStartOfCd);
			for (let n = 0; n < eocdHeader.nrOfEntriesOfSize; ++n) {
				const entry = await this.tokenizer.readToken(FileHeader);
				if (entry.signature !== Signature.CentralFileHeader) {
					throw new Error("Expected Central-File-Header signature");
				}
				entry.filename = await this.tokenizer.readToken(
					new StringType2(entry.filenameLength, "utf-8"),
				);
				await this.tokenizer.ignore(entry.extraFieldLength);
				await this.tokenizer.ignore(entry.fileCommentLength);
				files.push(entry);
				debug(
					`Add central-directory file-entry: n=${n + 1}/${files.length}: filename=${files[n].filename}`,
				);
			}
			this.tokenizer.setPosition(pos);
			return files;
		}
		this.tokenizer.setPosition(pos);
	}
	async unzip(fileCb) {
		const entries = await this.readCentralDirectory();
		if (entries) {
			return this.iterateOverCentralDirectory(entries, fileCb);
		}
		let stop = false;
		do {
			const zipHeader = await this.readLocalFileHeader();
			if (!zipHeader) break;
			const next = fileCb(zipHeader);
			stop = !!next.stop;
			let fileData;
			await this.tokenizer.ignore(zipHeader.extraFieldLength);
			if (zipHeader.dataDescriptor && zipHeader.compressedSize === 0) {
				const chunks = [];
				let len = syncBufferSize;
				debug("Compressed-file-size unknown, scanning for next data-descriptor-signature....");
				let nextHeaderIndex = -1;
				while (nextHeaderIndex < 0 && len === syncBufferSize) {
					len = await this.tokenizer.peekBuffer(this.syncBuffer, { mayBeLess: true });
					nextHeaderIndex = indexOf(this.syncBuffer.subarray(0, len), ddSignatureArray);
					const size = nextHeaderIndex >= 0 ? nextHeaderIndex : len;
					if (next.handler) {
						const data = new Uint8Array(size);
						await this.tokenizer.readBuffer(data);
						chunks.push(data);
					} else {
						await this.tokenizer.ignore(size);
					}
				}
				debug(`Found data-descriptor-signature at pos=${this.tokenizer.position}`);
				if (next.handler) {
					await this.inflate(zipHeader, mergeArrays(chunks), next.handler);
				}
			} else {
				if (next.handler) {
					debug(`Reading compressed-file-data: ${zipHeader.compressedSize} bytes`);
					fileData = new Uint8Array(zipHeader.compressedSize);
					await this.tokenizer.readBuffer(fileData);
					await this.inflate(zipHeader, fileData, next.handler);
				} else {
					debug(`Ignoring compressed-file-data: ${zipHeader.compressedSize} bytes`);
					await this.tokenizer.ignore(zipHeader.compressedSize);
				}
			}
			debug(`Reading data-descriptor at pos=${this.tokenizer.position}`);
			if (zipHeader.dataDescriptor) {
				const dataDescriptor = await this.tokenizer.readToken(DataDescriptor);
				if (dataDescriptor.signature !== 134695760) {
					throw new Error(
						`Expected data-descriptor-signature at position ${this.tokenizer.position - DataDescriptor.len}`,
					);
				}
			}
		} while (!stop);
	}
	async iterateOverCentralDirectory(entries, fileCb) {
		for (const fileHeader of entries) {
			const next = fileCb(fileHeader);
			if (next.handler) {
				this.tokenizer.setPosition(fileHeader.relativeOffsetOfLocalHeader);
				const zipHeader = await this.readLocalFileHeader();
				if (zipHeader) {
					await this.tokenizer.ignore(zipHeader.extraFieldLength);
					const fileData = new Uint8Array(fileHeader.compressedSize);
					await this.tokenizer.readBuffer(fileData);
					await this.inflate(zipHeader, fileData, next.handler);
				}
			}
			if (next.stop) break;
		}
	}
	async inflate(zipHeader, fileData, cb) {
		if (zipHeader.compressedMethod === 0) {
			return cb(fileData);
		}
		if (zipHeader.compressedMethod !== 8) {
			throw new Error(`Unsupported ZIP compression method: ${zipHeader.compressedMethod}`);
		}
		debug(`Decompress filename=${zipHeader.filename}, compressed-size=${fileData.length}`);
		const uncompressedData = await ZipHandler.decompressDeflateRaw(fileData);
		return cb(uncompressedData);
	}
	static async decompressDeflateRaw(data) {
		const input = new ReadableStream({
			start(controller) {
				controller.enqueue(data);
				controller.close();
			},
		});
		const ds = new DecompressionStream("deflate-raw");
		const output = input.pipeThrough(ds);
		try {
			const response = new Response(output);
			const buffer = await response.arrayBuffer();
			return new Uint8Array(buffer);
		} catch (err) {
			const message =
				err instanceof Error
					? `Failed to deflate ZIP entry: ${err.message}`
					: "Unknown decompression error in ZIP entry";
			throw new TypeError(message);
		}
	}
	async readLocalFileHeader() {
		const signature = await this.tokenizer.peekToken(UINT32_LE);
		if (signature === Signature.LocalFileHeader) {
			const header = await this.tokenizer.readToken(LocalFileHeaderToken);
			header.filename = await this.tokenizer.readToken(
				new StringType2(header.filenameLength, "utf-8"),
			);
			return header;
		}
		if (signature === Signature.CentralFileHeader) {
			return false;
		}
		if (signature === 3759263696) {
			throw new Error("Encrypted ZIP");
		}
		throw new Error("Unexpected signature");
	}
}
function indexOf(buffer, portion) {
	const bufferLength = buffer.length;
	const portionLength = portion.length;
	if (portionLength > bufferLength) return -1;
	for (let i = 0; i <= bufferLength - portionLength; i++) {
		let found = true;
		for (let j = 0; j < portionLength; j++) {
			if (buffer[i + j] !== portion[j]) {
				found = false;
				break;
			}
		}
		if (found) {
			return i;
		}
	}
	return -1;
}
function mergeArrays(chunks) {
	const totalLength = chunks.reduce((acc, curr) => acc + curr.length, 0);
	const mergedArray = new Uint8Array(totalLength);
	let offset = 0;
	for (const chunk of chunks) {
		mergedArray.set(chunk, offset);
		offset += chunk.length;
	}
	return mergedArray;
}
var import_debug, debug, syncBufferSize, ddSignatureArray, eocdSignatureBytes;
var init_ZipHandler = __esm(() => {
	init_lib3();
	init_ZipToken();
	import_debug = __toESM(require_src(), 1);
	debug = import_debug.default("tokenizer:inflate");
	syncBufferSize = 256 * 1024;
	ddSignatureArray = signatureToArray(Signature.DataDescriptor);
	eocdSignatureBytes = signatureToArray(Signature.EndOfCentralDirectory);
});

// node_modules/@tokenizer/inflate/lib/GzipHandler.js
class GzipHandler {
	constructor(tokenizer) {
		this.tokenizer = tokenizer;
	}
	inflate() {
		const tokenizer = this.tokenizer;
		return new ReadableStream({
			async pull(controller) {
				const buffer = new Uint8Array(1024);
				const size = await tokenizer.readBuffer(buffer, { mayBeLess: true });
				if (size === 0) {
					controller.close();
					return;
				}
				controller.enqueue(buffer.subarray(0, size));
			},
		}).pipeThrough(new DecompressionStream("gzip"));
	}
}

// node_modules/@tokenizer/inflate/lib/index.js
var init_lib4 = __esm(() => {
	init_ZipHandler();
});

// node_modules/uint8array-extras/index.js
function getUintBE(view) {
	const { byteLength } = view;
	if (byteLength === 6) {
		return view.getUint16(0) * 2 ** 32 + view.getUint32(2);
	}
	if (byteLength === 5) {
		return view.getUint8(0) * 2 ** 32 + view.getUint32(1);
	}
	if (byteLength === 4) {
		return view.getUint32(0);
	}
	if (byteLength === 3) {
		return view.getUint8(0) * 2 ** 16 + view.getUint16(1);
	}
	if (byteLength === 2) {
		return view.getUint16(0);
	}
	if (byteLength === 1) {
		return view.getUint8(0);
	}
}
var cachedDecoders, cachedEncoder, byteToHexLookupTable;
var init_uint8array_extras = __esm(() => {
	cachedDecoders = {
		utf8: new globalThis.TextDecoder("utf8"),
	};
	cachedEncoder = new globalThis.TextEncoder();
	byteToHexLookupTable = Array.from({ length: 256 }, (_, index) =>
		index.toString(16).padStart(2, "0"),
	);
});

// node_modules/file-type/util.js
function stringToBytes(string, encoding) {
	if (encoding === "utf-16le") {
		const bytes = [];
		for (let index = 0; index < string.length; index++) {
			const code = string.charCodeAt(index);
			bytes.push(code & 255, (code >> 8) & 255);
		}
		return bytes;
	}
	if (encoding === "utf-16be") {
		const bytes = [];
		for (let index = 0; index < string.length; index++) {
			const code = string.charCodeAt(index);
			bytes.push((code >> 8) & 255, code & 255);
		}
		return bytes;
	}
	return [...string].map((character) => character.charCodeAt(0));
}
function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {
	const readSum = Number.parseInt(
		new StringType2(6).get(arrayBuffer, 148).replace(/\0.*$/, "").trim(),
		8,
	);
	if (Number.isNaN(readSum)) {
		return false;
	}
	let sum = 8 * 32;
	for (let index = offset; index < offset + 148; index++) {
		sum += arrayBuffer[index];
	}
	for (let index = offset + 156; index < offset + 512; index++) {
		sum += arrayBuffer[index];
	}
	return readSum === sum;
}
var uint32SyncSafeToken;
var init_util = __esm(() => {
	init_lib3();
	uint32SyncSafeToken = {
		get: (buffer, offset) =>
			(buffer[offset + 3] & 127) |
			(buffer[offset + 2] << 7) |
			(buffer[offset + 1] << 14) |
			(buffer[offset] << 21),
		len: 4,
	};
});

// node_modules/file-type/supported.js
var extensions, mimeTypes;
var init_supported = __esm(() => {
	extensions = [
		"jpg",
		"png",
		"apng",
		"gif",
		"webp",
		"flif",
		"xcf",
		"cr2",
		"cr3",
		"orf",
		"arw",
		"dng",
		"nef",
		"rw2",
		"raf",
		"tif",
		"bmp",
		"icns",
		"jxr",
		"psd",
		"indd",
		"zip",
		"tar",
		"rar",
		"gz",
		"bz2",
		"7z",
		"dmg",
		"mp4",
		"mid",
		"mkv",
		"webm",
		"mov",
		"avi",
		"mpg",
		"mp2",
		"mp3",
		"m4a",
		"oga",
		"ogg",
		"ogv",
		"opus",
		"flac",
		"wav",
		"spx",
		"amr",
		"pdf",
		"epub",
		"elf",
		"macho",
		"exe",
		"swf",
		"rtf",
		"wasm",
		"woff",
		"woff2",
		"eot",
		"ttf",
		"otf",
		"ttc",
		"ico",
		"flv",
		"ps",
		"xz",
		"sqlite",
		"nes",
		"crx",
		"xpi",
		"cab",
		"deb",
		"ar",
		"rpm",
		"Z",
		"lz",
		"cfb",
		"mxf",
		"mts",
		"blend",
		"bpg",
		"docx",
		"pptx",
		"xlsx",
		"3gp",
		"3g2",
		"j2c",
		"jp2",
		"jpm",
		"jpx",
		"mj2",
		"aif",
		"qcp",
		"odt",
		"ods",
		"odp",
		"xml",
		"mobi",
		"heic",
		"cur",
		"ktx",
		"ape",
		"wv",
		"dcm",
		"ics",
		"glb",
		"pcap",
		"dsf",
		"lnk",
		"alias",
		"voc",
		"ac3",
		"m4v",
		"m4p",
		"m4b",
		"f4v",
		"f4p",
		"f4b",
		"f4a",
		"mie",
		"asf",
		"ogm",
		"ogx",
		"mpc",
		"arrow",
		"shp",
		"aac",
		"mp1",
		"it",
		"s3m",
		"xm",
		"skp",
		"avif",
		"eps",
		"lzh",
		"pgp",
		"asar",
		"stl",
		"chm",
		"3mf",
		"zst",
		"jxl",
		"vcf",
		"jls",
		"pst",
		"dwg",
		"parquet",
		"class",
		"arj",
		"cpio",
		"ace",
		"avro",
		"icc",
		"fbx",
		"vsdx",
		"vtt",
		"apk",
		"drc",
		"lz4",
		"potx",
		"xltx",
		"dotx",
		"xltm",
		"ott",
		"ots",
		"otp",
		"odg",
		"otg",
		"xlsm",
		"docm",
		"dotm",
		"potm",
		"pptm",
		"jar",
		"rm",
		"ppsm",
		"ppsx",
		"tar.gz",
		"reg",
		"dat",
	];
	mimeTypes = [
		"image/jpeg",
		"image/png",
		"image/gif",
		"image/webp",
		"image/flif",
		"image/x-xcf",
		"image/x-canon-cr2",
		"image/x-canon-cr3",
		"image/tiff",
		"image/bmp",
		"image/vnd.ms-photo",
		"image/vnd.adobe.photoshop",
		"application/x-indesign",
		"application/epub+zip",
		"application/x-xpinstall",
		"application/vnd.ms-powerpoint.slideshow.macroenabled.12",
		"application/vnd.oasis.opendocument.text",
		"application/vnd.oasis.opendocument.spreadsheet",
		"application/vnd.oasis.opendocument.presentation",
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document",
		"application/vnd.openxmlformats-officedocument.presentationml.presentation",
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow",
		"application/zip",
		"application/x-tar",
		"application/x-rar-compressed",
		"application/gzip",
		"application/x-bzip2",
		"application/x-7z-compressed",
		"application/x-apple-diskimage",
		"application/vnd.apache.arrow.file",
		"video/mp4",
		"audio/midi",
		"video/matroska",
		"video/webm",
		"video/quicktime",
		"video/vnd.avi",
		"audio/wav",
		"audio/qcelp",
		"audio/x-ms-asf",
		"video/x-ms-asf",
		"application/vnd.ms-asf",
		"video/mpeg",
		"video/3gpp",
		"audio/mpeg",
		"audio/mp4",
		"video/ogg",
		"audio/ogg",
		"audio/ogg; codecs=opus",
		"application/ogg",
		"audio/flac",
		"audio/ape",
		"audio/wavpack",
		"audio/amr",
		"application/pdf",
		"application/x-elf",
		"application/x-mach-binary",
		"application/x-msdownload",
		"application/x-shockwave-flash",
		"application/rtf",
		"application/wasm",
		"font/woff",
		"font/woff2",
		"application/vnd.ms-fontobject",
		"font/ttf",
		"font/otf",
		"font/collection",
		"image/x-icon",
		"video/x-flv",
		"application/postscript",
		"application/eps",
		"application/x-xz",
		"application/x-sqlite3",
		"application/x-nintendo-nes-rom",
		"application/x-google-chrome-extension",
		"application/vnd.ms-cab-compressed",
		"application/x-deb",
		"application/x-unix-archive",
		"application/x-rpm",
		"application/x-compress",
		"application/x-lzip",
		"application/x-cfb",
		"application/x-mie",
		"application/mxf",
		"video/mp2t",
		"application/x-blender",
		"image/bpg",
		"image/j2c",
		"image/jp2",
		"image/jpx",
		"image/jpm",
		"image/mj2",
		"audio/aiff",
		"application/xml",
		"application/x-mobipocket-ebook",
		"image/heif",
		"image/heif-sequence",
		"image/heic",
		"image/heic-sequence",
		"image/icns",
		"image/ktx",
		"application/dicom",
		"audio/x-musepack",
		"text/calendar",
		"text/vcard",
		"text/vtt",
		"model/gltf-binary",
		"application/vnd.tcpdump.pcap",
		"audio/x-dsf",
		"application/x.ms.shortcut",
		"application/x.apple.alias",
		"audio/x-voc",
		"audio/vnd.dolby.dd-raw",
		"audio/x-m4a",
		"image/apng",
		"image/x-olympus-orf",
		"image/x-sony-arw",
		"image/x-adobe-dng",
		"image/x-nikon-nef",
		"image/x-panasonic-rw2",
		"image/x-fujifilm-raf",
		"video/x-m4v",
		"video/3gpp2",
		"application/x-esri-shape",
		"audio/aac",
		"audio/x-it",
		"audio/x-s3m",
		"audio/x-xm",
		"video/MP1S",
		"video/MP2P",
		"application/vnd.sketchup.skp",
		"image/avif",
		"application/x-lzh-compressed",
		"application/pgp-encrypted",
		"application/x-asar",
		"model/stl",
		"application/vnd.ms-htmlhelp",
		"model/3mf",
		"image/jxl",
		"application/zstd",
		"image/jls",
		"application/vnd.ms-outlook",
		"image/vnd.dwg",
		"application/vnd.apache.parquet",
		"application/java-vm",
		"application/x-arj",
		"application/x-cpio",
		"application/x-ace-compressed",
		"application/avro",
		"application/vnd.iccprofile",
		"application/x.autodesk.fbx",
		"application/vnd.visio",
		"application/vnd.android.package-archive",
		"application/vnd.google.draco",
		"application/x-lz4",
		"application/vnd.openxmlformats-officedocument.presentationml.template",
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template",
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template",
		"application/vnd.ms-excel.template.macroenabled.12",
		"application/vnd.oasis.opendocument.text-template",
		"application/vnd.oasis.opendocument.spreadsheet-template",
		"application/vnd.oasis.opendocument.presentation-template",
		"application/vnd.oasis.opendocument.graphics",
		"application/vnd.oasis.opendocument.graphics-template",
		"application/vnd.ms-excel.sheet.macroenabled.12",
		"application/vnd.ms-word.document.macroenabled.12",
		"application/vnd.ms-word.template.macroenabled.12",
		"application/vnd.ms-powerpoint.template.macroenabled.12",
		"application/vnd.ms-powerpoint.presentation.macroenabled.12",
		"application/java-archive",
		"application/vnd.rn-realmedia",
		"application/x-ms-regedit",
		"application/x-ft-windows-registry-hive",
	];
});

// node_modules/file-type/core.js
async function fileTypeFromBuffer(input, options) {
	return new FileTypeParser(options).fromBuffer(input);
}
async function fileTypeFromBlob(blob, options) {
	return new FileTypeParser(options).fromBlob(blob);
}
function getFileTypeFromMimeType(mimeType) {
	mimeType = mimeType.toLowerCase();
	switch (mimeType) {
		case "application/epub+zip":
			return {
				ext: "epub",
				mime: mimeType,
			};
		case "application/vnd.oasis.opendocument.text":
			return {
				ext: "odt",
				mime: mimeType,
			};
		case "application/vnd.oasis.opendocument.text-template":
			return {
				ext: "ott",
				mime: mimeType,
			};
		case "application/vnd.oasis.opendocument.spreadsheet":
			return {
				ext: "ods",
				mime: mimeType,
			};
		case "application/vnd.oasis.opendocument.spreadsheet-template":
			return {
				ext: "ots",
				mime: mimeType,
			};
		case "application/vnd.oasis.opendocument.presentation":
			return {
				ext: "odp",
				mime: mimeType,
			};
		case "application/vnd.oasis.opendocument.presentation-template":
			return {
				ext: "otp",
				mime: mimeType,
			};
		case "application/vnd.oasis.opendocument.graphics":
			return {
				ext: "odg",
				mime: mimeType,
			};
		case "application/vnd.oasis.opendocument.graphics-template":
			return {
				ext: "otg",
				mime: mimeType,
			};
		case "application/vnd.openxmlformats-officedocument.presentationml.slideshow":
			return {
				ext: "ppsx",
				mime: mimeType,
			};
		case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
			return {
				ext: "xlsx",
				mime: mimeType,
			};
		case "application/vnd.ms-excel.sheet.macroenabled":
			return {
				ext: "xlsm",
				mime: "application/vnd.ms-excel.sheet.macroenabled.12",
			};
		case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
			return {
				ext: "xltx",
				mime: mimeType,
			};
		case "application/vnd.ms-excel.template.macroenabled":
			return {
				ext: "xltm",
				mime: "application/vnd.ms-excel.template.macroenabled.12",
			};
		case "application/vnd.ms-powerpoint.slideshow.macroenabled":
			return {
				ext: "ppsm",
				mime: "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
			};
		case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
			return {
				ext: "docx",
				mime: mimeType,
			};
		case "application/vnd.ms-word.document.macroenabled":
			return {
				ext: "docm",
				mime: "application/vnd.ms-word.document.macroenabled.12",
			};
		case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
			return {
				ext: "dotx",
				mime: mimeType,
			};
		case "application/vnd.ms-word.template.macroenabledtemplate":
			return {
				ext: "dotm",
				mime: "application/vnd.ms-word.template.macroenabled.12",
			};
		case "application/vnd.openxmlformats-officedocument.presentationml.template":
			return {
				ext: "potx",
				mime: mimeType,
			};
		case "application/vnd.ms-powerpoint.template.macroenabled":
			return {
				ext: "potm",
				mime: "application/vnd.ms-powerpoint.template.macroenabled.12",
			};
		case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
			return {
				ext: "pptx",
				mime: mimeType,
			};
		case "application/vnd.ms-powerpoint.presentation.macroenabled":
			return {
				ext: "pptm",
				mime: "application/vnd.ms-powerpoint.presentation.macroenabled.12",
			};
		case "application/vnd.ms-visio.drawing":
			return {
				ext: "vsdx",
				mime: "application/vnd.visio",
			};
		case "application/vnd.ms-package.3dmanufacturing-3dmodel+xml":
			return {
				ext: "3mf",
				mime: "model/3mf",
			};
		default:
	}
}
function _check(buffer, headers, options) {
	options = {
		offset: 0,
		...options,
	};
	for (const [index, header] of headers.entries()) {
		if (options.mask) {
			if (header !== (options.mask[index] & buffer[index + options.offset])) {
				return false;
			}
		} else if (header !== buffer[index + options.offset]) {
			return false;
		}
	}
	return true;
}
async function fileTypeFromTokenizer(tokenizer, options) {
	return new FileTypeParser(options).fromTokenizer(tokenizer);
}

class FileTypeParser {
	constructor(options) {
		this.options = {
			mpegOffsetTolerance: 0,
			...options,
		};
		this.detectors = [
			...(options?.customDetectors ?? []),
			{ id: "core", detect: this.detectConfident },
			{ id: "core.imprecise", detect: this.detectImprecise },
		];
		this.tokenizerOptions = {
			abortSignal: options?.signal,
		};
	}
	async fromTokenizer(tokenizer) {
		const initialPosition = tokenizer.position;
		for (const detector of this.detectors) {
			const fileType = await detector.detect(tokenizer);
			if (fileType) {
				return fileType;
			}
			if (initialPosition !== tokenizer.position) {
				return;
			}
		}
	}
	async fromBuffer(input) {
		if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
			throw new TypeError(
				`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof input}\``,
			);
		}
		const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
		if (!(buffer?.length > 1)) {
			return;
		}
		return this.fromTokenizer(fromBuffer(buffer, this.tokenizerOptions));
	}
	async fromBlob(blob) {
		const tokenizer = fromBlob(blob, this.tokenizerOptions);
		try {
			return await this.fromTokenizer(tokenizer);
		} finally {
			await tokenizer.close();
		}
	}
	async fromStream(stream) {
		const tokenizer = fromWebStream(stream, this.tokenizerOptions);
		try {
			return await this.fromTokenizer(tokenizer);
		} finally {
			await tokenizer.close();
		}
	}
	async toDetectionStream(stream, options) {
		const { sampleSize = reasonableDetectionSizeInBytes } = options;
		let detectedFileType;
		let firstChunk;
		const reader = stream.getReader({ mode: "byob" });
		try {
			const { value: chunk, done } = await reader.read(new Uint8Array(sampleSize));
			firstChunk = chunk;
			if (!done && chunk) {
				try {
					detectedFileType = await this.fromBuffer(chunk.subarray(0, sampleSize));
				} catch (error) {
					if (!(error instanceof EndOfStreamError)) {
						throw error;
					}
					detectedFileType = undefined;
				}
			}
			firstChunk = chunk;
		} finally {
			reader.releaseLock();
		}
		const transformStream = new TransformStream({
			async start(controller) {
				controller.enqueue(firstChunk);
			},
			transform(chunk, controller) {
				controller.enqueue(chunk);
			},
		});
		const newStream = stream.pipeThrough(transformStream);
		newStream.fileType = detectedFileType;
		return newStream;
	}
	check(header, options) {
		return _check(this.buffer, header, options);
	}
	checkString(header, options) {
		return this.check(stringToBytes(header, options?.encoding), options);
	}
	detectConfident = async (tokenizer) => {
		this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
		if (tokenizer.fileInfo.size === undefined) {
			tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
		}
		this.tokenizer = tokenizer;
		await tokenizer.peekBuffer(this.buffer, { length: 32, mayBeLess: true });
		if (this.check([66, 77])) {
			return {
				ext: "bmp",
				mime: "image/bmp",
			};
		}
		if (this.check([11, 119])) {
			return {
				ext: "ac3",
				mime: "audio/vnd.dolby.dd-raw",
			};
		}
		if (this.check([120, 1])) {
			return {
				ext: "dmg",
				mime: "application/x-apple-diskimage",
			};
		}
		if (this.check([77, 90])) {
			return {
				ext: "exe",
				mime: "application/x-msdownload",
			};
		}
		if (this.check([37, 33])) {
			await tokenizer.peekBuffer(this.buffer, { length: 24, mayBeLess: true });
			if (
				this.checkString("PS-Adobe-", { offset: 2 }) &&
				this.checkString(" EPSF-", { offset: 14 })
			) {
				return {
					ext: "eps",
					mime: "application/eps",
				};
			}
			return {
				ext: "ps",
				mime: "application/postscript",
			};
		}
		if (this.check([31, 160]) || this.check([31, 157])) {
			return {
				ext: "Z",
				mime: "application/x-compress",
			};
		}
		if (this.check([199, 113])) {
			return {
				ext: "cpio",
				mime: "application/x-cpio",
			};
		}
		if (this.check([96, 234])) {
			return {
				ext: "arj",
				mime: "application/x-arj",
			};
		}
		if (this.check([239, 187, 191])) {
			this.tokenizer.ignore(3);
			return this.detectConfident(tokenizer);
		}
		if (this.check([71, 73, 70])) {
			return {
				ext: "gif",
				mime: "image/gif",
			};
		}
		if (this.check([73, 73, 188])) {
			return {
				ext: "jxr",
				mime: "image/vnd.ms-photo",
			};
		}
		if (this.check([31, 139, 8])) {
			const gzipHandler = new GzipHandler(tokenizer);
			const stream = gzipHandler.inflate();
			let shouldCancelStream = true;
			try {
				let compressedFileType;
				try {
					compressedFileType = await this.fromStream(stream);
				} catch {
					shouldCancelStream = false;
				}
				if (compressedFileType && compressedFileType.ext === "tar") {
					return {
						ext: "tar.gz",
						mime: "application/gzip",
					};
				}
			} finally {
				if (shouldCancelStream) {
					await stream.cancel();
				}
			}
			return {
				ext: "gz",
				mime: "application/gzip",
			};
		}
		if (this.check([66, 90, 104])) {
			return {
				ext: "bz2",
				mime: "application/x-bzip2",
			};
		}
		if (this.checkString("ID3")) {
			await tokenizer.ignore(6);
			const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
			if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
				return {
					ext: "mp3",
					mime: "audio/mpeg",
				};
			}
			await tokenizer.ignore(id3HeaderLength);
			return this.fromTokenizer(tokenizer);
		}
		if (this.checkString("MP+")) {
			return {
				ext: "mpc",
				mime: "audio/x-musepack",
			};
		}
		if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([87, 83], { offset: 1 })) {
			return {
				ext: "swf",
				mime: "application/x-shockwave-flash",
			};
		}
		if (this.check([255, 216, 255])) {
			if (this.check([247], { offset: 3 })) {
				return {
					ext: "jls",
					mime: "image/jls",
				};
			}
			return {
				ext: "jpg",
				mime: "image/jpeg",
			};
		}
		if (this.check([79, 98, 106, 1])) {
			return {
				ext: "avro",
				mime: "application/avro",
			};
		}
		if (this.checkString("FLIF")) {
			return {
				ext: "flif",
				mime: "image/flif",
			};
		}
		if (this.checkString("8BPS")) {
			return {
				ext: "psd",
				mime: "image/vnd.adobe.photoshop",
			};
		}
		if (this.checkString("MPCK")) {
			return {
				ext: "mpc",
				mime: "audio/x-musepack",
			};
		}
		if (this.checkString("FORM")) {
			return {
				ext: "aif",
				mime: "audio/aiff",
			};
		}
		if (this.checkString("icns", { offset: 0 })) {
			return {
				ext: "icns",
				mime: "image/icns",
			};
		}
		if (this.check([80, 75, 3, 4])) {
			let fileType;
			await new ZipHandler(tokenizer)
				.unzip((zipHeader) => {
					switch (zipHeader.filename) {
						case "META-INF/mozilla.rsa":
							fileType = {
								ext: "xpi",
								mime: "application/x-xpinstall",
							};
							return {
								stop: true,
							};
						case "META-INF/MANIFEST.MF":
							fileType = {
								ext: "jar",
								mime: "application/java-archive",
							};
							return {
								stop: true,
							};
						case "mimetype":
							return {
								async handler(fileData) {
									const mimeType = new TextDecoder("utf-8").decode(fileData).trim();
									fileType = getFileTypeFromMimeType(mimeType);
								},
								stop: true,
							};
						case "[Content_Types].xml":
							return {
								async handler(fileData) {
									let xmlContent = new TextDecoder("utf-8").decode(fileData);
									const endPos = xmlContent.indexOf('.main+xml"');
									if (endPos === -1) {
										const mimeType = "application/vnd.ms-package.3dmanufacturing-3dmodel+xml";
										if (xmlContent.includes(`ContentType="${mimeType}"`)) {
											fileType = getFileTypeFromMimeType(mimeType);
										}
									} else {
										xmlContent = xmlContent.slice(0, Math.max(0, endPos));
										const firstPos = xmlContent.lastIndexOf('"');
										const mimeType = xmlContent.slice(Math.max(0, firstPos + 1));
										fileType = getFileTypeFromMimeType(mimeType);
									}
								},
								stop: true,
							};
						default:
							if (/classes\d*\.dex/.test(zipHeader.filename)) {
								fileType = {
									ext: "apk",
									mime: "application/vnd.android.package-archive",
								};
								return { stop: true };
							}
							return {};
					}
				})
				.catch((error) => {
					if (!(error instanceof EndOfStreamError)) {
						throw error;
					}
				});
			return (
				fileType ?? {
					ext: "zip",
					mime: "application/zip",
				}
			);
		}
		if (this.checkString("OggS")) {
			await tokenizer.ignore(28);
			const type = new Uint8Array(8);
			await tokenizer.readBuffer(type);
			if (_check(type, [79, 112, 117, 115, 72, 101, 97, 100])) {
				return {
					ext: "opus",
					mime: "audio/ogg; codecs=opus",
				};
			}
			if (_check(type, [128, 116, 104, 101, 111, 114, 97])) {
				return {
					ext: "ogv",
					mime: "video/ogg",
				};
			}
			if (_check(type, [1, 118, 105, 100, 101, 111, 0])) {
				return {
					ext: "ogm",
					mime: "video/ogg",
				};
			}
			if (_check(type, [127, 70, 76, 65, 67])) {
				return {
					ext: "oga",
					mime: "audio/ogg",
				};
			}
			if (_check(type, [83, 112, 101, 101, 120, 32, 32])) {
				return {
					ext: "spx",
					mime: "audio/ogg",
				};
			}
			if (_check(type, [1, 118, 111, 114, 98, 105, 115])) {
				return {
					ext: "ogg",
					mime: "audio/ogg",
				};
			}
			return {
				ext: "ogx",
				mime: "application/ogg",
			};
		}
		if (
			this.check([80, 75]) &&
			(this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) &&
			(this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)
		) {
			return {
				ext: "zip",
				mime: "application/zip",
			};
		}
		if (this.checkString("MThd")) {
			return {
				ext: "mid",
				mime: "audio/midi",
			};
		}
		if (
			this.checkString("wOFF") &&
			(this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))
		) {
			return {
				ext: "woff",
				mime: "font/woff",
			};
		}
		if (
			this.checkString("wOF2") &&
			(this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))
		) {
			return {
				ext: "woff2",
				mime: "font/woff2",
			};
		}
		if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212])) {
			return {
				ext: "pcap",
				mime: "application/vnd.tcpdump.pcap",
			};
		}
		if (this.checkString("DSD ")) {
			return {
				ext: "dsf",
				mime: "audio/x-dsf",
			};
		}
		if (this.checkString("LZIP")) {
			return {
				ext: "lz",
				mime: "application/x-lzip",
			};
		}
		if (this.checkString("fLaC")) {
			return {
				ext: "flac",
				mime: "audio/flac",
			};
		}
		if (this.check([66, 80, 71, 251])) {
			return {
				ext: "bpg",
				mime: "image/bpg",
			};
		}
		if (this.checkString("wvpk")) {
			return {
				ext: "wv",
				mime: "audio/wavpack",
			};
		}
		if (this.checkString("%PDF")) {
			return {
				ext: "pdf",
				mime: "application/pdf",
			};
		}
		if (this.check([0, 97, 115, 109])) {
			return {
				ext: "wasm",
				mime: "application/wasm",
			};
		}
		if (this.check([73, 73])) {
			const fileType = await this.readTiffHeader(false);
			if (fileType) {
				return fileType;
			}
		}
		if (this.check([77, 77])) {
			const fileType = await this.readTiffHeader(true);
			if (fileType) {
				return fileType;
			}
		}
		if (this.checkString("MAC ")) {
			return {
				ext: "ape",
				mime: "audio/ape",
			};
		}
		if (this.check([26, 69, 223, 163])) {
			async function readField() {
				const msb = await tokenizer.peekNumber(UINT8);
				let mask = 128;
				let ic = 0;
				while ((msb & mask) === 0 && mask !== 0) {
					++ic;
					mask >>= 1;
				}
				const id = new Uint8Array(ic + 1);
				await tokenizer.readBuffer(id);
				return id;
			}
			async function readElement() {
				const idField = await readField();
				const lengthField = await readField();
				lengthField[0] ^= 128 >> (lengthField.length - 1);
				const nrLength = Math.min(6, lengthField.length);
				const idView = new DataView(idField.buffer);
				const lengthView = new DataView(
					lengthField.buffer,
					lengthField.length - nrLength,
					nrLength,
				);
				return {
					id: getUintBE(idView),
					len: getUintBE(lengthView),
				};
			}
			async function readChildren(children) {
				while (children > 0) {
					const element = await readElement();
					if (element.id === 17026) {
						const rawValue = await tokenizer.readToken(new StringType2(element.len));
						return rawValue.replaceAll(/\00.*$/g, "");
					}
					await tokenizer.ignore(element.len);
					--children;
				}
			}
			const re = await readElement();
			const documentType = await readChildren(re.len);
			switch (documentType) {
				case "webm":
					return {
						ext: "webm",
						mime: "video/webm",
					};
				case "matroska":
					return {
						ext: "mkv",
						mime: "video/matroska",
					};
				default:
					return;
			}
		}
		if (this.checkString("SQLi")) {
			return {
				ext: "sqlite",
				mime: "application/x-sqlite3",
			};
		}
		if (this.check([78, 69, 83, 26])) {
			return {
				ext: "nes",
				mime: "application/x-nintendo-nes-rom",
			};
		}
		if (this.checkString("Cr24")) {
			return {
				ext: "crx",
				mime: "application/x-google-chrome-extension",
			};
		}
		if (this.checkString("MSCF") || this.checkString("ISc(")) {
			return {
				ext: "cab",
				mime: "application/vnd.ms-cab-compressed",
			};
		}
		if (this.check([237, 171, 238, 219])) {
			return {
				ext: "rpm",
				mime: "application/x-rpm",
			};
		}
		if (this.check([197, 208, 211, 198])) {
			return {
				ext: "eps",
				mime: "application/eps",
			};
		}
		if (this.check([40, 181, 47, 253])) {
			return {
				ext: "zst",
				mime: "application/zstd",
			};
		}
		if (this.check([127, 69, 76, 70])) {
			return {
				ext: "elf",
				mime: "application/x-elf",
			};
		}
		if (this.check([33, 66, 68, 78])) {
			return {
				ext: "pst",
				mime: "application/vnd.ms-outlook",
			};
		}
		if (this.checkString("PAR1") || this.checkString("PARE")) {
			return {
				ext: "parquet",
				mime: "application/vnd.apache.parquet",
			};
		}
		if (this.checkString("ttcf")) {
			return {
				ext: "ttc",
				mime: "font/collection",
			};
		}
		if (this.check([207, 250, 237, 254])) {
			return {
				ext: "macho",
				mime: "application/x-mach-binary",
			};
		}
		if (this.check([4, 34, 77, 24])) {
			return {
				ext: "lz4",
				mime: "application/x-lz4",
			};
		}
		if (this.checkString("regf")) {
			return {
				ext: "dat",
				mime: "application/x-ft-windows-registry-hive",
			};
		}
		if (this.check([79, 84, 84, 79, 0])) {
			return {
				ext: "otf",
				mime: "font/otf",
			};
		}
		if (this.checkString("#!AMR")) {
			return {
				ext: "amr",
				mime: "audio/amr",
			};
		}
		if (this.checkString("{\\rtf")) {
			return {
				ext: "rtf",
				mime: "application/rtf",
			};
		}
		if (this.check([70, 76, 86, 1])) {
			return {
				ext: "flv",
				mime: "video/x-flv",
			};
		}
		if (this.checkString("IMPM")) {
			return {
				ext: "it",
				mime: "audio/x-it",
			};
		}
		if (
			this.checkString("-lh0-", { offset: 2 }) ||
			this.checkString("-lh1-", { offset: 2 }) ||
			this.checkString("-lh2-", { offset: 2 }) ||
			this.checkString("-lh3-", { offset: 2 }) ||
			this.checkString("-lh4-", { offset: 2 }) ||
			this.checkString("-lh5-", { offset: 2 }) ||
			this.checkString("-lh6-", { offset: 2 }) ||
			this.checkString("-lh7-", { offset: 2 }) ||
			this.checkString("-lzs-", { offset: 2 }) ||
			this.checkString("-lz4-", { offset: 2 }) ||
			this.checkString("-lz5-", { offset: 2 }) ||
			this.checkString("-lhd-", { offset: 2 })
		) {
			return {
				ext: "lzh",
				mime: "application/x-lzh-compressed",
			};
		}
		if (this.check([0, 0, 1, 186])) {
			if (this.check([33], { offset: 4, mask: [241] })) {
				return {
					ext: "mpg",
					mime: "video/MP1S",
				};
			}
			if (this.check([68], { offset: 4, mask: [196] })) {
				return {
					ext: "mpg",
					mime: "video/MP2P",
				};
			}
		}
		if (this.checkString("ITSF")) {
			return {
				ext: "chm",
				mime: "application/vnd.ms-htmlhelp",
			};
		}
		if (this.check([202, 254, 186, 190])) {
			return {
				ext: "class",
				mime: "application/java-vm",
			};
		}
		if (this.checkString(".RMF")) {
			return {
				ext: "rm",
				mime: "application/vnd.rn-realmedia",
			};
		}
		if (this.checkString("DRACO")) {
			return {
				ext: "drc",
				mime: "application/vnd.google.draco",
			};
		}
		if (this.check([253, 55, 122, 88, 90, 0])) {
			return {
				ext: "xz",
				mime: "application/x-xz",
			};
		}
		if (this.checkString("<?xml ")) {
			return {
				ext: "xml",
				mime: "application/xml",
			};
		}
		if (this.check([55, 122, 188, 175, 39, 28])) {
			return {
				ext: "7z",
				mime: "application/x-7z-compressed",
			};
		}
		if (this.check([82, 97, 114, 33, 26, 7]) && (this.buffer[6] === 0 || this.buffer[6] === 1)) {
			return {
				ext: "rar",
				mime: "application/x-rar-compressed",
			};
		}
		if (this.checkString("solid ")) {
			return {
				ext: "stl",
				mime: "model/stl",
			};
		}
		if (this.checkString("AC")) {
			const version = new StringType2(4, "latin1").get(this.buffer, 2);
			if (version.match("^d*") && version >= 1000 && version <= 1050) {
				return {
					ext: "dwg",
					mime: "image/vnd.dwg",
				};
			}
		}
		if (this.checkString("070707")) {
			return {
				ext: "cpio",
				mime: "application/x-cpio",
			};
		}
		if (this.checkString("BLENDER")) {
			return {
				ext: "blend",
				mime: "application/x-blender",
			};
		}
		if (this.checkString("!<arch>")) {
			await tokenizer.ignore(8);
			const string = await tokenizer.readToken(new StringType2(13, "ascii"));
			if (string === "debian-binary") {
				return {
					ext: "deb",
					mime: "application/x-deb",
				};
			}
			return {
				ext: "ar",
				mime: "application/x-unix-archive",
			};
		}
		if (
			this.checkString("WEBVTT") &&
			[
				`
`,
				"\r",
				"\t",
				" ",
				"\x00",
			].some((char7) => this.checkString(char7, { offset: 6 }))
		) {
			return {
				ext: "vtt",
				mime: "text/vtt",
			};
		}
		if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
			await tokenizer.ignore(8);
			async function readChunkHeader() {
				return {
					length: await tokenizer.readToken(INT32_BE),
					type: await tokenizer.readToken(new StringType2(4, "latin1")),
				};
			}
			do {
				const chunk = await readChunkHeader();
				if (chunk.length < 0) {
					return;
				}
				switch (chunk.type) {
					case "IDAT":
						return {
							ext: "png",
							mime: "image/png",
						};
					case "acTL":
						return {
							ext: "apng",
							mime: "image/apng",
						};
					default:
						await tokenizer.ignore(chunk.length + 4);
				}
			} while (tokenizer.position + 8 < tokenizer.fileInfo.size);
			return {
				ext: "png",
				mime: "image/png",
			};
		}
		if (this.check([65, 82, 82, 79, 87, 49, 0, 0])) {
			return {
				ext: "arrow",
				mime: "application/vnd.apache.arrow.file",
			};
		}
		if (this.check([103, 108, 84, 70, 2, 0, 0, 0])) {
			return {
				ext: "glb",
				mime: "model/gltf-binary",
			};
		}
		if (
			this.check([102, 114, 101, 101], { offset: 4 }) ||
			this.check([109, 100, 97, 116], { offset: 4 }) ||
			this.check([109, 111, 111, 118], { offset: 4 }) ||
			this.check([119, 105, 100, 101], { offset: 4 })
		) {
			return {
				ext: "mov",
				mime: "video/quicktime",
			};
		}
		if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
			return {
				ext: "orf",
				mime: "image/x-olympus-orf",
			};
		}
		if (this.checkString("gimp xcf ")) {
			return {
				ext: "xcf",
				mime: "image/x-xcf",
			};
		}
		if (this.checkString("ftyp", { offset: 4 }) && (this.buffer[8] & 96) !== 0) {
			const brandMajor = new StringType2(4, "latin1")
				.get(this.buffer, 8)
				.replace("\x00", " ")
				.trim();
			switch (brandMajor) {
				case "avif":
				case "avis":
					return { ext: "avif", mime: "image/avif" };
				case "mif1":
					return { ext: "heic", mime: "image/heif" };
				case "msf1":
					return { ext: "heic", mime: "image/heif-sequence" };
				case "heic":
				case "heix":
					return { ext: "heic", mime: "image/heic" };
				case "hevc":
				case "hevx":
					return { ext: "heic", mime: "image/heic-sequence" };
				case "qt":
					return { ext: "mov", mime: "video/quicktime" };
				case "M4V":
				case "M4VH":
				case "M4VP":
					return { ext: "m4v", mime: "video/x-m4v" };
				case "M4P":
					return { ext: "m4p", mime: "video/mp4" };
				case "M4B":
					return { ext: "m4b", mime: "audio/mp4" };
				case "M4A":
					return { ext: "m4a", mime: "audio/x-m4a" };
				case "F4V":
					return { ext: "f4v", mime: "video/mp4" };
				case "F4P":
					return { ext: "f4p", mime: "video/mp4" };
				case "F4A":
					return { ext: "f4a", mime: "audio/mp4" };
				case "F4B":
					return { ext: "f4b", mime: "audio/mp4" };
				case "crx":
					return { ext: "cr3", mime: "image/x-canon-cr3" };
				default:
					if (brandMajor.startsWith("3g")) {
						if (brandMajor.startsWith("3g2")) {
							return { ext: "3g2", mime: "video/3gpp2" };
						}
						return { ext: "3gp", mime: "video/3gpp" };
					}
					return { ext: "mp4", mime: "video/mp4" };
			}
		}
		if (
			this.checkString(`REGEDIT4\r
`)
		) {
			return {
				ext: "reg",
				mime: "application/x-ms-regedit",
			};
		}
		if (this.check([82, 73, 70, 70])) {
			if (this.checkString("WEBP", { offset: 8 })) {
				return {
					ext: "webp",
					mime: "image/webp",
				};
			}
			if (this.check([65, 86, 73], { offset: 8 })) {
				return {
					ext: "avi",
					mime: "video/vnd.avi",
				};
			}
			if (this.check([87, 65, 86, 69], { offset: 8 })) {
				return {
					ext: "wav",
					mime: "audio/wav",
				};
			}
			if (this.check([81, 76, 67, 77], { offset: 8 })) {
				return {
					ext: "qcp",
					mime: "audio/qcelp",
				};
			}
		}
		if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
			return {
				ext: "rw2",
				mime: "image/x-panasonic-rw2",
			};
		}
		if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
			async function readHeader() {
				const guid = new Uint8Array(16);
				await tokenizer.readBuffer(guid);
				return {
					id: guid,
					size: Number(await tokenizer.readToken(UINT64_LE)),
				};
			}
			await tokenizer.ignore(30);
			while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
				const header = await readHeader();
				let payload = header.size - 24;
				if (
					_check(
						header.id,
						[145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101],
					)
				) {
					const typeId = new Uint8Array(16);
					payload -= await tokenizer.readBuffer(typeId);
					if (
						_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])
					) {
						return {
							ext: "asf",
							mime: "audio/x-ms-asf",
						};
					}
					if (
						_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])
					) {
						return {
							ext: "asf",
							mime: "video/x-ms-asf",
						};
					}
					break;
				}
				await tokenizer.ignore(payload);
			}
			return {
				ext: "asf",
				mime: "application/vnd.ms-asf",
			};
		}
		if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
			return {
				ext: "ktx",
				mime: "image/ktx",
			};
		}
		if (
			(this.check([126, 16, 4]) || this.check([126, 24, 4])) &&
			this.check([48, 77, 73, 69], { offset: 4 })
		) {
			return {
				ext: "mie",
				mime: "application/x-mie",
			};
		}
		if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
			return {
				ext: "shp",
				mime: "application/x-esri-shape",
			};
		}
		if (this.check([255, 79, 255, 81])) {
			return {
				ext: "j2c",
				mime: "image/j2c",
			};
		}
		if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
			await tokenizer.ignore(20);
			const type = await tokenizer.readToken(new StringType2(4, "ascii"));
			switch (type) {
				case "jp2 ":
					return {
						ext: "jp2",
						mime: "image/jp2",
					};
				case "jpx ":
					return {
						ext: "jpx",
						mime: "image/jpx",
					};
				case "jpm ":
					return {
						ext: "jpm",
						mime: "image/jpm",
					};
				case "mjp2":
					return {
						ext: "mj2",
						mime: "image/mj2",
					};
				default:
					return;
			}
		}
		if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
			return {
				ext: "jxl",
				mime: "image/jxl",
			};
		}
		if (this.check([254, 255])) {
			if (this.checkString("<?xml ", { offset: 2, encoding: "utf-16be" })) {
				return {
					ext: "xml",
					mime: "application/xml",
				};
			}
			return;
		}
		if (this.check([208, 207, 17, 224, 161, 177, 26, 225])) {
			return {
				ext: "cfb",
				mime: "application/x-cfb",
			};
		}
		await tokenizer.peekBuffer(this.buffer, {
			length: Math.min(256, tokenizer.fileInfo.size),
			mayBeLess: true,
		});
		if (this.check([97, 99, 115, 112], { offset: 36 })) {
			return {
				ext: "icc",
				mime: "application/vnd.iccprofile",
			};
		}
		if (this.checkString("**ACE", { offset: 7 }) && this.checkString("**", { offset: 12 })) {
			return {
				ext: "ace",
				mime: "application/x-ace-compressed",
			};
		}
		if (this.checkString("BEGIN:")) {
			if (this.checkString("VCARD", { offset: 6 })) {
				return {
					ext: "vcf",
					mime: "text/vcard",
				};
			}
			if (this.checkString("VCALENDAR", { offset: 6 })) {
				return {
					ext: "ics",
					mime: "text/calendar",
				};
			}
		}
		if (this.checkString("FUJIFILMCCD-RAW")) {
			return {
				ext: "raf",
				mime: "image/x-fujifilm-raf",
			};
		}
		if (this.checkString("Extended Module:")) {
			return {
				ext: "xm",
				mime: "audio/x-xm",
			};
		}
		if (this.checkString("Creative Voice File")) {
			return {
				ext: "voc",
				mime: "audio/x-voc",
			};
		}
		if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
			const jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);
			if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
				try {
					const header = new TextDecoder().decode(this.buffer.subarray(16, jsonSize + 16));
					const json = JSON.parse(header);
					if (json.files) {
						return {
							ext: "asar",
							mime: "application/x-asar",
						};
					}
				} catch {}
			}
		}
		if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
			return {
				ext: "mxf",
				mime: "application/mxf",
			};
		}
		if (this.checkString("SCRM", { offset: 44 })) {
			return {
				ext: "s3m",
				mime: "audio/x-s3m",
			};
		}
		if (this.check([71]) && this.check([71], { offset: 188 })) {
			return {
				ext: "mts",
				mime: "video/mp2t",
			};
		}
		if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 })) {
			return {
				ext: "mts",
				mime: "video/mp2t",
			};
		}
		if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
			return {
				ext: "mobi",
				mime: "application/x-mobipocket-ebook",
			};
		}
		if (this.check([68, 73, 67, 77], { offset: 128 })) {
			return {
				ext: "dcm",
				mime: "application/dicom",
			};
		}
		if (this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
			return {
				ext: "lnk",
				mime: "application/x.ms.shortcut",
			};
		}
		if (this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
			return {
				ext: "alias",
				mime: "application/x.apple.alias",
			};
		}
		if (this.checkString("Kaydara FBX Binary  \x00")) {
			return {
				ext: "fbx",
				mime: "application/x.autodesk.fbx",
			};
		}
		if (
			this.check([76, 80], { offset: 34 }) &&
			(this.check([0, 0, 1], { offset: 8 }) ||
				this.check([1, 0, 2], { offset: 8 }) ||
				this.check([2, 0, 2], { offset: 8 }))
		) {
			return {
				ext: "eot",
				mime: "application/vnd.ms-fontobject",
			};
		}
		if (this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
			return {
				ext: "indd",
				mime: "application/x-indesign",
			};
		}
		await tokenizer.peekBuffer(this.buffer, {
			length: Math.min(512, tokenizer.fileInfo.size),
			mayBeLess: true,
		});
		if (
			(this.checkString("ustar", { offset: 257 }) &&
				(this.checkString("\x00", { offset: 262 }) || this.checkString(" ", { offset: 262 }))) ||
			(this.check([0, 0, 0, 0, 0, 0], { offset: 257 }) && tarHeaderChecksumMatches(this.buffer))
		) {
			return {
				ext: "tar",
				mime: "application/x-tar",
			};
		}
		if (this.check([255, 254])) {
			const encoding = "utf-16le";
			if (this.checkString("<?xml ", { offset: 2, encoding })) {
				return {
					ext: "xml",
					mime: "application/xml",
				};
			}
			if (
				this.check([255, 14], { offset: 2 }) &&
				this.checkString("SketchUp Model", { offset: 4, encoding })
			) {
				return {
					ext: "skp",
					mime: "application/vnd.sketchup.skp",
				};
			}
			if (
				this.checkString(
					`Windows Registry Editor Version 5.00\r
`,
					{ offset: 2, encoding },
				)
			) {
				return {
					ext: "reg",
					mime: "application/x-ms-regedit",
				};
			}
			return;
		}
		if (this.checkString("-----BEGIN PGP MESSAGE-----")) {
			return {
				ext: "pgp",
				mime: "application/pgp-encrypted",
			};
		}
	};
	detectImprecise = async (tokenizer) => {
		this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
		await tokenizer.peekBuffer(this.buffer, {
			length: Math.min(8, tokenizer.fileInfo.size),
			mayBeLess: true,
		});
		if (this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179])) {
			return {
				ext: "mpg",
				mime: "video/mpeg",
			};
		}
		if (this.check([0, 1, 0, 0, 0])) {
			return {
				ext: "ttf",
				mime: "font/ttf",
			};
		}
		if (this.check([0, 0, 1, 0])) {
			return {
				ext: "ico",
				mime: "image/x-icon",
			};
		}
		if (this.check([0, 0, 2, 0])) {
			return {
				ext: "cur",
				mime: "image/x-icon",
			};
		}
		await tokenizer.peekBuffer(this.buffer, {
			length: Math.min(2 + this.options.mpegOffsetTolerance, tokenizer.fileInfo.size),
			mayBeLess: true,
		});
		if (this.buffer.length >= 2 + this.options.mpegOffsetTolerance) {
			for (let depth = 0; depth <= this.options.mpegOffsetTolerance; ++depth) {
				const type = this.scanMpeg(depth);
				if (type) {
					return type;
				}
			}
		}
	};
	async readTiffTag(bigEndian) {
		const tagId = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
		this.tokenizer.ignore(10);
		switch (tagId) {
			case 50341:
				return {
					ext: "arw",
					mime: "image/x-sony-arw",
				};
			case 50706:
				return {
					ext: "dng",
					mime: "image/x-adobe-dng",
				};
			default:
		}
	}
	async readTiffIFD(bigEndian) {
		const numberOfTags = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
		for (let n = 0; n < numberOfTags; ++n) {
			const fileType = await this.readTiffTag(bigEndian);
			if (fileType) {
				return fileType;
			}
		}
	}
	async readTiffHeader(bigEndian) {
		const version = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
		const ifdOffset = (bigEndian ? UINT32_BE : UINT32_LE).get(this.buffer, 4);
		if (version === 42) {
			if (ifdOffset >= 6) {
				if (this.checkString("CR", { offset: 8 })) {
					return {
						ext: "cr2",
						mime: "image/x-canon-cr2",
					};
				}
				if (ifdOffset >= 8) {
					const someId1 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 8);
					const someId2 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 10);
					if ((someId1 === 28 && someId2 === 254) || (someId1 === 31 && someId2 === 11)) {
						return {
							ext: "nef",
							mime: "image/x-nikon-nef",
						};
					}
				}
			}
			await this.tokenizer.ignore(ifdOffset);
			const fileType = await this.readTiffIFD(bigEndian);
			return (
				fileType ?? {
					ext: "tif",
					mime: "image/tiff",
				}
			);
		}
		if (version === 43) {
			return {
				ext: "tif",
				mime: "image/tiff",
			};
		}
	}
	scanMpeg(offset) {
		if (this.check([255, 224], { offset, mask: [255, 224] })) {
			if (this.check([16], { offset: offset + 1, mask: [22] })) {
				if (this.check([8], { offset: offset + 1, mask: [8] })) {
					return {
						ext: "aac",
						mime: "audio/aac",
					};
				}
				return {
					ext: "aac",
					mime: "audio/aac",
				};
			}
			if (this.check([2], { offset: offset + 1, mask: [6] })) {
				return {
					ext: "mp3",
					mime: "audio/mpeg",
				};
			}
			if (this.check([4], { offset: offset + 1, mask: [6] })) {
				return {
					ext: "mp2",
					mime: "audio/mpeg",
				};
			}
			if (this.check([6], { offset: offset + 1, mask: [6] })) {
				return {
					ext: "mp1",
					mime: "audio/mpeg",
				};
			}
		}
	}
}
var reasonableDetectionSizeInBytes = 4100,
	supportedExtensions,
	supportedMimeTypes;
var init_core2 = __esm(() => {
	init_lib3();
	init_core();
	init_lib4();
	init_uint8array_extras();
	init_util();
	init_supported();
	supportedExtensions = new Set(extensions);
	supportedMimeTypes = new Set(mimeTypes);
});

// node_modules/file-type/index.js
var exports_file_type = {};
__export(exports_file_type, {
	supportedMimeTypes: () => supportedMimeTypes,
	supportedExtensions: () => supportedExtensions,
	fileTypeStream: () => fileTypeStream,
	fileTypeFromTokenizer: () => fileTypeFromTokenizer,
	fileTypeFromStream: () => fileTypeFromStream,
	fileTypeFromFile: () => fileTypeFromFile,
	fileTypeFromBuffer: () => fileTypeFromBuffer,
	fileTypeFromBlob: () => fileTypeFromBlob,
	FileTypeParser: () => FileTypeParser2,
});
import { ReadableStream as WebReadableStream } from "stream/web";
import { pipeline, PassThrough, Readable } from "stream";
async function fileTypeFromFile(path, options) {
	return new FileTypeParser2(options).fromFile(path, options);
}
async function fileTypeFromStream(stream, options) {
	return new FileTypeParser2(options).fromStream(stream);
}
async function fileTypeStream(readableStream, options = {}) {
	return new FileTypeParser2(options).toDetectionStream(readableStream, options);
}
var FileTypeParser2;
var init_file_type = __esm(() => {
	init_lib();
	init_core2();
	init_core2();
	FileTypeParser2 = class FileTypeParser2 extends FileTypeParser {
		async fromStream(stream) {
			const tokenizer = await (stream instanceof WebReadableStream
				? fromWebStream(stream, this.tokenizerOptions)
				: fromStream2(stream, this.tokenizerOptions));
			try {
				return await super.fromTokenizer(tokenizer);
			} finally {
				await tokenizer.close();
			}
		}
		async fromFile(path) {
			const tokenizer = await fromFile(path);
			try {
				return await super.fromTokenizer(tokenizer);
			} finally {
				await tokenizer.close();
			}
		}
		async toDetectionStream(readableStream, options = {}) {
			if (!(readableStream instanceof Readable)) {
				return super.toDetectionStream(readableStream, options);
			}
			const { sampleSize = reasonableDetectionSizeInBytes } = options;
			return new Promise((resolve, reject) => {
				readableStream.on("error", reject);
				readableStream.once("readable", () => {
					(async () => {
						try {
							const pass = new PassThrough();
							const outputStream = pipeline
								? pipeline(readableStream, pass, () => {})
								: readableStream.pipe(pass);
							const chunk =
								readableStream.read(sampleSize) ?? readableStream.read() ?? new Uint8Array(0);
							try {
								pass.fileType = await this.fromBuffer(chunk);
							} catch (error) {
								if (error instanceof EndOfStreamError) {
									pass.fileType = undefined;
								} else {
									reject(error);
								}
							}
							resolve(outputStream);
						} catch (error) {
							reject(error);
						}
					})();
				});
			});
		}
	};
});

// node_modules/@kitajs/html/index.js
var require_html = __commonJS((exports) => {
	var ESCAPED_REGEX = /[<"'&]/;
	var CAMEL_REGEX = /[a-z][A-Z]/;
	function isUpper(input, index) {
		const code = input.charCodeAt(index);
		return code >= 65 && code <= 90;
	}
	function toKebabCase(camel) {
		if (!CAMEL_REGEX.test(camel)) {
			return camel;
		}
		const length = camel.length;
		let start = 0,
			end = 0,
			kebab = "",
			prev = true,
			curr = isUpper(camel, 0),
			next;
		for (; end < length; end++) {
			next = isUpper(camel, end + 1);
			if (!prev && curr && !next) {
				kebab += camel.slice(start, end) + "-" + camel[end].toLowerCase();
				start = end + 1;
			}
			prev = curr;
			curr = next;
		}
		kebab += camel.slice(start, end);
		return kebab;
	}
	function escape(strings, ...values) {
		const stringsLength = strings.length,
			valuesLength = values.length;
		let index = 0,
			result = "";
		for (; index < stringsLength; index++) {
			result += strings[index];
			if (index < valuesLength) {
				result += values[index];
			}
		}
		return escapeHtml(result);
	}
	var escapeHtml = function (value) {
		if (typeof value !== "string") {
			value = value.toString();
		}
		if (!ESCAPED_REGEX.test(value)) {
			return value;
		}
		const length = value.length;
		let escaped = "",
			start = 0,
			end = 0;
		for (; end < length; end++) {
			switch (value[end]) {
				case "&":
					escaped += value.slice(start, end) + "&amp;";
					start = end + 1;
					continue;
				case "<":
					escaped += value.slice(start, end) + "&lt;";
					start = end + 1;
					continue;
				case '"':
					escaped += value.slice(start, end) + "&#34;";
					start = end + 1;
					continue;
				case "'":
					escaped += value.slice(start, end) + "&#39;";
					start = end + 1;
					continue;
			}
		}
		escaped += value.slice(start, end);
		return escaped;
	};
	if (typeof Bun !== "undefined") escapeHtml = Bun.escapeHTML;
	function isVoidElement(tag) {
		return (
			tag === "meta" ||
			tag === "link" ||
			tag === "img" ||
			tag === "br" ||
			tag === "input" ||
			tag === "hr" ||
			tag === "area" ||
			tag === "base" ||
			tag === "col" ||
			tag === "command" ||
			tag === "embed" ||
			tag === "keygen" ||
			tag === "param" ||
			tag === "source" ||
			tag === "track" ||
			tag === "wbr"
		);
	}
	function styleToString(style) {
		if (typeof style === "string") {
			let end2 = style.indexOf('"');
			if (end2 === -1) {
				return style;
			}
			const length2 = style.length;
			let escaped = "",
				start2 = 0;
			for (; end2 < length2; end2++) {
				if (style[end2] === '"') {
					escaped += style.slice(start2, end2) + "&#34;";
					start2 = end2 + 1;
				}
			}
			escaped += style.slice(start2, end2);
			return escaped;
		}
		const keys = Object.keys(style),
			length = keys.length;
		let key,
			value,
			end,
			start,
			index = 0,
			result = "";
		for (; index < length; index++) {
			key = keys[index];
			value = style[key];
			if (value === null || value === undefined) {
				continue;
			}
			result += toKebabCase(key) + ":";
			if (typeof value !== "string") {
				result += value.toString() + ";";
				continue;
			}
			end = value.indexOf('"');
			if (end === -1) {
				result += value + ";";
				continue;
			}
			const length2 = value.length;
			start = 0;
			for (; end < length2; end++) {
				if (value[end] === '"') {
					result += value.slice(start, end) + "&#34;";
					start = end + 1;
				}
			}
			result += value.slice(start, end) + ";";
		}
		return result;
	}
	function attributesToString(attributes) {
		const keys = Object.keys(attributes);
		const length = keys.length;
		let key,
			value,
			type,
			end,
			start,
			classItems,
			valueLength,
			result = "",
			index = 0;
		for (; index < length; index++) {
			key = keys[index];
			if (key === "children" || key === "safe" || key === "of") {
				continue;
			}
			value = attributes[key];
			if (value === null || value === undefined) {
				continue;
			}
			if (key === "className") {
				if (attributes.class !== undefined) {
					continue;
				}
				key = "class";
			} else if (key === "class" && Array.isArray(value)) {
				classItems = value;
				valueLength = value.length;
				value = "";
				for (let i = 0; i < valueLength; i++) {
					if (classItems[i] && classItems[i].length > 0) {
						if (value) {
							value += " " + classItems[i].trim();
						} else {
							value += classItems[i].trim();
						}
					}
				}
				if (value.length === 0) {
					continue;
				}
			} else if (key === "style") {
				result += ' style="' + styleToString(value) + '"';
				continue;
			} else if (key === "attrs") {
				if (typeof value === "string") {
					result += " " + value;
				} else {
					result += attributesToString(value);
				}
				continue;
			}
			type = typeof value;
			if (type === "boolean") {
				if (value) {
					result += " " + key;
				}
				continue;
			}
			result += " " + key;
			if (type !== "string") {
				if (type !== "object") {
					result += '="' + value.toString() + '"';
					continue;
				}
				if (value instanceof Date) {
					result += '="' + value.toISOString() + '"';
					continue;
				}
				value = value.toString();
			}
			end = value.indexOf('"');
			if (end === -1) {
				result += '="' + value + '"';
				continue;
			}
			result += '="';
			valueLength = value.length;
			start = 0;
			for (; end < valueLength; end++) {
				if (value[end] === '"') {
					result += value.slice(start, end) + "&#34;";
					start = end + 1;
				}
			}
			result += value.slice(start, end) + '"';
		}
		return result;
	}
	function contentsToString(contents, escape2) {
		let length = contents.length;
		let result = "";
		for (let index = 0; index < length; index++) {
			const content = contents[index];
			switch (typeof content) {
				case "string":
				case "number":
				case "bigint":
					result += content;
					continue;
				case "boolean":
					continue;
			}
			if (!content) {
				continue;
			}
			if (Array.isArray(content)) {
				contents.splice(index--, 1, ...content);
				length += content.length - 1;
				continue;
			}
			if (typeof content.then === "function") {
				return Promise.all(contents.slice(index)).then(function resolveContents(resolved) {
					resolved.unshift(result);
					return contentsToString(resolved, escape2);
				});
			}
			throw new Error("Objects are not valid as a KitaJSX child");
		}
		if (escape2 === true) {
			return escapeHtml(result);
		}
		return result;
	}
	function contentToString(content, safe) {
		switch (typeof content) {
			case "string":
				return safe ? escapeHtml(content) : content;
			case "number":
			case "bigint":
				return content.toString();
			case "boolean":
				return "";
		}
		if (!content) {
			return "";
		}
		if (Array.isArray(content)) {
			return contentsToString(content, safe);
		}
		if (typeof content.then === "function") {
			return content.then(function resolveContent(resolved) {
				return contentToString(resolved, safe);
			});
		}
		throw new Error("Objects are not valid as a KitaJSX child");
	}
	function createElement(name, attrs, ...children) {
		const hasAttrs = attrs !== null;
		if (typeof name === "function") {
			if (!hasAttrs) {
				return name({ children: children.length > 1 ? children : children[0] });
			}
			attrs.children = children.length > 1 ? children : children[0];
			return name(attrs);
		}
		if (hasAttrs && name === "tag") {
			name = attrs.of;
		}
		const attributes = hasAttrs ? attributesToString(attrs) : "";
		if (children.length === 0) {
			return isVoidElement(name)
				? "<" + name + attributes + "/>"
				: "<" + name + attributes + "></" + name + ">";
		}
		const contents = contentsToString(children, hasAttrs && attrs.safe);
		if (typeof contents === "string") {
			return "<" + name + attributes + ">" + contents + "</" + name + ">";
		}
		return contents.then(function resolveContents(contents2) {
			return "<" + name + attributes + ">" + contents2 + "</" + name + ">";
		});
	}
	function Fragment(props) {
		return contentsToString([props.children]);
	}
	exports.escape = escape;
	exports.e = escape;
	exports.escapeHtml = escapeHtml;
	exports.isVoidElement = isVoidElement;
	exports.attributesToString = attributesToString;
	exports.toKebabCase = toKebabCase;
	exports.isUpper = isUpper;
	exports.styleToString = styleToString;
	exports.createElement = createElement;
	exports.h = createElement;
	exports.contentsToString = contentsToString;
	exports.contentToString = contentToString;
	exports.Fragment = Fragment;
	exports.Html = { ...exports };
});

// node_modules/fast-decode-uri-component/index.js
var require_fast_decode_uri_component2 = __commonJS((exports, module) => {
	var UTF8_ACCEPT = 12;
	var UTF8_REJECT = 0;
	var UTF8_DATA = [
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
		4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
		6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
		4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12,
		12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48,
		48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15,
		15, 7, 7, 7,
	];
	function decodeURIComponent2(uri2) {
		var percentPosition = uri2.indexOf("%");
		if (percentPosition === -1) return uri2;
		var length = uri2.length;
		var decoded = "";
		var last = 0;
		var codepoint = 0;
		var startOfOctets = percentPosition;
		var state = UTF8_ACCEPT;
		while (percentPosition > -1 && percentPosition < length) {
			var high = hexCodeToInt(uri2[percentPosition + 1], 4);
			var low = hexCodeToInt(uri2[percentPosition + 2], 0);
			var byte2 = high | low;
			var type = UTF8_DATA[byte2];
			state = UTF8_DATA[256 + state + type];
			codepoint = (codepoint << 6) | (byte2 & UTF8_DATA[364 + type]);
			if (state === UTF8_ACCEPT) {
				decoded += uri2.slice(last, startOfOctets);
				decoded +=
					codepoint <= 65535
						? String.fromCharCode(codepoint)
						: String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
				codepoint = 0;
				last = percentPosition + 3;
				percentPosition = startOfOctets = uri2.indexOf("%", last);
			} else if (state === UTF8_REJECT) {
				return null;
			} else {
				percentPosition += 3;
				if (percentPosition < length && uri2.charCodeAt(percentPosition) === 37) continue;
				return null;
			}
		}
		return decoded + uri2.slice(last);
	}
	var HEX = {
		0: 0,
		1: 1,
		2: 2,
		3: 3,
		4: 4,
		5: 5,
		6: 6,
		7: 7,
		8: 8,
		9: 9,
		a: 10,
		A: 10,
		b: 11,
		B: 11,
		c: 12,
		C: 12,
		d: 13,
		D: 13,
		e: 14,
		E: 14,
		f: 15,
		F: 15,
	};
	function hexCodeToInt(c, shift) {
		var i = HEX[c];
		return i === undefined ? 255 : i << shift;
	}
	module.exports = decodeURIComponent2;
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS((exports, module) => {
	var Stream = __require("stream").Stream;
	var util3 = __require("util");
	module.exports = DelayedStream;
	function DelayedStream() {
		this.source = null;
		this.dataSize = 0;
		this.maxDataSize = 1024 * 1024;
		this.pauseStream = true;
		this._maxDataSizeExceeded = false;
		this._released = false;
		this._bufferedEvents = [];
	}
	util3.inherits(DelayedStream, Stream);
	DelayedStream.create = function (source, options) {
		var delayedStream = new this();
		options = options || {};
		for (var option in options) {
			delayedStream[option] = options[option];
		}
		delayedStream.source = source;
		var realEmit = source.emit;
		source.emit = function () {
			delayedStream._handleEmit(arguments);
			return realEmit.apply(source, arguments);
		};
		source.on("error", function () {});
		if (delayedStream.pauseStream) {
			source.pause();
		}
		return delayedStream;
	};
	Object.defineProperty(DelayedStream.prototype, "readable", {
		configurable: true,
		enumerable: true,
		get: function () {
			return this.source.readable;
		},
	});
	DelayedStream.prototype.setEncoding = function () {
		return this.source.setEncoding.apply(this.source, arguments);
	};
	DelayedStream.prototype.resume = function () {
		if (!this._released) {
			this.release();
		}
		this.source.resume();
	};
	DelayedStream.prototype.pause = function () {
		this.source.pause();
	};
	DelayedStream.prototype.release = function () {
		this._released = true;
		this._bufferedEvents.forEach(
			function (args) {
				this.emit.apply(this, args);
			}.bind(this),
		);
		this._bufferedEvents = [];
	};
	DelayedStream.prototype.pipe = function () {
		var r2 = Stream.prototype.pipe.apply(this, arguments);
		this.resume();
		return r2;
	};
	DelayedStream.prototype._handleEmit = function (args) {
		if (this._released) {
			this.emit.apply(this, args);
			return;
		}
		if (args[0] === "data") {
			this.dataSize += args[1].length;
			this._checkIfMaxDataSizeExceeded();
		}
		this._bufferedEvents.push(args);
	};
	DelayedStream.prototype._checkIfMaxDataSizeExceeded = function () {
		if (this._maxDataSizeExceeded) {
			return;
		}
		if (this.dataSize <= this.maxDataSize) {
			return;
		}
		this._maxDataSizeExceeded = true;
		var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
		this.emit("error", new Error(message));
	};
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS((exports, module) => {
	var util3 = __require("util");
	var Stream = __require("stream").Stream;
	var DelayedStream = require_delayed_stream();
	module.exports = CombinedStream;
	function CombinedStream() {
		this.writable = false;
		this.readable = true;
		this.dataSize = 0;
		this.maxDataSize = 2 * 1024 * 1024;
		this.pauseStreams = true;
		this._released = false;
		this._streams = [];
		this._currentStream = null;
		this._insideLoop = false;
		this._pendingNext = false;
	}
	util3.inherits(CombinedStream, Stream);
	CombinedStream.create = function (options) {
		var combinedStream = new this();
		options = options || {};
		for (var option in options) {
			combinedStream[option] = options[option];
		}
		return combinedStream;
	};
	CombinedStream.isStreamLike = function (stream) {
		return (
			typeof stream !== "function" &&
			typeof stream !== "string" &&
			typeof stream !== "boolean" &&
			typeof stream !== "number" &&
			!Buffer.isBuffer(stream)
		);
	};
	CombinedStream.prototype.append = function (stream) {
		var isStreamLike = CombinedStream.isStreamLike(stream);
		if (isStreamLike) {
			if (!(stream instanceof DelayedStream)) {
				var newStream = DelayedStream.create(stream, {
					maxDataSize: Infinity,
					pauseStream: this.pauseStreams,
				});
				stream.on("data", this._checkDataSize.bind(this));
				stream = newStream;
			}
			this._handleErrors(stream);
			if (this.pauseStreams) {
				stream.pause();
			}
		}
		this._streams.push(stream);
		return this;
	};
	CombinedStream.prototype.pipe = function (dest, options) {
		Stream.prototype.pipe.call(this, dest, options);
		this.resume();
		return dest;
	};
	CombinedStream.prototype._getNext = function () {
		this._currentStream = null;
		if (this._insideLoop) {
			this._pendingNext = true;
			return;
		}
		this._insideLoop = true;
		try {
			do {
				this._pendingNext = false;
				this._realGetNext();
			} while (this._pendingNext);
		} finally {
			this._insideLoop = false;
		}
	};
	CombinedStream.prototype._realGetNext = function () {
		var stream = this._streams.shift();
		if (typeof stream == "undefined") {
			this.end();
			return;
		}
		if (typeof stream !== "function") {
			this._pipeNext(stream);
			return;
		}
		var getStream = stream;
		getStream(
			function (stream2) {
				var isStreamLike = CombinedStream.isStreamLike(stream2);
				if (isStreamLike) {
					stream2.on("data", this._checkDataSize.bind(this));
					this._handleErrors(stream2);
				}
				this._pipeNext(stream2);
			}.bind(this),
		);
	};
	CombinedStream.prototype._pipeNext = function (stream) {
		this._currentStream = stream;
		var isStreamLike = CombinedStream.isStreamLike(stream);
		if (isStreamLike) {
			stream.on("end", this._getNext.bind(this));
			stream.pipe(this, { end: false });
			return;
		}
		var value = stream;
		this.write(value);
		this._getNext();
	};
	CombinedStream.prototype._handleErrors = function (stream) {
		var self2 = this;
		stream.on("error", function (err) {
			self2._emitError(err);
		});
	};
	CombinedStream.prototype.write = function (data) {
		this.emit("data", data);
	};
	CombinedStream.prototype.pause = function () {
		if (!this.pauseStreams) {
			return;
		}
		if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
			this._currentStream.pause();
		this.emit("pause");
	};
	CombinedStream.prototype.resume = function () {
		if (!this._released) {
			this._released = true;
			this.writable = true;
			this._getNext();
		}
		if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
			this._currentStream.resume();
		this.emit("resume");
	};
	CombinedStream.prototype.end = function () {
		this._reset();
		this.emit("end");
	};
	CombinedStream.prototype.destroy = function () {
		this._reset();
		this.emit("close");
	};
	CombinedStream.prototype._reset = function () {
		this.writable = false;
		this._streams = [];
		this._currentStream = null;
	};
	CombinedStream.prototype._checkDataSize = function () {
		this._updateDataSize();
		if (this.dataSize <= this.maxDataSize) {
			return;
		}
		var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
		this._emitError(new Error(message));
	};
	CombinedStream.prototype._updateDataSize = function () {
		this.dataSize = 0;
		var self2 = this;
		this._streams.forEach(function (stream) {
			if (!stream.dataSize) {
				return;
			}
			self2.dataSize += stream.dataSize;
		});
		if (this._currentStream && this._currentStream.dataSize) {
			this.dataSize += this._currentStream.dataSize;
		}
	};
	CombinedStream.prototype._emitError = function (err) {
		this._reset();
		this.emit("error", err);
	};
});

// node_modules/mime-db/db.json
var require_db = __commonJS((exports, module) => {
	module.exports = {
		"application/1d-interleaved-parityfec": {
			source: "iana",
		},
		"application/3gpdash-qoe-report+xml": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
		},
		"application/3gpp-ims+xml": {
			source: "iana",
			compressible: true,
		},
		"application/3gpphal+json": {
			source: "iana",
			compressible: true,
		},
		"application/3gpphalforms+json": {
			source: "iana",
			compressible: true,
		},
		"application/a2l": {
			source: "iana",
		},
		"application/ace+cbor": {
			source: "iana",
		},
		"application/activemessage": {
			source: "iana",
		},
		"application/activity+json": {
			source: "iana",
			compressible: true,
		},
		"application/alto-costmap+json": {
			source: "iana",
			compressible: true,
		},
		"application/alto-costmapfilter+json": {
			source: "iana",
			compressible: true,
		},
		"application/alto-directory+json": {
			source: "iana",
			compressible: true,
		},
		"application/alto-endpointcost+json": {
			source: "iana",
			compressible: true,
		},
		"application/alto-endpointcostparams+json": {
			source: "iana",
			compressible: true,
		},
		"application/alto-endpointprop+json": {
			source: "iana",
			compressible: true,
		},
		"application/alto-endpointpropparams+json": {
			source: "iana",
			compressible: true,
		},
		"application/alto-error+json": {
			source: "iana",
			compressible: true,
		},
		"application/alto-networkmap+json": {
			source: "iana",
			compressible: true,
		},
		"application/alto-networkmapfilter+json": {
			source: "iana",
			compressible: true,
		},
		"application/alto-updatestreamcontrol+json": {
			source: "iana",
			compressible: true,
		},
		"application/alto-updatestreamparams+json": {
			source: "iana",
			compressible: true,
		},
		"application/aml": {
			source: "iana",
		},
		"application/andrew-inset": {
			source: "iana",
			extensions: ["ez"],
		},
		"application/applefile": {
			source: "iana",
		},
		"application/applixware": {
			source: "apache",
			extensions: ["aw"],
		},
		"application/at+jwt": {
			source: "iana",
		},
		"application/atf": {
			source: "iana",
		},
		"application/atfx": {
			source: "iana",
		},
		"application/atom+xml": {
			source: "iana",
			compressible: true,
			extensions: ["atom"],
		},
		"application/atomcat+xml": {
			source: "iana",
			compressible: true,
			extensions: ["atomcat"],
		},
		"application/atomdeleted+xml": {
			source: "iana",
			compressible: true,
			extensions: ["atomdeleted"],
		},
		"application/atomicmail": {
			source: "iana",
		},
		"application/atomsvc+xml": {
			source: "iana",
			compressible: true,
			extensions: ["atomsvc"],
		},
		"application/atsc-dwd+xml": {
			source: "iana",
			compressible: true,
			extensions: ["dwd"],
		},
		"application/atsc-dynamic-event-message": {
			source: "iana",
		},
		"application/atsc-held+xml": {
			source: "iana",
			compressible: true,
			extensions: ["held"],
		},
		"application/atsc-rdt+json": {
			source: "iana",
			compressible: true,
		},
		"application/atsc-rsat+xml": {
			source: "iana",
			compressible: true,
			extensions: ["rsat"],
		},
		"application/atxml": {
			source: "iana",
		},
		"application/auth-policy+xml": {
			source: "iana",
			compressible: true,
		},
		"application/bacnet-xdd+zip": {
			source: "iana",
			compressible: false,
		},
		"application/batch-smtp": {
			source: "iana",
		},
		"application/bdoc": {
			compressible: false,
			extensions: ["bdoc"],
		},
		"application/beep+xml": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
		},
		"application/calendar+json": {
			source: "iana",
			compressible: true,
		},
		"application/calendar+xml": {
			source: "iana",
			compressible: true,
			extensions: ["xcs"],
		},
		"application/call-completion": {
			source: "iana",
		},
		"application/cals-1840": {
			source: "iana",
		},
		"application/captive+json": {
			source: "iana",
			compressible: true,
		},
		"application/cbor": {
			source: "iana",
		},
		"application/cbor-seq": {
			source: "iana",
		},
		"application/cccex": {
			source: "iana",
		},
		"application/ccmp+xml": {
			source: "iana",
			compressible: true,
		},
		"application/ccxml+xml": {
			source: "iana",
			compressible: true,
			extensions: ["ccxml"],
		},
		"application/cdfx+xml": {
			source: "iana",
			compressible: true,
			extensions: ["cdfx"],
		},
		"application/cdmi-capability": {
			source: "iana",
			extensions: ["cdmia"],
		},
		"application/cdmi-container": {
			source: "iana",
			extensions: ["cdmic"],
		},
		"application/cdmi-domain": {
			source: "iana",
			extensions: ["cdmid"],
		},
		"application/cdmi-object": {
			source: "iana",
			extensions: ["cdmio"],
		},
		"application/cdmi-queue": {
			source: "iana",
			extensions: ["cdmiq"],
		},
		"application/cdni": {
			source: "iana",
		},
		"application/cea": {
			source: "iana",
		},
		"application/cea-2018+xml": {
			source: "iana",
			compressible: true,
		},
		"application/cellml+xml": {
			source: "iana",
			compressible: true,
		},
		"application/cfw": {
			source: "iana",
		},
		"application/city+json": {
			source: "iana",
			compressible: true,
		},
		"application/clr": {
			source: "iana",
		},
		"application/clue+xml": {
			source: "iana",
			compressible: true,
		},
		"application/clue_info+xml": {
			source: "iana",
			compressible: true,
		},
		"application/cms": {
			source: "iana",
		},
		"application/cnrp+xml": {
			source: "iana",
			compressible: true,
		},
		"application/coap-group+json": {
			source: "iana",
			compressible: true,
		},
		"application/coap-payload": {
			source: "iana",
		},
		"application/commonground": {
			source: "iana",
		},
		"application/conference-info+xml": {
			source: "iana",
			compressible: true,
		},
		"application/cose": {
			source: "iana",
		},
		"application/cose-key": {
			source: "iana",
		},
		"application/cose-key-set": {
			source: "iana",
		},
		"application/cpl+xml": {
			source: "iana",
			compressible: true,
			extensions: ["cpl"],
		},
		"application/csrattrs": {
			source: "iana",
		},
		"application/csta+xml": {
			source: "iana",
			compressible: true,
		},
		"application/cstadata+xml": {
			source: "iana",
			compressible: true,
		},
		"application/csvm+json": {
			source: "iana",
			compressible: true,
		},
		"application/cu-seeme": {
			source: "apache",
			extensions: ["cu"],
		},
		"application/cwt": {
			source: "iana",
		},
		"application/cybercash": {
			source: "iana",
		},
		"application/dart": {
			compressible: true,
		},
		"application/dash+xml": {
			source: "iana",
			compressible: true,
			extensions: ["mpd"],
		},
		"application/dash-patch+xml": {
			source: "iana",
			compressible: true,
			extensions: ["mpp"],
		},
		"application/dashdelta": {
			source: "iana",
		},
		"application/davmount+xml": {
			source: "iana",
			compressible: true,
			extensions: ["davmount"],
		},
		"application/dca-rft": {
			source: "iana",
		},
		"application/dcd": {
			source: "iana",
		},
		"application/dec-dx": {
			source: "iana",
		},
		"application/dialog-info+xml": {
			source: "iana",
			compressible: true,
		},
		"application/dicom": {
			source: "iana",
		},
		"application/dicom+json": {
			source: "iana",
			compressible: true,
		},
		"application/dicom+xml": {
			source: "iana",
			compressible: true,
		},
		"application/dii": {
			source: "iana",
		},
		"application/dit": {
			source: "iana",
		},
		"application/dns": {
			source: "iana",
		},
		"application/dns+json": {
			source: "iana",
			compressible: true,
		},
		"application/dns-message": {
			source: "iana",
		},
		"application/docbook+xml": {
			source: "apache",
			compressible: true,
			extensions: ["dbk"],
		},
		"application/dots+cbor": {
			source: "iana",
		},
		"application/dskpp+xml": {
			source: "iana",
			compressible: true,
		},
		"application/dssc+der": {
			source: "iana",
			extensions: ["dssc"],
		},
		"application/dssc+xml": {
			source: "iana",
			compressible: true,
			extensions: ["xdssc"],
		},
		"application/dvcs": {
			source: "iana",
		},
		"application/ecmascript": {
			source: "iana",
			compressible: true,
			extensions: ["es", "ecma"],
		},
		"application/edi-consent": {
			source: "iana",
		},
		"application/edi-x12": {
			source: "iana",
			compressible: false,
		},
		"application/edifact": {
			source: "iana",
			compressible: false,
		},
		"application/efi": {
			source: "iana",
		},
		"application/elm+json": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
		},
		"application/elm+xml": {
			source: "iana",
			compressible: true,
		},
		"application/emergencycalldata.cap+xml": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
		},
		"application/emergencycalldata.comment+xml": {
			source: "iana",
			compressible: true,
		},
		"application/emergencycalldata.control+xml": {
			source: "iana",
			compressible: true,
		},
		"application/emergencycalldata.deviceinfo+xml": {
			source: "iana",
			compressible: true,
		},
		"application/emergencycalldata.ecall.msd": {
			source: "iana",
		},
		"application/emergencycalldata.providerinfo+xml": {
			source: "iana",
			compressible: true,
		},
		"application/emergencycalldata.serviceinfo+xml": {
			source: "iana",
			compressible: true,
		},
		"application/emergencycalldata.subscriberinfo+xml": {
			source: "iana",
			compressible: true,
		},
		"application/emergencycalldata.veds+xml": {
			source: "iana",
			compressible: true,
		},
		"application/emma+xml": {
			source: "iana",
			compressible: true,
			extensions: ["emma"],
		},
		"application/emotionml+xml": {
			source: "iana",
			compressible: true,
			extensions: ["emotionml"],
		},
		"application/encaprtp": {
			source: "iana",
		},
		"application/epp+xml": {
			source: "iana",
			compressible: true,
		},
		"application/epub+zip": {
			source: "iana",
			compressible: false,
			extensions: ["epub"],
		},
		"application/eshop": {
			source: "iana",
		},
		"application/exi": {
			source: "iana",
			extensions: ["exi"],
		},
		"application/expect-ct-report+json": {
			source: "iana",
			compressible: true,
		},
		"application/express": {
			source: "iana",
			extensions: ["exp"],
		},
		"application/fastinfoset": {
			source: "iana",
		},
		"application/fastsoap": {
			source: "iana",
		},
		"application/fdt+xml": {
			source: "iana",
			compressible: true,
			extensions: ["fdt"],
		},
		"application/fhir+json": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
		},
		"application/fhir+xml": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
		},
		"application/fido.trusted-apps+json": {
			compressible: true,
		},
		"application/fits": {
			source: "iana",
		},
		"application/flexfec": {
			source: "iana",
		},
		"application/font-sfnt": {
			source: "iana",
		},
		"application/font-tdpfr": {
			source: "iana",
			extensions: ["pfr"],
		},
		"application/font-woff": {
			source: "iana",
			compressible: false,
		},
		"application/framework-attributes+xml": {
			source: "iana",
			compressible: true,
		},
		"application/geo+json": {
			source: "iana",
			compressible: true,
			extensions: ["geojson"],
		},
		"application/geo+json-seq": {
			source: "iana",
		},
		"application/geopackage+sqlite3": {
			source: "iana",
		},
		"application/geoxacml+xml": {
			source: "iana",
			compressible: true,
		},
		"application/gltf-buffer": {
			source: "iana",
		},
		"application/gml+xml": {
			source: "iana",
			compressible: true,
			extensions: ["gml"],
		},
		"application/gpx+xml": {
			source: "apache",
			compressible: true,
			extensions: ["gpx"],
		},
		"application/gxf": {
			source: "apache",
			extensions: ["gxf"],
		},
		"application/gzip": {
			source: "iana",
			compressible: false,
			extensions: ["gz"],
		},
		"application/h224": {
			source: "iana",
		},
		"application/held+xml": {
			source: "iana",
			compressible: true,
		},
		"application/hjson": {
			extensions: ["hjson"],
		},
		"application/http": {
			source: "iana",
		},
		"application/hyperstudio": {
			source: "iana",
			extensions: ["stk"],
		},
		"application/ibe-key-request+xml": {
			source: "iana",
			compressible: true,
		},
		"application/ibe-pkg-reply+xml": {
			source: "iana",
			compressible: true,
		},
		"application/ibe-pp-data": {
			source: "iana",
		},
		"application/iges": {
			source: "iana",
		},
		"application/im-iscomposing+xml": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
		},
		"application/index": {
			source: "iana",
		},
		"application/index.cmd": {
			source: "iana",
		},
		"application/index.obj": {
			source: "iana",
		},
		"application/index.response": {
			source: "iana",
		},
		"application/index.vnd": {
			source: "iana",
		},
		"application/inkml+xml": {
			source: "iana",
			compressible: true,
			extensions: ["ink", "inkml"],
		},
		"application/iotp": {
			source: "iana",
		},
		"application/ipfix": {
			source: "iana",
			extensions: ["ipfix"],
		},
		"application/ipp": {
			source: "iana",
		},
		"application/isup": {
			source: "iana",
		},
		"application/its+xml": {
			source: "iana",
			compressible: true,
			extensions: ["its"],
		},
		"application/java-archive": {
			source: "apache",
			compressible: false,
			extensions: ["jar", "war", "ear"],
		},
		"application/java-serialized-object": {
			source: "apache",
			compressible: false,
			extensions: ["ser"],
		},
		"application/java-vm": {
			source: "apache",
			compressible: false,
			extensions: ["class"],
		},
		"application/javascript": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
			extensions: ["js", "mjs"],
		},
		"application/jf2feed+json": {
			source: "iana",
			compressible: true,
		},
		"application/jose": {
			source: "iana",
		},
		"application/jose+json": {
			source: "iana",
			compressible: true,
		},
		"application/jrd+json": {
			source: "iana",
			compressible: true,
		},
		"application/jscalendar+json": {
			source: "iana",
			compressible: true,
		},
		"application/json": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
			extensions: ["json", "map"],
		},
		"application/json-patch+json": {
			source: "iana",
			compressible: true,
		},
		"application/json-seq": {
			source: "iana",
		},
		"application/json5": {
			extensions: ["json5"],
		},
		"application/jsonml+json": {
			source: "apache",
			compressible: true,
			extensions: ["jsonml"],
		},
		"application/jwk+json": {
			source: "iana",
			compressible: true,
		},
		"application/jwk-set+json": {
			source: "iana",
			compressible: true,
		},
		"application/jwt": {
			source: "iana",
		},
		"application/kpml-request+xml": {
			source: "iana",
			compressible: true,
		},
		"application/kpml-response+xml": {
			source: "iana",
			compressible: true,
		},
		"application/ld+json": {
			source: "iana",
			compressible: true,
			extensions: ["jsonld"],
		},
		"application/lgr+xml": {
			source: "iana",
			compressible: true,
			extensions: ["lgr"],
		},
		"application/link-format": {
			source: "iana",
		},
		"application/load-control+xml": {
			source: "iana",
			compressible: true,
		},
		"application/lost+xml": {
			source: "iana",
			compressible: true,
			extensions: ["lostxml"],
		},
		"application/lostsync+xml": {
			source: "iana",
			compressible: true,
		},
		"application/lpf+zip": {
			source: "iana",
			compressible: false,
		},
		"application/lxf": {
			source: "iana",
		},
		"application/mac-binhex40": {
			source: "iana",
			extensions: ["hqx"],
		},
		"application/mac-compactpro": {
			source: "apache",
			extensions: ["cpt"],
		},
		"application/macwriteii": {
			source: "iana",
		},
		"application/mads+xml": {
			source: "iana",
			compressible: true,
			extensions: ["mads"],
		},
		"application/manifest+json": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
			extensions: ["webmanifest"],
		},
		"application/marc": {
			source: "iana",
			extensions: ["mrc"],
		},
		"application/marcxml+xml": {
			source: "iana",
			compressible: true,
			extensions: ["mrcx"],
		},
		"application/mathematica": {
			source: "iana",
			extensions: ["ma", "nb", "mb"],
		},
		"application/mathml+xml": {
			source: "iana",
			compressible: true,
			extensions: ["mathml"],
		},
		"application/mathml-content+xml": {
			source: "iana",
			compressible: true,
		},
		"application/mathml-presentation+xml": {
			source: "iana",
			compressible: true,
		},
		"application/mbms-associated-procedure-description+xml": {
			source: "iana",
			compressible: true,
		},
		"application/mbms-deregister+xml": {
			source: "iana",
			compressible: true,
		},
		"application/mbms-envelope+xml": {
			source: "iana",
			compressible: true,
		},
		"application/mbms-msk+xml": {
			source: "iana",
			compressible: true,
		},
		"application/mbms-msk-response+xml": {
			source: "iana",
			compressible: true,
		},
		"application/mbms-protection-description+xml": {
			source: "iana",
			compressible: true,
		},
		"application/mbms-reception-report+xml": {
			source: "iana",
			compressible: true,
		},
		"application/mbms-register+xml": {
			source: "iana",
			compressible: true,
		},
		"application/mbms-register-response+xml": {
			source: "iana",
			compressible: true,
		},
		"application/mbms-schedule+xml": {
			source: "iana",
			compressible: true,
		},
		"application/mbms-user-service-description+xml": {
			source: "iana",
			compressible: true,
		},
		"application/mbox": {
			source: "iana",
			extensions: ["mbox"],
		},
		"application/media-policy-dataset+xml": {
			source: "iana",
			compressible: true,
			extensions: ["mpf"],
		},
		"application/media_control+xml": {
			source: "iana",
			compressible: true,
		},
		"application/mediaservercontrol+xml": {
			source: "iana",
			compressible: true,
			extensions: ["mscml"],
		},
		"application/merge-patch+json": {
			source: "iana",
			compressible: true,
		},
		"application/metalink+xml": {
			source: "apache",
			compressible: true,
			extensions: ["metalink"],
		},
		"application/metalink4+xml": {
			source: "iana",
			compressible: true,
			extensions: ["meta4"],
		},
		"application/mets+xml": {
			source: "iana",
			compressible: true,
			extensions: ["mets"],
		},
		"application/mf4": {
			source: "iana",
		},
		"application/mikey": {
			source: "iana",
		},
		"application/mipc": {
			source: "iana",
		},
		"application/missing-blocks+cbor-seq": {
			source: "iana",
		},
		"application/mmt-aei+xml": {
			source: "iana",
			compressible: true,
			extensions: ["maei"],
		},
		"application/mmt-usd+xml": {
			source: "iana",
			compressible: true,
			extensions: ["musd"],
		},
		"application/mods+xml": {
			source: "iana",
			compressible: true,
			extensions: ["mods"],
		},
		"application/moss-keys": {
			source: "iana",
		},
		"application/moss-signature": {
			source: "iana",
		},
		"application/mosskey-data": {
			source: "iana",
		},
		"application/mosskey-request": {
			source: "iana",
		},
		"application/mp21": {
			source: "iana",
			extensions: ["m21", "mp21"],
		},
		"application/mp4": {
			source: "iana",
			extensions: ["mp4s", "m4p"],
		},
		"application/mpeg4-generic": {
			source: "iana",
		},
		"application/mpeg4-iod": {
			source: "iana",
		},
		"application/mpeg4-iod-xmt": {
			source: "iana",
		},
		"application/mrb-consumer+xml": {
			source: "iana",
			compressible: true,
		},
		"application/mrb-publish+xml": {
			source: "iana",
			compressible: true,
		},
		"application/msc-ivr+xml": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
		},
		"application/msc-mixer+xml": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
		},
		"application/msword": {
			source: "iana",
			compressible: false,
			extensions: ["doc", "dot"],
		},
		"application/mud+json": {
			source: "iana",
			compressible: true,
		},
		"application/multipart-core": {
			source: "iana",
		},
		"application/mxf": {
			source: "iana",
			extensions: ["mxf"],
		},
		"application/n-quads": {
			source: "iana",
			extensions: ["nq"],
		},
		"application/n-triples": {
			source: "iana",
			extensions: ["nt"],
		},
		"application/nasdata": {
			source: "iana",
		},
		"application/news-checkgroups": {
			source: "iana",
			charset: "US-ASCII",
		},
		"application/news-groupinfo": {
			source: "iana",
			charset: "US-ASCII",
		},
		"application/news-transmission": {
			source: "iana",
		},
		"application/nlsml+xml": {
			source: "iana",
			compressible: true,
		},
		"application/node": {
			source: "iana",
			extensions: ["cjs"],
		},
		"application/nss": {
			source: "iana",
		},
		"application/oauth-authz-req+jwt": {
			source: "iana",
		},
		"application/oblivious-dns-message": {
			source: "iana",
		},
		"application/ocsp-request": {
			source: "iana",
		},
		"application/ocsp-response": {
			source: "iana",
		},
		"application/octet-stream": {
			source: "iana",
			compressible: false,
			extensions: [
				"bin",
				"dms",
				"lrf",
				"mar",
				"so",
				"dist",
				"distz",
				"pkg",
				"bpk",
				"dump",
				"elc",
				"deploy",
				"exe",
				"dll",
				"deb",
				"dmg",
				"iso",
				"img",
				"msi",
				"msp",
				"msm",
				"buffer",
			],
		},
		"application/oda": {
			source: "iana",
			extensions: ["oda"],
		},
		"application/odm+xml": {
			source: "iana",
			compressible: true,
		},
		"application/odx": {
			source: "iana",
		},
		"application/oebps-package+xml": {
			source: "iana",
			compressible: true,
			extensions: ["opf"],
		},
		"application/ogg": {
			source: "iana",
			compressible: false,
			extensions: ["ogx"],
		},
		"application/omdoc+xml": {
			source: "apache",
			compressible: true,
			extensions: ["omdoc"],
		},
		"application/onenote": {
			source: "apache",
			extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"],
		},
		"application/opc-nodeset+xml": {
			source: "iana",
			compressible: true,
		},
		"application/oscore": {
			source: "iana",
		},
		"application/oxps": {
			source: "iana",
			extensions: ["oxps"],
		},
		"application/p21": {
			source: "iana",
		},
		"application/p21+zip": {
			source: "iana",
			compressible: false,
		},
		"application/p2p-overlay+xml": {
			source: "iana",
			compressible: true,
			extensions: ["relo"],
		},
		"application/parityfec": {
			source: "iana",
		},
		"application/passport": {
			source: "iana",
		},
		"application/patch-ops-error+xml": {
			source: "iana",
			compressible: true,
			extensions: ["xer"],
		},
		"application/pdf": {
			source: "iana",
			compressible: false,
			extensions: ["pdf"],
		},
		"application/pdx": {
			source: "iana",
		},
		"application/pem-certificate-chain": {
			source: "iana",
		},
		"application/pgp-encrypted": {
			source: "iana",
			compressible: false,
			extensions: ["pgp"],
		},
		"application/pgp-keys": {
			source: "iana",
			extensions: ["asc"],
		},
		"application/pgp-signature": {
			source: "iana",
			extensions: ["asc", "sig"],
		},
		"application/pics-rules": {
			source: "apache",
			extensions: ["prf"],
		},
		"application/pidf+xml": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
		},
		"application/pidf-diff+xml": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
		},
		"application/pkcs10": {
			source: "iana",
			extensions: ["p10"],
		},
		"application/pkcs12": {
			source: "iana",
		},
		"application/pkcs7-mime": {
			source: "iana",
			extensions: ["p7m", "p7c"],
		},
		"application/pkcs7-signature": {
			source: "iana",
			extensions: ["p7s"],
		},
		"application/pkcs8": {
			source: "iana",
			extensions: ["p8"],
		},
		"application/pkcs8-encrypted": {
			source: "iana",
		},
		"application/pkix-attr-cert": {
			source: "iana",
			extensions: ["ac"],
		},
		"application/pkix-cert": {
			source: "iana",
			extensions: ["cer"],
		},
		"application/pkix-crl": {
			source: "iana",
			extensions: ["crl"],
		},
		"application/pkix-pkipath": {
			source: "iana",
			extensions: ["pkipath"],
		},
		"application/pkixcmp": {
			source: "iana",
			extensions: ["pki"],
		},
		"application/pls+xml": {
			source: "iana",
			compressible: true,
			extensions: ["pls"],
		},
		"application/poc-settings+xml": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
		},
		"application/postscript": {
			source: "iana",
			compressible: true,
			extensions: ["ai", "eps", "ps"],
		},
		"application/ppsp-tracker+json": {
			source: "iana",
			compressible: true,
		},
		"application/problem+json": {
			source: "iana",
			compressible: true,
		},
		"application/problem+xml": {
			source: "iana",
			compressible: true,
		},
		"application/provenance+xml": {
			source: "iana",
			compressible: true,
			extensions: ["provx"],
		},
		"application/prs.alvestrand.titrax-sheet": {
			source: "iana",
		},
		"application/prs.cww": {
			source: "iana",
			extensions: ["cww"],
		},
		"application/prs.cyn": {
			source: "iana",
			charset: "7-BIT",
		},
		"application/prs.hpub+zip": {
			source: "iana",
			compressible: false,
		},
		"application/prs.nprend": {
			source: "iana",
		},
		"application/prs.plucker": {
			source: "iana",
		},
		"application/prs.rdf-xml-crypt": {
			source: "iana",
		},
		"application/prs.xsf+xml": {
			source: "iana",
			compressible: true,
		},
		"application/pskc+xml": {
			source: "iana",
			compressible: true,
			extensions: ["pskcxml"],
		},
		"application/pvd+json": {
			source: "iana",
			compressible: true,
		},
		"application/qsig": {
			source: "iana",
		},
		"application/raml+yaml": {
			compressible: true,
			extensions: ["raml"],
		},
		"application/raptorfec": {
			source: "iana",
		},
		"application/rdap+json": {
			source: "iana",
			compressible: true,
		},
		"application/rdf+xml": {
			source: "iana",
			compressible: true,
			extensions: ["rdf", "owl"],
		},
		"application/reginfo+xml": {
			source: "iana",
			compressible: true,
			extensions: ["rif"],
		},
		"application/relax-ng-compact-syntax": {
			source: "iana",
			extensions: ["rnc"],
		},
		"application/remote-printing": {
			source: "iana",
		},
		"application/reputon+json": {
			source: "iana",
			compressible: true,
		},
		"application/resource-lists+xml": {
			source: "iana",
			compressible: true,
			extensions: ["rl"],
		},
		"application/resource-lists-diff+xml": {
			source: "iana",
			compressible: true,
			extensions: ["rld"],
		},
		"application/rfc+xml": {
			source: "iana",
			compressible: true,
		},
		"application/riscos": {
			source: "iana",
		},
		"application/rlmi+xml": {
			source: "iana",
			compressible: true,
		},
		"application/rls-services+xml": {
			source: "iana",
			compressible: true,
			extensions: ["rs"],
		},
		"application/route-apd+xml": {
			source: "iana",
			compressible: true,
			extensions: ["rapd"],
		},
		"application/route-s-tsid+xml": {
			source: "iana",
			compressible: true,
			extensions: ["sls"],
		},
		"application/route-usd+xml": {
			source: "iana",
			compressible: true,
			extensions: ["rusd"],
		},
		"application/rpki-ghostbusters": {
			source: "iana",
			extensions: ["gbr"],
		},
		"application/rpki-manifest": {
			source: "iana",
			extensions: ["mft"],
		},
		"application/rpki-publication": {
			source: "iana",
		},
		"application/rpki-roa": {
			source: "iana",
			extensions: ["roa"],
		},
		"application/rpki-updown": {
			source: "iana",
		},
		"application/rsd+xml": {
			source: "apache",
			compressible: true,
			extensions: ["rsd"],
		},
		"application/rss+xml": {
			source: "apache",
			compressible: true,
			extensions: ["rss"],
		},
		"application/rtf": {
			source: "iana",
			compressible: true,
			extensions: ["rtf"],
		},
		"application/rtploopback": {
			source: "iana",
		},
		"application/rtx": {
			source: "iana",
		},
		"application/samlassertion+xml": {
			source: "iana",
			compressible: true,
		},
		"application/samlmetadata+xml": {
			source: "iana",
			compressible: true,
		},
		"application/sarif+json": {
			source: "iana",
			compressible: true,
		},
		"application/sarif-external-properties+json": {
			source: "iana",
			compressible: true,
		},
		"application/sbe": {
			source: "iana",
		},
		"application/sbml+xml": {
			source: "iana",
			compressible: true,
			extensions: ["sbml"],
		},
		"application/scaip+xml": {
			source: "iana",
			compressible: true,
		},
		"application/scim+json": {
			source: "iana",
			compressible: true,
		},
		"application/scvp-cv-request": {
			source: "iana",
			extensions: ["scq"],
		},
		"application/scvp-cv-response": {
			source: "iana",
			extensions: ["scs"],
		},
		"application/scvp-vp-request": {
			source: "iana",
			extensions: ["spq"],
		},
		"application/scvp-vp-response": {
			source: "iana",
			extensions: ["spp"],
		},
		"application/sdp": {
			source: "iana",
			extensions: ["sdp"],
		},
		"application/secevent+jwt": {
			source: "iana",
		},
		"application/senml+cbor": {
			source: "iana",
		},
		"application/senml+json": {
			source: "iana",
			compressible: true,
		},
		"application/senml+xml": {
			source: "iana",
			compressible: true,
			extensions: ["senmlx"],
		},
		"application/senml-etch+cbor": {
			source: "iana",
		},
		"application/senml-etch+json": {
			source: "iana",
			compressible: true,
		},
		"application/senml-exi": {
			source: "iana",
		},
		"application/sensml+cbor": {
			source: "iana",
		},
		"application/sensml+json": {
			source: "iana",
			compressible: true,
		},
		"application/sensml+xml": {
			source: "iana",
			compressible: true,
			extensions: ["sensmlx"],
		},
		"application/sensml-exi": {
			source: "iana",
		},
		"application/sep+xml": {
			source: "iana",
			compressible: true,
		},
		"application/sep-exi": {
			source: "iana",
		},
		"application/session-info": {
			source: "iana",
		},
		"application/set-payment": {
			source: "iana",
		},
		"application/set-payment-initiation": {
			source: "iana",
			extensions: ["setpay"],
		},
		"application/set-registration": {
			source: "iana",
		},
		"application/set-registration-initiation": {
			source: "iana",
			extensions: ["setreg"],
		},
		"application/sgml": {
			source: "iana",
		},
		"application/sgml-open-catalog": {
			source: "iana",
		},
		"application/shf+xml": {
			source: "iana",
			compressible: true,
			extensions: ["shf"],
		},
		"application/sieve": {
			source: "iana",
			extensions: ["siv", "sieve"],
		},
		"application/simple-filter+xml": {
			source: "iana",
			compressible: true,
		},
		"application/simple-message-summary": {
			source: "iana",
		},
		"application/simplesymbolcontainer": {
			source: "iana",
		},
		"application/sipc": {
			source: "iana",
		},
		"application/slate": {
			source: "iana",
		},
		"application/smil": {
			source: "iana",
		},
		"application/smil+xml": {
			source: "iana",
			compressible: true,
			extensions: ["smi", "smil"],
		},
		"application/smpte336m": {
			source: "iana",
		},
		"application/soap+fastinfoset": {
			source: "iana",
		},
		"application/soap+xml": {
			source: "iana",
			compressible: true,
		},
		"application/sparql-query": {
			source: "iana",
			extensions: ["rq"],
		},
		"application/sparql-results+xml": {
			source: "iana",
			compressible: true,
			extensions: ["srx"],
		},
		"application/spdx+json": {
			source: "iana",
			compressible: true,
		},
		"application/spirits-event+xml": {
			source: "iana",
			compressible: true,
		},
		"application/sql": {
			source: "iana",
		},
		"application/srgs": {
			source: "iana",
			extensions: ["gram"],
		},
		"application/srgs+xml": {
			source: "iana",
			compressible: true,
			extensions: ["grxml"],
		},
		"application/sru+xml": {
			source: "iana",
			compressible: true,
			extensions: ["sru"],
		},
		"application/ssdl+xml": {
			source: "apache",
			compressible: true,
			extensions: ["ssdl"],
		},
		"application/ssml+xml": {
			source: "iana",
			compressible: true,
			extensions: ["ssml"],
		},
		"application/stix+json": {
			source: "iana",
			compressible: true,
		},
		"application/swid+xml": {
			source: "iana",
			compressible: true,
			extensions: ["swidtag"],
		},
		"application/tamp-apex-update": {
			source: "iana",
		},
		"application/tamp-apex-update-confirm": {
			source: "iana",
		},
		"application/tamp-community-update": {
			source: "iana",
		},
		"application/tamp-community-update-confirm": {
			source: "iana",
		},
		"application/tamp-error": {
			source: "iana",
		},
		"application/tamp-sequence-adjust": {
			source: "iana",
		},
		"application/tamp-sequence-adjust-confirm": {
			source: "iana",
		},
		"application/tamp-status-query": {
			source: "iana",
		},
		"application/tamp-status-response": {
			source: "iana",
		},
		"application/tamp-update": {
			source: "iana",
		},
		"application/tamp-update-confirm": {
			source: "iana",
		},
		"application/tar": {
			compressible: true,
		},
		"application/taxii+json": {
			source: "iana",
			compressible: true,
		},
		"application/td+json": {
			source: "iana",
			compressible: true,
		},
		"application/tei+xml": {
			source: "iana",
			compressible: true,
			extensions: ["tei", "teicorpus"],
		},
		"application/tetra_isi": {
			source: "iana",
		},
		"application/thraud+xml": {
			source: "iana",
			compressible: true,
			extensions: ["tfi"],
		},
		"application/timestamp-query": {
			source: "iana",
		},
		"application/timestamp-reply": {
			source: "iana",
		},
		"application/timestamped-data": {
			source: "iana",
			extensions: ["tsd"],
		},
		"application/tlsrpt+gzip": {
			source: "iana",
		},
		"application/tlsrpt+json": {
			source: "iana",
			compressible: true,
		},
		"application/tnauthlist": {
			source: "iana",
		},
		"application/token-introspection+jwt": {
			source: "iana",
		},
		"application/toml": {
			compressible: true,
			extensions: ["toml"],
		},
		"application/trickle-ice-sdpfrag": {
			source: "iana",
		},
		"application/trig": {
			source: "iana",
			extensions: ["trig"],
		},
		"application/ttml+xml": {
			source: "iana",
			compressible: true,
			extensions: ["ttml"],
		},
		"application/tve-trigger": {
			source: "iana",
		},
		"application/tzif": {
			source: "iana",
		},
		"application/tzif-leap": {
			source: "iana",
		},
		"application/ubjson": {
			compressible: false,
			extensions: ["ubj"],
		},
		"application/ulpfec": {
			source: "iana",
		},
		"application/urc-grpsheet+xml": {
			source: "iana",
			compressible: true,
		},
		"application/urc-ressheet+xml": {
			source: "iana",
			compressible: true,
			extensions: ["rsheet"],
		},
		"application/urc-targetdesc+xml": {
			source: "iana",
			compressible: true,
			extensions: ["td"],
		},
		"application/urc-uisocketdesc+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vcard+json": {
			source: "iana",
			compressible: true,
		},
		"application/vcard+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vemmi": {
			source: "iana",
		},
		"application/vividence.scriptfile": {
			source: "apache",
		},
		"application/vnd.1000minds.decision-model+xml": {
			source: "iana",
			compressible: true,
			extensions: ["1km"],
		},
		"application/vnd.3gpp-prose+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp-prose-pc3ch+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp-v2x-local-service-information": {
			source: "iana",
		},
		"application/vnd.3gpp.5gnas": {
			source: "iana",
		},
		"application/vnd.3gpp.access-transfer-events+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.bsf+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.gmop+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.gtpc": {
			source: "iana",
		},
		"application/vnd.3gpp.interworking-data": {
			source: "iana",
		},
		"application/vnd.3gpp.lpp": {
			source: "iana",
		},
		"application/vnd.3gpp.mc-signalling-ear": {
			source: "iana",
		},
		"application/vnd.3gpp.mcdata-affiliation-command+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.mcdata-info+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.mcdata-payload": {
			source: "iana",
		},
		"application/vnd.3gpp.mcdata-service-config+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.mcdata-signalling": {
			source: "iana",
		},
		"application/vnd.3gpp.mcdata-ue-config+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.mcdata-user-profile+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.mcptt-affiliation-command+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.mcptt-floor-request+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.mcptt-info+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.mcptt-location-info+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.mcptt-service-config+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.mcptt-signed+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.mcptt-ue-config+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.mcptt-ue-init-config+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.mcptt-user-profile+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.mcvideo-affiliation-command+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.mcvideo-affiliation-info+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.mcvideo-info+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.mcvideo-location-info+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.mcvideo-service-config+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.mcvideo-transmission-request+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.mcvideo-ue-config+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.mcvideo-user-profile+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.mid-call+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.ngap": {
			source: "iana",
		},
		"application/vnd.3gpp.pfcp": {
			source: "iana",
		},
		"application/vnd.3gpp.pic-bw-large": {
			source: "iana",
			extensions: ["plb"],
		},
		"application/vnd.3gpp.pic-bw-small": {
			source: "iana",
			extensions: ["psb"],
		},
		"application/vnd.3gpp.pic-bw-var": {
			source: "iana",
			extensions: ["pvb"],
		},
		"application/vnd.3gpp.s1ap": {
			source: "iana",
		},
		"application/vnd.3gpp.sms": {
			source: "iana",
		},
		"application/vnd.3gpp.sms+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.srvcc-ext+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.srvcc-info+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.state-and-event-info+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp.ussd+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp2.bcmcsinfo+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.3gpp2.sms": {
			source: "iana",
		},
		"application/vnd.3gpp2.tcap": {
			source: "iana",
			extensions: ["tcap"],
		},
		"application/vnd.3lightssoftware.imagescal": {
			source: "iana",
		},
		"application/vnd.3m.post-it-notes": {
			source: "iana",
			extensions: ["pwn"],
		},
		"application/vnd.accpac.simply.aso": {
			source: "iana",
			extensions: ["aso"],
		},
		"application/vnd.accpac.simply.imp": {
			source: "iana",
			extensions: ["imp"],
		},
		"application/vnd.acucobol": {
			source: "iana",
			extensions: ["acu"],
		},
		"application/vnd.acucorp": {
			source: "iana",
			extensions: ["atc", "acutc"],
		},
		"application/vnd.adobe.air-application-installer-package+zip": {
			source: "apache",
			compressible: false,
			extensions: ["air"],
		},
		"application/vnd.adobe.flash.movie": {
			source: "iana",
		},
		"application/vnd.adobe.formscentral.fcdt": {
			source: "iana",
			extensions: ["fcdt"],
		},
		"application/vnd.adobe.fxp": {
			source: "iana",
			extensions: ["fxp", "fxpl"],
		},
		"application/vnd.adobe.partial-upload": {
			source: "iana",
		},
		"application/vnd.adobe.xdp+xml": {
			source: "iana",
			compressible: true,
			extensions: ["xdp"],
		},
		"application/vnd.adobe.xfdf": {
			source: "iana",
			extensions: ["xfdf"],
		},
		"application/vnd.aether.imp": {
			source: "iana",
		},
		"application/vnd.afpc.afplinedata": {
			source: "iana",
		},
		"application/vnd.afpc.afplinedata-pagedef": {
			source: "iana",
		},
		"application/vnd.afpc.cmoca-cmresource": {
			source: "iana",
		},
		"application/vnd.afpc.foca-charset": {
			source: "iana",
		},
		"application/vnd.afpc.foca-codedfont": {
			source: "iana",
		},
		"application/vnd.afpc.foca-codepage": {
			source: "iana",
		},
		"application/vnd.afpc.modca": {
			source: "iana",
		},
		"application/vnd.afpc.modca-cmtable": {
			source: "iana",
		},
		"application/vnd.afpc.modca-formdef": {
			source: "iana",
		},
		"application/vnd.afpc.modca-mediummap": {
			source: "iana",
		},
		"application/vnd.afpc.modca-objectcontainer": {
			source: "iana",
		},
		"application/vnd.afpc.modca-overlay": {
			source: "iana",
		},
		"application/vnd.afpc.modca-pagesegment": {
			source: "iana",
		},
		"application/vnd.age": {
			source: "iana",
			extensions: ["age"],
		},
		"application/vnd.ah-barcode": {
			source: "iana",
		},
		"application/vnd.ahead.space": {
			source: "iana",
			extensions: ["ahead"],
		},
		"application/vnd.airzip.filesecure.azf": {
			source: "iana",
			extensions: ["azf"],
		},
		"application/vnd.airzip.filesecure.azs": {
			source: "iana",
			extensions: ["azs"],
		},
		"application/vnd.amadeus+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.amazon.ebook": {
			source: "apache",
			extensions: ["azw"],
		},
		"application/vnd.amazon.mobi8-ebook": {
			source: "iana",
		},
		"application/vnd.americandynamics.acc": {
			source: "iana",
			extensions: ["acc"],
		},
		"application/vnd.amiga.ami": {
			source: "iana",
			extensions: ["ami"],
		},
		"application/vnd.amundsen.maze+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.android.ota": {
			source: "iana",
		},
		"application/vnd.android.package-archive": {
			source: "apache",
			compressible: false,
			extensions: ["apk"],
		},
		"application/vnd.anki": {
			source: "iana",
		},
		"application/vnd.anser-web-certificate-issue-initiation": {
			source: "iana",
			extensions: ["cii"],
		},
		"application/vnd.anser-web-funds-transfer-initiation": {
			source: "apache",
			extensions: ["fti"],
		},
		"application/vnd.antix.game-component": {
			source: "iana",
			extensions: ["atx"],
		},
		"application/vnd.apache.arrow.file": {
			source: "iana",
		},
		"application/vnd.apache.arrow.stream": {
			source: "iana",
		},
		"application/vnd.apache.thrift.binary": {
			source: "iana",
		},
		"application/vnd.apache.thrift.compact": {
			source: "iana",
		},
		"application/vnd.apache.thrift.json": {
			source: "iana",
		},
		"application/vnd.api+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.aplextor.warrp+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.apothekende.reservation+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.apple.installer+xml": {
			source: "iana",
			compressible: true,
			extensions: ["mpkg"],
		},
		"application/vnd.apple.keynote": {
			source: "iana",
			extensions: ["key"],
		},
		"application/vnd.apple.mpegurl": {
			source: "iana",
			extensions: ["m3u8"],
		},
		"application/vnd.apple.numbers": {
			source: "iana",
			extensions: ["numbers"],
		},
		"application/vnd.apple.pages": {
			source: "iana",
			extensions: ["pages"],
		},
		"application/vnd.apple.pkpass": {
			compressible: false,
			extensions: ["pkpass"],
		},
		"application/vnd.arastra.swi": {
			source: "iana",
		},
		"application/vnd.aristanetworks.swi": {
			source: "iana",
			extensions: ["swi"],
		},
		"application/vnd.artisan+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.artsquare": {
			source: "iana",
		},
		"application/vnd.astraea-software.iota": {
			source: "iana",
			extensions: ["iota"],
		},
		"application/vnd.audiograph": {
			source: "iana",
			extensions: ["aep"],
		},
		"application/vnd.autopackage": {
			source: "iana",
		},
		"application/vnd.avalon+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.avistar+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.balsamiq.bmml+xml": {
			source: "iana",
			compressible: true,
			extensions: ["bmml"],
		},
		"application/vnd.balsamiq.bmpr": {
			source: "iana",
		},
		"application/vnd.banana-accounting": {
			source: "iana",
		},
		"application/vnd.bbf.usp.error": {
			source: "iana",
		},
		"application/vnd.bbf.usp.msg": {
			source: "iana",
		},
		"application/vnd.bbf.usp.msg+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.bekitzur-stech+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.bint.med-content": {
			source: "iana",
		},
		"application/vnd.biopax.rdf+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.blink-idb-value-wrapper": {
			source: "iana",
		},
		"application/vnd.blueice.multipass": {
			source: "iana",
			extensions: ["mpm"],
		},
		"application/vnd.bluetooth.ep.oob": {
			source: "iana",
		},
		"application/vnd.bluetooth.le.oob": {
			source: "iana",
		},
		"application/vnd.bmi": {
			source: "iana",
			extensions: ["bmi"],
		},
		"application/vnd.bpf": {
			source: "iana",
		},
		"application/vnd.bpf3": {
			source: "iana",
		},
		"application/vnd.businessobjects": {
			source: "iana",
			extensions: ["rep"],
		},
		"application/vnd.byu.uapi+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.cab-jscript": {
			source: "iana",
		},
		"application/vnd.canon-cpdl": {
			source: "iana",
		},
		"application/vnd.canon-lips": {
			source: "iana",
		},
		"application/vnd.capasystems-pg+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.cendio.thinlinc.clientconf": {
			source: "iana",
		},
		"application/vnd.century-systems.tcp_stream": {
			source: "iana",
		},
		"application/vnd.chemdraw+xml": {
			source: "iana",
			compressible: true,
			extensions: ["cdxml"],
		},
		"application/vnd.chess-pgn": {
			source: "iana",
		},
		"application/vnd.chipnuts.karaoke-mmd": {
			source: "iana",
			extensions: ["mmd"],
		},
		"application/vnd.ciedi": {
			source: "iana",
		},
		"application/vnd.cinderella": {
			source: "iana",
			extensions: ["cdy"],
		},
		"application/vnd.cirpack.isdn-ext": {
			source: "iana",
		},
		"application/vnd.citationstyles.style+xml": {
			source: "iana",
			compressible: true,
			extensions: ["csl"],
		},
		"application/vnd.claymore": {
			source: "iana",
			extensions: ["cla"],
		},
		"application/vnd.cloanto.rp9": {
			source: "iana",
			extensions: ["rp9"],
		},
		"application/vnd.clonk.c4group": {
			source: "iana",
			extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"],
		},
		"application/vnd.cluetrust.cartomobile-config": {
			source: "iana",
			extensions: ["c11amc"],
		},
		"application/vnd.cluetrust.cartomobile-config-pkg": {
			source: "iana",
			extensions: ["c11amz"],
		},
		"application/vnd.coffeescript": {
			source: "iana",
		},
		"application/vnd.collabio.xodocuments.document": {
			source: "iana",
		},
		"application/vnd.collabio.xodocuments.document-template": {
			source: "iana",
		},
		"application/vnd.collabio.xodocuments.presentation": {
			source: "iana",
		},
		"application/vnd.collabio.xodocuments.presentation-template": {
			source: "iana",
		},
		"application/vnd.collabio.xodocuments.spreadsheet": {
			source: "iana",
		},
		"application/vnd.collabio.xodocuments.spreadsheet-template": {
			source: "iana",
		},
		"application/vnd.collection+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.collection.doc+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.collection.next+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.comicbook+zip": {
			source: "iana",
			compressible: false,
		},
		"application/vnd.comicbook-rar": {
			source: "iana",
		},
		"application/vnd.commerce-battelle": {
			source: "iana",
		},
		"application/vnd.commonspace": {
			source: "iana",
			extensions: ["csp"],
		},
		"application/vnd.contact.cmsg": {
			source: "iana",
			extensions: ["cdbcmsg"],
		},
		"application/vnd.coreos.ignition+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.cosmocaller": {
			source: "iana",
			extensions: ["cmc"],
		},
		"application/vnd.crick.clicker": {
			source: "iana",
			extensions: ["clkx"],
		},
		"application/vnd.crick.clicker.keyboard": {
			source: "iana",
			extensions: ["clkk"],
		},
		"application/vnd.crick.clicker.palette": {
			source: "iana",
			extensions: ["clkp"],
		},
		"application/vnd.crick.clicker.template": {
			source: "iana",
			extensions: ["clkt"],
		},
		"application/vnd.crick.clicker.wordbank": {
			source: "iana",
			extensions: ["clkw"],
		},
		"application/vnd.criticaltools.wbs+xml": {
			source: "iana",
			compressible: true,
			extensions: ["wbs"],
		},
		"application/vnd.cryptii.pipe+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.crypto-shade-file": {
			source: "iana",
		},
		"application/vnd.cryptomator.encrypted": {
			source: "iana",
		},
		"application/vnd.cryptomator.vault": {
			source: "iana",
		},
		"application/vnd.ctc-posml": {
			source: "iana",
			extensions: ["pml"],
		},
		"application/vnd.ctct.ws+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.cups-pdf": {
			source: "iana",
		},
		"application/vnd.cups-postscript": {
			source: "iana",
		},
		"application/vnd.cups-ppd": {
			source: "iana",
			extensions: ["ppd"],
		},
		"application/vnd.cups-raster": {
			source: "iana",
		},
		"application/vnd.cups-raw": {
			source: "iana",
		},
		"application/vnd.curl": {
			source: "iana",
		},
		"application/vnd.curl.car": {
			source: "apache",
			extensions: ["car"],
		},
		"application/vnd.curl.pcurl": {
			source: "apache",
			extensions: ["pcurl"],
		},
		"application/vnd.cyan.dean.root+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.cybank": {
			source: "iana",
		},
		"application/vnd.cyclonedx+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.cyclonedx+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.d2l.coursepackage1p0+zip": {
			source: "iana",
			compressible: false,
		},
		"application/vnd.d3m-dataset": {
			source: "iana",
		},
		"application/vnd.d3m-problem": {
			source: "iana",
		},
		"application/vnd.dart": {
			source: "iana",
			compressible: true,
			extensions: ["dart"],
		},
		"application/vnd.data-vision.rdz": {
			source: "iana",
			extensions: ["rdz"],
		},
		"application/vnd.datapackage+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.dataresource+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.dbf": {
			source: "iana",
			extensions: ["dbf"],
		},
		"application/vnd.debian.binary-package": {
			source: "iana",
		},
		"application/vnd.dece.data": {
			source: "iana",
			extensions: ["uvf", "uvvf", "uvd", "uvvd"],
		},
		"application/vnd.dece.ttml+xml": {
			source: "iana",
			compressible: true,
			extensions: ["uvt", "uvvt"],
		},
		"application/vnd.dece.unspecified": {
			source: "iana",
			extensions: ["uvx", "uvvx"],
		},
		"application/vnd.dece.zip": {
			source: "iana",
			extensions: ["uvz", "uvvz"],
		},
		"application/vnd.denovo.fcselayout-link": {
			source: "iana",
			extensions: ["fe_launch"],
		},
		"application/vnd.desmume.movie": {
			source: "iana",
		},
		"application/vnd.dir-bi.plate-dl-nosuffix": {
			source: "iana",
		},
		"application/vnd.dm.delegation+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.dna": {
			source: "iana",
			extensions: ["dna"],
		},
		"application/vnd.document+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.dolby.mlp": {
			source: "apache",
			extensions: ["mlp"],
		},
		"application/vnd.dolby.mobile.1": {
			source: "iana",
		},
		"application/vnd.dolby.mobile.2": {
			source: "iana",
		},
		"application/vnd.doremir.scorecloud-binary-document": {
			source: "iana",
		},
		"application/vnd.dpgraph": {
			source: "iana",
			extensions: ["dpg"],
		},
		"application/vnd.dreamfactory": {
			source: "iana",
			extensions: ["dfac"],
		},
		"application/vnd.drive+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.ds-keypoint": {
			source: "apache",
			extensions: ["kpxx"],
		},
		"application/vnd.dtg.local": {
			source: "iana",
		},
		"application/vnd.dtg.local.flash": {
			source: "iana",
		},
		"application/vnd.dtg.local.html": {
			source: "iana",
		},
		"application/vnd.dvb.ait": {
			source: "iana",
			extensions: ["ait"],
		},
		"application/vnd.dvb.dvbisl+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.dvb.dvbj": {
			source: "iana",
		},
		"application/vnd.dvb.esgcontainer": {
			source: "iana",
		},
		"application/vnd.dvb.ipdcdftnotifaccess": {
			source: "iana",
		},
		"application/vnd.dvb.ipdcesgaccess": {
			source: "iana",
		},
		"application/vnd.dvb.ipdcesgaccess2": {
			source: "iana",
		},
		"application/vnd.dvb.ipdcesgpdd": {
			source: "iana",
		},
		"application/vnd.dvb.ipdcroaming": {
			source: "iana",
		},
		"application/vnd.dvb.iptv.alfec-base": {
			source: "iana",
		},
		"application/vnd.dvb.iptv.alfec-enhancement": {
			source: "iana",
		},
		"application/vnd.dvb.notif-aggregate-root+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.dvb.notif-container+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.dvb.notif-generic+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.dvb.notif-ia-msglist+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.dvb.notif-ia-registration-request+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.dvb.notif-ia-registration-response+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.dvb.notif-init+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.dvb.pfr": {
			source: "iana",
		},
		"application/vnd.dvb.service": {
			source: "iana",
			extensions: ["svc"],
		},
		"application/vnd.dxr": {
			source: "iana",
		},
		"application/vnd.dynageo": {
			source: "iana",
			extensions: ["geo"],
		},
		"application/vnd.dzr": {
			source: "iana",
		},
		"application/vnd.easykaraoke.cdgdownload": {
			source: "iana",
		},
		"application/vnd.ecdis-update": {
			source: "iana",
		},
		"application/vnd.ecip.rlp": {
			source: "iana",
		},
		"application/vnd.eclipse.ditto+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.ecowin.chart": {
			source: "iana",
			extensions: ["mag"],
		},
		"application/vnd.ecowin.filerequest": {
			source: "iana",
		},
		"application/vnd.ecowin.fileupdate": {
			source: "iana",
		},
		"application/vnd.ecowin.series": {
			source: "iana",
		},
		"application/vnd.ecowin.seriesrequest": {
			source: "iana",
		},
		"application/vnd.ecowin.seriesupdate": {
			source: "iana",
		},
		"application/vnd.efi.img": {
			source: "iana",
		},
		"application/vnd.efi.iso": {
			source: "iana",
		},
		"application/vnd.emclient.accessrequest+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.enliven": {
			source: "iana",
			extensions: ["nml"],
		},
		"application/vnd.enphase.envoy": {
			source: "iana",
		},
		"application/vnd.eprints.data+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.epson.esf": {
			source: "iana",
			extensions: ["esf"],
		},
		"application/vnd.epson.msf": {
			source: "iana",
			extensions: ["msf"],
		},
		"application/vnd.epson.quickanime": {
			source: "iana",
			extensions: ["qam"],
		},
		"application/vnd.epson.salt": {
			source: "iana",
			extensions: ["slt"],
		},
		"application/vnd.epson.ssf": {
			source: "iana",
			extensions: ["ssf"],
		},
		"application/vnd.ericsson.quickcall": {
			source: "iana",
		},
		"application/vnd.espass-espass+zip": {
			source: "iana",
			compressible: false,
		},
		"application/vnd.eszigno3+xml": {
			source: "iana",
			compressible: true,
			extensions: ["es3", "et3"],
		},
		"application/vnd.etsi.aoc+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.etsi.asic-e+zip": {
			source: "iana",
			compressible: false,
		},
		"application/vnd.etsi.asic-s+zip": {
			source: "iana",
			compressible: false,
		},
		"application/vnd.etsi.cug+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.etsi.iptvcommand+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.etsi.iptvdiscovery+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.etsi.iptvprofile+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.etsi.iptvsad-bc+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.etsi.iptvsad-cod+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.etsi.iptvsad-npvr+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.etsi.iptvservice+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.etsi.iptvsync+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.etsi.iptvueprofile+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.etsi.mcid+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.etsi.mheg5": {
			source: "iana",
		},
		"application/vnd.etsi.overload-control-policy-dataset+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.etsi.pstn+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.etsi.sci+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.etsi.simservs+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.etsi.timestamp-token": {
			source: "iana",
		},
		"application/vnd.etsi.tsl+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.etsi.tsl.der": {
			source: "iana",
		},
		"application/vnd.eu.kasparian.car+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.eudora.data": {
			source: "iana",
		},
		"application/vnd.evolv.ecig.profile": {
			source: "iana",
		},
		"application/vnd.evolv.ecig.settings": {
			source: "iana",
		},
		"application/vnd.evolv.ecig.theme": {
			source: "iana",
		},
		"application/vnd.exstream-empower+zip": {
			source: "iana",
			compressible: false,
		},
		"application/vnd.exstream-package": {
			source: "iana",
		},
		"application/vnd.ezpix-album": {
			source: "iana",
			extensions: ["ez2"],
		},
		"application/vnd.ezpix-package": {
			source: "iana",
			extensions: ["ez3"],
		},
		"application/vnd.f-secure.mobile": {
			source: "iana",
		},
		"application/vnd.familysearch.gedcom+zip": {
			source: "iana",
			compressible: false,
		},
		"application/vnd.fastcopy-disk-image": {
			source: "iana",
		},
		"application/vnd.fdf": {
			source: "iana",
			extensions: ["fdf"],
		},
		"application/vnd.fdsn.mseed": {
			source: "iana",
			extensions: ["mseed"],
		},
		"application/vnd.fdsn.seed": {
			source: "iana",
			extensions: ["seed", "dataless"],
		},
		"application/vnd.ffsns": {
			source: "iana",
		},
		"application/vnd.ficlab.flb+zip": {
			source: "iana",
			compressible: false,
		},
		"application/vnd.filmit.zfc": {
			source: "iana",
		},
		"application/vnd.fints": {
			source: "iana",
		},
		"application/vnd.firemonkeys.cloudcell": {
			source: "iana",
		},
		"application/vnd.flographit": {
			source: "iana",
			extensions: ["gph"],
		},
		"application/vnd.fluxtime.clip": {
			source: "iana",
			extensions: ["ftc"],
		},
		"application/vnd.font-fontforge-sfd": {
			source: "iana",
		},
		"application/vnd.framemaker": {
			source: "iana",
			extensions: ["fm", "frame", "maker", "book"],
		},
		"application/vnd.frogans.fnc": {
			source: "iana",
			extensions: ["fnc"],
		},
		"application/vnd.frogans.ltf": {
			source: "iana",
			extensions: ["ltf"],
		},
		"application/vnd.fsc.weblaunch": {
			source: "iana",
			extensions: ["fsc"],
		},
		"application/vnd.fujifilm.fb.docuworks": {
			source: "iana",
		},
		"application/vnd.fujifilm.fb.docuworks.binder": {
			source: "iana",
		},
		"application/vnd.fujifilm.fb.docuworks.container": {
			source: "iana",
		},
		"application/vnd.fujifilm.fb.jfi+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.fujitsu.oasys": {
			source: "iana",
			extensions: ["oas"],
		},
		"application/vnd.fujitsu.oasys2": {
			source: "iana",
			extensions: ["oa2"],
		},
		"application/vnd.fujitsu.oasys3": {
			source: "iana",
			extensions: ["oa3"],
		},
		"application/vnd.fujitsu.oasysgp": {
			source: "iana",
			extensions: ["fg5"],
		},
		"application/vnd.fujitsu.oasysprs": {
			source: "iana",
			extensions: ["bh2"],
		},
		"application/vnd.fujixerox.art-ex": {
			source: "iana",
		},
		"application/vnd.fujixerox.art4": {
			source: "iana",
		},
		"application/vnd.fujixerox.ddd": {
			source: "iana",
			extensions: ["ddd"],
		},
		"application/vnd.fujixerox.docuworks": {
			source: "iana",
			extensions: ["xdw"],
		},
		"application/vnd.fujixerox.docuworks.binder": {
			source: "iana",
			extensions: ["xbd"],
		},
		"application/vnd.fujixerox.docuworks.container": {
			source: "iana",
		},
		"application/vnd.fujixerox.hbpl": {
			source: "iana",
		},
		"application/vnd.fut-misnet": {
			source: "iana",
		},
		"application/vnd.futoin+cbor": {
			source: "iana",
		},
		"application/vnd.futoin+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.fuzzysheet": {
			source: "iana",
			extensions: ["fzs"],
		},
		"application/vnd.genomatix.tuxedo": {
			source: "iana",
			extensions: ["txd"],
		},
		"application/vnd.gentics.grd+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.geo+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.geocube+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.geogebra.file": {
			source: "iana",
			extensions: ["ggb"],
		},
		"application/vnd.geogebra.slides": {
			source: "iana",
		},
		"application/vnd.geogebra.tool": {
			source: "iana",
			extensions: ["ggt"],
		},
		"application/vnd.geometry-explorer": {
			source: "iana",
			extensions: ["gex", "gre"],
		},
		"application/vnd.geonext": {
			source: "iana",
			extensions: ["gxt"],
		},
		"application/vnd.geoplan": {
			source: "iana",
			extensions: ["g2w"],
		},
		"application/vnd.geospace": {
			source: "iana",
			extensions: ["g3w"],
		},
		"application/vnd.gerber": {
			source: "iana",
		},
		"application/vnd.globalplatform.card-content-mgt": {
			source: "iana",
		},
		"application/vnd.globalplatform.card-content-mgt-response": {
			source: "iana",
		},
		"application/vnd.gmx": {
			source: "iana",
			extensions: ["gmx"],
		},
		"application/vnd.google-apps.document": {
			compressible: false,
			extensions: ["gdoc"],
		},
		"application/vnd.google-apps.presentation": {
			compressible: false,
			extensions: ["gslides"],
		},
		"application/vnd.google-apps.spreadsheet": {
			compressible: false,
			extensions: ["gsheet"],
		},
		"application/vnd.google-earth.kml+xml": {
			source: "iana",
			compressible: true,
			extensions: ["kml"],
		},
		"application/vnd.google-earth.kmz": {
			source: "iana",
			compressible: false,
			extensions: ["kmz"],
		},
		"application/vnd.gov.sk.e-form+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.gov.sk.e-form+zip": {
			source: "iana",
			compressible: false,
		},
		"application/vnd.gov.sk.xmldatacontainer+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.grafeq": {
			source: "iana",
			extensions: ["gqf", "gqs"],
		},
		"application/vnd.gridmp": {
			source: "iana",
		},
		"application/vnd.groove-account": {
			source: "iana",
			extensions: ["gac"],
		},
		"application/vnd.groove-help": {
			source: "iana",
			extensions: ["ghf"],
		},
		"application/vnd.groove-identity-message": {
			source: "iana",
			extensions: ["gim"],
		},
		"application/vnd.groove-injector": {
			source: "iana",
			extensions: ["grv"],
		},
		"application/vnd.groove-tool-message": {
			source: "iana",
			extensions: ["gtm"],
		},
		"application/vnd.groove-tool-template": {
			source: "iana",
			extensions: ["tpl"],
		},
		"application/vnd.groove-vcard": {
			source: "iana",
			extensions: ["vcg"],
		},
		"application/vnd.hal+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.hal+xml": {
			source: "iana",
			compressible: true,
			extensions: ["hal"],
		},
		"application/vnd.handheld-entertainment+xml": {
			source: "iana",
			compressible: true,
			extensions: ["zmm"],
		},
		"application/vnd.hbci": {
			source: "iana",
			extensions: ["hbci"],
		},
		"application/vnd.hc+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.hcl-bireports": {
			source: "iana",
		},
		"application/vnd.hdt": {
			source: "iana",
		},
		"application/vnd.heroku+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.hhe.lesson-player": {
			source: "iana",
			extensions: ["les"],
		},
		"application/vnd.hl7cda+xml": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
		},
		"application/vnd.hl7v2+xml": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
		},
		"application/vnd.hp-hpgl": {
			source: "iana",
			extensions: ["hpgl"],
		},
		"application/vnd.hp-hpid": {
			source: "iana",
			extensions: ["hpid"],
		},
		"application/vnd.hp-hps": {
			source: "iana",
			extensions: ["hps"],
		},
		"application/vnd.hp-jlyt": {
			source: "iana",
			extensions: ["jlt"],
		},
		"application/vnd.hp-pcl": {
			source: "iana",
			extensions: ["pcl"],
		},
		"application/vnd.hp-pclxl": {
			source: "iana",
			extensions: ["pclxl"],
		},
		"application/vnd.httphone": {
			source: "iana",
		},
		"application/vnd.hydrostatix.sof-data": {
			source: "iana",
			extensions: ["sfd-hdstx"],
		},
		"application/vnd.hyper+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.hyper-item+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.hyperdrive+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.hzn-3d-crossword": {
			source: "iana",
		},
		"application/vnd.ibm.afplinedata": {
			source: "iana",
		},
		"application/vnd.ibm.electronic-media": {
			source: "iana",
		},
		"application/vnd.ibm.minipay": {
			source: "iana",
			extensions: ["mpy"],
		},
		"application/vnd.ibm.modcap": {
			source: "iana",
			extensions: ["afp", "listafp", "list3820"],
		},
		"application/vnd.ibm.rights-management": {
			source: "iana",
			extensions: ["irm"],
		},
		"application/vnd.ibm.secure-container": {
			source: "iana",
			extensions: ["sc"],
		},
		"application/vnd.iccprofile": {
			source: "iana",
			extensions: ["icc", "icm"],
		},
		"application/vnd.ieee.1905": {
			source: "iana",
		},
		"application/vnd.igloader": {
			source: "iana",
			extensions: ["igl"],
		},
		"application/vnd.imagemeter.folder+zip": {
			source: "iana",
			compressible: false,
		},
		"application/vnd.imagemeter.image+zip": {
			source: "iana",
			compressible: false,
		},
		"application/vnd.immervision-ivp": {
			source: "iana",
			extensions: ["ivp"],
		},
		"application/vnd.immervision-ivu": {
			source: "iana",
			extensions: ["ivu"],
		},
		"application/vnd.ims.imsccv1p1": {
			source: "iana",
		},
		"application/vnd.ims.imsccv1p2": {
			source: "iana",
		},
		"application/vnd.ims.imsccv1p3": {
			source: "iana",
		},
		"application/vnd.ims.lis.v2.result+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.ims.lti.v2.toolconsumerprofile+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.ims.lti.v2.toolproxy+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.ims.lti.v2.toolproxy.id+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.ims.lti.v2.toolsettings+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.ims.lti.v2.toolsettings.simple+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.informedcontrol.rms+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.informix-visionary": {
			source: "iana",
		},
		"application/vnd.infotech.project": {
			source: "iana",
		},
		"application/vnd.infotech.project+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.innopath.wamp.notification": {
			source: "iana",
		},
		"application/vnd.insors.igm": {
			source: "iana",
			extensions: ["igm"],
		},
		"application/vnd.intercon.formnet": {
			source: "iana",
			extensions: ["xpw", "xpx"],
		},
		"application/vnd.intergeo": {
			source: "iana",
			extensions: ["i2g"],
		},
		"application/vnd.intertrust.digibox": {
			source: "iana",
		},
		"application/vnd.intertrust.nncp": {
			source: "iana",
		},
		"application/vnd.intu.qbo": {
			source: "iana",
			extensions: ["qbo"],
		},
		"application/vnd.intu.qfx": {
			source: "iana",
			extensions: ["qfx"],
		},
		"application/vnd.iptc.g2.catalogitem+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.iptc.g2.conceptitem+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.iptc.g2.knowledgeitem+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.iptc.g2.newsitem+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.iptc.g2.newsmessage+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.iptc.g2.packageitem+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.iptc.g2.planningitem+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.ipunplugged.rcprofile": {
			source: "iana",
			extensions: ["rcprofile"],
		},
		"application/vnd.irepository.package+xml": {
			source: "iana",
			compressible: true,
			extensions: ["irp"],
		},
		"application/vnd.is-xpr": {
			source: "iana",
			extensions: ["xpr"],
		},
		"application/vnd.isac.fcs": {
			source: "iana",
			extensions: ["fcs"],
		},
		"application/vnd.iso11783-10+zip": {
			source: "iana",
			compressible: false,
		},
		"application/vnd.jam": {
			source: "iana",
			extensions: ["jam"],
		},
		"application/vnd.japannet-directory-service": {
			source: "iana",
		},
		"application/vnd.japannet-jpnstore-wakeup": {
			source: "iana",
		},
		"application/vnd.japannet-payment-wakeup": {
			source: "iana",
		},
		"application/vnd.japannet-registration": {
			source: "iana",
		},
		"application/vnd.japannet-registration-wakeup": {
			source: "iana",
		},
		"application/vnd.japannet-setstore-wakeup": {
			source: "iana",
		},
		"application/vnd.japannet-verification": {
			source: "iana",
		},
		"application/vnd.japannet-verification-wakeup": {
			source: "iana",
		},
		"application/vnd.jcp.javame.midlet-rms": {
			source: "iana",
			extensions: ["rms"],
		},
		"application/vnd.jisp": {
			source: "iana",
			extensions: ["jisp"],
		},
		"application/vnd.joost.joda-archive": {
			source: "iana",
			extensions: ["joda"],
		},
		"application/vnd.jsk.isdn-ngn": {
			source: "iana",
		},
		"application/vnd.kahootz": {
			source: "iana",
			extensions: ["ktz", "ktr"],
		},
		"application/vnd.kde.karbon": {
			source: "iana",
			extensions: ["karbon"],
		},
		"application/vnd.kde.kchart": {
			source: "iana",
			extensions: ["chrt"],
		},
		"application/vnd.kde.kformula": {
			source: "iana",
			extensions: ["kfo"],
		},
		"application/vnd.kde.kivio": {
			source: "iana",
			extensions: ["flw"],
		},
		"application/vnd.kde.kontour": {
			source: "iana",
			extensions: ["kon"],
		},
		"application/vnd.kde.kpresenter": {
			source: "iana",
			extensions: ["kpr", "kpt"],
		},
		"application/vnd.kde.kspread": {
			source: "iana",
			extensions: ["ksp"],
		},
		"application/vnd.kde.kword": {
			source: "iana",
			extensions: ["kwd", "kwt"],
		},
		"application/vnd.kenameaapp": {
			source: "iana",
			extensions: ["htke"],
		},
		"application/vnd.kidspiration": {
			source: "iana",
			extensions: ["kia"],
		},
		"application/vnd.kinar": {
			source: "iana",
			extensions: ["kne", "knp"],
		},
		"application/vnd.koan": {
			source: "iana",
			extensions: ["skp", "skd", "skt", "skm"],
		},
		"application/vnd.kodak-descriptor": {
			source: "iana",
			extensions: ["sse"],
		},
		"application/vnd.las": {
			source: "iana",
		},
		"application/vnd.las.las+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.las.las+xml": {
			source: "iana",
			compressible: true,
			extensions: ["lasxml"],
		},
		"application/vnd.laszip": {
			source: "iana",
		},
		"application/vnd.leap+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.liberty-request+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.llamagraphics.life-balance.desktop": {
			source: "iana",
			extensions: ["lbd"],
		},
		"application/vnd.llamagraphics.life-balance.exchange+xml": {
			source: "iana",
			compressible: true,
			extensions: ["lbe"],
		},
		"application/vnd.logipipe.circuit+zip": {
			source: "iana",
			compressible: false,
		},
		"application/vnd.loom": {
			source: "iana",
		},
		"application/vnd.lotus-1-2-3": {
			source: "iana",
			extensions: ["123"],
		},
		"application/vnd.lotus-approach": {
			source: "iana",
			extensions: ["apr"],
		},
		"application/vnd.lotus-freelance": {
			source: "iana",
			extensions: ["pre"],
		},
		"application/vnd.lotus-notes": {
			source: "iana",
			extensions: ["nsf"],
		},
		"application/vnd.lotus-organizer": {
			source: "iana",
			extensions: ["org"],
		},
		"application/vnd.lotus-screencam": {
			source: "iana",
			extensions: ["scm"],
		},
		"application/vnd.lotus-wordpro": {
			source: "iana",
			extensions: ["lwp"],
		},
		"application/vnd.macports.portpkg": {
			source: "iana",
			extensions: ["portpkg"],
		},
		"application/vnd.mapbox-vector-tile": {
			source: "iana",
			extensions: ["mvt"],
		},
		"application/vnd.marlin.drm.actiontoken+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.marlin.drm.conftoken+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.marlin.drm.license+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.marlin.drm.mdcf": {
			source: "iana",
		},
		"application/vnd.mason+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.maxar.archive.3tz+zip": {
			source: "iana",
			compressible: false,
		},
		"application/vnd.maxmind.maxmind-db": {
			source: "iana",
		},
		"application/vnd.mcd": {
			source: "iana",
			extensions: ["mcd"],
		},
		"application/vnd.medcalcdata": {
			source: "iana",
			extensions: ["mc1"],
		},
		"application/vnd.mediastation.cdkey": {
			source: "iana",
			extensions: ["cdkey"],
		},
		"application/vnd.meridian-slingshot": {
			source: "iana",
		},
		"application/vnd.mfer": {
			source: "iana",
			extensions: ["mwf"],
		},
		"application/vnd.mfmp": {
			source: "iana",
			extensions: ["mfm"],
		},
		"application/vnd.micro+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.micrografx.flo": {
			source: "iana",
			extensions: ["flo"],
		},
		"application/vnd.micrografx.igx": {
			source: "iana",
			extensions: ["igx"],
		},
		"application/vnd.microsoft.portable-executable": {
			source: "iana",
		},
		"application/vnd.microsoft.windows.thumbnail-cache": {
			source: "iana",
		},
		"application/vnd.miele+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.mif": {
			source: "iana",
			extensions: ["mif"],
		},
		"application/vnd.minisoft-hp3000-save": {
			source: "iana",
		},
		"application/vnd.mitsubishi.misty-guard.trustweb": {
			source: "iana",
		},
		"application/vnd.mobius.daf": {
			source: "iana",
			extensions: ["daf"],
		},
		"application/vnd.mobius.dis": {
			source: "iana",
			extensions: ["dis"],
		},
		"application/vnd.mobius.mbk": {
			source: "iana",
			extensions: ["mbk"],
		},
		"application/vnd.mobius.mqy": {
			source: "iana",
			extensions: ["mqy"],
		},
		"application/vnd.mobius.msl": {
			source: "iana",
			extensions: ["msl"],
		},
		"application/vnd.mobius.plc": {
			source: "iana",
			extensions: ["plc"],
		},
		"application/vnd.mobius.txf": {
			source: "iana",
			extensions: ["txf"],
		},
		"application/vnd.mophun.application": {
			source: "iana",
			extensions: ["mpn"],
		},
		"application/vnd.mophun.certificate": {
			source: "iana",
			extensions: ["mpc"],
		},
		"application/vnd.motorola.flexsuite": {
			source: "iana",
		},
		"application/vnd.motorola.flexsuite.adsi": {
			source: "iana",
		},
		"application/vnd.motorola.flexsuite.fis": {
			source: "iana",
		},
		"application/vnd.motorola.flexsuite.gotap": {
			source: "iana",
		},
		"application/vnd.motorola.flexsuite.kmr": {
			source: "iana",
		},
		"application/vnd.motorola.flexsuite.ttc": {
			source: "iana",
		},
		"application/vnd.motorola.flexsuite.wem": {
			source: "iana",
		},
		"application/vnd.motorola.iprm": {
			source: "iana",
		},
		"application/vnd.mozilla.xul+xml": {
			source: "iana",
			compressible: true,
			extensions: ["xul"],
		},
		"application/vnd.ms-3mfdocument": {
			source: "iana",
		},
		"application/vnd.ms-artgalry": {
			source: "iana",
			extensions: ["cil"],
		},
		"application/vnd.ms-asf": {
			source: "iana",
		},
		"application/vnd.ms-cab-compressed": {
			source: "iana",
			extensions: ["cab"],
		},
		"application/vnd.ms-color.iccprofile": {
			source: "apache",
		},
		"application/vnd.ms-excel": {
			source: "iana",
			compressible: false,
			extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"],
		},
		"application/vnd.ms-excel.addin.macroenabled.12": {
			source: "iana",
			extensions: ["xlam"],
		},
		"application/vnd.ms-excel.sheet.binary.macroenabled.12": {
			source: "iana",
			extensions: ["xlsb"],
		},
		"application/vnd.ms-excel.sheet.macroenabled.12": {
			source: "iana",
			extensions: ["xlsm"],
		},
		"application/vnd.ms-excel.template.macroenabled.12": {
			source: "iana",
			extensions: ["xltm"],
		},
		"application/vnd.ms-fontobject": {
			source: "iana",
			compressible: true,
			extensions: ["eot"],
		},
		"application/vnd.ms-htmlhelp": {
			source: "iana",
			extensions: ["chm"],
		},
		"application/vnd.ms-ims": {
			source: "iana",
			extensions: ["ims"],
		},
		"application/vnd.ms-lrm": {
			source: "iana",
			extensions: ["lrm"],
		},
		"application/vnd.ms-office.activex+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.ms-officetheme": {
			source: "iana",
			extensions: ["thmx"],
		},
		"application/vnd.ms-opentype": {
			source: "apache",
			compressible: true,
		},
		"application/vnd.ms-outlook": {
			compressible: false,
			extensions: ["msg"],
		},
		"application/vnd.ms-package.obfuscated-opentype": {
			source: "apache",
		},
		"application/vnd.ms-pki.seccat": {
			source: "apache",
			extensions: ["cat"],
		},
		"application/vnd.ms-pki.stl": {
			source: "apache",
			extensions: ["stl"],
		},
		"application/vnd.ms-playready.initiator+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.ms-powerpoint": {
			source: "iana",
			compressible: false,
			extensions: ["ppt", "pps", "pot"],
		},
		"application/vnd.ms-powerpoint.addin.macroenabled.12": {
			source: "iana",
			extensions: ["ppam"],
		},
		"application/vnd.ms-powerpoint.presentation.macroenabled.12": {
			source: "iana",
			extensions: ["pptm"],
		},
		"application/vnd.ms-powerpoint.slide.macroenabled.12": {
			source: "iana",
			extensions: ["sldm"],
		},
		"application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
			source: "iana",
			extensions: ["ppsm"],
		},
		"application/vnd.ms-powerpoint.template.macroenabled.12": {
			source: "iana",
			extensions: ["potm"],
		},
		"application/vnd.ms-printdevicecapabilities+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.ms-printing.printticket+xml": {
			source: "apache",
			compressible: true,
		},
		"application/vnd.ms-printschematicket+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.ms-project": {
			source: "iana",
			extensions: ["mpp", "mpt"],
		},
		"application/vnd.ms-tnef": {
			source: "iana",
		},
		"application/vnd.ms-windows.devicepairing": {
			source: "iana",
		},
		"application/vnd.ms-windows.nwprinting.oob": {
			source: "iana",
		},
		"application/vnd.ms-windows.printerpairing": {
			source: "iana",
		},
		"application/vnd.ms-windows.wsd.oob": {
			source: "iana",
		},
		"application/vnd.ms-wmdrm.lic-chlg-req": {
			source: "iana",
		},
		"application/vnd.ms-wmdrm.lic-resp": {
			source: "iana",
		},
		"application/vnd.ms-wmdrm.meter-chlg-req": {
			source: "iana",
		},
		"application/vnd.ms-wmdrm.meter-resp": {
			source: "iana",
		},
		"application/vnd.ms-word.document.macroenabled.12": {
			source: "iana",
			extensions: ["docm"],
		},
		"application/vnd.ms-word.template.macroenabled.12": {
			source: "iana",
			extensions: ["dotm"],
		},
		"application/vnd.ms-works": {
			source: "iana",
			extensions: ["wps", "wks", "wcm", "wdb"],
		},
		"application/vnd.ms-wpl": {
			source: "iana",
			extensions: ["wpl"],
		},
		"application/vnd.ms-xpsdocument": {
			source: "iana",
			compressible: false,
			extensions: ["xps"],
		},
		"application/vnd.msa-disk-image": {
			source: "iana",
		},
		"application/vnd.mseq": {
			source: "iana",
			extensions: ["mseq"],
		},
		"application/vnd.msign": {
			source: "iana",
		},
		"application/vnd.multiad.creator": {
			source: "iana",
		},
		"application/vnd.multiad.creator.cif": {
			source: "iana",
		},
		"application/vnd.music-niff": {
			source: "iana",
		},
		"application/vnd.musician": {
			source: "iana",
			extensions: ["mus"],
		},
		"application/vnd.muvee.style": {
			source: "iana",
			extensions: ["msty"],
		},
		"application/vnd.mynfc": {
			source: "iana",
			extensions: ["taglet"],
		},
		"application/vnd.nacamar.ybrid+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.ncd.control": {
			source: "iana",
		},
		"application/vnd.ncd.reference": {
			source: "iana",
		},
		"application/vnd.nearst.inv+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.nebumind.line": {
			source: "iana",
		},
		"application/vnd.nervana": {
			source: "iana",
		},
		"application/vnd.netfpx": {
			source: "iana",
		},
		"application/vnd.neurolanguage.nlu": {
			source: "iana",
			extensions: ["nlu"],
		},
		"application/vnd.nimn": {
			source: "iana",
		},
		"application/vnd.nintendo.nitro.rom": {
			source: "iana",
		},
		"application/vnd.nintendo.snes.rom": {
			source: "iana",
		},
		"application/vnd.nitf": {
			source: "iana",
			extensions: ["ntf", "nitf"],
		},
		"application/vnd.noblenet-directory": {
			source: "iana",
			extensions: ["nnd"],
		},
		"application/vnd.noblenet-sealer": {
			source: "iana",
			extensions: ["nns"],
		},
		"application/vnd.noblenet-web": {
			source: "iana",
			extensions: ["nnw"],
		},
		"application/vnd.nokia.catalogs": {
			source: "iana",
		},
		"application/vnd.nokia.conml+wbxml": {
			source: "iana",
		},
		"application/vnd.nokia.conml+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.nokia.iptv.config+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.nokia.isds-radio-presets": {
			source: "iana",
		},
		"application/vnd.nokia.landmark+wbxml": {
			source: "iana",
		},
		"application/vnd.nokia.landmark+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.nokia.landmarkcollection+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.nokia.n-gage.ac+xml": {
			source: "iana",
			compressible: true,
			extensions: ["ac"],
		},
		"application/vnd.nokia.n-gage.data": {
			source: "iana",
			extensions: ["ngdat"],
		},
		"application/vnd.nokia.n-gage.symbian.install": {
			source: "iana",
			extensions: ["n-gage"],
		},
		"application/vnd.nokia.ncd": {
			source: "iana",
		},
		"application/vnd.nokia.pcd+wbxml": {
			source: "iana",
		},
		"application/vnd.nokia.pcd+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.nokia.radio-preset": {
			source: "iana",
			extensions: ["rpst"],
		},
		"application/vnd.nokia.radio-presets": {
			source: "iana",
			extensions: ["rpss"],
		},
		"application/vnd.novadigm.edm": {
			source: "iana",
			extensions: ["edm"],
		},
		"application/vnd.novadigm.edx": {
			source: "iana",
			extensions: ["edx"],
		},
		"application/vnd.novadigm.ext": {
			source: "iana",
			extensions: ["ext"],
		},
		"application/vnd.ntt-local.content-share": {
			source: "iana",
		},
		"application/vnd.ntt-local.file-transfer": {
			source: "iana",
		},
		"application/vnd.ntt-local.ogw_remote-access": {
			source: "iana",
		},
		"application/vnd.ntt-local.sip-ta_remote": {
			source: "iana",
		},
		"application/vnd.ntt-local.sip-ta_tcp_stream": {
			source: "iana",
		},
		"application/vnd.oasis.opendocument.chart": {
			source: "iana",
			extensions: ["odc"],
		},
		"application/vnd.oasis.opendocument.chart-template": {
			source: "iana",
			extensions: ["otc"],
		},
		"application/vnd.oasis.opendocument.database": {
			source: "iana",
			extensions: ["odb"],
		},
		"application/vnd.oasis.opendocument.formula": {
			source: "iana",
			extensions: ["odf"],
		},
		"application/vnd.oasis.opendocument.formula-template": {
			source: "iana",
			extensions: ["odft"],
		},
		"application/vnd.oasis.opendocument.graphics": {
			source: "iana",
			compressible: false,
			extensions: ["odg"],
		},
		"application/vnd.oasis.opendocument.graphics-template": {
			source: "iana",
			extensions: ["otg"],
		},
		"application/vnd.oasis.opendocument.image": {
			source: "iana",
			extensions: ["odi"],
		},
		"application/vnd.oasis.opendocument.image-template": {
			source: "iana",
			extensions: ["oti"],
		},
		"application/vnd.oasis.opendocument.presentation": {
			source: "iana",
			compressible: false,
			extensions: ["odp"],
		},
		"application/vnd.oasis.opendocument.presentation-template": {
			source: "iana",
			extensions: ["otp"],
		},
		"application/vnd.oasis.opendocument.spreadsheet": {
			source: "iana",
			compressible: false,
			extensions: ["ods"],
		},
		"application/vnd.oasis.opendocument.spreadsheet-template": {
			source: "iana",
			extensions: ["ots"],
		},
		"application/vnd.oasis.opendocument.text": {
			source: "iana",
			compressible: false,
			extensions: ["odt"],
		},
		"application/vnd.oasis.opendocument.text-master": {
			source: "iana",
			extensions: ["odm"],
		},
		"application/vnd.oasis.opendocument.text-template": {
			source: "iana",
			extensions: ["ott"],
		},
		"application/vnd.oasis.opendocument.text-web": {
			source: "iana",
			extensions: ["oth"],
		},
		"application/vnd.obn": {
			source: "iana",
		},
		"application/vnd.ocf+cbor": {
			source: "iana",
		},
		"application/vnd.oci.image.manifest.v1+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oftn.l10n+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oipf.contentaccessdownload+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oipf.contentaccessstreaming+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oipf.cspg-hexbinary": {
			source: "iana",
		},
		"application/vnd.oipf.dae.svg+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oipf.dae.xhtml+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oipf.mippvcontrolmessage+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oipf.pae.gem": {
			source: "iana",
		},
		"application/vnd.oipf.spdiscovery+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oipf.spdlist+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oipf.ueprofile+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oipf.userprofile+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.olpc-sugar": {
			source: "iana",
			extensions: ["xo"],
		},
		"application/vnd.oma-scws-config": {
			source: "iana",
		},
		"application/vnd.oma-scws-http-request": {
			source: "iana",
		},
		"application/vnd.oma-scws-http-response": {
			source: "iana",
		},
		"application/vnd.oma.bcast.associated-procedure-parameter+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oma.bcast.drm-trigger+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oma.bcast.imd+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oma.bcast.ltkm": {
			source: "iana",
		},
		"application/vnd.oma.bcast.notification+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oma.bcast.provisioningtrigger": {
			source: "iana",
		},
		"application/vnd.oma.bcast.sgboot": {
			source: "iana",
		},
		"application/vnd.oma.bcast.sgdd+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oma.bcast.sgdu": {
			source: "iana",
		},
		"application/vnd.oma.bcast.simple-symbol-container": {
			source: "iana",
		},
		"application/vnd.oma.bcast.smartcard-trigger+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oma.bcast.sprov+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oma.bcast.stkm": {
			source: "iana",
		},
		"application/vnd.oma.cab-address-book+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oma.cab-feature-handler+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oma.cab-pcc+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oma.cab-subs-invite+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oma.cab-user-prefs+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oma.dcd": {
			source: "iana",
		},
		"application/vnd.oma.dcdc": {
			source: "iana",
		},
		"application/vnd.oma.dd2+xml": {
			source: "iana",
			compressible: true,
			extensions: ["dd2"],
		},
		"application/vnd.oma.drm.risd+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oma.group-usage-list+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oma.lwm2m+cbor": {
			source: "iana",
		},
		"application/vnd.oma.lwm2m+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oma.lwm2m+tlv": {
			source: "iana",
		},
		"application/vnd.oma.pal+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oma.poc.detailed-progress-report+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oma.poc.final-report+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oma.poc.groups+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oma.poc.invocation-descriptor+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oma.poc.optimized-progress-report+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oma.push": {
			source: "iana",
		},
		"application/vnd.oma.scidm.messages+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oma.xcap-directory+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.omads-email+xml": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
		},
		"application/vnd.omads-file+xml": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
		},
		"application/vnd.omads-folder+xml": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
		},
		"application/vnd.omaloc-supl-init": {
			source: "iana",
		},
		"application/vnd.onepager": {
			source: "iana",
		},
		"application/vnd.onepagertamp": {
			source: "iana",
		},
		"application/vnd.onepagertamx": {
			source: "iana",
		},
		"application/vnd.onepagertat": {
			source: "iana",
		},
		"application/vnd.onepagertatp": {
			source: "iana",
		},
		"application/vnd.onepagertatx": {
			source: "iana",
		},
		"application/vnd.openblox.game+xml": {
			source: "iana",
			compressible: true,
			extensions: ["obgx"],
		},
		"application/vnd.openblox.game-binary": {
			source: "iana",
		},
		"application/vnd.openeye.oeb": {
			source: "iana",
		},
		"application/vnd.openofficeorg.extension": {
			source: "apache",
			extensions: ["oxt"],
		},
		"application/vnd.openstreetmap.data+xml": {
			source: "iana",
			compressible: true,
			extensions: ["osm"],
		},
		"application/vnd.opentimestamps.ots": {
			source: "iana",
		},
		"application/vnd.openxmlformats-officedocument.custom-properties+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.drawing+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.extended-properties+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presentation": {
			source: "iana",
			compressible: false,
			extensions: ["pptx"],
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slide": {
			source: "iana",
			extensions: ["sldx"],
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
			source: "iana",
			extensions: ["ppsx"],
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.presentationml.template": {
			source: "iana",
			extensions: ["potx"],
		},
		"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
			source: "iana",
			compressible: false,
			extensions: ["xlsx"],
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
			source: "iana",
			extensions: ["xltx"],
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.theme+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.themeoverride+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.vmldrawing": {
			source: "iana",
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
			source: "iana",
			compressible: false,
			extensions: ["docx"],
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
			source: "iana",
			extensions: ["dotx"],
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-package.core-properties+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.openxmlformats-package.relationships+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oracle.resource+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.orange.indata": {
			source: "iana",
		},
		"application/vnd.osa.netdeploy": {
			source: "iana",
		},
		"application/vnd.osgeo.mapguide.package": {
			source: "iana",
			extensions: ["mgp"],
		},
		"application/vnd.osgi.bundle": {
			source: "iana",
		},
		"application/vnd.osgi.dp": {
			source: "iana",
			extensions: ["dp"],
		},
		"application/vnd.osgi.subsystem": {
			source: "iana",
			extensions: ["esa"],
		},
		"application/vnd.otps.ct-kip+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.oxli.countgraph": {
			source: "iana",
		},
		"application/vnd.pagerduty+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.palm": {
			source: "iana",
			extensions: ["pdb", "pqa", "oprc"],
		},
		"application/vnd.panoply": {
			source: "iana",
		},
		"application/vnd.paos.xml": {
			source: "iana",
		},
		"application/vnd.patentdive": {
			source: "iana",
		},
		"application/vnd.patientecommsdoc": {
			source: "iana",
		},
		"application/vnd.pawaafile": {
			source: "iana",
			extensions: ["paw"],
		},
		"application/vnd.pcos": {
			source: "iana",
		},
		"application/vnd.pg.format": {
			source: "iana",
			extensions: ["str"],
		},
		"application/vnd.pg.osasli": {
			source: "iana",
			extensions: ["ei6"],
		},
		"application/vnd.piaccess.application-licence": {
			source: "iana",
		},
		"application/vnd.picsel": {
			source: "iana",
			extensions: ["efif"],
		},
		"application/vnd.pmi.widget": {
			source: "iana",
			extensions: ["wg"],
		},
		"application/vnd.poc.group-advertisement+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.pocketlearn": {
			source: "iana",
			extensions: ["plf"],
		},
		"application/vnd.powerbuilder6": {
			source: "iana",
			extensions: ["pbd"],
		},
		"application/vnd.powerbuilder6-s": {
			source: "iana",
		},
		"application/vnd.powerbuilder7": {
			source: "iana",
		},
		"application/vnd.powerbuilder7-s": {
			source: "iana",
		},
		"application/vnd.powerbuilder75": {
			source: "iana",
		},
		"application/vnd.powerbuilder75-s": {
			source: "iana",
		},
		"application/vnd.preminet": {
			source: "iana",
		},
		"application/vnd.previewsystems.box": {
			source: "iana",
			extensions: ["box"],
		},
		"application/vnd.proteus.magazine": {
			source: "iana",
			extensions: ["mgz"],
		},
		"application/vnd.psfs": {
			source: "iana",
		},
		"application/vnd.publishare-delta-tree": {
			source: "iana",
			extensions: ["qps"],
		},
		"application/vnd.pvi.ptid1": {
			source: "iana",
			extensions: ["ptid"],
		},
		"application/vnd.pwg-multiplexed": {
			source: "iana",
		},
		"application/vnd.pwg-xhtml-print+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.qualcomm.brew-app-res": {
			source: "iana",
		},
		"application/vnd.quarantainenet": {
			source: "iana",
		},
		"application/vnd.quark.quarkxpress": {
			source: "iana",
			extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"],
		},
		"application/vnd.quobject-quoxdocument": {
			source: "iana",
		},
		"application/vnd.radisys.moml+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.radisys.msml+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.radisys.msml-audit+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.radisys.msml-audit-conf+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.radisys.msml-audit-conn+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.radisys.msml-audit-dialog+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.radisys.msml-audit-stream+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.radisys.msml-conf+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.radisys.msml-dialog+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.radisys.msml-dialog-base+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.radisys.msml-dialog-fax-detect+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.radisys.msml-dialog-group+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.radisys.msml-dialog-speech+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.radisys.msml-dialog-transform+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.rainstor.data": {
			source: "iana",
		},
		"application/vnd.rapid": {
			source: "iana",
		},
		"application/vnd.rar": {
			source: "iana",
			extensions: ["rar"],
		},
		"application/vnd.realvnc.bed": {
			source: "iana",
			extensions: ["bed"],
		},
		"application/vnd.recordare.musicxml": {
			source: "iana",
			extensions: ["mxl"],
		},
		"application/vnd.recordare.musicxml+xml": {
			source: "iana",
			compressible: true,
			extensions: ["musicxml"],
		},
		"application/vnd.renlearn.rlprint": {
			source: "iana",
		},
		"application/vnd.resilient.logic": {
			source: "iana",
		},
		"application/vnd.restful+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.rig.cryptonote": {
			source: "iana",
			extensions: ["cryptonote"],
		},
		"application/vnd.rim.cod": {
			source: "apache",
			extensions: ["cod"],
		},
		"application/vnd.rn-realmedia": {
			source: "apache",
			extensions: ["rm"],
		},
		"application/vnd.rn-realmedia-vbr": {
			source: "apache",
			extensions: ["rmvb"],
		},
		"application/vnd.route66.link66+xml": {
			source: "iana",
			compressible: true,
			extensions: ["link66"],
		},
		"application/vnd.rs-274x": {
			source: "iana",
		},
		"application/vnd.ruckus.download": {
			source: "iana",
		},
		"application/vnd.s3sms": {
			source: "iana",
		},
		"application/vnd.sailingtracker.track": {
			source: "iana",
			extensions: ["st"],
		},
		"application/vnd.sar": {
			source: "iana",
		},
		"application/vnd.sbm.cid": {
			source: "iana",
		},
		"application/vnd.sbm.mid2": {
			source: "iana",
		},
		"application/vnd.scribus": {
			source: "iana",
		},
		"application/vnd.sealed.3df": {
			source: "iana",
		},
		"application/vnd.sealed.csf": {
			source: "iana",
		},
		"application/vnd.sealed.doc": {
			source: "iana",
		},
		"application/vnd.sealed.eml": {
			source: "iana",
		},
		"application/vnd.sealed.mht": {
			source: "iana",
		},
		"application/vnd.sealed.net": {
			source: "iana",
		},
		"application/vnd.sealed.ppt": {
			source: "iana",
		},
		"application/vnd.sealed.tiff": {
			source: "iana",
		},
		"application/vnd.sealed.xls": {
			source: "iana",
		},
		"application/vnd.sealedmedia.softseal.html": {
			source: "iana",
		},
		"application/vnd.sealedmedia.softseal.pdf": {
			source: "iana",
		},
		"application/vnd.seemail": {
			source: "iana",
			extensions: ["see"],
		},
		"application/vnd.seis+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.sema": {
			source: "iana",
			extensions: ["sema"],
		},
		"application/vnd.semd": {
			source: "iana",
			extensions: ["semd"],
		},
		"application/vnd.semf": {
			source: "iana",
			extensions: ["semf"],
		},
		"application/vnd.shade-save-file": {
			source: "iana",
		},
		"application/vnd.shana.informed.formdata": {
			source: "iana",
			extensions: ["ifm"],
		},
		"application/vnd.shana.informed.formtemplate": {
			source: "iana",
			extensions: ["itp"],
		},
		"application/vnd.shana.informed.interchange": {
			source: "iana",
			extensions: ["iif"],
		},
		"application/vnd.shana.informed.package": {
			source: "iana",
			extensions: ["ipk"],
		},
		"application/vnd.shootproof+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.shopkick+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.shp": {
			source: "iana",
		},
		"application/vnd.shx": {
			source: "iana",
		},
		"application/vnd.sigrok.session": {
			source: "iana",
		},
		"application/vnd.simtech-mindmapper": {
			source: "iana",
			extensions: ["twd", "twds"],
		},
		"application/vnd.siren+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.smaf": {
			source: "iana",
			extensions: ["mmf"],
		},
		"application/vnd.smart.notebook": {
			source: "iana",
		},
		"application/vnd.smart.teacher": {
			source: "iana",
			extensions: ["teacher"],
		},
		"application/vnd.snesdev-page-table": {
			source: "iana",
		},
		"application/vnd.software602.filler.form+xml": {
			source: "iana",
			compressible: true,
			extensions: ["fo"],
		},
		"application/vnd.software602.filler.form-xml-zip": {
			source: "iana",
		},
		"application/vnd.solent.sdkm+xml": {
			source: "iana",
			compressible: true,
			extensions: ["sdkm", "sdkd"],
		},
		"application/vnd.spotfire.dxp": {
			source: "iana",
			extensions: ["dxp"],
		},
		"application/vnd.spotfire.sfs": {
			source: "iana",
			extensions: ["sfs"],
		},
		"application/vnd.sqlite3": {
			source: "iana",
		},
		"application/vnd.sss-cod": {
			source: "iana",
		},
		"application/vnd.sss-dtf": {
			source: "iana",
		},
		"application/vnd.sss-ntf": {
			source: "iana",
		},
		"application/vnd.stardivision.calc": {
			source: "apache",
			extensions: ["sdc"],
		},
		"application/vnd.stardivision.draw": {
			source: "apache",
			extensions: ["sda"],
		},
		"application/vnd.stardivision.impress": {
			source: "apache",
			extensions: ["sdd"],
		},
		"application/vnd.stardivision.math": {
			source: "apache",
			extensions: ["smf"],
		},
		"application/vnd.stardivision.writer": {
			source: "apache",
			extensions: ["sdw", "vor"],
		},
		"application/vnd.stardivision.writer-global": {
			source: "apache",
			extensions: ["sgl"],
		},
		"application/vnd.stepmania.package": {
			source: "iana",
			extensions: ["smzip"],
		},
		"application/vnd.stepmania.stepchart": {
			source: "iana",
			extensions: ["sm"],
		},
		"application/vnd.street-stream": {
			source: "iana",
		},
		"application/vnd.sun.wadl+xml": {
			source: "iana",
			compressible: true,
			extensions: ["wadl"],
		},
		"application/vnd.sun.xml.calc": {
			source: "apache",
			extensions: ["sxc"],
		},
		"application/vnd.sun.xml.calc.template": {
			source: "apache",
			extensions: ["stc"],
		},
		"application/vnd.sun.xml.draw": {
			source: "apache",
			extensions: ["sxd"],
		},
		"application/vnd.sun.xml.draw.template": {
			source: "apache",
			extensions: ["std"],
		},
		"application/vnd.sun.xml.impress": {
			source: "apache",
			extensions: ["sxi"],
		},
		"application/vnd.sun.xml.impress.template": {
			source: "apache",
			extensions: ["sti"],
		},
		"application/vnd.sun.xml.math": {
			source: "apache",
			extensions: ["sxm"],
		},
		"application/vnd.sun.xml.writer": {
			source: "apache",
			extensions: ["sxw"],
		},
		"application/vnd.sun.xml.writer.global": {
			source: "apache",
			extensions: ["sxg"],
		},
		"application/vnd.sun.xml.writer.template": {
			source: "apache",
			extensions: ["stw"],
		},
		"application/vnd.sus-calendar": {
			source: "iana",
			extensions: ["sus", "susp"],
		},
		"application/vnd.svd": {
			source: "iana",
			extensions: ["svd"],
		},
		"application/vnd.swiftview-ics": {
			source: "iana",
		},
		"application/vnd.sycle+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.syft+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.symbian.install": {
			source: "apache",
			extensions: ["sis", "sisx"],
		},
		"application/vnd.syncml+xml": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
			extensions: ["xsm"],
		},
		"application/vnd.syncml.dm+wbxml": {
			source: "iana",
			charset: "UTF-8",
			extensions: ["bdm"],
		},
		"application/vnd.syncml.dm+xml": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
			extensions: ["xdm"],
		},
		"application/vnd.syncml.dm.notification": {
			source: "iana",
		},
		"application/vnd.syncml.dmddf+wbxml": {
			source: "iana",
		},
		"application/vnd.syncml.dmddf+xml": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
			extensions: ["ddf"],
		},
		"application/vnd.syncml.dmtnds+wbxml": {
			source: "iana",
		},
		"application/vnd.syncml.dmtnds+xml": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
		},
		"application/vnd.syncml.ds.notification": {
			source: "iana",
		},
		"application/vnd.tableschema+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.tao.intent-module-archive": {
			source: "iana",
			extensions: ["tao"],
		},
		"application/vnd.tcpdump.pcap": {
			source: "iana",
			extensions: ["pcap", "cap", "dmp"],
		},
		"application/vnd.think-cell.ppttc+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.tmd.mediaflex.api+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.tml": {
			source: "iana",
		},
		"application/vnd.tmobile-livetv": {
			source: "iana",
			extensions: ["tmo"],
		},
		"application/vnd.tri.onesource": {
			source: "iana",
		},
		"application/vnd.trid.tpt": {
			source: "iana",
			extensions: ["tpt"],
		},
		"application/vnd.triscape.mxs": {
			source: "iana",
			extensions: ["mxs"],
		},
		"application/vnd.trueapp": {
			source: "iana",
			extensions: ["tra"],
		},
		"application/vnd.truedoc": {
			source: "iana",
		},
		"application/vnd.ubisoft.webplayer": {
			source: "iana",
		},
		"application/vnd.ufdl": {
			source: "iana",
			extensions: ["ufd", "ufdl"],
		},
		"application/vnd.uiq.theme": {
			source: "iana",
			extensions: ["utz"],
		},
		"application/vnd.umajin": {
			source: "iana",
			extensions: ["umj"],
		},
		"application/vnd.unity": {
			source: "iana",
			extensions: ["unityweb"],
		},
		"application/vnd.uoml+xml": {
			source: "iana",
			compressible: true,
			extensions: ["uoml"],
		},
		"application/vnd.uplanet.alert": {
			source: "iana",
		},
		"application/vnd.uplanet.alert-wbxml": {
			source: "iana",
		},
		"application/vnd.uplanet.bearer-choice": {
			source: "iana",
		},
		"application/vnd.uplanet.bearer-choice-wbxml": {
			source: "iana",
		},
		"application/vnd.uplanet.cacheop": {
			source: "iana",
		},
		"application/vnd.uplanet.cacheop-wbxml": {
			source: "iana",
		},
		"application/vnd.uplanet.channel": {
			source: "iana",
		},
		"application/vnd.uplanet.channel-wbxml": {
			source: "iana",
		},
		"application/vnd.uplanet.list": {
			source: "iana",
		},
		"application/vnd.uplanet.list-wbxml": {
			source: "iana",
		},
		"application/vnd.uplanet.listcmd": {
			source: "iana",
		},
		"application/vnd.uplanet.listcmd-wbxml": {
			source: "iana",
		},
		"application/vnd.uplanet.signal": {
			source: "iana",
		},
		"application/vnd.uri-map": {
			source: "iana",
		},
		"application/vnd.valve.source.material": {
			source: "iana",
		},
		"application/vnd.vcx": {
			source: "iana",
			extensions: ["vcx"],
		},
		"application/vnd.vd-study": {
			source: "iana",
		},
		"application/vnd.vectorworks": {
			source: "iana",
		},
		"application/vnd.vel+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.verimatrix.vcas": {
			source: "iana",
		},
		"application/vnd.veritone.aion+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.veryant.thin": {
			source: "iana",
		},
		"application/vnd.ves.encrypted": {
			source: "iana",
		},
		"application/vnd.vidsoft.vidconference": {
			source: "iana",
		},
		"application/vnd.visio": {
			source: "iana",
			extensions: ["vsd", "vst", "vss", "vsw"],
		},
		"application/vnd.visionary": {
			source: "iana",
			extensions: ["vis"],
		},
		"application/vnd.vividence.scriptfile": {
			source: "iana",
		},
		"application/vnd.vsf": {
			source: "iana",
			extensions: ["vsf"],
		},
		"application/vnd.wap.sic": {
			source: "iana",
		},
		"application/vnd.wap.slc": {
			source: "iana",
		},
		"application/vnd.wap.wbxml": {
			source: "iana",
			charset: "UTF-8",
			extensions: ["wbxml"],
		},
		"application/vnd.wap.wmlc": {
			source: "iana",
			extensions: ["wmlc"],
		},
		"application/vnd.wap.wmlscriptc": {
			source: "iana",
			extensions: ["wmlsc"],
		},
		"application/vnd.webturbo": {
			source: "iana",
			extensions: ["wtb"],
		},
		"application/vnd.wfa.dpp": {
			source: "iana",
		},
		"application/vnd.wfa.p2p": {
			source: "iana",
		},
		"application/vnd.wfa.wsc": {
			source: "iana",
		},
		"application/vnd.windows.devicepairing": {
			source: "iana",
		},
		"application/vnd.wmc": {
			source: "iana",
		},
		"application/vnd.wmf.bootstrap": {
			source: "iana",
		},
		"application/vnd.wolfram.mathematica": {
			source: "iana",
		},
		"application/vnd.wolfram.mathematica.package": {
			source: "iana",
		},
		"application/vnd.wolfram.player": {
			source: "iana",
			extensions: ["nbp"],
		},
		"application/vnd.wordperfect": {
			source: "iana",
			extensions: ["wpd"],
		},
		"application/vnd.wqd": {
			source: "iana",
			extensions: ["wqd"],
		},
		"application/vnd.wrq-hp3000-labelled": {
			source: "iana",
		},
		"application/vnd.wt.stf": {
			source: "iana",
			extensions: ["stf"],
		},
		"application/vnd.wv.csp+wbxml": {
			source: "iana",
		},
		"application/vnd.wv.csp+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.wv.ssp+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.xacml+json": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.xara": {
			source: "iana",
			extensions: ["xar"],
		},
		"application/vnd.xfdl": {
			source: "iana",
			extensions: ["xfdl"],
		},
		"application/vnd.xfdl.webform": {
			source: "iana",
		},
		"application/vnd.xmi+xml": {
			source: "iana",
			compressible: true,
		},
		"application/vnd.xmpie.cpkg": {
			source: "iana",
		},
		"application/vnd.xmpie.dpkg": {
			source: "iana",
		},
		"application/vnd.xmpie.plan": {
			source: "iana",
		},
		"application/vnd.xmpie.ppkg": {
			source: "iana",
		},
		"application/vnd.xmpie.xlim": {
			source: "iana",
		},
		"application/vnd.yamaha.hv-dic": {
			source: "iana",
			extensions: ["hvd"],
		},
		"application/vnd.yamaha.hv-script": {
			source: "iana",
			extensions: ["hvs"],
		},
		"application/vnd.yamaha.hv-voice": {
			source: "iana",
			extensions: ["hvp"],
		},
		"application/vnd.yamaha.openscoreformat": {
			source: "iana",
			extensions: ["osf"],
		},
		"application/vnd.yamaha.openscoreformat.osfpvg+xml": {
			source: "iana",
			compressible: true,
			extensions: ["osfpvg"],
		},
		"application/vnd.yamaha.remote-setup": {
			source: "iana",
		},
		"application/vnd.yamaha.smaf-audio": {
			source: "iana",
			extensions: ["saf"],
		},
		"application/vnd.yamaha.smaf-phrase": {
			source: "iana",
			extensions: ["spf"],
		},
		"application/vnd.yamaha.through-ngn": {
			source: "iana",
		},
		"application/vnd.yamaha.tunnel-udpencap": {
			source: "iana",
		},
		"application/vnd.yaoweme": {
			source: "iana",
		},
		"application/vnd.yellowriver-custom-menu": {
			source: "iana",
			extensions: ["cmp"],
		},
		"application/vnd.youtube.yt": {
			source: "iana",
		},
		"application/vnd.zul": {
			source: "iana",
			extensions: ["zir", "zirz"],
		},
		"application/vnd.zzazz.deck+xml": {
			source: "iana",
			compressible: true,
			extensions: ["zaz"],
		},
		"application/voicexml+xml": {
			source: "iana",
			compressible: true,
			extensions: ["vxml"],
		},
		"application/voucher-cms+json": {
			source: "iana",
			compressible: true,
		},
		"application/vq-rtcpxr": {
			source: "iana",
		},
		"application/wasm": {
			source: "iana",
			compressible: true,
			extensions: ["wasm"],
		},
		"application/watcherinfo+xml": {
			source: "iana",
			compressible: true,
			extensions: ["wif"],
		},
		"application/webpush-options+json": {
			source: "iana",
			compressible: true,
		},
		"application/whoispp-query": {
			source: "iana",
		},
		"application/whoispp-response": {
			source: "iana",
		},
		"application/widget": {
			source: "iana",
			extensions: ["wgt"],
		},
		"application/winhlp": {
			source: "apache",
			extensions: ["hlp"],
		},
		"application/wita": {
			source: "iana",
		},
		"application/wordperfect5.1": {
			source: "iana",
		},
		"application/wsdl+xml": {
			source: "iana",
			compressible: true,
			extensions: ["wsdl"],
		},
		"application/wspolicy+xml": {
			source: "iana",
			compressible: true,
			extensions: ["wspolicy"],
		},
		"application/x-7z-compressed": {
			source: "apache",
			compressible: false,
			extensions: ["7z"],
		},
		"application/x-abiword": {
			source: "apache",
			extensions: ["abw"],
		},
		"application/x-ace-compressed": {
			source: "apache",
			extensions: ["ace"],
		},
		"application/x-amf": {
			source: "apache",
		},
		"application/x-apple-diskimage": {
			source: "apache",
			extensions: ["dmg"],
		},
		"application/x-arj": {
			compressible: false,
			extensions: ["arj"],
		},
		"application/x-authorware-bin": {
			source: "apache",
			extensions: ["aab", "x32", "u32", "vox"],
		},
		"application/x-authorware-map": {
			source: "apache",
			extensions: ["aam"],
		},
		"application/x-authorware-seg": {
			source: "apache",
			extensions: ["aas"],
		},
		"application/x-bcpio": {
			source: "apache",
			extensions: ["bcpio"],
		},
		"application/x-bdoc": {
			compressible: false,
			extensions: ["bdoc"],
		},
		"application/x-bittorrent": {
			source: "apache",
			extensions: ["torrent"],
		},
		"application/x-blorb": {
			source: "apache",
			extensions: ["blb", "blorb"],
		},
		"application/x-bzip": {
			source: "apache",
			compressible: false,
			extensions: ["bz"],
		},
		"application/x-bzip2": {
			source: "apache",
			compressible: false,
			extensions: ["bz2", "boz"],
		},
		"application/x-cbr": {
			source: "apache",
			extensions: ["cbr", "cba", "cbt", "cbz", "cb7"],
		},
		"application/x-cdlink": {
			source: "apache",
			extensions: ["vcd"],
		},
		"application/x-cfs-compressed": {
			source: "apache",
			extensions: ["cfs"],
		},
		"application/x-chat": {
			source: "apache",
			extensions: ["chat"],
		},
		"application/x-chess-pgn": {
			source: "apache",
			extensions: ["pgn"],
		},
		"application/x-chrome-extension": {
			extensions: ["crx"],
		},
		"application/x-cocoa": {
			source: "nginx",
			extensions: ["cco"],
		},
		"application/x-compress": {
			source: "apache",
		},
		"application/x-conference": {
			source: "apache",
			extensions: ["nsc"],
		},
		"application/x-cpio": {
			source: "apache",
			extensions: ["cpio"],
		},
		"application/x-csh": {
			source: "apache",
			extensions: ["csh"],
		},
		"application/x-deb": {
			compressible: false,
		},
		"application/x-debian-package": {
			source: "apache",
			extensions: ["deb", "udeb"],
		},
		"application/x-dgc-compressed": {
			source: "apache",
			extensions: ["dgc"],
		},
		"application/x-director": {
			source: "apache",
			extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"],
		},
		"application/x-doom": {
			source: "apache",
			extensions: ["wad"],
		},
		"application/x-dtbncx+xml": {
			source: "apache",
			compressible: true,
			extensions: ["ncx"],
		},
		"application/x-dtbook+xml": {
			source: "apache",
			compressible: true,
			extensions: ["dtb"],
		},
		"application/x-dtbresource+xml": {
			source: "apache",
			compressible: true,
			extensions: ["res"],
		},
		"application/x-dvi": {
			source: "apache",
			compressible: false,
			extensions: ["dvi"],
		},
		"application/x-envoy": {
			source: "apache",
			extensions: ["evy"],
		},
		"application/x-eva": {
			source: "apache",
			extensions: ["eva"],
		},
		"application/x-font-bdf": {
			source: "apache",
			extensions: ["bdf"],
		},
		"application/x-font-dos": {
			source: "apache",
		},
		"application/x-font-framemaker": {
			source: "apache",
		},
		"application/x-font-ghostscript": {
			source: "apache",
			extensions: ["gsf"],
		},
		"application/x-font-libgrx": {
			source: "apache",
		},
		"application/x-font-linux-psf": {
			source: "apache",
			extensions: ["psf"],
		},
		"application/x-font-pcf": {
			source: "apache",
			extensions: ["pcf"],
		},
		"application/x-font-snf": {
			source: "apache",
			extensions: ["snf"],
		},
		"application/x-font-speedo": {
			source: "apache",
		},
		"application/x-font-sunos-news": {
			source: "apache",
		},
		"application/x-font-type1": {
			source: "apache",
			extensions: ["pfa", "pfb", "pfm", "afm"],
		},
		"application/x-font-vfont": {
			source: "apache",
		},
		"application/x-freearc": {
			source: "apache",
			extensions: ["arc"],
		},
		"application/x-futuresplash": {
			source: "apache",
			extensions: ["spl"],
		},
		"application/x-gca-compressed": {
			source: "apache",
			extensions: ["gca"],
		},
		"application/x-glulx": {
			source: "apache",
			extensions: ["ulx"],
		},
		"application/x-gnumeric": {
			source: "apache",
			extensions: ["gnumeric"],
		},
		"application/x-gramps-xml": {
			source: "apache",
			extensions: ["gramps"],
		},
		"application/x-gtar": {
			source: "apache",
			extensions: ["gtar"],
		},
		"application/x-gzip": {
			source: "apache",
		},
		"application/x-hdf": {
			source: "apache",
			extensions: ["hdf"],
		},
		"application/x-httpd-php": {
			compressible: true,
			extensions: ["php"],
		},
		"application/x-install-instructions": {
			source: "apache",
			extensions: ["install"],
		},
		"application/x-iso9660-image": {
			source: "apache",
			extensions: ["iso"],
		},
		"application/x-iwork-keynote-sffkey": {
			extensions: ["key"],
		},
		"application/x-iwork-numbers-sffnumbers": {
			extensions: ["numbers"],
		},
		"application/x-iwork-pages-sffpages": {
			extensions: ["pages"],
		},
		"application/x-java-archive-diff": {
			source: "nginx",
			extensions: ["jardiff"],
		},
		"application/x-java-jnlp-file": {
			source: "apache",
			compressible: false,
			extensions: ["jnlp"],
		},
		"application/x-javascript": {
			compressible: true,
		},
		"application/x-keepass2": {
			extensions: ["kdbx"],
		},
		"application/x-latex": {
			source: "apache",
			compressible: false,
			extensions: ["latex"],
		},
		"application/x-lua-bytecode": {
			extensions: ["luac"],
		},
		"application/x-lzh-compressed": {
			source: "apache",
			extensions: ["lzh", "lha"],
		},
		"application/x-makeself": {
			source: "nginx",
			extensions: ["run"],
		},
		"application/x-mie": {
			source: "apache",
			extensions: ["mie"],
		},
		"application/x-mobipocket-ebook": {
			source: "apache",
			extensions: ["prc", "mobi"],
		},
		"application/x-mpegurl": {
			compressible: false,
		},
		"application/x-ms-application": {
			source: "apache",
			extensions: ["application"],
		},
		"application/x-ms-shortcut": {
			source: "apache",
			extensions: ["lnk"],
		},
		"application/x-ms-wmd": {
			source: "apache",
			extensions: ["wmd"],
		},
		"application/x-ms-wmz": {
			source: "apache",
			extensions: ["wmz"],
		},
		"application/x-ms-xbap": {
			source: "apache",
			extensions: ["xbap"],
		},
		"application/x-msaccess": {
			source: "apache",
			extensions: ["mdb"],
		},
		"application/x-msbinder": {
			source: "apache",
			extensions: ["obd"],
		},
		"application/x-mscardfile": {
			source: "apache",
			extensions: ["crd"],
		},
		"application/x-msclip": {
			source: "apache",
			extensions: ["clp"],
		},
		"application/x-msdos-program": {
			extensions: ["exe"],
		},
		"application/x-msdownload": {
			source: "apache",
			extensions: ["exe", "dll", "com", "bat", "msi"],
		},
		"application/x-msmediaview": {
			source: "apache",
			extensions: ["mvb", "m13", "m14"],
		},
		"application/x-msmetafile": {
			source: "apache",
			extensions: ["wmf", "wmz", "emf", "emz"],
		},
		"application/x-msmoney": {
			source: "apache",
			extensions: ["mny"],
		},
		"application/x-mspublisher": {
			source: "apache",
			extensions: ["pub"],
		},
		"application/x-msschedule": {
			source: "apache",
			extensions: ["scd"],
		},
		"application/x-msterminal": {
			source: "apache",
			extensions: ["trm"],
		},
		"application/x-mswrite": {
			source: "apache",
			extensions: ["wri"],
		},
		"application/x-netcdf": {
			source: "apache",
			extensions: ["nc", "cdf"],
		},
		"application/x-ns-proxy-autoconfig": {
			compressible: true,
			extensions: ["pac"],
		},
		"application/x-nzb": {
			source: "apache",
			extensions: ["nzb"],
		},
		"application/x-perl": {
			source: "nginx",
			extensions: ["pl", "pm"],
		},
		"application/x-pilot": {
			source: "nginx",
			extensions: ["prc", "pdb"],
		},
		"application/x-pkcs12": {
			source: "apache",
			compressible: false,
			extensions: ["p12", "pfx"],
		},
		"application/x-pkcs7-certificates": {
			source: "apache",
			extensions: ["p7b", "spc"],
		},
		"application/x-pkcs7-certreqresp": {
			source: "apache",
			extensions: ["p7r"],
		},
		"application/x-pki-message": {
			source: "iana",
		},
		"application/x-rar-compressed": {
			source: "apache",
			compressible: false,
			extensions: ["rar"],
		},
		"application/x-redhat-package-manager": {
			source: "nginx",
			extensions: ["rpm"],
		},
		"application/x-research-info-systems": {
			source: "apache",
			extensions: ["ris"],
		},
		"application/x-sea": {
			source: "nginx",
			extensions: ["sea"],
		},
		"application/x-sh": {
			source: "apache",
			compressible: true,
			extensions: ["sh"],
		},
		"application/x-shar": {
			source: "apache",
			extensions: ["shar"],
		},
		"application/x-shockwave-flash": {
			source: "apache",
			compressible: false,
			extensions: ["swf"],
		},
		"application/x-silverlight-app": {
			source: "apache",
			extensions: ["xap"],
		},
		"application/x-sql": {
			source: "apache",
			extensions: ["sql"],
		},
		"application/x-stuffit": {
			source: "apache",
			compressible: false,
			extensions: ["sit"],
		},
		"application/x-stuffitx": {
			source: "apache",
			extensions: ["sitx"],
		},
		"application/x-subrip": {
			source: "apache",
			extensions: ["srt"],
		},
		"application/x-sv4cpio": {
			source: "apache",
			extensions: ["sv4cpio"],
		},
		"application/x-sv4crc": {
			source: "apache",
			extensions: ["sv4crc"],
		},
		"application/x-t3vm-image": {
			source: "apache",
			extensions: ["t3"],
		},
		"application/x-tads": {
			source: "apache",
			extensions: ["gam"],
		},
		"application/x-tar": {
			source: "apache",
			compressible: true,
			extensions: ["tar"],
		},
		"application/x-tcl": {
			source: "apache",
			extensions: ["tcl", "tk"],
		},
		"application/x-tex": {
			source: "apache",
			extensions: ["tex"],
		},
		"application/x-tex-tfm": {
			source: "apache",
			extensions: ["tfm"],
		},
		"application/x-texinfo": {
			source: "apache",
			extensions: ["texinfo", "texi"],
		},
		"application/x-tgif": {
			source: "apache",
			extensions: ["obj"],
		},
		"application/x-ustar": {
			source: "apache",
			extensions: ["ustar"],
		},
		"application/x-virtualbox-hdd": {
			compressible: true,
			extensions: ["hdd"],
		},
		"application/x-virtualbox-ova": {
			compressible: true,
			extensions: ["ova"],
		},
		"application/x-virtualbox-ovf": {
			compressible: true,
			extensions: ["ovf"],
		},
		"application/x-virtualbox-vbox": {
			compressible: true,
			extensions: ["vbox"],
		},
		"application/x-virtualbox-vbox-extpack": {
			compressible: false,
			extensions: ["vbox-extpack"],
		},
		"application/x-virtualbox-vdi": {
			compressible: true,
			extensions: ["vdi"],
		},
		"application/x-virtualbox-vhd": {
			compressible: true,
			extensions: ["vhd"],
		},
		"application/x-virtualbox-vmdk": {
			compressible: true,
			extensions: ["vmdk"],
		},
		"application/x-wais-source": {
			source: "apache",
			extensions: ["src"],
		},
		"application/x-web-app-manifest+json": {
			compressible: true,
			extensions: ["webapp"],
		},
		"application/x-www-form-urlencoded": {
			source: "iana",
			compressible: true,
		},
		"application/x-x509-ca-cert": {
			source: "iana",
			extensions: ["der", "crt", "pem"],
		},
		"application/x-x509-ca-ra-cert": {
			source: "iana",
		},
		"application/x-x509-next-ca-cert": {
			source: "iana",
		},
		"application/x-xfig": {
			source: "apache",
			extensions: ["fig"],
		},
		"application/x-xliff+xml": {
			source: "apache",
			compressible: true,
			extensions: ["xlf"],
		},
		"application/x-xpinstall": {
			source: "apache",
			compressible: false,
			extensions: ["xpi"],
		},
		"application/x-xz": {
			source: "apache",
			extensions: ["xz"],
		},
		"application/x-zmachine": {
			source: "apache",
			extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"],
		},
		"application/x400-bp": {
			source: "iana",
		},
		"application/xacml+xml": {
			source: "iana",
			compressible: true,
		},
		"application/xaml+xml": {
			source: "apache",
			compressible: true,
			extensions: ["xaml"],
		},
		"application/xcap-att+xml": {
			source: "iana",
			compressible: true,
			extensions: ["xav"],
		},
		"application/xcap-caps+xml": {
			source: "iana",
			compressible: true,
			extensions: ["xca"],
		},
		"application/xcap-diff+xml": {
			source: "iana",
			compressible: true,
			extensions: ["xdf"],
		},
		"application/xcap-el+xml": {
			source: "iana",
			compressible: true,
			extensions: ["xel"],
		},
		"application/xcap-error+xml": {
			source: "iana",
			compressible: true,
		},
		"application/xcap-ns+xml": {
			source: "iana",
			compressible: true,
			extensions: ["xns"],
		},
		"application/xcon-conference-info+xml": {
			source: "iana",
			compressible: true,
		},
		"application/xcon-conference-info-diff+xml": {
			source: "iana",
			compressible: true,
		},
		"application/xenc+xml": {
			source: "iana",
			compressible: true,
			extensions: ["xenc"],
		},
		"application/xhtml+xml": {
			source: "iana",
			compressible: true,
			extensions: ["xhtml", "xht"],
		},
		"application/xhtml-voice+xml": {
			source: "apache",
			compressible: true,
		},
		"application/xliff+xml": {
			source: "iana",
			compressible: true,
			extensions: ["xlf"],
		},
		"application/xml": {
			source: "iana",
			compressible: true,
			extensions: ["xml", "xsl", "xsd", "rng"],
		},
		"application/xml-dtd": {
			source: "iana",
			compressible: true,
			extensions: ["dtd"],
		},
		"application/xml-external-parsed-entity": {
			source: "iana",
		},
		"application/xml-patch+xml": {
			source: "iana",
			compressible: true,
		},
		"application/xmpp+xml": {
			source: "iana",
			compressible: true,
		},
		"application/xop+xml": {
			source: "iana",
			compressible: true,
			extensions: ["xop"],
		},
		"application/xproc+xml": {
			source: "apache",
			compressible: true,
			extensions: ["xpl"],
		},
		"application/xslt+xml": {
			source: "iana",
			compressible: true,
			extensions: ["xsl", "xslt"],
		},
		"application/xspf+xml": {
			source: "apache",
			compressible: true,
			extensions: ["xspf"],
		},
		"application/xv+xml": {
			source: "iana",
			compressible: true,
			extensions: ["mxml", "xhvml", "xvml", "xvm"],
		},
		"application/yang": {
			source: "iana",
			extensions: ["yang"],
		},
		"application/yang-data+json": {
			source: "iana",
			compressible: true,
		},
		"application/yang-data+xml": {
			source: "iana",
			compressible: true,
		},
		"application/yang-patch+json": {
			source: "iana",
			compressible: true,
		},
		"application/yang-patch+xml": {
			source: "iana",
			compressible: true,
		},
		"application/yin+xml": {
			source: "iana",
			compressible: true,
			extensions: ["yin"],
		},
		"application/zip": {
			source: "iana",
			compressible: false,
			extensions: ["zip"],
		},
		"application/zlib": {
			source: "iana",
		},
		"application/zstd": {
			source: "iana",
		},
		"audio/1d-interleaved-parityfec": {
			source: "iana",
		},
		"audio/32kadpcm": {
			source: "iana",
		},
		"audio/3gpp": {
			source: "iana",
			compressible: false,
			extensions: ["3gpp"],
		},
		"audio/3gpp2": {
			source: "iana",
		},
		"audio/aac": {
			source: "iana",
		},
		"audio/ac3": {
			source: "iana",
		},
		"audio/adpcm": {
			source: "apache",
			extensions: ["adp"],
		},
		"audio/amr": {
			source: "iana",
			extensions: ["amr"],
		},
		"audio/amr-wb": {
			source: "iana",
		},
		"audio/amr-wb+": {
			source: "iana",
		},
		"audio/aptx": {
			source: "iana",
		},
		"audio/asc": {
			source: "iana",
		},
		"audio/atrac-advanced-lossless": {
			source: "iana",
		},
		"audio/atrac-x": {
			source: "iana",
		},
		"audio/atrac3": {
			source: "iana",
		},
		"audio/basic": {
			source: "iana",
			compressible: false,
			extensions: ["au", "snd"],
		},
		"audio/bv16": {
			source: "iana",
		},
		"audio/bv32": {
			source: "iana",
		},
		"audio/clearmode": {
			source: "iana",
		},
		"audio/cn": {
			source: "iana",
		},
		"audio/dat12": {
			source: "iana",
		},
		"audio/dls": {
			source: "iana",
		},
		"audio/dsr-es201108": {
			source: "iana",
		},
		"audio/dsr-es202050": {
			source: "iana",
		},
		"audio/dsr-es202211": {
			source: "iana",
		},
		"audio/dsr-es202212": {
			source: "iana",
		},
		"audio/dv": {
			source: "iana",
		},
		"audio/dvi4": {
			source: "iana",
		},
		"audio/eac3": {
			source: "iana",
		},
		"audio/encaprtp": {
			source: "iana",
		},
		"audio/evrc": {
			source: "iana",
		},
		"audio/evrc-qcp": {
			source: "iana",
		},
		"audio/evrc0": {
			source: "iana",
		},
		"audio/evrc1": {
			source: "iana",
		},
		"audio/evrcb": {
			source: "iana",
		},
		"audio/evrcb0": {
			source: "iana",
		},
		"audio/evrcb1": {
			source: "iana",
		},
		"audio/evrcnw": {
			source: "iana",
		},
		"audio/evrcnw0": {
			source: "iana",
		},
		"audio/evrcnw1": {
			source: "iana",
		},
		"audio/evrcwb": {
			source: "iana",
		},
		"audio/evrcwb0": {
			source: "iana",
		},
		"audio/evrcwb1": {
			source: "iana",
		},
		"audio/evs": {
			source: "iana",
		},
		"audio/flexfec": {
			source: "iana",
		},
		"audio/fwdred": {
			source: "iana",
		},
		"audio/g711-0": {
			source: "iana",
		},
		"audio/g719": {
			source: "iana",
		},
		"audio/g722": {
			source: "iana",
		},
		"audio/g7221": {
			source: "iana",
		},
		"audio/g723": {
			source: "iana",
		},
		"audio/g726-16": {
			source: "iana",
		},
		"audio/g726-24": {
			source: "iana",
		},
		"audio/g726-32": {
			source: "iana",
		},
		"audio/g726-40": {
			source: "iana",
		},
		"audio/g728": {
			source: "iana",
		},
		"audio/g729": {
			source: "iana",
		},
		"audio/g7291": {
			source: "iana",
		},
		"audio/g729d": {
			source: "iana",
		},
		"audio/g729e": {
			source: "iana",
		},
		"audio/gsm": {
			source: "iana",
		},
		"audio/gsm-efr": {
			source: "iana",
		},
		"audio/gsm-hr-08": {
			source: "iana",
		},
		"audio/ilbc": {
			source: "iana",
		},
		"audio/ip-mr_v2.5": {
			source: "iana",
		},
		"audio/isac": {
			source: "apache",
		},
		"audio/l16": {
			source: "iana",
		},
		"audio/l20": {
			source: "iana",
		},
		"audio/l24": {
			source: "iana",
			compressible: false,
		},
		"audio/l8": {
			source: "iana",
		},
		"audio/lpc": {
			source: "iana",
		},
		"audio/melp": {
			source: "iana",
		},
		"audio/melp1200": {
			source: "iana",
		},
		"audio/melp2400": {
			source: "iana",
		},
		"audio/melp600": {
			source: "iana",
		},
		"audio/mhas": {
			source: "iana",
		},
		"audio/midi": {
			source: "apache",
			extensions: ["mid", "midi", "kar", "rmi"],
		},
		"audio/mobile-xmf": {
			source: "iana",
			extensions: ["mxmf"],
		},
		"audio/mp3": {
			compressible: false,
			extensions: ["mp3"],
		},
		"audio/mp4": {
			source: "iana",
			compressible: false,
			extensions: ["m4a", "mp4a"],
		},
		"audio/mp4a-latm": {
			source: "iana",
		},
		"audio/mpa": {
			source: "iana",
		},
		"audio/mpa-robust": {
			source: "iana",
		},
		"audio/mpeg": {
			source: "iana",
			compressible: false,
			extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
		},
		"audio/mpeg4-generic": {
			source: "iana",
		},
		"audio/musepack": {
			source: "apache",
		},
		"audio/ogg": {
			source: "iana",
			compressible: false,
			extensions: ["oga", "ogg", "spx", "opus"],
		},
		"audio/opus": {
			source: "iana",
		},
		"audio/parityfec": {
			source: "iana",
		},
		"audio/pcma": {
			source: "iana",
		},
		"audio/pcma-wb": {
			source: "iana",
		},
		"audio/pcmu": {
			source: "iana",
		},
		"audio/pcmu-wb": {
			source: "iana",
		},
		"audio/prs.sid": {
			source: "iana",
		},
		"audio/qcelp": {
			source: "iana",
		},
		"audio/raptorfec": {
			source: "iana",
		},
		"audio/red": {
			source: "iana",
		},
		"audio/rtp-enc-aescm128": {
			source: "iana",
		},
		"audio/rtp-midi": {
			source: "iana",
		},
		"audio/rtploopback": {
			source: "iana",
		},
		"audio/rtx": {
			source: "iana",
		},
		"audio/s3m": {
			source: "apache",
			extensions: ["s3m"],
		},
		"audio/scip": {
			source: "iana",
		},
		"audio/silk": {
			source: "apache",
			extensions: ["sil"],
		},
		"audio/smv": {
			source: "iana",
		},
		"audio/smv-qcp": {
			source: "iana",
		},
		"audio/smv0": {
			source: "iana",
		},
		"audio/sofa": {
			source: "iana",
		},
		"audio/sp-midi": {
			source: "iana",
		},
		"audio/speex": {
			source: "iana",
		},
		"audio/t140c": {
			source: "iana",
		},
		"audio/t38": {
			source: "iana",
		},
		"audio/telephone-event": {
			source: "iana",
		},
		"audio/tetra_acelp": {
			source: "iana",
		},
		"audio/tetra_acelp_bb": {
			source: "iana",
		},
		"audio/tone": {
			source: "iana",
		},
		"audio/tsvcis": {
			source: "iana",
		},
		"audio/uemclip": {
			source: "iana",
		},
		"audio/ulpfec": {
			source: "iana",
		},
		"audio/usac": {
			source: "iana",
		},
		"audio/vdvi": {
			source: "iana",
		},
		"audio/vmr-wb": {
			source: "iana",
		},
		"audio/vnd.3gpp.iufp": {
			source: "iana",
		},
		"audio/vnd.4sb": {
			source: "iana",
		},
		"audio/vnd.audiokoz": {
			source: "iana",
		},
		"audio/vnd.celp": {
			source: "iana",
		},
		"audio/vnd.cisco.nse": {
			source: "iana",
		},
		"audio/vnd.cmles.radio-events": {
			source: "iana",
		},
		"audio/vnd.cns.anp1": {
			source: "iana",
		},
		"audio/vnd.cns.inf1": {
			source: "iana",
		},
		"audio/vnd.dece.audio": {
			source: "iana",
			extensions: ["uva", "uvva"],
		},
		"audio/vnd.digital-winds": {
			source: "iana",
			extensions: ["eol"],
		},
		"audio/vnd.dlna.adts": {
			source: "iana",
		},
		"audio/vnd.dolby.heaac.1": {
			source: "iana",
		},
		"audio/vnd.dolby.heaac.2": {
			source: "iana",
		},
		"audio/vnd.dolby.mlp": {
			source: "iana",
		},
		"audio/vnd.dolby.mps": {
			source: "iana",
		},
		"audio/vnd.dolby.pl2": {
			source: "iana",
		},
		"audio/vnd.dolby.pl2x": {
			source: "iana",
		},
		"audio/vnd.dolby.pl2z": {
			source: "iana",
		},
		"audio/vnd.dolby.pulse.1": {
			source: "iana",
		},
		"audio/vnd.dra": {
			source: "iana",
			extensions: ["dra"],
		},
		"audio/vnd.dts": {
			source: "iana",
			extensions: ["dts"],
		},
		"audio/vnd.dts.hd": {
			source: "iana",
			extensions: ["dtshd"],
		},
		"audio/vnd.dts.uhd": {
			source: "iana",
		},
		"audio/vnd.dvb.file": {
			source: "iana",
		},
		"audio/vnd.everad.plj": {
			source: "iana",
		},
		"audio/vnd.hns.audio": {
			source: "iana",
		},
		"audio/vnd.lucent.voice": {
			source: "iana",
			extensions: ["lvp"],
		},
		"audio/vnd.ms-playready.media.pya": {
			source: "iana",
			extensions: ["pya"],
		},
		"audio/vnd.nokia.mobile-xmf": {
			source: "iana",
		},
		"audio/vnd.nortel.vbk": {
			source: "iana",
		},
		"audio/vnd.nuera.ecelp4800": {
			source: "iana",
			extensions: ["ecelp4800"],
		},
		"audio/vnd.nuera.ecelp7470": {
			source: "iana",
			extensions: ["ecelp7470"],
		},
		"audio/vnd.nuera.ecelp9600": {
			source: "iana",
			extensions: ["ecelp9600"],
		},
		"audio/vnd.octel.sbc": {
			source: "iana",
		},
		"audio/vnd.presonus.multitrack": {
			source: "iana",
		},
		"audio/vnd.qcelp": {
			source: "iana",
		},
		"audio/vnd.rhetorex.32kadpcm": {
			source: "iana",
		},
		"audio/vnd.rip": {
			source: "iana",
			extensions: ["rip"],
		},
		"audio/vnd.rn-realaudio": {
			compressible: false,
		},
		"audio/vnd.sealedmedia.softseal.mpeg": {
			source: "iana",
		},
		"audio/vnd.vmx.cvsd": {
			source: "iana",
		},
		"audio/vnd.wave": {
			compressible: false,
		},
		"audio/vorbis": {
			source: "iana",
			compressible: false,
		},
		"audio/vorbis-config": {
			source: "iana",
		},
		"audio/wav": {
			compressible: false,
			extensions: ["wav"],
		},
		"audio/wave": {
			compressible: false,
			extensions: ["wav"],
		},
		"audio/webm": {
			source: "apache",
			compressible: false,
			extensions: ["weba"],
		},
		"audio/x-aac": {
			source: "apache",
			compressible: false,
			extensions: ["aac"],
		},
		"audio/x-aiff": {
			source: "apache",
			extensions: ["aif", "aiff", "aifc"],
		},
		"audio/x-caf": {
			source: "apache",
			compressible: false,
			extensions: ["caf"],
		},
		"audio/x-flac": {
			source: "apache",
			extensions: ["flac"],
		},
		"audio/x-m4a": {
			source: "nginx",
			extensions: ["m4a"],
		},
		"audio/x-matroska": {
			source: "apache",
			extensions: ["mka"],
		},
		"audio/x-mpegurl": {
			source: "apache",
			extensions: ["m3u"],
		},
		"audio/x-ms-wax": {
			source: "apache",
			extensions: ["wax"],
		},
		"audio/x-ms-wma": {
			source: "apache",
			extensions: ["wma"],
		},
		"audio/x-pn-realaudio": {
			source: "apache",
			extensions: ["ram", "ra"],
		},
		"audio/x-pn-realaudio-plugin": {
			source: "apache",
			extensions: ["rmp"],
		},
		"audio/x-realaudio": {
			source: "nginx",
			extensions: ["ra"],
		},
		"audio/x-tta": {
			source: "apache",
		},
		"audio/x-wav": {
			source: "apache",
			extensions: ["wav"],
		},
		"audio/xm": {
			source: "apache",
			extensions: ["xm"],
		},
		"chemical/x-cdx": {
			source: "apache",
			extensions: ["cdx"],
		},
		"chemical/x-cif": {
			source: "apache",
			extensions: ["cif"],
		},
		"chemical/x-cmdf": {
			source: "apache",
			extensions: ["cmdf"],
		},
		"chemical/x-cml": {
			source: "apache",
			extensions: ["cml"],
		},
		"chemical/x-csml": {
			source: "apache",
			extensions: ["csml"],
		},
		"chemical/x-pdb": {
			source: "apache",
		},
		"chemical/x-xyz": {
			source: "apache",
			extensions: ["xyz"],
		},
		"font/collection": {
			source: "iana",
			extensions: ["ttc"],
		},
		"font/otf": {
			source: "iana",
			compressible: true,
			extensions: ["otf"],
		},
		"font/sfnt": {
			source: "iana",
		},
		"font/ttf": {
			source: "iana",
			compressible: true,
			extensions: ["ttf"],
		},
		"font/woff": {
			source: "iana",
			extensions: ["woff"],
		},
		"font/woff2": {
			source: "iana",
			extensions: ["woff2"],
		},
		"image/aces": {
			source: "iana",
			extensions: ["exr"],
		},
		"image/apng": {
			compressible: false,
			extensions: ["apng"],
		},
		"image/avci": {
			source: "iana",
			extensions: ["avci"],
		},
		"image/avcs": {
			source: "iana",
			extensions: ["avcs"],
		},
		"image/avif": {
			source: "iana",
			compressible: false,
			extensions: ["avif"],
		},
		"image/bmp": {
			source: "iana",
			compressible: true,
			extensions: ["bmp"],
		},
		"image/cgm": {
			source: "iana",
			extensions: ["cgm"],
		},
		"image/dicom-rle": {
			source: "iana",
			extensions: ["drle"],
		},
		"image/emf": {
			source: "iana",
			extensions: ["emf"],
		},
		"image/fits": {
			source: "iana",
			extensions: ["fits"],
		},
		"image/g3fax": {
			source: "iana",
			extensions: ["g3"],
		},
		"image/gif": {
			source: "iana",
			compressible: false,
			extensions: ["gif"],
		},
		"image/heic": {
			source: "iana",
			extensions: ["heic"],
		},
		"image/heic-sequence": {
			source: "iana",
			extensions: ["heics"],
		},
		"image/heif": {
			source: "iana",
			extensions: ["heif"],
		},
		"image/heif-sequence": {
			source: "iana",
			extensions: ["heifs"],
		},
		"image/hej2k": {
			source: "iana",
			extensions: ["hej2"],
		},
		"image/hsj2": {
			source: "iana",
			extensions: ["hsj2"],
		},
		"image/ief": {
			source: "iana",
			extensions: ["ief"],
		},
		"image/jls": {
			source: "iana",
			extensions: ["jls"],
		},
		"image/jp2": {
			source: "iana",
			compressible: false,
			extensions: ["jp2", "jpg2"],
		},
		"image/jpeg": {
			source: "iana",
			compressible: false,
			extensions: ["jpeg", "jpg", "jpe"],
		},
		"image/jph": {
			source: "iana",
			extensions: ["jph"],
		},
		"image/jphc": {
			source: "iana",
			extensions: ["jhc"],
		},
		"image/jpm": {
			source: "iana",
			compressible: false,
			extensions: ["jpm"],
		},
		"image/jpx": {
			source: "iana",
			compressible: false,
			extensions: ["jpx", "jpf"],
		},
		"image/jxr": {
			source: "iana",
			extensions: ["jxr"],
		},
		"image/jxra": {
			source: "iana",
			extensions: ["jxra"],
		},
		"image/jxrs": {
			source: "iana",
			extensions: ["jxrs"],
		},
		"image/jxs": {
			source: "iana",
			extensions: ["jxs"],
		},
		"image/jxsc": {
			source: "iana",
			extensions: ["jxsc"],
		},
		"image/jxsi": {
			source: "iana",
			extensions: ["jxsi"],
		},
		"image/jxss": {
			source: "iana",
			extensions: ["jxss"],
		},
		"image/ktx": {
			source: "iana",
			extensions: ["ktx"],
		},
		"image/ktx2": {
			source: "iana",
			extensions: ["ktx2"],
		},
		"image/naplps": {
			source: "iana",
		},
		"image/pjpeg": {
			compressible: false,
		},
		"image/png": {
			source: "iana",
			compressible: false,
			extensions: ["png"],
		},
		"image/prs.btif": {
			source: "iana",
			extensions: ["btif"],
		},
		"image/prs.pti": {
			source: "iana",
			extensions: ["pti"],
		},
		"image/pwg-raster": {
			source: "iana",
		},
		"image/sgi": {
			source: "apache",
			extensions: ["sgi"],
		},
		"image/svg+xml": {
			source: "iana",
			compressible: true,
			extensions: ["svg", "svgz"],
		},
		"image/t38": {
			source: "iana",
			extensions: ["t38"],
		},
		"image/tiff": {
			source: "iana",
			compressible: false,
			extensions: ["tif", "tiff"],
		},
		"image/tiff-fx": {
			source: "iana",
			extensions: ["tfx"],
		},
		"image/vnd.adobe.photoshop": {
			source: "iana",
			compressible: true,
			extensions: ["psd"],
		},
		"image/vnd.airzip.accelerator.azv": {
			source: "iana",
			extensions: ["azv"],
		},
		"image/vnd.cns.inf2": {
			source: "iana",
		},
		"image/vnd.dece.graphic": {
			source: "iana",
			extensions: ["uvi", "uvvi", "uvg", "uvvg"],
		},
		"image/vnd.djvu": {
			source: "iana",
			extensions: ["djvu", "djv"],
		},
		"image/vnd.dvb.subtitle": {
			source: "iana",
			extensions: ["sub"],
		},
		"image/vnd.dwg": {
			source: "iana",
			extensions: ["dwg"],
		},
		"image/vnd.dxf": {
			source: "iana",
			extensions: ["dxf"],
		},
		"image/vnd.fastbidsheet": {
			source: "iana",
			extensions: ["fbs"],
		},
		"image/vnd.fpx": {
			source: "iana",
			extensions: ["fpx"],
		},
		"image/vnd.fst": {
			source: "iana",
			extensions: ["fst"],
		},
		"image/vnd.fujixerox.edmics-mmr": {
			source: "iana",
			extensions: ["mmr"],
		},
		"image/vnd.fujixerox.edmics-rlc": {
			source: "iana",
			extensions: ["rlc"],
		},
		"image/vnd.globalgraphics.pgb": {
			source: "iana",
		},
		"image/vnd.microsoft.icon": {
			source: "iana",
			compressible: true,
			extensions: ["ico"],
		},
		"image/vnd.mix": {
			source: "iana",
		},
		"image/vnd.mozilla.apng": {
			source: "iana",
		},
		"image/vnd.ms-dds": {
			compressible: true,
			extensions: ["dds"],
		},
		"image/vnd.ms-modi": {
			source: "iana",
			extensions: ["mdi"],
		},
		"image/vnd.ms-photo": {
			source: "apache",
			extensions: ["wdp"],
		},
		"image/vnd.net-fpx": {
			source: "iana",
			extensions: ["npx"],
		},
		"image/vnd.pco.b16": {
			source: "iana",
			extensions: ["b16"],
		},
		"image/vnd.radiance": {
			source: "iana",
		},
		"image/vnd.sealed.png": {
			source: "iana",
		},
		"image/vnd.sealedmedia.softseal.gif": {
			source: "iana",
		},
		"image/vnd.sealedmedia.softseal.jpg": {
			source: "iana",
		},
		"image/vnd.svf": {
			source: "iana",
		},
		"image/vnd.tencent.tap": {
			source: "iana",
			extensions: ["tap"],
		},
		"image/vnd.valve.source.texture": {
			source: "iana",
			extensions: ["vtf"],
		},
		"image/vnd.wap.wbmp": {
			source: "iana",
			extensions: ["wbmp"],
		},
		"image/vnd.xiff": {
			source: "iana",
			extensions: ["xif"],
		},
		"image/vnd.zbrush.pcx": {
			source: "iana",
			extensions: ["pcx"],
		},
		"image/webp": {
			source: "apache",
			extensions: ["webp"],
		},
		"image/wmf": {
			source: "iana",
			extensions: ["wmf"],
		},
		"image/x-3ds": {
			source: "apache",
			extensions: ["3ds"],
		},
		"image/x-cmu-raster": {
			source: "apache",
			extensions: ["ras"],
		},
		"image/x-cmx": {
			source: "apache",
			extensions: ["cmx"],
		},
		"image/x-freehand": {
			source: "apache",
			extensions: ["fh", "fhc", "fh4", "fh5", "fh7"],
		},
		"image/x-icon": {
			source: "apache",
			compressible: true,
			extensions: ["ico"],
		},
		"image/x-jng": {
			source: "nginx",
			extensions: ["jng"],
		},
		"image/x-mrsid-image": {
			source: "apache",
			extensions: ["sid"],
		},
		"image/x-ms-bmp": {
			source: "nginx",
			compressible: true,
			extensions: ["bmp"],
		},
		"image/x-pcx": {
			source: "apache",
			extensions: ["pcx"],
		},
		"image/x-pict": {
			source: "apache",
			extensions: ["pic", "pct"],
		},
		"image/x-portable-anymap": {
			source: "apache",
			extensions: ["pnm"],
		},
		"image/x-portable-bitmap": {
			source: "apache",
			extensions: ["pbm"],
		},
		"image/x-portable-graymap": {
			source: "apache",
			extensions: ["pgm"],
		},
		"image/x-portable-pixmap": {
			source: "apache",
			extensions: ["ppm"],
		},
		"image/x-rgb": {
			source: "apache",
			extensions: ["rgb"],
		},
		"image/x-tga": {
			source: "apache",
			extensions: ["tga"],
		},
		"image/x-xbitmap": {
			source: "apache",
			extensions: ["xbm"],
		},
		"image/x-xcf": {
			compressible: false,
		},
		"image/x-xpixmap": {
			source: "apache",
			extensions: ["xpm"],
		},
		"image/x-xwindowdump": {
			source: "apache",
			extensions: ["xwd"],
		},
		"message/cpim": {
			source: "iana",
		},
		"message/delivery-status": {
			source: "iana",
		},
		"message/disposition-notification": {
			source: "iana",
			extensions: ["disposition-notification"],
		},
		"message/external-body": {
			source: "iana",
		},
		"message/feedback-report": {
			source: "iana",
		},
		"message/global": {
			source: "iana",
			extensions: ["u8msg"],
		},
		"message/global-delivery-status": {
			source: "iana",
			extensions: ["u8dsn"],
		},
		"message/global-disposition-notification": {
			source: "iana",
			extensions: ["u8mdn"],
		},
		"message/global-headers": {
			source: "iana",
			extensions: ["u8hdr"],
		},
		"message/http": {
			source: "iana",
			compressible: false,
		},
		"message/imdn+xml": {
			source: "iana",
			compressible: true,
		},
		"message/news": {
			source: "iana",
		},
		"message/partial": {
			source: "iana",
			compressible: false,
		},
		"message/rfc822": {
			source: "iana",
			compressible: true,
			extensions: ["eml", "mime"],
		},
		"message/s-http": {
			source: "iana",
		},
		"message/sip": {
			source: "iana",
		},
		"message/sipfrag": {
			source: "iana",
		},
		"message/tracking-status": {
			source: "iana",
		},
		"message/vnd.si.simp": {
			source: "iana",
		},
		"message/vnd.wfa.wsc": {
			source: "iana",
			extensions: ["wsc"],
		},
		"model/3mf": {
			source: "iana",
			extensions: ["3mf"],
		},
		"model/e57": {
			source: "iana",
		},
		"model/gltf+json": {
			source: "iana",
			compressible: true,
			extensions: ["gltf"],
		},
		"model/gltf-binary": {
			source: "iana",
			compressible: true,
			extensions: ["glb"],
		},
		"model/iges": {
			source: "iana",
			compressible: false,
			extensions: ["igs", "iges"],
		},
		"model/mesh": {
			source: "iana",
			compressible: false,
			extensions: ["msh", "mesh", "silo"],
		},
		"model/mtl": {
			source: "iana",
			extensions: ["mtl"],
		},
		"model/obj": {
			source: "iana",
			extensions: ["obj"],
		},
		"model/step": {
			source: "iana",
		},
		"model/step+xml": {
			source: "iana",
			compressible: true,
			extensions: ["stpx"],
		},
		"model/step+zip": {
			source: "iana",
			compressible: false,
			extensions: ["stpz"],
		},
		"model/step-xml+zip": {
			source: "iana",
			compressible: false,
			extensions: ["stpxz"],
		},
		"model/stl": {
			source: "iana",
			extensions: ["stl"],
		},
		"model/vnd.collada+xml": {
			source: "iana",
			compressible: true,
			extensions: ["dae"],
		},
		"model/vnd.dwf": {
			source: "iana",
			extensions: ["dwf"],
		},
		"model/vnd.flatland.3dml": {
			source: "iana",
		},
		"model/vnd.gdl": {
			source: "iana",
			extensions: ["gdl"],
		},
		"model/vnd.gs-gdl": {
			source: "apache",
		},
		"model/vnd.gs.gdl": {
			source: "iana",
		},
		"model/vnd.gtw": {
			source: "iana",
			extensions: ["gtw"],
		},
		"model/vnd.moml+xml": {
			source: "iana",
			compressible: true,
		},
		"model/vnd.mts": {
			source: "iana",
			extensions: ["mts"],
		},
		"model/vnd.opengex": {
			source: "iana",
			extensions: ["ogex"],
		},
		"model/vnd.parasolid.transmit.binary": {
			source: "iana",
			extensions: ["x_b"],
		},
		"model/vnd.parasolid.transmit.text": {
			source: "iana",
			extensions: ["x_t"],
		},
		"model/vnd.pytha.pyox": {
			source: "iana",
		},
		"model/vnd.rosette.annotated-data-model": {
			source: "iana",
		},
		"model/vnd.sap.vds": {
			source: "iana",
			extensions: ["vds"],
		},
		"model/vnd.usdz+zip": {
			source: "iana",
			compressible: false,
			extensions: ["usdz"],
		},
		"model/vnd.valve.source.compiled-map": {
			source: "iana",
			extensions: ["bsp"],
		},
		"model/vnd.vtu": {
			source: "iana",
			extensions: ["vtu"],
		},
		"model/vrml": {
			source: "iana",
			compressible: false,
			extensions: ["wrl", "vrml"],
		},
		"model/x3d+binary": {
			source: "apache",
			compressible: false,
			extensions: ["x3db", "x3dbz"],
		},
		"model/x3d+fastinfoset": {
			source: "iana",
			extensions: ["x3db"],
		},
		"model/x3d+vrml": {
			source: "apache",
			compressible: false,
			extensions: ["x3dv", "x3dvz"],
		},
		"model/x3d+xml": {
			source: "iana",
			compressible: true,
			extensions: ["x3d", "x3dz"],
		},
		"model/x3d-vrml": {
			source: "iana",
			extensions: ["x3dv"],
		},
		"multipart/alternative": {
			source: "iana",
			compressible: false,
		},
		"multipart/appledouble": {
			source: "iana",
		},
		"multipart/byteranges": {
			source: "iana",
		},
		"multipart/digest": {
			source: "iana",
		},
		"multipart/encrypted": {
			source: "iana",
			compressible: false,
		},
		"multipart/form-data": {
			source: "iana",
			compressible: false,
		},
		"multipart/header-set": {
			source: "iana",
		},
		"multipart/mixed": {
			source: "iana",
		},
		"multipart/multilingual": {
			source: "iana",
		},
		"multipart/parallel": {
			source: "iana",
		},
		"multipart/related": {
			source: "iana",
			compressible: false,
		},
		"multipart/report": {
			source: "iana",
		},
		"multipart/signed": {
			source: "iana",
			compressible: false,
		},
		"multipart/vnd.bint.med-plus": {
			source: "iana",
		},
		"multipart/voice-message": {
			source: "iana",
		},
		"multipart/x-mixed-replace": {
			source: "iana",
		},
		"text/1d-interleaved-parityfec": {
			source: "iana",
		},
		"text/cache-manifest": {
			source: "iana",
			compressible: true,
			extensions: ["appcache", "manifest"],
		},
		"text/calendar": {
			source: "iana",
			extensions: ["ics", "ifb"],
		},
		"text/calender": {
			compressible: true,
		},
		"text/cmd": {
			compressible: true,
		},
		"text/coffeescript": {
			extensions: ["coffee", "litcoffee"],
		},
		"text/cql": {
			source: "iana",
		},
		"text/cql-expression": {
			source: "iana",
		},
		"text/cql-identifier": {
			source: "iana",
		},
		"text/css": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
			extensions: ["css"],
		},
		"text/csv": {
			source: "iana",
			compressible: true,
			extensions: ["csv"],
		},
		"text/csv-schema": {
			source: "iana",
		},
		"text/directory": {
			source: "iana",
		},
		"text/dns": {
			source: "iana",
		},
		"text/ecmascript": {
			source: "iana",
		},
		"text/encaprtp": {
			source: "iana",
		},
		"text/enriched": {
			source: "iana",
		},
		"text/fhirpath": {
			source: "iana",
		},
		"text/flexfec": {
			source: "iana",
		},
		"text/fwdred": {
			source: "iana",
		},
		"text/gff3": {
			source: "iana",
		},
		"text/grammar-ref-list": {
			source: "iana",
		},
		"text/html": {
			source: "iana",
			compressible: true,
			extensions: ["html", "htm", "shtml"],
		},
		"text/jade": {
			extensions: ["jade"],
		},
		"text/javascript": {
			source: "iana",
			compressible: true,
		},
		"text/jcr-cnd": {
			source: "iana",
		},
		"text/jsx": {
			compressible: true,
			extensions: ["jsx"],
		},
		"text/less": {
			compressible: true,
			extensions: ["less"],
		},
		"text/markdown": {
			source: "iana",
			compressible: true,
			extensions: ["markdown", "md"],
		},
		"text/mathml": {
			source: "nginx",
			extensions: ["mml"],
		},
		"text/mdx": {
			compressible: true,
			extensions: ["mdx"],
		},
		"text/mizar": {
			source: "iana",
		},
		"text/n3": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
			extensions: ["n3"],
		},
		"text/parameters": {
			source: "iana",
			charset: "UTF-8",
		},
		"text/parityfec": {
			source: "iana",
		},
		"text/plain": {
			source: "iana",
			compressible: true,
			extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"],
		},
		"text/provenance-notation": {
			source: "iana",
			charset: "UTF-8",
		},
		"text/prs.fallenstein.rst": {
			source: "iana",
		},
		"text/prs.lines.tag": {
			source: "iana",
			extensions: ["dsc"],
		},
		"text/prs.prop.logic": {
			source: "iana",
		},
		"text/raptorfec": {
			source: "iana",
		},
		"text/red": {
			source: "iana",
		},
		"text/rfc822-headers": {
			source: "iana",
		},
		"text/richtext": {
			source: "iana",
			compressible: true,
			extensions: ["rtx"],
		},
		"text/rtf": {
			source: "iana",
			compressible: true,
			extensions: ["rtf"],
		},
		"text/rtp-enc-aescm128": {
			source: "iana",
		},
		"text/rtploopback": {
			source: "iana",
		},
		"text/rtx": {
			source: "iana",
		},
		"text/sgml": {
			source: "iana",
			extensions: ["sgml", "sgm"],
		},
		"text/shaclc": {
			source: "iana",
		},
		"text/shex": {
			source: "iana",
			extensions: ["shex"],
		},
		"text/slim": {
			extensions: ["slim", "slm"],
		},
		"text/spdx": {
			source: "iana",
			extensions: ["spdx"],
		},
		"text/strings": {
			source: "iana",
		},
		"text/stylus": {
			extensions: ["stylus", "styl"],
		},
		"text/t140": {
			source: "iana",
		},
		"text/tab-separated-values": {
			source: "iana",
			compressible: true,
			extensions: ["tsv"],
		},
		"text/troff": {
			source: "iana",
			extensions: ["t", "tr", "roff", "man", "me", "ms"],
		},
		"text/turtle": {
			source: "iana",
			charset: "UTF-8",
			extensions: ["ttl"],
		},
		"text/ulpfec": {
			source: "iana",
		},
		"text/uri-list": {
			source: "iana",
			compressible: true,
			extensions: ["uri", "uris", "urls"],
		},
		"text/vcard": {
			source: "iana",
			compressible: true,
			extensions: ["vcard"],
		},
		"text/vnd.a": {
			source: "iana",
		},
		"text/vnd.abc": {
			source: "iana",
		},
		"text/vnd.ascii-art": {
			source: "iana",
		},
		"text/vnd.curl": {
			source: "iana",
			extensions: ["curl"],
		},
		"text/vnd.curl.dcurl": {
			source: "apache",
			extensions: ["dcurl"],
		},
		"text/vnd.curl.mcurl": {
			source: "apache",
			extensions: ["mcurl"],
		},
		"text/vnd.curl.scurl": {
			source: "apache",
			extensions: ["scurl"],
		},
		"text/vnd.debian.copyright": {
			source: "iana",
			charset: "UTF-8",
		},
		"text/vnd.dmclientscript": {
			source: "iana",
		},
		"text/vnd.dvb.subtitle": {
			source: "iana",
			extensions: ["sub"],
		},
		"text/vnd.esmertec.theme-descriptor": {
			source: "iana",
			charset: "UTF-8",
		},
		"text/vnd.familysearch.gedcom": {
			source: "iana",
			extensions: ["ged"],
		},
		"text/vnd.ficlab.flt": {
			source: "iana",
		},
		"text/vnd.fly": {
			source: "iana",
			extensions: ["fly"],
		},
		"text/vnd.fmi.flexstor": {
			source: "iana",
			extensions: ["flx"],
		},
		"text/vnd.gml": {
			source: "iana",
		},
		"text/vnd.graphviz": {
			source: "iana",
			extensions: ["gv"],
		},
		"text/vnd.hans": {
			source: "iana",
		},
		"text/vnd.hgl": {
			source: "iana",
		},
		"text/vnd.in3d.3dml": {
			source: "iana",
			extensions: ["3dml"],
		},
		"text/vnd.in3d.spot": {
			source: "iana",
			extensions: ["spot"],
		},
		"text/vnd.iptc.newsml": {
			source: "iana",
		},
		"text/vnd.iptc.nitf": {
			source: "iana",
		},
		"text/vnd.latex-z": {
			source: "iana",
		},
		"text/vnd.motorola.reflex": {
			source: "iana",
		},
		"text/vnd.ms-mediapackage": {
			source: "iana",
		},
		"text/vnd.net2phone.commcenter.command": {
			source: "iana",
		},
		"text/vnd.radisys.msml-basic-layout": {
			source: "iana",
		},
		"text/vnd.senx.warpscript": {
			source: "iana",
		},
		"text/vnd.si.uricatalogue": {
			source: "iana",
		},
		"text/vnd.sosi": {
			source: "iana",
		},
		"text/vnd.sun.j2me.app-descriptor": {
			source: "iana",
			charset: "UTF-8",
			extensions: ["jad"],
		},
		"text/vnd.trolltech.linguist": {
			source: "iana",
			charset: "UTF-8",
		},
		"text/vnd.wap.si": {
			source: "iana",
		},
		"text/vnd.wap.sl": {
			source: "iana",
		},
		"text/vnd.wap.wml": {
			source: "iana",
			extensions: ["wml"],
		},
		"text/vnd.wap.wmlscript": {
			source: "iana",
			extensions: ["wmls"],
		},
		"text/vtt": {
			source: "iana",
			charset: "UTF-8",
			compressible: true,
			extensions: ["vtt"],
		},
		"text/x-asm": {
			source: "apache",
			extensions: ["s", "asm"],
		},
		"text/x-c": {
			source: "apache",
			extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"],
		},
		"text/x-component": {
			source: "nginx",
			extensions: ["htc"],
		},
		"text/x-fortran": {
			source: "apache",
			extensions: ["f", "for", "f77", "f90"],
		},
		"text/x-gwt-rpc": {
			compressible: true,
		},
		"text/x-handlebars-template": {
			extensions: ["hbs"],
		},
		"text/x-java-source": {
			source: "apache",
			extensions: ["java"],
		},
		"text/x-jquery-tmpl": {
			compressible: true,
		},
		"text/x-lua": {
			extensions: ["lua"],
		},
		"text/x-markdown": {
			compressible: true,
			extensions: ["mkd"],
		},
		"text/x-nfo": {
			source: "apache",
			extensions: ["nfo"],
		},
		"text/x-opml": {
			source: "apache",
			extensions: ["opml"],
		},
		"text/x-org": {
			compressible: true,
			extensions: ["org"],
		},
		"text/x-pascal": {
			source: "apache",
			extensions: ["p", "pas"],
		},
		"text/x-processing": {
			compressible: true,
			extensions: ["pde"],
		},
		"text/x-sass": {
			extensions: ["sass"],
		},
		"text/x-scss": {
			extensions: ["scss"],
		},
		"text/x-setext": {
			source: "apache",
			extensions: ["etx"],
		},
		"text/x-sfv": {
			source: "apache",
			extensions: ["sfv"],
		},
		"text/x-suse-ymp": {
			compressible: true,
			extensions: ["ymp"],
		},
		"text/x-uuencode": {
			source: "apache",
			extensions: ["uu"],
		},
		"text/x-vcalendar": {
			source: "apache",
			extensions: ["vcs"],
		},
		"text/x-vcard": {
			source: "apache",
			extensions: ["vcf"],
		},
		"text/xml": {
			source: "iana",
			compressible: true,
			extensions: ["xml"],
		},
		"text/xml-external-parsed-entity": {
			source: "iana",
		},
		"text/yaml": {
			compressible: true,
			extensions: ["yaml", "yml"],
		},
		"video/1d-interleaved-parityfec": {
			source: "iana",
		},
		"video/3gpp": {
			source: "iana",
			extensions: ["3gp", "3gpp"],
		},
		"video/3gpp-tt": {
			source: "iana",
		},
		"video/3gpp2": {
			source: "iana",
			extensions: ["3g2"],
		},
		"video/av1": {
			source: "iana",
		},
		"video/bmpeg": {
			source: "iana",
		},
		"video/bt656": {
			source: "iana",
		},
		"video/celb": {
			source: "iana",
		},
		"video/dv": {
			source: "iana",
		},
		"video/encaprtp": {
			source: "iana",
		},
		"video/ffv1": {
			source: "iana",
		},
		"video/flexfec": {
			source: "iana",
		},
		"video/h261": {
			source: "iana",
			extensions: ["h261"],
		},
		"video/h263": {
			source: "iana",
			extensions: ["h263"],
		},
		"video/h263-1998": {
			source: "iana",
		},
		"video/h263-2000": {
			source: "iana",
		},
		"video/h264": {
			source: "iana",
			extensions: ["h264"],
		},
		"video/h264-rcdo": {
			source: "iana",
		},
		"video/h264-svc": {
			source: "iana",
		},
		"video/h265": {
			source: "iana",
		},
		"video/iso.segment": {
			source: "iana",
			extensions: ["m4s"],
		},
		"video/jpeg": {
			source: "iana",
			extensions: ["jpgv"],
		},
		"video/jpeg2000": {
			source: "iana",
		},
		"video/jpm": {
			source: "apache",
			extensions: ["jpm", "jpgm"],
		},
		"video/jxsv": {
			source: "iana",
		},
		"video/mj2": {
			source: "iana",
			extensions: ["mj2", "mjp2"],
		},
		"video/mp1s": {
			source: "iana",
		},
		"video/mp2p": {
			source: "iana",
		},
		"video/mp2t": {
			source: "iana",
			extensions: ["ts"],
		},
		"video/mp4": {
			source: "iana",
			compressible: false,
			extensions: ["mp4", "mp4v", "mpg4"],
		},
		"video/mp4v-es": {
			source: "iana",
		},
		"video/mpeg": {
			source: "iana",
			compressible: false,
			extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"],
		},
		"video/mpeg4-generic": {
			source: "iana",
		},
		"video/mpv": {
			source: "iana",
		},
		"video/nv": {
			source: "iana",
		},
		"video/ogg": {
			source: "iana",
			compressible: false,
			extensions: ["ogv"],
		},
		"video/parityfec": {
			source: "iana",
		},
		"video/pointer": {
			source: "iana",
		},
		"video/quicktime": {
			source: "iana",
			compressible: false,
			extensions: ["qt", "mov"],
		},
		"video/raptorfec": {
			source: "iana",
		},
		"video/raw": {
			source: "iana",
		},
		"video/rtp-enc-aescm128": {
			source: "iana",
		},
		"video/rtploopback": {
			source: "iana",
		},
		"video/rtx": {
			source: "iana",
		},
		"video/scip": {
			source: "iana",
		},
		"video/smpte291": {
			source: "iana",
		},
		"video/smpte292m": {
			source: "iana",
		},
		"video/ulpfec": {
			source: "iana",
		},
		"video/vc1": {
			source: "iana",
		},
		"video/vc2": {
			source: "iana",
		},
		"video/vnd.cctv": {
			source: "iana",
		},
		"video/vnd.dece.hd": {
			source: "iana",
			extensions: ["uvh", "uvvh"],
		},
		"video/vnd.dece.mobile": {
			source: "iana",
			extensions: ["uvm", "uvvm"],
		},
		"video/vnd.dece.mp4": {
			source: "iana",
		},
		"video/vnd.dece.pd": {
			source: "iana",
			extensions: ["uvp", "uvvp"],
		},
		"video/vnd.dece.sd": {
			source: "iana",
			extensions: ["uvs", "uvvs"],
		},
		"video/vnd.dece.video": {
			source: "iana",
			extensions: ["uvv", "uvvv"],
		},
		"video/vnd.directv.mpeg": {
			source: "iana",
		},
		"video/vnd.directv.mpeg-tts": {
			source: "iana",
		},
		"video/vnd.dlna.mpeg-tts": {
			source: "iana",
		},
		"video/vnd.dvb.file": {
			source: "iana",
			extensions: ["dvb"],
		},
		"video/vnd.fvt": {
			source: "iana",
			extensions: ["fvt"],
		},
		"video/vnd.hns.video": {
			source: "iana",
		},
		"video/vnd.iptvforum.1dparityfec-1010": {
			source: "iana",
		},
		"video/vnd.iptvforum.1dparityfec-2005": {
			source: "iana",
		},
		"video/vnd.iptvforum.2dparityfec-1010": {
			source: "iana",
		},
		"video/vnd.iptvforum.2dparityfec-2005": {
			source: "iana",
		},
		"video/vnd.iptvforum.ttsavc": {
			source: "iana",
		},
		"video/vnd.iptvforum.ttsmpeg2": {
			source: "iana",
		},
		"video/vnd.motorola.video": {
			source: "iana",
		},
		"video/vnd.motorola.videop": {
			source: "iana",
		},
		"video/vnd.mpegurl": {
			source: "iana",
			extensions: ["mxu", "m4u"],
		},
		"video/vnd.ms-playready.media.pyv": {
			source: "iana",
			extensions: ["pyv"],
		},
		"video/vnd.nokia.interleaved-multimedia": {
			source: "iana",
		},
		"video/vnd.nokia.mp4vr": {
			source: "iana",
		},
		"video/vnd.nokia.videovoip": {
			source: "iana",
		},
		"video/vnd.objectvideo": {
			source: "iana",
		},
		"video/vnd.radgamettools.bink": {
			source: "iana",
		},
		"video/vnd.radgamettools.smacker": {
			source: "iana",
		},
		"video/vnd.sealed.mpeg1": {
			source: "iana",
		},
		"video/vnd.sealed.mpeg4": {
			source: "iana",
		},
		"video/vnd.sealed.swf": {
			source: "iana",
		},
		"video/vnd.sealedmedia.softseal.mov": {
			source: "iana",
		},
		"video/vnd.uvvu.mp4": {
			source: "iana",
			extensions: ["uvu", "uvvu"],
		},
		"video/vnd.vivo": {
			source: "iana",
			extensions: ["viv"],
		},
		"video/vnd.youtube.yt": {
			source: "iana",
		},
		"video/vp8": {
			source: "iana",
		},
		"video/vp9": {
			source: "iana",
		},
		"video/webm": {
			source: "apache",
			compressible: false,
			extensions: ["webm"],
		},
		"video/x-f4v": {
			source: "apache",
			extensions: ["f4v"],
		},
		"video/x-fli": {
			source: "apache",
			extensions: ["fli"],
		},
		"video/x-flv": {
			source: "apache",
			compressible: false,
			extensions: ["flv"],
		},
		"video/x-m4v": {
			source: "apache",
			extensions: ["m4v"],
		},
		"video/x-matroska": {
			source: "apache",
			compressible: false,
			extensions: ["mkv", "mk3d", "mks"],
		},
		"video/x-mng": {
			source: "apache",
			extensions: ["mng"],
		},
		"video/x-ms-asf": {
			source: "apache",
			extensions: ["asf", "asx"],
		},
		"video/x-ms-vob": {
			source: "apache",
			extensions: ["vob"],
		},
		"video/x-ms-wm": {
			source: "apache",
			extensions: ["wm"],
		},
		"video/x-ms-wmv": {
			source: "apache",
			compressible: false,
			extensions: ["wmv"],
		},
		"video/x-ms-wmx": {
			source: "apache",
			extensions: ["wmx"],
		},
		"video/x-ms-wvx": {
			source: "apache",
			extensions: ["wvx"],
		},
		"video/x-msvideo": {
			source: "apache",
			extensions: ["avi"],
		},
		"video/x-sgi-movie": {
			source: "apache",
			extensions: ["movie"],
		},
		"video/x-smv": {
			source: "apache",
			extensions: ["smv"],
		},
		"x-conference/x-cooltalk": {
			source: "apache",
			extensions: ["ice"],
		},
		"x-shader/x-fragment": {
			compressible: true,
		},
		"x-shader/x-vertex": {
			compressible: true,
		},
	};
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS((exports, module) => {
	/*!
	 * mime-db
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2015-2022 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	module.exports = require_db();
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS((exports) => {
	/*!
	 * mime-types
	 * Copyright(c) 2014 Jonathan Ong
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */
	var db = require_mime_db();
	var extname = __require("path").extname;
	var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
	var TEXT_TYPE_REGEXP = /^text\//i;
	exports.charset = charset;
	exports.charsets = { lookup: charset };
	exports.contentType = contentType;
	exports.extension = extension;
	exports.extensions = Object.create(null);
	exports.lookup = lookup;
	exports.types = Object.create(null);
	populateMaps(exports.extensions, exports.types);
	function charset(type) {
		if (!type || typeof type !== "string") {
			return false;
		}
		var match = EXTRACT_TYPE_REGEXP.exec(type);
		var mime2 = match && db[match[1].toLowerCase()];
		if (mime2 && mime2.charset) {
			return mime2.charset;
		}
		if (match && TEXT_TYPE_REGEXP.test(match[1])) {
			return "UTF-8";
		}
		return false;
	}
	function contentType(str) {
		if (!str || typeof str !== "string") {
			return false;
		}
		var mime2 = str.indexOf("/") === -1 ? exports.lookup(str) : str;
		if (!mime2) {
			return false;
		}
		if (mime2.indexOf("charset") === -1) {
			var charset2 = exports.charset(mime2);
			if (charset2) mime2 += "; charset=" + charset2.toLowerCase();
		}
		return mime2;
	}
	function extension(type) {
		if (!type || typeof type !== "string") {
			return false;
		}
		var match = EXTRACT_TYPE_REGEXP.exec(type);
		var exts = match && exports.extensions[match[1].toLowerCase()];
		if (!exts || !exts.length) {
			return false;
		}
		return exts[0];
	}
	function lookup(path2) {
		if (!path2 || typeof path2 !== "string") {
			return false;
		}
		var extension2 = extname("x." + path2)
			.toLowerCase()
			.substr(1);
		if (!extension2) {
			return false;
		}
		return exports.types[extension2] || false;
	}
	function populateMaps(extensions2, types2) {
		var preference = ["nginx", "apache", undefined, "iana"];
		Object.keys(db).forEach(function forEachMimeType(type) {
			var mime2 = db[type];
			var exts = mime2.extensions;
			if (!exts || !exts.length) {
				return;
			}
			extensions2[type] = exts;
			for (var i = 0; i < exts.length; i++) {
				var extension2 = exts[i];
				if (types2[extension2]) {
					var from = preference.indexOf(db[types2[extension2]].source);
					var to = preference.indexOf(mime2.source);
					if (
						types2[extension2] !== "application/octet-stream" &&
						(from > to || (from === to && types2[extension2].substr(0, 12) === "application/"))
					) {
						continue;
					}
				}
				types2[extension2] = type;
			}
		});
	}
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS((exports, module) => {
	module.exports = defer;
	function defer(fn) {
		var nextTick =
			typeof setImmediate == "function"
				? setImmediate
				: typeof process == "object" && typeof process.nextTick == "function"
					? process.nextTick
					: null;
		if (nextTick) {
			nextTick(fn);
		} else {
			setTimeout(fn, 0);
		}
	}
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS((exports, module) => {
	var defer = require_defer();
	module.exports = async;
	function async(callback) {
		var isAsync3 = false;
		defer(function () {
			isAsync3 = true;
		});
		return function async_callback(err, result) {
			if (isAsync3) {
				callback(err, result);
			} else {
				defer(function nextTick_callback() {
					callback(err, result);
				});
			}
		};
	}
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS((exports, module) => {
	module.exports = abort;
	function abort(state) {
		Object.keys(state.jobs).forEach(clean2.bind(state));
		state.jobs = {};
	}
	function clean2(key) {
		if (typeof this.jobs[key] == "function") {
			this.jobs[key]();
		}
	}
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS((exports, module) => {
	var async = require_async();
	var abort = require_abort();
	module.exports = iterate;
	function iterate(list, iterator2, state, callback) {
		var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
		state.jobs[key] = runJob(iterator2, key, list[key], function (error, output) {
			if (!(key in state.jobs)) {
				return;
			}
			delete state.jobs[key];
			if (error) {
				abort(state);
			} else {
				state.results[key] = output;
			}
			callback(error, state.results);
		});
	}
	function runJob(iterator2, key, item, callback) {
		var aborter;
		if (iterator2.length == 2) {
			aborter = iterator2(item, async(callback));
		} else {
			aborter = iterator2(item, key, async(callback));
		}
		return aborter;
	}
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS((exports, module) => {
	module.exports = state;
	function state(list, sortMethod) {
		var isNamedList = !Array.isArray(list),
			initState = {
				index: 0,
				keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
				jobs: {},
				results: isNamedList ? {} : [],
				size: isNamedList ? Object.keys(list).length : list.length,
			};
		if (sortMethod) {
			initState.keyedList.sort(
				isNamedList
					? sortMethod
					: function (a12, b) {
							return sortMethod(list[a12], list[b]);
						},
			);
		}
		return initState;
	}
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS((exports, module) => {
	var abort = require_abort();
	var async = require_async();
	module.exports = terminator;
	function terminator(callback) {
		if (!Object.keys(this.jobs).length) {
			return;
		}
		this.index = this.size;
		abort(this);
		async(callback)(null, this.results);
	}
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS((exports, module) => {
	var iterate = require_iterate();
	var initState = require_state();
	var terminator = require_terminator();
	module.exports = parallel;
	function parallel(list, iterator2, callback) {
		var state = initState(list);
		while (state.index < (state["keyedList"] || list).length) {
			iterate(list, iterator2, state, function (error, result) {
				if (error) {
					callback(error, result);
					return;
				}
				if (Object.keys(state.jobs).length === 0) {
					callback(null, state.results);
					return;
				}
			});
			state.index++;
		}
		return terminator.bind(state, callback);
	}
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS((exports, module) => {
	var iterate = require_iterate();
	var initState = require_state();
	var terminator = require_terminator();
	module.exports = serialOrdered;
	module.exports.ascending = ascending;
	module.exports.descending = descending;
	function serialOrdered(list, iterator2, sortMethod, callback) {
		var state = initState(list, sortMethod);
		iterate(list, iterator2, state, function iteratorHandler(error, result) {
			if (error) {
				callback(error, result);
				return;
			}
			state.index++;
			if (state.index < (state["keyedList"] || list).length) {
				iterate(list, iterator2, state, iteratorHandler);
				return;
			}
			callback(null, state.results);
		});
		return terminator.bind(state, callback);
	}
	function ascending(a12, b) {
		return a12 < b ? -1 : a12 > b ? 1 : 0;
	}
	function descending(a12, b) {
		return -1 * ascending(a12, b);
	}
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS((exports, module) => {
	var serialOrdered = require_serialOrdered();
	module.exports = serial;
	function serial(list, iterator2, callback) {
		return serialOrdered(list, iterator2, null, callback);
	}
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS((exports, module) => {
	module.exports = {
		parallel: require_parallel(),
		serial: require_serial(),
		serialOrdered: require_serialOrdered(),
	};
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS((exports, module) => {
	module.exports = Object;
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS((exports, module) => {
	module.exports = Error;
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS((exports, module) => {
	module.exports = EvalError;
});

// node_modules/es-errors/range.js
var require_range = __commonJS((exports, module) => {
	module.exports = RangeError;
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS((exports, module) => {
	module.exports = ReferenceError;
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS((exports, module) => {
	module.exports = SyntaxError;
});

// node_modules/es-errors/type.js
var require_type = __commonJS((exports, module) => {
	module.exports = TypeError;
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS((exports, module) => {
	module.exports = URIError;
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS((exports, module) => {
	module.exports = Math.abs;
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS((exports, module) => {
	module.exports = Math.floor;
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS((exports, module) => {
	module.exports = Math.max;
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS((exports, module) => {
	module.exports = Math.min;
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS((exports, module) => {
	module.exports = Math.pow;
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS((exports, module) => {
	module.exports = Math.round;
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS((exports, module) => {
	module.exports =
		Number.isNaN ||
		function isNaN(a12) {
			return a12 !== a12;
		};
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS((exports, module) => {
	var $isNaN = require_isNaN();
	module.exports = function sign(number) {
		if ($isNaN(number) || number === 0) {
			return number;
		}
		return number < 0 ? -1 : 1;
	};
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS((exports, module) => {
	module.exports = Object.getOwnPropertyDescriptor;
});

// node_modules/gopd/index.js
var require_gopd = __commonJS((exports, module) => {
	var $gOPD = require_gOPD();
	if ($gOPD) {
		try {
			$gOPD([], "length");
		} catch (e) {
			$gOPD = null;
		}
	}
	module.exports = $gOPD;
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS((exports, module) => {
	var $defineProperty = Object.defineProperty || false;
	if ($defineProperty) {
		try {
			$defineProperty({}, "a", { value: 1 });
		} catch (e) {
			$defineProperty = false;
		}
	}
	module.exports = $defineProperty;
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS((exports, module) => {
	module.exports = function hasSymbols() {
		if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
			return false;
		}
		if (typeof Symbol.iterator === "symbol") {
			return true;
		}
		var obj = {};
		var sym = Symbol("test");
		var symObj = Object(sym);
		if (typeof sym === "string") {
			return false;
		}
		if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
			return false;
		}
		if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
			return false;
		}
		var symVal = 42;
		obj[sym] = symVal;
		for (var _2 in obj) {
			return false;
		}
		if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
			return false;
		}
		if (
			typeof Object.getOwnPropertyNames === "function" &&
			Object.getOwnPropertyNames(obj).length !== 0
		) {
			return false;
		}
		var syms = Object.getOwnPropertySymbols(obj);
		if (syms.length !== 1 || syms[0] !== sym) {
			return false;
		}
		if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
			return false;
		}
		if (typeof Object.getOwnPropertyDescriptor === "function") {
			var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
			if (descriptor.value !== symVal || descriptor.enumerable !== true) {
				return false;
			}
		}
		return true;
	};
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS((exports, module) => {
	var origSymbol = typeof Symbol !== "undefined" && Symbol;
	var hasSymbolSham = require_shams();
	module.exports = function hasNativeSymbols() {
		if (typeof origSymbol !== "function") {
			return false;
		}
		if (typeof Symbol !== "function") {
			return false;
		}
		if (typeof origSymbol("foo") !== "symbol") {
			return false;
		}
		if (typeof Symbol("bar") !== "symbol") {
			return false;
		}
		return hasSymbolSham();
	};
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS((exports, module) => {
	module.exports = (typeof Reflect !== "undefined" && Reflect.getPrototypeOf) || null;
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS((exports, module) => {
	var $Object = require_es_object_atoms();
	module.exports = $Object.getPrototypeOf || null;
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS((exports, module) => {
	var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
	var toStr = Object.prototype.toString;
	var max = Math.max;
	var funcType = "[object Function]";
	var concatty = function concatty(a12, b) {
		var arr = [];
		for (var i = 0; i < a12.length; i += 1) {
			arr[i] = a12[i];
		}
		for (var j = 0; j < b.length; j += 1) {
			arr[j + a12.length] = b[j];
		}
		return arr;
	};
	var slicy = function slicy(arrLike, offset) {
		var arr = [];
		for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
			arr[j] = arrLike[i];
		}
		return arr;
	};
	var joiny = function (arr, joiner) {
		var str = "";
		for (var i = 0; i < arr.length; i += 1) {
			str += arr[i];
			if (i + 1 < arr.length) {
				str += joiner;
			}
		}
		return str;
	};
	module.exports = function bind(that) {
		var target = this;
		if (typeof target !== "function" || toStr.apply(target) !== funcType) {
			throw new TypeError(ERROR_MESSAGE + target);
		}
		var args = slicy(arguments, 1);
		var bound;
		var binder = function () {
			if (this instanceof bound) {
				var result = target.apply(this, concatty(args, arguments));
				if (Object(result) === result) {
					return result;
				}
				return this;
			}
			return target.apply(that, concatty(args, arguments));
		};
		var boundLength = max(0, target.length - args.length);
		var boundArgs = [];
		for (var i = 0; i < boundLength; i++) {
			boundArgs[i] = "$" + i;
		}
		bound = Function(
			"binder",
			"return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }",
		)(binder);
		if (target.prototype) {
			var Empty = function Empty() {};
			Empty.prototype = target.prototype;
			bound.prototype = new Empty();
			Empty.prototype = null;
		}
		return bound;
	};
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS((exports, module) => {
	var implementation = require_implementation();
	module.exports = Function.prototype.bind || implementation;
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS((exports, module) => {
	module.exports = Function.prototype.call;
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS((exports, module) => {
	module.exports = Function.prototype.apply;
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS((exports, module) => {
	module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS((exports, module) => {
	var bind2 = require_function_bind();
	var $apply = require_functionApply();
	var $call = require_functionCall();
	var $reflectApply = require_reflectApply();
	module.exports = $reflectApply || bind2.call($call, $apply);
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS((exports, module) => {
	var bind2 = require_function_bind();
	var $TypeError = require_type();
	var $call = require_functionCall();
	var $actualApply = require_actualApply();
	module.exports = function callBindBasic(args) {
		if (args.length < 1 || typeof args[0] !== "function") {
			throw new $TypeError("a function is required");
		}
		return $actualApply(bind2, $call, args);
	};
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS((exports, module) => {
	var callBind = require_call_bind_apply_helpers();
	var gOPD = require_gopd();
	var hasProtoAccessor;
	try {
		hasProtoAccessor = [].__proto__ === Array.prototype;
	} catch (e) {
		if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
			throw e;
		}
	}
	var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, "__proto__");
	var $Object = Object;
	var $getPrototypeOf = $Object.getPrototypeOf;
	module.exports =
		desc && typeof desc.get === "function"
			? callBind([desc.get])
			: typeof $getPrototypeOf === "function"
				? function getDunder(value) {
						return $getPrototypeOf(value == null ? value : $Object(value));
					}
				: false;
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS((exports, module) => {
	var reflectGetProto = require_Reflect_getPrototypeOf();
	var originalGetProto = require_Object_getPrototypeOf();
	var getDunderProto = require_get();
	module.exports = reflectGetProto
		? function getProto(O) {
				return reflectGetProto(O);
			}
		: originalGetProto
			? function getProto(O) {
					if (!O || (typeof O !== "object" && typeof O !== "function")) {
						throw new TypeError("getProto: not an object");
					}
					return originalGetProto(O);
				}
			: getDunderProto
				? function getProto(O) {
						return getDunderProto(O);
					}
				: null;
});

// node_modules/hasown/index.js
var require_hasown = __commonJS((exports, module) => {
	var call = Function.prototype.call;
	var $hasOwn = Object.prototype.hasOwnProperty;
	var bind2 = require_function_bind();
	module.exports = bind2.call(call, $hasOwn);
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS((exports, module) => {
	var undefined2;
	var $Object = require_es_object_atoms();
	var $Error = require_es_errors();
	var $EvalError = require_eval();
	var $RangeError = require_range();
	var $ReferenceError = require_ref();
	var $SyntaxError = require_syntax();
	var $TypeError = require_type();
	var $URIError = require_uri();
	var abs = require_abs();
	var floor = require_floor();
	var max = require_max();
	var min = require_min();
	var pow = require_pow();
	var round = require_round();
	var sign = require_sign();
	var $Function = Function;
	var getEvalledConstructor = function (expressionSyntax) {
		try {
			return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
		} catch (e) {}
	};
	var $gOPD = require_gopd();
	var $defineProperty = require_es_define_property();
	var throwTypeError = function () {
		throw new $TypeError();
	};
	var ThrowTypeError = $gOPD
		? (function () {
				try {
					arguments.callee;
					return throwTypeError;
				} catch (calleeThrows) {
					try {
						return $gOPD(arguments, "callee").get;
					} catch (gOPDthrows) {
						return throwTypeError;
					}
				}
			})()
		: throwTypeError;
	var hasSymbols = require_has_symbols()();
	var getProto = require_get_proto();
	var $ObjectGPO = require_Object_getPrototypeOf();
	var $ReflectGPO = require_Reflect_getPrototypeOf();
	var $apply = require_functionApply();
	var $call = require_functionCall();
	var needsEval = {};
	var TypedArray =
		typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
	var INTRINSICS = {
		__proto__: null,
		"%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
		"%Array%": Array,
		"%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
		"%ArrayIteratorPrototype%":
			hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
		"%AsyncFromSyncIteratorPrototype%": undefined2,
		"%AsyncFunction%": needsEval,
		"%AsyncGenerator%": needsEval,
		"%AsyncGeneratorFunction%": needsEval,
		"%AsyncIteratorPrototype%": needsEval,
		"%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
		"%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
		"%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
		"%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
		"%Boolean%": Boolean,
		"%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
		"%Date%": Date,
		"%decodeURI%": decodeURI,
		"%decodeURIComponent%": decodeURIComponent,
		"%encodeURI%": encodeURI,
		"%encodeURIComponent%": encodeURIComponent,
		"%Error%": $Error,
		"%eval%": eval,
		"%EvalError%": $EvalError,
		"%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
		"%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
		"%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
		"%FinalizationRegistry%":
			typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
		"%Function%": $Function,
		"%GeneratorFunction%": needsEval,
		"%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
		"%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
		"%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
		"%isFinite%": isFinite,
		"%isNaN%": isNaN,
		"%IteratorPrototype%":
			hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
		"%JSON%": typeof JSON === "object" ? JSON : undefined2,
		"%Map%": typeof Map === "undefined" ? undefined2 : Map,
		"%MapIteratorPrototype%":
			typeof Map === "undefined" || !hasSymbols || !getProto
				? undefined2
				: getProto(new Map()[Symbol.iterator]()),
		"%Math%": Math,
		"%Number%": Number,
		"%Object%": $Object,
		"%Object.getOwnPropertyDescriptor%": $gOPD,
		"%parseFloat%": parseFloat,
		"%parseInt%": parseInt,
		"%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
		"%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
		"%RangeError%": $RangeError,
		"%ReferenceError%": $ReferenceError,
		"%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
		"%RegExp%": RegExp,
		"%Set%": typeof Set === "undefined" ? undefined2 : Set,
		"%SetIteratorPrototype%":
			typeof Set === "undefined" || !hasSymbols || !getProto
				? undefined2
				: getProto(new Set()[Symbol.iterator]()),
		"%SharedArrayBuffer%":
			typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
		"%String%": String,
		"%StringIteratorPrototype%":
			hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
		"%Symbol%": hasSymbols ? Symbol : undefined2,
		"%SyntaxError%": $SyntaxError,
		"%ThrowTypeError%": ThrowTypeError,
		"%TypedArray%": TypedArray,
		"%TypeError%": $TypeError,
		"%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
		"%Uint8ClampedArray%":
			typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
		"%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
		"%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
		"%URIError%": $URIError,
		"%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
		"%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
		"%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
		"%Function.prototype.call%": $call,
		"%Function.prototype.apply%": $apply,
		"%Object.defineProperty%": $defineProperty,
		"%Object.getPrototypeOf%": $ObjectGPO,
		"%Math.abs%": abs,
		"%Math.floor%": floor,
		"%Math.max%": max,
		"%Math.min%": min,
		"%Math.pow%": pow,
		"%Math.round%": round,
		"%Math.sign%": sign,
		"%Reflect.getPrototypeOf%": $ReflectGPO,
	};
	if (getProto) {
		try {
			null.error;
		} catch (e) {
			errorProto = getProto(getProto(e));
			INTRINSICS["%Error.prototype%"] = errorProto;
		}
	}
	var errorProto;
	var doEval = function doEval(name) {
		var value;
		if (name === "%AsyncFunction%") {
			value = getEvalledConstructor("async function () {}");
		} else if (name === "%GeneratorFunction%") {
			value = getEvalledConstructor("function* () {}");
		} else if (name === "%AsyncGeneratorFunction%") {
			value = getEvalledConstructor("async function* () {}");
		} else if (name === "%AsyncGenerator%") {
			var fn = doEval("%AsyncGeneratorFunction%");
			if (fn) {
				value = fn.prototype;
			}
		} else if (name === "%AsyncIteratorPrototype%") {
			var gen = doEval("%AsyncGenerator%");
			if (gen && getProto) {
				value = getProto(gen.prototype);
			}
		}
		INTRINSICS[name] = value;
		return value;
	};
	var LEGACY_ALIASES = {
		__proto__: null,
		"%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
		"%ArrayPrototype%": ["Array", "prototype"],
		"%ArrayProto_entries%": ["Array", "prototype", "entries"],
		"%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
		"%ArrayProto_keys%": ["Array", "prototype", "keys"],
		"%ArrayProto_values%": ["Array", "prototype", "values"],
		"%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
		"%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
		"%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
		"%BooleanPrototype%": ["Boolean", "prototype"],
		"%DataViewPrototype%": ["DataView", "prototype"],
		"%DatePrototype%": ["Date", "prototype"],
		"%ErrorPrototype%": ["Error", "prototype"],
		"%EvalErrorPrototype%": ["EvalError", "prototype"],
		"%Float32ArrayPrototype%": ["Float32Array", "prototype"],
		"%Float64ArrayPrototype%": ["Float64Array", "prototype"],
		"%FunctionPrototype%": ["Function", "prototype"],
		"%Generator%": ["GeneratorFunction", "prototype"],
		"%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
		"%Int8ArrayPrototype%": ["Int8Array", "prototype"],
		"%Int16ArrayPrototype%": ["Int16Array", "prototype"],
		"%Int32ArrayPrototype%": ["Int32Array", "prototype"],
		"%JSONParse%": ["JSON", "parse"],
		"%JSONStringify%": ["JSON", "stringify"],
		"%MapPrototype%": ["Map", "prototype"],
		"%NumberPrototype%": ["Number", "prototype"],
		"%ObjectPrototype%": ["Object", "prototype"],
		"%ObjProto_toString%": ["Object", "prototype", "toString"],
		"%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
		"%PromisePrototype%": ["Promise", "prototype"],
		"%PromiseProto_then%": ["Promise", "prototype", "then"],
		"%Promise_all%": ["Promise", "all"],
		"%Promise_reject%": ["Promise", "reject"],
		"%Promise_resolve%": ["Promise", "resolve"],
		"%RangeErrorPrototype%": ["RangeError", "prototype"],
		"%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
		"%RegExpPrototype%": ["RegExp", "prototype"],
		"%SetPrototype%": ["Set", "prototype"],
		"%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
		"%StringPrototype%": ["String", "prototype"],
		"%SymbolPrototype%": ["Symbol", "prototype"],
		"%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
		"%TypedArrayPrototype%": ["TypedArray", "prototype"],
		"%TypeErrorPrototype%": ["TypeError", "prototype"],
		"%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
		"%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
		"%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
		"%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
		"%URIErrorPrototype%": ["URIError", "prototype"],
		"%WeakMapPrototype%": ["WeakMap", "prototype"],
		"%WeakSetPrototype%": ["WeakSet", "prototype"],
	};
	var bind2 = require_function_bind();
	var hasOwn = require_hasown();
	var $concat = bind2.call($call, Array.prototype.concat);
	var $spliceApply = bind2.call($apply, Array.prototype.splice);
	var $replace = bind2.call($call, String.prototype.replace);
	var $strSlice = bind2.call($call, String.prototype.slice);
	var $exec = bind2.call($call, RegExp.prototype.exec);
	var rePropName =
		/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
	var reEscapeChar = /\\(\\)?/g;
	var stringToPath = function stringToPath(string) {
		var first = $strSlice(string, 0, 1);
		var last = $strSlice(string, -1);
		if (first === "%" && last !== "%") {
			throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
		} else if (last === "%" && first !== "%") {
			throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
		}
		var result = [];
		$replace(string, rePropName, function (match, number, quote, subString) {
			result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
		});
		return result;
	};
	var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
		var intrinsicName = name;
		var alias;
		if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
			alias = LEGACY_ALIASES[intrinsicName];
			intrinsicName = "%" + alias[0] + "%";
		}
		if (hasOwn(INTRINSICS, intrinsicName)) {
			var value = INTRINSICS[intrinsicName];
			if (value === needsEval) {
				value = doEval(intrinsicName);
			}
			if (typeof value === "undefined" && !allowMissing) {
				throw new $TypeError(
					"intrinsic " + name + " exists, but is not available. Please file an issue!",
				);
			}
			return {
				alias,
				name: intrinsicName,
				value,
			};
		}
		throw new $SyntaxError("intrinsic " + name + " does not exist!");
	};
	module.exports = function GetIntrinsic(name, allowMissing) {
		if (typeof name !== "string" || name.length === 0) {
			throw new $TypeError("intrinsic name must be a non-empty string");
		}
		if (arguments.length > 1 && typeof allowMissing !== "boolean") {
			throw new $TypeError('"allowMissing" argument must be a boolean');
		}
		if ($exec(/^%?[^%]*%?$/, name) === null) {
			throw new $SyntaxError(
				"`%` may not be present anywhere but at the beginning and end of the intrinsic name",
			);
		}
		var parts = stringToPath(name);
		var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
		var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
		var intrinsicRealName = intrinsic.name;
		var value = intrinsic.value;
		var skipFurtherCaching = false;
		var alias = intrinsic.alias;
		if (alias) {
			intrinsicBaseName = alias[0];
			$spliceApply(parts, $concat([0, 1], alias));
		}
		for (var i = 1, isOwn = true; i < parts.length; i += 1) {
			var part = parts[i];
			var first = $strSlice(part, 0, 1);
			var last = $strSlice(part, -1);
			if (
				(first === '"' ||
					first === "'" ||
					first === "`" ||
					last === '"' ||
					last === "'" ||
					last === "`") &&
				first !== last
			) {
				throw new $SyntaxError("property names with quotes must have matching quotes");
			}
			if (part === "constructor" || !isOwn) {
				skipFurtherCaching = true;
			}
			intrinsicBaseName += "." + part;
			intrinsicRealName = "%" + intrinsicBaseName + "%";
			if (hasOwn(INTRINSICS, intrinsicRealName)) {
				value = INTRINSICS[intrinsicRealName];
			} else if (value != null) {
				if (!(part in value)) {
					if (!allowMissing) {
						throw new $TypeError(
							"base intrinsic for " + name + " exists, but the property is not available.",
						);
					}
					return;
				}
				if ($gOPD && i + 1 >= parts.length) {
					var desc = $gOPD(value, part);
					isOwn = !!desc;
					if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
						value = desc.get;
					} else {
						value = value[part];
					}
				} else {
					isOwn = hasOwn(value, part);
					value = value[part];
				}
				if (isOwn && !skipFurtherCaching) {
					INTRINSICS[intrinsicRealName] = value;
				}
			}
		}
		return value;
	};
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS((exports, module) => {
	var hasSymbols = require_shams();
	module.exports = function hasToStringTagShams() {
		return hasSymbols() && !!Symbol.toStringTag;
	};
});

// node_modules/es-set-tostringtag/index.js
var require_es_set_tostringtag = __commonJS((exports, module) => {
	var GetIntrinsic = require_get_intrinsic();
	var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
	var hasToStringTag = require_shams2()();
	var hasOwn = require_hasown();
	var $TypeError = require_type();
	var toStringTag2 = hasToStringTag ? Symbol.toStringTag : null;
	module.exports = function setToStringTag(object, value) {
		var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
		var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
		if (
			(typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean") ||
			(typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean")
		) {
			throw new $TypeError(
				"if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans",
			);
		}
		if (toStringTag2 && (overrideIfSet || !hasOwn(object, toStringTag2))) {
			if ($defineProperty) {
				$defineProperty(object, toStringTag2, {
					configurable: !nonConfigurable,
					enumerable: false,
					value,
					writable: false,
				});
			} else {
				object[toStringTag2] = value;
			}
		}
	};
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS((exports, module) => {
	module.exports = function (dst, src) {
		Object.keys(src).forEach(function (prop) {
			dst[prop] = dst[prop] || src[prop];
		});
		return dst;
	};
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS((exports, module) => {
	var CombinedStream = require_combined_stream();
	var util3 = __require("util");
	var path2 = __require("path");
	var http = __require("http");
	var https = __require("https");
	var parseUrl = __require("url").parse;
	var fs2 = __require("fs");
	var Stream = __require("stream").Stream;
	var crypto2 = __require("crypto");
	var mime2 = require_mime_types();
	var asynckit = require_asynckit();
	var setToStringTag = require_es_set_tostringtag();
	var hasOwn = require_hasown();
	var populate = require_populate();
	function FormData2(options) {
		if (!(this instanceof FormData2)) {
			return new FormData2(options);
		}
		this._overheadLength = 0;
		this._valueLength = 0;
		this._valuesToMeasure = [];
		CombinedStream.call(this);
		options = options || {};
		for (var option in options) {
			this[option] = options[option];
		}
	}
	util3.inherits(FormData2, CombinedStream);
	FormData2.LINE_BREAK = `\r
`;
	FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
	FormData2.prototype.append = function (field, value, options) {
		options = options || {};
		if (typeof options === "string") {
			options = { filename: options };
		}
		var append = CombinedStream.prototype.append.bind(this);
		if (typeof value === "number" || value == null) {
			value = String(value);
		}
		if (Array.isArray(value)) {
			this._error(new Error("Arrays are not supported."));
			return;
		}
		var header = this._multiPartHeader(field, value, options);
		var footer = this._multiPartFooter();
		append(header);
		append(value);
		append(footer);
		this._trackLength(header, value, options);
	};
	FormData2.prototype._trackLength = function (header, value, options) {
		var valueLength = 0;
		if (options.knownLength != null) {
			valueLength += Number(options.knownLength);
		} else if (Buffer.isBuffer(value)) {
			valueLength = value.length;
		} else if (typeof value === "string") {
			valueLength = Buffer.byteLength(value);
		}
		this._valueLength += valueLength;
		this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
		if (
			!value ||
			(!value.path &&
				!(value.readable && hasOwn(value, "httpVersion")) &&
				!(value instanceof Stream))
		) {
			return;
		}
		if (!options.knownLength) {
			this._valuesToMeasure.push(value);
		}
	};
	FormData2.prototype._lengthRetriever = function (value, callback) {
		if (hasOwn(value, "fd")) {
			if (value.end != null && value.end != Infinity && value.start != null) {
				callback(null, value.end + 1 - (value.start ? value.start : 0));
			} else {
				fs2.stat(value.path, function (err, stat2) {
					if (err) {
						callback(err);
						return;
					}
					var fileSize = stat2.size - (value.start ? value.start : 0);
					callback(null, fileSize);
				});
			}
		} else if (hasOwn(value, "httpVersion")) {
			callback(null, Number(value.headers["content-length"]));
		} else if (hasOwn(value, "httpModule")) {
			value.on("response", function (response) {
				value.pause();
				callback(null, Number(response.headers["content-length"]));
			});
			value.resume();
		} else {
			callback("Unknown stream");
		}
	};
	FormData2.prototype._multiPartHeader = function (field, value, options) {
		if (typeof options.header === "string") {
			return options.header;
		}
		var contentDisposition = this._getContentDisposition(value, options);
		var contentType = this._getContentType(value, options);
		var contents = "";
		var headers = {
			"Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
			"Content-Type": [].concat(contentType || []),
		};
		if (typeof options.header === "object") {
			populate(headers, options.header);
		}
		var header;
		for (var prop in headers) {
			if (hasOwn(headers, prop)) {
				header = headers[prop];
				if (header == null) {
					continue;
				}
				if (!Array.isArray(header)) {
					header = [header];
				}
				if (header.length) {
					contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
				}
			}
		}
		return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
	};
	FormData2.prototype._getContentDisposition = function (value, options) {
		var filename;
		if (typeof options.filepath === "string") {
			filename = path2.normalize(options.filepath).replace(/\\/g, "/");
		} else if (options.filename || (value && (value.name || value.path))) {
			filename = path2.basename(options.filename || (value && (value.name || value.path)));
		} else if (value && value.readable && hasOwn(value, "httpVersion")) {
			filename = path2.basename(value.client._httpMessage.path || "");
		}
		if (filename) {
			return 'filename="' + filename + '"';
		}
	};
	FormData2.prototype._getContentType = function (value, options) {
		var contentType = options.contentType;
		if (!contentType && value && value.name) {
			contentType = mime2.lookup(value.name);
		}
		if (!contentType && value && value.path) {
			contentType = mime2.lookup(value.path);
		}
		if (!contentType && value && value.readable && hasOwn(value, "httpVersion")) {
			contentType = value.headers["content-type"];
		}
		if (!contentType && (options.filepath || options.filename)) {
			contentType = mime2.lookup(options.filepath || options.filename);
		}
		if (!contentType && value && typeof value === "object") {
			contentType = FormData2.DEFAULT_CONTENT_TYPE;
		}
		return contentType;
	};
	FormData2.prototype._multiPartFooter = function () {
		return function (next) {
			var footer = FormData2.LINE_BREAK;
			var lastPart = this._streams.length === 0;
			if (lastPart) {
				footer += this._lastBoundary();
			}
			next(footer);
		}.bind(this);
	};
	FormData2.prototype._lastBoundary = function () {
		return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
	};
	FormData2.prototype.getHeaders = function (userHeaders) {
		var header;
		var formHeaders = {
			"content-type": "multipart/form-data; boundary=" + this.getBoundary(),
		};
		for (header in userHeaders) {
			if (hasOwn(userHeaders, header)) {
				formHeaders[header.toLowerCase()] = userHeaders[header];
			}
		}
		return formHeaders;
	};
	FormData2.prototype.setBoundary = function (boundary) {
		if (typeof boundary !== "string") {
			throw new TypeError("FormData boundary must be a string");
		}
		this._boundary = boundary;
	};
	FormData2.prototype.getBoundary = function () {
		if (!this._boundary) {
			this._generateBoundary();
		}
		return this._boundary;
	};
	FormData2.prototype.getBuffer = function () {
		var dataBuffer = new Buffer.alloc(0);
		var boundary = this.getBoundary();
		for (var i = 0, len = this._streams.length; i < len; i++) {
			if (typeof this._streams[i] !== "function") {
				if (Buffer.isBuffer(this._streams[i])) {
					dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
				} else {
					dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
				}
				if (
					typeof this._streams[i] !== "string" ||
					this._streams[i].substring(2, boundary.length + 2) !== boundary
				) {
					dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
				}
			}
		}
		return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
	};
	FormData2.prototype._generateBoundary = function () {
		this._boundary = "--------------------------" + crypto2.randomBytes(12).toString("hex");
	};
	FormData2.prototype.getLengthSync = function () {
		var knownLength = this._overheadLength + this._valueLength;
		if (this._streams.length) {
			knownLength += this._lastBoundary().length;
		}
		if (!this.hasKnownLength()) {
			this._error(new Error("Cannot calculate proper length in synchronous way."));
		}
		return knownLength;
	};
	FormData2.prototype.hasKnownLength = function () {
		var hasKnownLength = true;
		if (this._valuesToMeasure.length) {
			hasKnownLength = false;
		}
		return hasKnownLength;
	};
	FormData2.prototype.getLength = function (cb) {
		var knownLength = this._overheadLength + this._valueLength;
		if (this._streams.length) {
			knownLength += this._lastBoundary().length;
		}
		if (!this._valuesToMeasure.length) {
			process.nextTick(cb.bind(this, null, knownLength));
			return;
		}
		asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function (err, values) {
			if (err) {
				cb(err);
				return;
			}
			values.forEach(function (length) {
				knownLength += length;
			});
			cb(null, knownLength);
		});
	};
	FormData2.prototype.submit = function (params, cb) {
		var request;
		var options;
		var defaults = { method: "post" };
		if (typeof params === "string") {
			params = parseUrl(params);
			options = populate(
				{
					port: params.port,
					path: params.pathname,
					host: params.hostname,
					protocol: params.protocol,
				},
				defaults,
			);
		} else {
			options = populate(params, defaults);
			if (!options.port) {
				options.port = options.protocol === "https:" ? 443 : 80;
			}
		}
		options.headers = this.getHeaders(params.headers);
		if (options.protocol === "https:") {
			request = https.request(options);
		} else {
			request = http.request(options);
		}
		this.getLength(
			function (err, length) {
				if (err && err !== "Unknown stream") {
					this._error(err);
					return;
				}
				if (length) {
					request.setHeader("Content-Length", length);
				}
				this.pipe(request);
				if (cb) {
					var onResponse;
					var callback = function (error, responce) {
						request.removeListener("error", callback);
						request.removeListener("response", onResponse);
						return cb.call(this, error, responce);
					};
					onResponse = callback.bind(this, null);
					request.on("error", callback);
					request.on("response", onResponse);
				}
			}.bind(this),
		);
		return request;
	};
	FormData2.prototype._error = function (err) {
		if (!this.error) {
			this.error = err;
			this.pause();
			this.emit("error", err);
		}
	};
	FormData2.prototype.toString = function () {
		return "[object FormData]";
	};
	setToStringTag(FormData2.prototype, "FormData");
	module.exports = FormData2;
});

// node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS((exports) => {
	var parseUrl = __require("url").parse;
	var DEFAULT_PORTS = {
		ftp: 21,
		gopher: 70,
		http: 80,
		https: 443,
		ws: 80,
		wss: 443,
	};
	var stringEndsWith =
		String.prototype.endsWith ||
		function (s) {
			return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
		};
	function getProxyForUrl(url2) {
		var parsedUrl = typeof url2 === "string" ? parseUrl(url2) : url2 || {};
		var proto = parsedUrl.protocol;
		var hostname = parsedUrl.host;
		var port = parsedUrl.port;
		if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
			return "";
		}
		proto = proto.split(":", 1)[0];
		hostname = hostname.replace(/:\d*$/, "");
		port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
		if (!shouldProxy(hostname, port)) {
			return "";
		}
		var proxy =
			getEnv("npm_config_" + proto + "_proxy") ||
			getEnv(proto + "_proxy") ||
			getEnv("npm_config_proxy") ||
			getEnv("all_proxy");
		if (proxy && proxy.indexOf("://") === -1) {
			proxy = proto + "://" + proxy;
		}
		return proxy;
	}
	function shouldProxy(hostname, port) {
		var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
		if (!NO_PROXY) {
			return true;
		}
		if (NO_PROXY === "*") {
			return false;
		}
		return NO_PROXY.split(/[,\s]/).every(function (proxy) {
			if (!proxy) {
				return true;
			}
			var parsedProxy = proxy.match(/^(.+):(\d+)$/);
			var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
			var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
			if (parsedProxyPort && parsedProxyPort !== port) {
				return true;
			}
			if (!/^[.*]/.test(parsedProxyHostname)) {
				return hostname !== parsedProxyHostname;
			}
			if (parsedProxyHostname.charAt(0) === "*") {
				parsedProxyHostname = parsedProxyHostname.slice(1);
			}
			return !stringEndsWith.call(hostname, parsedProxyHostname);
		});
	}
	function getEnv(key) {
		return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
	}
	exports.getProxyForUrl = getProxyForUrl;
});

// node_modules/follow-redirects/debug.js
var require_debug = __commonJS((exports, module) => {
	var debug2;
	module.exports = function () {
		if (!debug2) {
			try {
				debug2 = require_src()("follow-redirects");
			} catch (error) {}
			if (typeof debug2 !== "function") {
				debug2 = function () {};
			}
		}
		debug2.apply(null, arguments);
	};
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS((exports, module) => {
	var url2 = __require("url");
	var URL2 = url2.URL;
	var http = __require("http");
	var https = __require("https");
	var Writable = __require("stream").Writable;
	var assert2 = __require("assert");
	var debug2 = require_debug();
	(function detectUnsupportedEnvironment() {
		var looksLikeNode = typeof process !== "undefined";
		var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
		var looksLikeV8 = isFunction2(Error.captureStackTrace);
		if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
			console.warn("The follow-redirects package should be excluded from browser builds.");
		}
	})();
	var useNativeURL = false;
	try {
		assert2(new URL2(""));
	} catch (error) {
		useNativeURL = error.code === "ERR_INVALID_URL";
	}
	var preservedUrlFields = [
		"auth",
		"host",
		"hostname",
		"href",
		"path",
		"pathname",
		"port",
		"protocol",
		"query",
		"search",
		"hash",
	];
	var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
	var eventHandlers = Object.create(null);
	events.forEach(function (event) {
		eventHandlers[event] = function (arg1, arg2, arg3) {
			this._redirectable.emit(event, arg1, arg2, arg3);
		};
	});
	var InvalidUrlError = createErrorType("ERR_INVALID_URL", "Invalid URL", TypeError);
	var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed");
	var TooManyRedirectsError = createErrorType(
		"ERR_FR_TOO_MANY_REDIRECTS",
		"Maximum number of redirects exceeded",
		RedirectionError,
	);
	var MaxBodyLengthExceededError = createErrorType(
		"ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
		"Request body larger than maxBodyLength limit",
	);
	var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
	var destroy = Writable.prototype.destroy || noop2;
	function RedirectableRequest(options, responseCallback) {
		Writable.call(this);
		this._sanitizeOptions(options);
		this._options = options;
		this._ended = false;
		this._ending = false;
		this._redirectCount = 0;
		this._redirects = [];
		this._requestBodyLength = 0;
		this._requestBodyBuffers = [];
		if (responseCallback) {
			this.on("response", responseCallback);
		}
		var self2 = this;
		this._onNativeResponse = function (response) {
			try {
				self2._processResponse(response);
			} catch (cause) {
				self2.emit(
					"error",
					cause instanceof RedirectionError ? cause : new RedirectionError({ cause }),
				);
			}
		};
		this._performRequest();
	}
	RedirectableRequest.prototype = Object.create(Writable.prototype);
	RedirectableRequest.prototype.abort = function () {
		destroyRequest(this._currentRequest);
		this._currentRequest.abort();
		this.emit("abort");
	};
	RedirectableRequest.prototype.destroy = function (error) {
		destroyRequest(this._currentRequest, error);
		destroy.call(this, error);
		return this;
	};
	RedirectableRequest.prototype.write = function (data, encoding, callback) {
		if (this._ending) {
			throw new WriteAfterEndError();
		}
		if (!isString2(data) && !isBuffer2(data)) {
			throw new TypeError("data should be a string, Buffer or Uint8Array");
		}
		if (isFunction2(encoding)) {
			callback = encoding;
			encoding = null;
		}
		if (data.length === 0) {
			if (callback) {
				callback();
			}
			return;
		}
		if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
			this._requestBodyLength += data.length;
			this._requestBodyBuffers.push({ data, encoding });
			this._currentRequest.write(data, encoding, callback);
		} else {
			this.emit("error", new MaxBodyLengthExceededError());
			this.abort();
		}
	};
	RedirectableRequest.prototype.end = function (data, encoding, callback) {
		if (isFunction2(data)) {
			callback = data;
			data = encoding = null;
		} else if (isFunction2(encoding)) {
			callback = encoding;
			encoding = null;
		}
		if (!data) {
			this._ended = this._ending = true;
			this._currentRequest.end(null, null, callback);
		} else {
			var self2 = this;
			var currentRequest = this._currentRequest;
			this.write(data, encoding, function () {
				self2._ended = true;
				currentRequest.end(null, null, callback);
			});
			this._ending = true;
		}
	};
	RedirectableRequest.prototype.setHeader = function (name, value) {
		this._options.headers[name] = value;
		this._currentRequest.setHeader(name, value);
	};
	RedirectableRequest.prototype.removeHeader = function (name) {
		delete this._options.headers[name];
		this._currentRequest.removeHeader(name);
	};
	RedirectableRequest.prototype.setTimeout = function (msecs, callback) {
		var self2 = this;
		function destroyOnTimeout(socket) {
			socket.setTimeout(msecs);
			socket.removeListener("timeout", socket.destroy);
			socket.addListener("timeout", socket.destroy);
		}
		function startTimer(socket) {
			if (self2._timeout) {
				clearTimeout(self2._timeout);
			}
			self2._timeout = setTimeout(function () {
				self2.emit("timeout");
				clearTimer();
			}, msecs);
			destroyOnTimeout(socket);
		}
		function clearTimer() {
			if (self2._timeout) {
				clearTimeout(self2._timeout);
				self2._timeout = null;
			}
			self2.removeListener("abort", clearTimer);
			self2.removeListener("error", clearTimer);
			self2.removeListener("response", clearTimer);
			self2.removeListener("close", clearTimer);
			if (callback) {
				self2.removeListener("timeout", callback);
			}
			if (!self2.socket) {
				self2._currentRequest.removeListener("socket", startTimer);
			}
		}
		if (callback) {
			this.on("timeout", callback);
		}
		if (this.socket) {
			startTimer(this.socket);
		} else {
			this._currentRequest.once("socket", startTimer);
		}
		this.on("socket", destroyOnTimeout);
		this.on("abort", clearTimer);
		this.on("error", clearTimer);
		this.on("response", clearTimer);
		this.on("close", clearTimer);
		return this;
	};
	["flushHeaders", "getHeader", "setNoDelay", "setSocketKeepAlive"].forEach(function (method) {
		RedirectableRequest.prototype[method] = function (a12, b) {
			return this._currentRequest[method](a12, b);
		};
	});
	["aborted", "connection", "socket"].forEach(function (property) {
		Object.defineProperty(RedirectableRequest.prototype, property, {
			get: function () {
				return this._currentRequest[property];
			},
		});
	});
	RedirectableRequest.prototype._sanitizeOptions = function (options) {
		if (!options.headers) {
			options.headers = {};
		}
		if (options.host) {
			if (!options.hostname) {
				options.hostname = options.host;
			}
			delete options.host;
		}
		if (!options.pathname && options.path) {
			var searchPos = options.path.indexOf("?");
			if (searchPos < 0) {
				options.pathname = options.path;
			} else {
				options.pathname = options.path.substring(0, searchPos);
				options.search = options.path.substring(searchPos);
			}
		}
	};
	RedirectableRequest.prototype._performRequest = function () {
		var protocol = this._options.protocol;
		var nativeProtocol = this._options.nativeProtocols[protocol];
		if (!nativeProtocol) {
			throw new TypeError("Unsupported protocol " + protocol);
		}
		if (this._options.agents) {
			var scheme = protocol.slice(0, -1);
			this._options.agent = this._options.agents[scheme];
		}
		var request = (this._currentRequest = nativeProtocol.request(
			this._options,
			this._onNativeResponse,
		));
		request._redirectable = this;
		for (var event of events) {
			request.on(event, eventHandlers[event]);
		}
		this._currentUrl = /^\//.test(this._options.path)
			? url2.format(this._options)
			: this._options.path;
		if (this._isRedirect) {
			var i = 0;
			var self2 = this;
			var buffers = this._requestBodyBuffers;
			(function writeNext(error) {
				if (request === self2._currentRequest) {
					if (error) {
						self2.emit("error", error);
					} else if (i < buffers.length) {
						var buffer = buffers[i++];
						if (!request.finished) {
							request.write(buffer.data, buffer.encoding, writeNext);
						}
					} else if (self2._ended) {
						request.end();
					}
				}
			})();
		}
	};
	RedirectableRequest.prototype._processResponse = function (response) {
		var statusCode = response.statusCode;
		if (this._options.trackRedirects) {
			this._redirects.push({
				url: this._currentUrl,
				headers: response.headers,
				statusCode,
			});
		}
		var location = response.headers.location;
		if (
			!location ||
			this._options.followRedirects === false ||
			statusCode < 300 ||
			statusCode >= 400
		) {
			response.responseUrl = this._currentUrl;
			response.redirects = this._redirects;
			this.emit("response", response);
			this._requestBodyBuffers = [];
			return;
		}
		destroyRequest(this._currentRequest);
		response.destroy();
		if (++this._redirectCount > this._options.maxRedirects) {
			throw new TooManyRedirectsError();
		}
		var requestHeaders;
		var beforeRedirect = this._options.beforeRedirect;
		if (beforeRedirect) {
			requestHeaders = Object.assign(
				{
					Host: response.req.getHeader("host"),
				},
				this._options.headers,
			);
		}
		var method = this._options.method;
		if (
			((statusCode === 301 || statusCode === 302) && this._options.method === "POST") ||
			(statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method))
		) {
			this._options.method = "GET";
			this._requestBodyBuffers = [];
			removeMatchingHeaders(/^content-/i, this._options.headers);
		}
		var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
		var currentUrlParts = parseUrl(this._currentUrl);
		var currentHost = currentHostHeader || currentUrlParts.host;
		var currentUrl = /^\w+:/.test(location)
			? this._currentUrl
			: url2.format(Object.assign(currentUrlParts, { host: currentHost }));
		var redirectUrl = resolveUrl(location, currentUrl);
		debug2("redirecting to", redirectUrl.href);
		this._isRedirect = true;
		spreadUrlObject(redirectUrl, this._options);
		if (
			(redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:") ||
			(redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost))
		) {
			removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
		}
		if (isFunction2(beforeRedirect)) {
			var responseDetails = {
				headers: response.headers,
				statusCode,
			};
			var requestDetails = {
				url: currentUrl,
				method,
				headers: requestHeaders,
			};
			beforeRedirect(this._options, responseDetails, requestDetails);
			this._sanitizeOptions(this._options);
		}
		this._performRequest();
	};
	function wrap(protocols) {
		var exports2 = {
			maxRedirects: 21,
			maxBodyLength: 10 * 1024 * 1024,
		};
		var nativeProtocols = {};
		Object.keys(protocols).forEach(function (scheme) {
			var protocol = scheme + ":";
			var nativeProtocol = (nativeProtocols[protocol] = protocols[scheme]);
			var wrappedProtocol = (exports2[scheme] = Object.create(nativeProtocol));
			function request(input, options, callback) {
				if (isURL(input)) {
					input = spreadUrlObject(input);
				} else if (isString2(input)) {
					input = spreadUrlObject(parseUrl(input));
				} else {
					callback = options;
					options = validateUrl(input);
					input = { protocol };
				}
				if (isFunction2(options)) {
					callback = options;
					options = null;
				}
				options = Object.assign(
					{
						maxRedirects: exports2.maxRedirects,
						maxBodyLength: exports2.maxBodyLength,
					},
					input,
					options,
				);
				options.nativeProtocols = nativeProtocols;
				if (!isString2(options.host) && !isString2(options.hostname)) {
					options.hostname = "::1";
				}
				assert2.equal(options.protocol, protocol, "protocol mismatch");
				debug2("options", options);
				return new RedirectableRequest(options, callback);
			}
			function get(input, options, callback) {
				var wrappedRequest = wrappedProtocol.request(input, options, callback);
				wrappedRequest.end();
				return wrappedRequest;
			}
			Object.defineProperties(wrappedProtocol, {
				request: { value: request, configurable: true, enumerable: true, writable: true },
				get: { value: get, configurable: true, enumerable: true, writable: true },
			});
		});
		return exports2;
	}
	function noop2() {}
	function parseUrl(input) {
		var parsed;
		if (useNativeURL) {
			parsed = new URL2(input);
		} else {
			parsed = validateUrl(url2.parse(input));
			if (!isString2(parsed.protocol)) {
				throw new InvalidUrlError({ input });
			}
		}
		return parsed;
	}
	function resolveUrl(relative, base) {
		return useNativeURL ? new URL2(relative, base) : parseUrl(url2.resolve(base, relative));
	}
	function validateUrl(input) {
		if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
			throw new InvalidUrlError({ input: input.href || input });
		}
		if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
			throw new InvalidUrlError({ input: input.href || input });
		}
		return input;
	}
	function spreadUrlObject(urlObject, target) {
		var spread = target || {};
		for (var key of preservedUrlFields) {
			spread[key] = urlObject[key];
		}
		if (spread.hostname.startsWith("[")) {
			spread.hostname = spread.hostname.slice(1, -1);
		}
		if (spread.port !== "") {
			spread.port = Number(spread.port);
		}
		spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
		return spread;
	}
	function removeMatchingHeaders(regex2, headers) {
		var lastValue;
		for (var header in headers) {
			if (regex2.test(header)) {
				lastValue = headers[header];
				delete headers[header];
			}
		}
		return lastValue === null || typeof lastValue === "undefined"
			? undefined
			: String(lastValue).trim();
	}
	function createErrorType(code, message, baseClass) {
		function CustomError(properties) {
			if (isFunction2(Error.captureStackTrace)) {
				Error.captureStackTrace(this, this.constructor);
			}
			Object.assign(this, properties || {});
			this.code = code;
			this.message = this.cause ? message + ": " + this.cause.message : message;
		}
		CustomError.prototype = new (baseClass || Error)();
		Object.defineProperties(CustomError.prototype, {
			constructor: {
				value: CustomError,
				enumerable: false,
			},
			name: {
				value: "Error [" + code + "]",
				enumerable: false,
			},
		});
		return CustomError;
	}
	function destroyRequest(request, error) {
		for (var event of events) {
			request.removeListener(event, eventHandlers[event]);
		}
		request.on("error", noop2);
		request.destroy(error);
	}
	function isSubdomain(subdomain, domain) {
		assert2(isString2(subdomain) && isString2(domain));
		var dot = subdomain.length - domain.length - 1;
		return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
	}
	function isString2(value) {
		return typeof value === "string" || value instanceof String;
	}
	function isFunction2(value) {
		return typeof value === "function";
	}
	function isBuffer2(value) {
		return typeof value === "object" && "length" in value;
	}
	function isURL(value) {
		return URL2 && value instanceof URL2;
	}
	module.exports = wrap({ http, https });
	module.exports.wrap = wrap;
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
	/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
	var buffer = __require("buffer");
	var Buffer2 = buffer.Buffer;
	function copyProps(src, dst) {
		for (var key in src) {
			dst[key] = src[key];
		}
	}
	if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
		module.exports = buffer;
	} else {
		copyProps(buffer, exports);
		exports.Buffer = SafeBuffer;
	}
	function SafeBuffer(arg, encodingOrOffset, length) {
		return Buffer2(arg, encodingOrOffset, length);
	}
	SafeBuffer.prototype = Object.create(Buffer2.prototype);
	copyProps(Buffer2, SafeBuffer);
	SafeBuffer.from = function (arg, encodingOrOffset, length) {
		if (typeof arg === "number") {
			throw new TypeError("Argument must not be a number");
		}
		return Buffer2(arg, encodingOrOffset, length);
	};
	SafeBuffer.alloc = function (size, fill, encoding) {
		if (typeof size !== "number") {
			throw new TypeError("Argument must be a number");
		}
		var buf = Buffer2(size);
		if (fill !== undefined) {
			if (typeof encoding === "string") {
				buf.fill(fill, encoding);
			} else {
				buf.fill(fill);
			}
		} else {
			buf.fill(0);
		}
		return buf;
	};
	SafeBuffer.allocUnsafe = function (size) {
		if (typeof size !== "number") {
			throw new TypeError("Argument must be a number");
		}
		return Buffer2(size);
	};
	SafeBuffer.allocUnsafeSlow = function (size) {
		if (typeof size !== "number") {
			throw new TypeError("Argument must be a number");
		}
		return buffer.SlowBuffer(size);
	};
});

// node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS((exports, module) => {
	var Buffer2 = require_safe_buffer().Buffer;
	var Stream = __require("stream");
	var util5 = __require("util");
	function DataStream(data) {
		this.buffer = null;
		this.writable = true;
		this.readable = true;
		if (!data) {
			this.buffer = Buffer2.alloc(0);
			return this;
		}
		if (typeof data.pipe === "function") {
			this.buffer = Buffer2.alloc(0);
			data.pipe(this);
			return this;
		}
		if (data.length || typeof data === "object") {
			this.buffer = data;
			this.writable = false;
			process.nextTick(
				function () {
					this.emit("end", data);
					this.readable = false;
					this.emit("close");
				}.bind(this),
			);
			return this;
		}
		throw new TypeError("Unexpected data type (" + typeof data + ")");
	}
	util5.inherits(DataStream, Stream);
	DataStream.prototype.write = function write(data) {
		this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
		this.emit("data", data);
	};
	DataStream.prototype.end = function end(data) {
		if (data) this.write(data);
		this.emit("end", data);
		this.emit("close");
		this.writable = false;
		this.readable = false;
	};
	module.exports = DataStream;
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS((exports, module) => {
	function getParamSize(keySize) {
		var result = ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1);
		return result;
	}
	var paramBytesForAlg = {
		ES256: getParamSize(256),
		ES384: getParamSize(384),
		ES512: getParamSize(521),
	};
	function getParamBytesForAlg(alg) {
		var paramBytes = paramBytesForAlg[alg];
		if (paramBytes) {
			return paramBytes;
		}
		throw new Error('Unknown algorithm "' + alg + '"');
	}
	module.exports = getParamBytesForAlg;
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS((exports, module) => {
	var Buffer2 = require_safe_buffer().Buffer;
	var getParamBytesForAlg = require_param_bytes_for_alg();
	var MAX_OCTET = 128;
	var CLASS_UNIVERSAL = 0;
	var PRIMITIVE_BIT = 32;
	var TAG_SEQ = 16;
	var TAG_INT = 2;
	var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | (CLASS_UNIVERSAL << 6);
	var ENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6);
	function base64Url(base64) {
		return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
	}
	function signatureAsBuffer(signature) {
		if (Buffer2.isBuffer(signature)) {
			return signature;
		} else if (typeof signature === "string") {
			return Buffer2.from(signature, "base64");
		}
		throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
	}
	function derToJose(signature, alg) {
		signature = signatureAsBuffer(signature);
		var paramBytes = getParamBytesForAlg(alg);
		var maxEncodedParamLength = paramBytes + 1;
		var inputLength = signature.length;
		var offset = 0;
		if (signature[offset++] !== ENCODED_TAG_SEQ) {
			throw new Error('Could not find expected "seq"');
		}
		var seqLength = signature[offset++];
		if (seqLength === (MAX_OCTET | 1)) {
			seqLength = signature[offset++];
		}
		if (inputLength - offset < seqLength) {
			throw new Error(
				'"seq" specified length of "' +
					seqLength +
					'", only "' +
					(inputLength - offset) +
					'" remaining',
			);
		}
		if (signature[offset++] !== ENCODED_TAG_INT) {
			throw new Error('Could not find expected "int" for "r"');
		}
		var rLength = signature[offset++];
		if (inputLength - offset - 2 < rLength) {
			throw new Error(
				'"r" specified length of "' +
					rLength +
					'", only "' +
					(inputLength - offset - 2) +
					'" available',
			);
		}
		if (maxEncodedParamLength < rLength) {
			throw new Error(
				'"r" specified length of "' +
					rLength +
					'", max of "' +
					maxEncodedParamLength +
					'" is acceptable',
			);
		}
		var rOffset = offset;
		offset += rLength;
		if (signature[offset++] !== ENCODED_TAG_INT) {
			throw new Error('Could not find expected "int" for "s"');
		}
		var sLength = signature[offset++];
		if (inputLength - offset !== sLength) {
			throw new Error(
				'"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"',
			);
		}
		if (maxEncodedParamLength < sLength) {
			throw new Error(
				'"s" specified length of "' +
					sLength +
					'", max of "' +
					maxEncodedParamLength +
					'" is acceptable',
			);
		}
		var sOffset = offset;
		offset += sLength;
		if (offset !== inputLength) {
			throw new Error(
				'Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain',
			);
		}
		var rPadding = paramBytes - rLength,
			sPadding = paramBytes - sLength;
		var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
		for (offset = 0; offset < rPadding; ++offset) {
			dst[offset] = 0;
		}
		signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
		offset = paramBytes;
		for (var o = offset; offset < o + sPadding; ++offset) {
			dst[offset] = 0;
		}
		signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
		dst = dst.toString("base64");
		dst = base64Url(dst);
		return dst;
	}
	function countPadding(buf, start, stop) {
		var padding = 0;
		while (start + padding < stop && buf[start + padding] === 0) {
			++padding;
		}
		var needsSign = buf[start + padding] >= MAX_OCTET;
		if (needsSign) {
			--padding;
		}
		return padding;
	}
	function joseToDer(signature, alg) {
		signature = signatureAsBuffer(signature);
		var paramBytes = getParamBytesForAlg(alg);
		var signatureBytes = signature.length;
		if (signatureBytes !== paramBytes * 2) {
			throw new TypeError(
				'"' +
					alg +
					'" signatures must be "' +
					paramBytes * 2 +
					'" bytes, saw "' +
					signatureBytes +
					'"',
			);
		}
		var rPadding = countPadding(signature, 0, paramBytes);
		var sPadding = countPadding(signature, paramBytes, signature.length);
		var rLength = paramBytes - rPadding;
		var sLength = paramBytes - sPadding;
		var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
		var shortLength = rsBytes < MAX_OCTET;
		var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
		var offset = 0;
		dst[offset++] = ENCODED_TAG_SEQ;
		if (shortLength) {
			dst[offset++] = rsBytes;
		} else {
			dst[offset++] = MAX_OCTET | 1;
			dst[offset++] = rsBytes & 255;
		}
		dst[offset++] = ENCODED_TAG_INT;
		dst[offset++] = rLength;
		if (rPadding < 0) {
			dst[offset++] = 0;
			offset += signature.copy(dst, offset, 0, paramBytes);
		} else {
			offset += signature.copy(dst, offset, rPadding, paramBytes);
		}
		dst[offset++] = ENCODED_TAG_INT;
		dst[offset++] = sLength;
		if (sPadding < 0) {
			dst[offset++] = 0;
			signature.copy(dst, offset, paramBytes);
		} else {
			signature.copy(dst, offset, paramBytes + sPadding);
		}
		return dst;
	}
	module.exports = {
		derToJose,
		joseToDer,
	};
});

// node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS((exports, module) => {
	var Buffer2 = __require("buffer").Buffer;
	var SlowBuffer = __require("buffer").SlowBuffer;
	module.exports = bufferEq;
	function bufferEq(a12, b) {
		if (!Buffer2.isBuffer(a12) || !Buffer2.isBuffer(b)) {
			return false;
		}
		if (a12.length !== b.length) {
			return false;
		}
		var c = 0;
		for (var i = 0; i < a12.length; i++) {
			c |= a12[i] ^ b[i];
		}
		return c === 0;
	}
	bufferEq.install = function () {
		Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
			return bufferEq(this, that);
		};
	};
	var origBufEqual = Buffer2.prototype.equal;
	var origSlowBufEqual = SlowBuffer.prototype.equal;
	bufferEq.restore = function () {
		Buffer2.prototype.equal = origBufEqual;
		SlowBuffer.prototype.equal = origSlowBufEqual;
	};
});

// node_modules/jwa/index.js
var require_jwa = __commonJS((exports, module) => {
	var Buffer2 = require_safe_buffer().Buffer;
	var crypto3 = __require("crypto");
	var formatEcdsa = require_ecdsa_sig_formatter();
	var util5 = __require("util");
	var MSG_INVALID_ALGORITHM = `"%s" is not a valid algorithm.
  Supported algorithms are:
  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".`;
	var MSG_INVALID_SECRET = "secret must be a string or buffer";
	var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
	var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
	var supportsKeyObjects = typeof crypto3.createPublicKey === "function";
	if (supportsKeyObjects) {
		MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
		MSG_INVALID_SECRET += "or a KeyObject";
	}
	function checkIsPublicKey(key) {
		if (Buffer2.isBuffer(key)) {
			return;
		}
		if (typeof key === "string") {
			return;
		}
		if (!supportsKeyObjects) {
			throw typeError(MSG_INVALID_VERIFIER_KEY);
		}
		if (typeof key !== "object") {
			throw typeError(MSG_INVALID_VERIFIER_KEY);
		}
		if (typeof key.type !== "string") {
			throw typeError(MSG_INVALID_VERIFIER_KEY);
		}
		if (typeof key.asymmetricKeyType !== "string") {
			throw typeError(MSG_INVALID_VERIFIER_KEY);
		}
		if (typeof key.export !== "function") {
			throw typeError(MSG_INVALID_VERIFIER_KEY);
		}
	}
	function checkIsPrivateKey(key) {
		if (Buffer2.isBuffer(key)) {
			return;
		}
		if (typeof key === "string") {
			return;
		}
		if (typeof key === "object") {
			return;
		}
		throw typeError(MSG_INVALID_SIGNER_KEY);
	}
	function checkIsSecretKey(key) {
		if (Buffer2.isBuffer(key)) {
			return;
		}
		if (typeof key === "string") {
			return key;
		}
		if (!supportsKeyObjects) {
			throw typeError(MSG_INVALID_SECRET);
		}
		if (typeof key !== "object") {
			throw typeError(MSG_INVALID_SECRET);
		}
		if (key.type !== "secret") {
			throw typeError(MSG_INVALID_SECRET);
		}
		if (typeof key.export !== "function") {
			throw typeError(MSG_INVALID_SECRET);
		}
	}
	function fromBase64(base64) {
		return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
	}
	function toBase64(base64url) {
		base64url = base64url.toString();
		var padding = 4 - (base64url.length % 4);
		if (padding !== 4) {
			for (var i = 0; i < padding; ++i) {
				base64url += "=";
			}
		}
		return base64url.replace(/\-/g, "+").replace(/_/g, "/");
	}
	function typeError(template) {
		var args = [].slice.call(arguments, 1);
		var errMsg = util5.format.bind(util5, template).apply(null, args);
		return new TypeError(errMsg);
	}
	function bufferOrString(obj) {
		return Buffer2.isBuffer(obj) || typeof obj === "string";
	}
	function normalizeInput(thing) {
		if (!bufferOrString(thing)) thing = JSON.stringify(thing);
		return thing;
	}
	function createHmacSigner(bits) {
		return function sign(thing, secret) {
			checkIsSecretKey(secret);
			thing = normalizeInput(thing);
			var hmac = crypto3.createHmac("sha" + bits, secret);
			var sig = (hmac.update(thing), hmac.digest("base64"));
			return fromBase64(sig);
		};
	}
	var bufferEqual;
	var timingSafeEqual =
		"timingSafeEqual" in crypto3
			? function timingSafeEqual(a12, b) {
					if (a12.byteLength !== b.byteLength) {
						return false;
					}
					return crypto3.timingSafeEqual(a12, b);
				}
			: function timingSafeEqual(a12, b) {
					if (!bufferEqual) {
						bufferEqual = require_buffer_equal_constant_time();
					}
					return bufferEqual(a12, b);
				};
	function createHmacVerifier(bits) {
		return function verify(thing, signature, secret) {
			var computedSig = createHmacSigner(bits)(thing, secret);
			return timingSafeEqual(Buffer2.from(signature), Buffer2.from(computedSig));
		};
	}
	function createKeySigner(bits) {
		return function sign(thing, privateKey) {
			checkIsPrivateKey(privateKey);
			thing = normalizeInput(thing);
			var signer = crypto3.createSign("RSA-SHA" + bits);
			var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
			return fromBase64(sig);
		};
	}
	function createKeyVerifier(bits) {
		return function verify(thing, signature, publicKey) {
			checkIsPublicKey(publicKey);
			thing = normalizeInput(thing);
			signature = toBase64(signature);
			var verifier = crypto3.createVerify("RSA-SHA" + bits);
			verifier.update(thing);
			return verifier.verify(publicKey, signature, "base64");
		};
	}
	function createPSSKeySigner(bits) {
		return function sign(thing, privateKey) {
			checkIsPrivateKey(privateKey);
			thing = normalizeInput(thing);
			var signer = crypto3.createSign("RSA-SHA" + bits);
			var sig =
				(signer.update(thing),
				signer.sign(
					{
						key: privateKey,
						padding: crypto3.constants.RSA_PKCS1_PSS_PADDING,
						saltLength: crypto3.constants.RSA_PSS_SALTLEN_DIGEST,
					},
					"base64",
				));
			return fromBase64(sig);
		};
	}
	function createPSSKeyVerifier(bits) {
		return function verify(thing, signature, publicKey) {
			checkIsPublicKey(publicKey);
			thing = normalizeInput(thing);
			signature = toBase64(signature);
			var verifier = crypto3.createVerify("RSA-SHA" + bits);
			verifier.update(thing);
			return verifier.verify(
				{
					key: publicKey,
					padding: crypto3.constants.RSA_PKCS1_PSS_PADDING,
					saltLength: crypto3.constants.RSA_PSS_SALTLEN_DIGEST,
				},
				signature,
				"base64",
			);
		};
	}
	function createECDSASigner(bits) {
		var inner = createKeySigner(bits);
		return function sign() {
			var signature = inner.apply(null, arguments);
			signature = formatEcdsa.derToJose(signature, "ES" + bits);
			return signature;
		};
	}
	function createECDSAVerifer(bits) {
		var inner = createKeyVerifier(bits);
		return function verify(thing, signature, publicKey) {
			signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
			var result = inner(thing, signature, publicKey);
			return result;
		};
	}
	function createNoneSigner() {
		return function sign() {
			return "";
		};
	}
	function createNoneVerifier() {
		return function verify(thing, signature) {
			return signature === "";
		};
	}
	module.exports = function jwa(algorithm) {
		var signerFactories = {
			hs: createHmacSigner,
			rs: createKeySigner,
			ps: createPSSKeySigner,
			es: createECDSASigner,
			none: createNoneSigner,
		};
		var verifierFactories = {
			hs: createHmacVerifier,
			rs: createKeyVerifier,
			ps: createPSSKeyVerifier,
			es: createECDSAVerifer,
			none: createNoneVerifier,
		};
		var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
		if (!match) throw typeError(MSG_INVALID_ALGORITHM, algorithm);
		var algo = (match[1] || match[3]).toLowerCase();
		var bits = match[2];
		return {
			sign: signerFactories[algo](bits),
			verify: verifierFactories[algo](bits),
		};
	};
});

// node_modules/jws/lib/tostring.js
var require_tostring = __commonJS((exports, module) => {
	var Buffer2 = __require("buffer").Buffer;
	module.exports = function toString(obj) {
		if (typeof obj === "string") return obj;
		if (typeof obj === "number" || Buffer2.isBuffer(obj)) return obj.toString();
		return JSON.stringify(obj);
	};
});

// node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS((exports, module) => {
	var Buffer2 = require_safe_buffer().Buffer;
	var DataStream = require_data_stream();
	var jwa = require_jwa();
	var Stream = __require("stream");
	var toString3 = require_tostring();
	var util5 = __require("util");
	function base64url(string, encoding) {
		return Buffer2.from(string, encoding)
			.toString("base64")
			.replace(/=/g, "")
			.replace(/\+/g, "-")
			.replace(/\//g, "_");
	}
	function jwsSecuredInput(header, payload, encoding) {
		encoding = encoding || "utf8";
		var encodedHeader = base64url(toString3(header), "binary");
		var encodedPayload = base64url(toString3(payload), encoding);
		return util5.format("%s.%s", encodedHeader, encodedPayload);
	}
	function jwsSign(opts) {
		var header = opts.header;
		var payload = opts.payload;
		var secretOrKey = opts.secret || opts.privateKey;
		var encoding = opts.encoding;
		var algo = jwa(header.alg);
		var securedInput = jwsSecuredInput(header, payload, encoding);
		var signature = algo.sign(securedInput, secretOrKey);
		return util5.format("%s.%s", securedInput, signature);
	}
	function SignStream(opts) {
		var secret = opts.secret || opts.privateKey || opts.key;
		var secretStream = new DataStream(secret);
		this.readable = true;
		this.header = opts.header;
		this.encoding = opts.encoding;
		this.secret = this.privateKey = this.key = secretStream;
		this.payload = new DataStream(opts.payload);
		this.secret.once(
			"close",
			function () {
				if (!this.payload.writable && this.readable) this.sign();
			}.bind(this),
		);
		this.payload.once(
			"close",
			function () {
				if (!this.secret.writable && this.readable) this.sign();
			}.bind(this),
		);
	}
	util5.inherits(SignStream, Stream);
	SignStream.prototype.sign = function sign() {
		try {
			var signature = jwsSign({
				header: this.header,
				payload: this.payload.buffer,
				secret: this.secret.buffer,
				encoding: this.encoding,
			});
			this.emit("done", signature);
			this.emit("data", signature);
			this.emit("end");
			this.readable = false;
			return signature;
		} catch (e) {
			this.readable = false;
			this.emit("error", e);
			this.emit("close");
		}
	};
	SignStream.sign = jwsSign;
	module.exports = SignStream;
});

// node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS((exports, module) => {
	var Buffer2 = require_safe_buffer().Buffer;
	var DataStream = require_data_stream();
	var jwa = require_jwa();
	var Stream = __require("stream");
	var toString3 = require_tostring();
	var util5 = __require("util");
	var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
	function isObject3(thing) {
		return Object.prototype.toString.call(thing) === "[object Object]";
	}
	function safeJsonParse(thing) {
		if (isObject3(thing)) return thing;
		try {
			return JSON.parse(thing);
		} catch (e) {
			return;
		}
	}
	function headerFromJWS(jwsSig) {
		var encodedHeader = jwsSig.split(".", 1)[0];
		return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
	}
	function securedInputFromJWS(jwsSig) {
		return jwsSig.split(".", 2).join(".");
	}
	function signatureFromJWS(jwsSig) {
		return jwsSig.split(".")[2];
	}
	function payloadFromJWS(jwsSig, encoding) {
		encoding = encoding || "utf8";
		var payload = jwsSig.split(".")[1];
		return Buffer2.from(payload, "base64").toString(encoding);
	}
	function isValidJws(string) {
		return JWS_REGEX.test(string) && !!headerFromJWS(string);
	}
	function jwsVerify(jwsSig, algorithm, secretOrKey) {
		if (!algorithm) {
			var err = new Error("Missing algorithm parameter for jws.verify");
			err.code = "MISSING_ALGORITHM";
			throw err;
		}
		jwsSig = toString3(jwsSig);
		var signature = signatureFromJWS(jwsSig);
		var securedInput = securedInputFromJWS(jwsSig);
		var algo = jwa(algorithm);
		return algo.verify(securedInput, signature, secretOrKey);
	}
	function jwsDecode(jwsSig, opts) {
		opts = opts || {};
		jwsSig = toString3(jwsSig);
		if (!isValidJws(jwsSig)) return null;
		var header = headerFromJWS(jwsSig);
		if (!header) return null;
		var payload = payloadFromJWS(jwsSig);
		if (header.typ === "JWT" || opts.json) payload = JSON.parse(payload, opts.encoding);
		return {
			header,
			payload,
			signature: signatureFromJWS(jwsSig),
		};
	}
	function VerifyStream(opts) {
		opts = opts || {};
		var secretOrKey = opts.secret || opts.publicKey || opts.key;
		var secretStream = new DataStream(secretOrKey);
		this.readable = true;
		this.algorithm = opts.algorithm;
		this.encoding = opts.encoding;
		this.secret = this.publicKey = this.key = secretStream;
		this.signature = new DataStream(opts.signature);
		this.secret.once(
			"close",
			function () {
				if (!this.signature.writable && this.readable) this.verify();
			}.bind(this),
		);
		this.signature.once(
			"close",
			function () {
				if (!this.secret.writable && this.readable) this.verify();
			}.bind(this),
		);
	}
	util5.inherits(VerifyStream, Stream);
	VerifyStream.prototype.verify = function verify() {
		try {
			var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
			var obj = jwsDecode(this.signature.buffer, this.encoding);
			this.emit("done", valid, obj);
			this.emit("data", valid);
			this.emit("end");
			this.readable = false;
			return valid;
		} catch (e) {
			this.readable = false;
			this.emit("error", e);
			this.emit("close");
		}
	};
	VerifyStream.decode = jwsDecode;
	VerifyStream.isValid = isValidJws;
	VerifyStream.verify = jwsVerify;
	module.exports = VerifyStream;
});

// node_modules/jws/index.js
var require_jws = __commonJS((exports) => {
	var SignStream = require_sign_stream();
	var VerifyStream = require_verify_stream();
	var ALGORITHMS = [
		"HS256",
		"HS384",
		"HS512",
		"RS256",
		"RS384",
		"RS512",
		"PS256",
		"PS384",
		"PS512",
		"ES256",
		"ES384",
		"ES512",
	];
	exports.ALGORITHMS = ALGORITHMS;
	exports.sign = SignStream.sign;
	exports.verify = VerifyStream.verify;
	exports.decode = VerifyStream.decode;
	exports.isValid = VerifyStream.isValid;
	exports.createSign = function createSign(opts) {
		return new SignStream(opts);
	};
	exports.createVerify = function createVerify(opts) {
		return new VerifyStream(opts);
	};
});

// node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS((exports, module) => {
	var jws = require_jws();
	module.exports = function (jwt, options) {
		options = options || {};
		var decoded = jws.decode(jwt, options);
		if (!decoded) {
			return null;
		}
		var payload = decoded.payload;
		if (typeof payload === "string") {
			try {
				var obj = JSON.parse(payload);
				if (obj !== null && typeof obj === "object") {
					payload = obj;
				}
			} catch (e) {}
		}
		if (options.complete === true) {
			return {
				header: decoded.header,
				payload,
				signature: decoded.signature,
			};
		}
		return payload;
	};
});

// node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS((exports, module) => {
	var JsonWebTokenError = function (message, error) {
		Error.call(this, message);
		if (Error.captureStackTrace) {
			Error.captureStackTrace(this, this.constructor);
		}
		this.name = "JsonWebTokenError";
		this.message = message;
		if (error) this.inner = error;
	};
	JsonWebTokenError.prototype = Object.create(Error.prototype);
	JsonWebTokenError.prototype.constructor = JsonWebTokenError;
	module.exports = JsonWebTokenError;
});

// node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS((exports, module) => {
	var JsonWebTokenError = require_JsonWebTokenError();
	var NotBeforeError = function (message, date2) {
		JsonWebTokenError.call(this, message);
		this.name = "NotBeforeError";
		this.date = date2;
	};
	NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
	NotBeforeError.prototype.constructor = NotBeforeError;
	module.exports = NotBeforeError;
});

// node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS((exports, module) => {
	var JsonWebTokenError = require_JsonWebTokenError();
	var TokenExpiredError = function (message, expiredAt) {
		JsonWebTokenError.call(this, message);
		this.name = "TokenExpiredError";
		this.expiredAt = expiredAt;
	};
	TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
	TokenExpiredError.prototype.constructor = TokenExpiredError;
	module.exports = TokenExpiredError;
});

// node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS((exports, module) => {
	var ms = require_ms();
	module.exports = function (time, iat) {
		var timestamp = iat || Math.floor(Date.now() / 1000);
		if (typeof time === "string") {
			var milliseconds = ms(time);
			if (typeof milliseconds === "undefined") {
				return;
			}
			return Math.floor(timestamp + milliseconds / 1000);
		} else if (typeof time === "number") {
			return timestamp + time;
		} else {
			return;
		}
	};
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS((exports, module) => {
	var SEMVER_SPEC_VERSION = "2.0.0";
	var MAX_LENGTH = 256;
	var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
	var MAX_SAFE_COMPONENT_LENGTH = 16;
	var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
	var RELEASE_TYPES = ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"];
	module.exports = {
		MAX_LENGTH,
		MAX_SAFE_COMPONENT_LENGTH,
		MAX_SAFE_BUILD_LENGTH,
		MAX_SAFE_INTEGER,
		RELEASE_TYPES,
		SEMVER_SPEC_VERSION,
		FLAG_INCLUDE_PRERELEASE: 1,
		FLAG_LOOSE: 2,
	};
});

// node_modules/semver/internal/debug.js
var require_debug2 = __commonJS((exports, module) => {
	var debug2 =
		typeof process === "object" &&
		process.env &&
		process.env.NODE_DEBUG &&
		/\bsemver\b/i.test(process.env.NODE_DEBUG)
			? (...args) => console.error("SEMVER", ...args)
			: () => {};
	module.exports = debug2;
});

// node_modules/semver/internal/re.js
var require_re = __commonJS((exports, module) => {
	var { MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH, MAX_LENGTH } = require_constants();
	var debug2 = require_debug2();
	exports = module.exports = {};
	var re = (exports.re = []);
	var safeRe = (exports.safeRe = []);
	var src = (exports.src = []);
	var safeSrc = (exports.safeSrc = []);
	var t2 = (exports.t = {});
	var R = 0;
	var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
	var safeRegexReplacements = [
		["\\s", 1],
		["\\d", MAX_LENGTH],
		[LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
	];
	var makeSafeRegex = (value) => {
		for (const [token, max] of safeRegexReplacements) {
			value = value
				.split(`${token}*`)
				.join(`${token}{0,${max}}`)
				.split(`${token}+`)
				.join(`${token}{1,${max}}`);
		}
		return value;
	};
	var createToken = (name, value, isGlobal) => {
		const safe = makeSafeRegex(value);
		const index = R++;
		debug2(name, index, value);
		t2[name] = index;
		src[index] = value;
		safeSrc[index] = safe;
		re[index] = new RegExp(value, isGlobal ? "g" : undefined);
		safeRe[index] = new RegExp(safe, isGlobal ? "g" : undefined);
	};
	createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
	createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
	createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
	createToken(
		"MAINVERSION",
		`(${src[t2.NUMERICIDENTIFIER]})\\.` +
			`(${src[t2.NUMERICIDENTIFIER]})\\.` +
			`(${src[t2.NUMERICIDENTIFIER]})`,
	);
	createToken(
		"MAINVERSIONLOOSE",
		`(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.` +
			`(${src[t2.NUMERICIDENTIFIERLOOSE]})\\.` +
			`(${src[t2.NUMERICIDENTIFIERLOOSE]})`,
	);
	createToken(
		"PRERELEASEIDENTIFIER",
		`(?:${src[t2.NONNUMERICIDENTIFIER]}|${src[t2.NUMERICIDENTIFIER]})`,
	);
	createToken(
		"PRERELEASEIDENTIFIERLOOSE",
		`(?:${src[t2.NONNUMERICIDENTIFIER]}|${src[t2.NUMERICIDENTIFIERLOOSE]})`,
	);
	createToken(
		"PRERELEASE",
		`(?:-(${src[t2.PRERELEASEIDENTIFIER]}(?:\\.${src[t2.PRERELEASEIDENTIFIER]})*))`,
	);
	createToken(
		"PRERELEASELOOSE",
		`(?:-?(${src[t2.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t2.PRERELEASEIDENTIFIERLOOSE]})*))`,
	);
	createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
	createToken("BUILD", `(?:\\+(${src[t2.BUILDIDENTIFIER]}(?:\\.${src[t2.BUILDIDENTIFIER]})*))`);
	createToken("FULLPLAIN", `v?${src[t2.MAINVERSION]}${src[t2.PRERELEASE]}?${src[t2.BUILD]}?`);
	createToken("FULL", `^${src[t2.FULLPLAIN]}$`);
	createToken(
		"LOOSEPLAIN",
		`[v=\\s]*${src[t2.MAINVERSIONLOOSE]}${src[t2.PRERELEASELOOSE]}?${src[t2.BUILD]}?`,
	);
	createToken("LOOSE", `^${src[t2.LOOSEPLAIN]}$`);
	createToken("GTLT", "((?:<|>)?=?)");
	createToken("XRANGEIDENTIFIERLOOSE", `${src[t2.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
	createToken("XRANGEIDENTIFIER", `${src[t2.NUMERICIDENTIFIER]}|x|X|\\*`);
	createToken(
		"XRANGEPLAIN",
		`[v=\\s]*(${src[t2.XRANGEIDENTIFIER]})` +
			`(?:\\.(${src[t2.XRANGEIDENTIFIER]})` +
			`(?:\\.(${src[t2.XRANGEIDENTIFIER]})` +
			`(?:${src[t2.PRERELEASE]})?${src[t2.BUILD]}?` +
			")?)?",
	);
	createToken(
		"XRANGEPLAINLOOSE",
		`[v=\\s]*(${src[t2.XRANGEIDENTIFIERLOOSE]})` +
			`(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})` +
			`(?:\\.(${src[t2.XRANGEIDENTIFIERLOOSE]})` +
			`(?:${src[t2.PRERELEASELOOSE]})?${src[t2.BUILD]}?` +
			")?)?",
	);
	createToken("XRANGE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAIN]}$`);
	createToken("XRANGELOOSE", `^${src[t2.GTLT]}\\s*${src[t2.XRANGEPLAINLOOSE]}$`);
	createToken(
		"COERCEPLAIN",
		`${"(^|[^\\d])" + "(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` +
			`(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
			`(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`,
	);
	createToken("COERCE", `${src[t2.COERCEPLAIN]}(?:$|[^\\d])`);
	createToken(
		"COERCEFULL",
		src[t2.COERCEPLAIN] + `(?:${src[t2.PRERELEASE]})?` + `(?:${src[t2.BUILD]})?` + "(?:$|[^\\d])",
	);
	createToken("COERCERTL", src[t2.COERCE], true);
	createToken("COERCERTLFULL", src[t2.COERCEFULL], true);
	createToken("LONETILDE", "(?:~>?)");
	createToken("TILDETRIM", `(\\s*)${src[t2.LONETILDE]}\\s+`, true);
	exports.tildeTrimReplace = "$1~";
	createToken("TILDE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAIN]}$`);
	createToken("TILDELOOSE", `^${src[t2.LONETILDE]}${src[t2.XRANGEPLAINLOOSE]}$`);
	createToken("LONECARET", "(?:\\^)");
	createToken("CARETTRIM", `(\\s*)${src[t2.LONECARET]}\\s+`, true);
	exports.caretTrimReplace = "$1^";
	createToken("CARET", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAIN]}$`);
	createToken("CARETLOOSE", `^${src[t2.LONECARET]}${src[t2.XRANGEPLAINLOOSE]}$`);
	createToken("COMPARATORLOOSE", `^${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]})$|^$`);
	createToken("COMPARATOR", `^${src[t2.GTLT]}\\s*(${src[t2.FULLPLAIN]})$|^$`);
	createToken(
		"COMPARATORTRIM",
		`(\\s*)${src[t2.GTLT]}\\s*(${src[t2.LOOSEPLAIN]}|${src[t2.XRANGEPLAIN]})`,
		true,
	);
	exports.comparatorTrimReplace = "$1$2$3";
	createToken(
		"HYPHENRANGE",
		`^\\s*(${src[t2.XRANGEPLAIN]})` + "\\s+-\\s+" + `(${src[t2.XRANGEPLAIN]})` + "\\s*$",
	);
	createToken(
		"HYPHENRANGELOOSE",
		`^\\s*(${src[t2.XRANGEPLAINLOOSE]})` + "\\s+-\\s+" + `(${src[t2.XRANGEPLAINLOOSE]})` + "\\s*$",
	);
	createToken("STAR", "(<|>)?=?\\s*\\*");
	createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
	createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS((exports, module) => {
	var looseOption = Object.freeze({ loose: true });
	var emptyOpts = Object.freeze({});
	var parseOptions = (options) => {
		if (!options) {
			return emptyOpts;
		}
		if (typeof options !== "object") {
			return looseOption;
		}
		return options;
	};
	module.exports = parseOptions;
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS((exports, module) => {
	var numeric = /^[0-9]+$/;
	var compareIdentifiers = (a12, b) => {
		if (typeof a12 === "number" && typeof b === "number") {
			return a12 === b ? 0 : a12 < b ? -1 : 1;
		}
		const anum = numeric.test(a12);
		const bnum = numeric.test(b);
		if (anum && bnum) {
			a12 = +a12;
			b = +b;
		}
		return a12 === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a12 < b ? -1 : 1;
	};
	var rcompareIdentifiers = (a12, b) => compareIdentifiers(b, a12);
	module.exports = {
		compareIdentifiers,
		rcompareIdentifiers,
	};
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS((exports, module) => {
	var debug2 = require_debug2();
	var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
	var { safeRe: re, t: t2 } = require_re();
	var parseOptions = require_parse_options();
	var { compareIdentifiers } = require_identifiers();

	class SemVer {
		constructor(version, options) {
			options = parseOptions(options);
			if (version instanceof SemVer) {
				if (
					version.loose === !!options.loose &&
					version.includePrerelease === !!options.includePrerelease
				) {
					return version;
				} else {
					version = version.version;
				}
			} else if (typeof version !== "string") {
				throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
			}
			if (version.length > MAX_LENGTH) {
				throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
			}
			debug2("SemVer", version, options);
			this.options = options;
			this.loose = !!options.loose;
			this.includePrerelease = !!options.includePrerelease;
			const m2 = version.trim().match(options.loose ? re[t2.LOOSE] : re[t2.FULL]);
			if (!m2) {
				throw new TypeError(`Invalid Version: ${version}`);
			}
			this.raw = version;
			this.major = +m2[1];
			this.minor = +m2[2];
			this.patch = +m2[3];
			if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
				throw new TypeError("Invalid major version");
			}
			if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
				throw new TypeError("Invalid minor version");
			}
			if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
				throw new TypeError("Invalid patch version");
			}
			if (!m2[4]) {
				this.prerelease = [];
			} else {
				this.prerelease = m2[4].split(".").map((id) => {
					if (/^[0-9]+$/.test(id)) {
						const num = +id;
						if (num >= 0 && num < MAX_SAFE_INTEGER) {
							return num;
						}
					}
					return id;
				});
			}
			this.build = m2[5] ? m2[5].split(".") : [];
			this.format();
		}
		format() {
			this.version = `${this.major}.${this.minor}.${this.patch}`;
			if (this.prerelease.length) {
				this.version += `-${this.prerelease.join(".")}`;
			}
			return this.version;
		}
		toString() {
			return this.version;
		}
		compare(other) {
			debug2("SemVer.compare", this.version, this.options, other);
			if (!(other instanceof SemVer)) {
				if (typeof other === "string" && other === this.version) {
					return 0;
				}
				other = new SemVer(other, this.options);
			}
			if (other.version === this.version) {
				return 0;
			}
			return this.compareMain(other) || this.comparePre(other);
		}
		compareMain(other) {
			if (!(other instanceof SemVer)) {
				other = new SemVer(other, this.options);
			}
			if (this.major < other.major) {
				return -1;
			}
			if (this.major > other.major) {
				return 1;
			}
			if (this.minor < other.minor) {
				return -1;
			}
			if (this.minor > other.minor) {
				return 1;
			}
			if (this.patch < other.patch) {
				return -1;
			}
			if (this.patch > other.patch) {
				return 1;
			}
			return 0;
		}
		comparePre(other) {
			if (!(other instanceof SemVer)) {
				other = new SemVer(other, this.options);
			}
			if (this.prerelease.length && !other.prerelease.length) {
				return -1;
			} else if (!this.prerelease.length && other.prerelease.length) {
				return 1;
			} else if (!this.prerelease.length && !other.prerelease.length) {
				return 0;
			}
			let i = 0;
			do {
				const a12 = this.prerelease[i];
				const b = other.prerelease[i];
				debug2("prerelease compare", i, a12, b);
				if (a12 === undefined && b === undefined) {
					return 0;
				} else if (b === undefined) {
					return 1;
				} else if (a12 === undefined) {
					return -1;
				} else if (a12 === b) {
					continue;
				} else {
					return compareIdentifiers(a12, b);
				}
			} while (++i);
		}
		compareBuild(other) {
			if (!(other instanceof SemVer)) {
				other = new SemVer(other, this.options);
			}
			let i = 0;
			do {
				const a12 = this.build[i];
				const b = other.build[i];
				debug2("build compare", i, a12, b);
				if (a12 === undefined && b === undefined) {
					return 0;
				} else if (b === undefined) {
					return 1;
				} else if (a12 === undefined) {
					return -1;
				} else if (a12 === b) {
					continue;
				} else {
					return compareIdentifiers(a12, b);
				}
			} while (++i);
		}
		inc(release, identifier, identifierBase) {
			if (release.startsWith("pre")) {
				if (!identifier && identifierBase === false) {
					throw new Error("invalid increment argument: identifier is empty");
				}
				if (identifier) {
					const match = `-${identifier}`.match(
						this.options.loose ? re[t2.PRERELEASELOOSE] : re[t2.PRERELEASE],
					);
					if (!match || match[1] !== identifier) {
						throw new Error(`invalid identifier: ${identifier}`);
					}
				}
			}
			switch (release) {
				case "premajor":
					this.prerelease.length = 0;
					this.patch = 0;
					this.minor = 0;
					this.major++;
					this.inc("pre", identifier, identifierBase);
					break;
				case "preminor":
					this.prerelease.length = 0;
					this.patch = 0;
					this.minor++;
					this.inc("pre", identifier, identifierBase);
					break;
				case "prepatch":
					this.prerelease.length = 0;
					this.inc("patch", identifier, identifierBase);
					this.inc("pre", identifier, identifierBase);
					break;
				case "prerelease":
					if (this.prerelease.length === 0) {
						this.inc("patch", identifier, identifierBase);
					}
					this.inc("pre", identifier, identifierBase);
					break;
				case "release":
					if (this.prerelease.length === 0) {
						throw new Error(`version ${this.raw} is not a prerelease`);
					}
					this.prerelease.length = 0;
					break;
				case "major":
					if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
						this.major++;
					}
					this.minor = 0;
					this.patch = 0;
					this.prerelease = [];
					break;
				case "minor":
					if (this.patch !== 0 || this.prerelease.length === 0) {
						this.minor++;
					}
					this.patch = 0;
					this.prerelease = [];
					break;
				case "patch":
					if (this.prerelease.length === 0) {
						this.patch++;
					}
					this.prerelease = [];
					break;
				case "pre": {
					const base = Number(identifierBase) ? 1 : 0;
					if (this.prerelease.length === 0) {
						this.prerelease = [base];
					} else {
						let i = this.prerelease.length;
						while (--i >= 0) {
							if (typeof this.prerelease[i] === "number") {
								this.prerelease[i]++;
								i = -2;
							}
						}
						if (i === -1) {
							if (identifier === this.prerelease.join(".") && identifierBase === false) {
								throw new Error("invalid increment argument: identifier already exists");
							}
							this.prerelease.push(base);
						}
					}
					if (identifier) {
						let prerelease = [identifier, base];
						if (identifierBase === false) {
							prerelease = [identifier];
						}
						if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
							if (isNaN(this.prerelease[1])) {
								this.prerelease = prerelease;
							}
						} else {
							this.prerelease = prerelease;
						}
					}
					break;
				}
				default:
					throw new Error(`invalid increment argument: ${release}`);
			}
			this.raw = this.format();
			if (this.build.length) {
				this.raw += `+${this.build.join(".")}`;
			}
			return this;
		}
	}
	module.exports = SemVer;
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS((exports, module) => {
	var SemVer = require_semver();
	var parse2 = (version, options, throwErrors = false) => {
		if (version instanceof SemVer) {
			return version;
		}
		try {
			return new SemVer(version, options);
		} catch (er) {
			if (!throwErrors) {
				return null;
			}
			throw er;
		}
	};
	module.exports = parse2;
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS((exports, module) => {
	var parse2 = require_parse();
	var valid = (version, options) => {
		const v = parse2(version, options);
		return v ? v.version : null;
	};
	module.exports = valid;
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS((exports, module) => {
	var parse2 = require_parse();
	var clean2 = (version, options) => {
		const s = parse2(version.trim().replace(/^[=v]+/, ""), options);
		return s ? s.version : null;
	};
	module.exports = clean2;
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS((exports, module) => {
	var SemVer = require_semver();
	var inc = (version, release, options, identifier, identifierBase) => {
		if (typeof options === "string") {
			identifierBase = identifier;
			identifier = options;
			options = undefined;
		}
		try {
			return new SemVer(version instanceof SemVer ? version.version : version, options).inc(
				release,
				identifier,
				identifierBase,
			).version;
		} catch (er) {
			return null;
		}
	};
	module.exports = inc;
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS((exports, module) => {
	var parse2 = require_parse();
	var diff = (version1, version2) => {
		const v1 = parse2(version1, null, true);
		const v2 = parse2(version2, null, true);
		const comparison = v1.compare(v2);
		if (comparison === 0) {
			return null;
		}
		const v1Higher = comparison > 0;
		const highVersion = v1Higher ? v1 : v2;
		const lowVersion = v1Higher ? v2 : v1;
		const highHasPre = !!highVersion.prerelease.length;
		const lowHasPre = !!lowVersion.prerelease.length;
		if (lowHasPre && !highHasPre) {
			if (!lowVersion.patch && !lowVersion.minor) {
				return "major";
			}
			if (lowVersion.compareMain(highVersion) === 0) {
				if (lowVersion.minor && !lowVersion.patch) {
					return "minor";
				}
				return "patch";
			}
		}
		const prefix = highHasPre ? "pre" : "";
		if (v1.major !== v2.major) {
			return prefix + "major";
		}
		if (v1.minor !== v2.minor) {
			return prefix + "minor";
		}
		if (v1.patch !== v2.patch) {
			return prefix + "patch";
		}
		return "prerelease";
	};
	module.exports = diff;
});

// node_modules/semver/functions/major.js
var require_major = __commonJS((exports, module) => {
	var SemVer = require_semver();
	var major = (a12, loose) => new SemVer(a12, loose).major;
	module.exports = major;
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS((exports, module) => {
	var SemVer = require_semver();
	var minor = (a12, loose) => new SemVer(a12, loose).minor;
	module.exports = minor;
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS((exports, module) => {
	var SemVer = require_semver();
	var patch = (a12, loose) => new SemVer(a12, loose).patch;
	module.exports = patch;
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS((exports, module) => {
	var parse2 = require_parse();
	var prerelease = (version, options) => {
		const parsed = parse2(version, options);
		return parsed && parsed.prerelease.length ? parsed.prerelease : null;
	};
	module.exports = prerelease;
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS((exports, module) => {
	var SemVer = require_semver();
	var compare = (a12, b, loose) => new SemVer(a12, loose).compare(new SemVer(b, loose));
	module.exports = compare;
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS((exports, module) => {
	var compare = require_compare();
	var rcompare = (a12, b, loose) => compare(b, a12, loose);
	module.exports = rcompare;
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS((exports, module) => {
	var compare = require_compare();
	var compareLoose = (a12, b) => compare(a12, b, true);
	module.exports = compareLoose;
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS((exports, module) => {
	var SemVer = require_semver();
	var compareBuild = (a12, b, loose) => {
		const versionA = new SemVer(a12, loose);
		const versionB = new SemVer(b, loose);
		return versionA.compare(versionB) || versionA.compareBuild(versionB);
	};
	module.exports = compareBuild;
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS((exports, module) => {
	var compareBuild = require_compare_build();
	var sort = (list, loose) => list.sort((a12, b) => compareBuild(a12, b, loose));
	module.exports = sort;
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS((exports, module) => {
	var compareBuild = require_compare_build();
	var rsort = (list, loose) => list.sort((a12, b) => compareBuild(b, a12, loose));
	module.exports = rsort;
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS((exports, module) => {
	var compare = require_compare();
	var gt = (a12, b, loose) => compare(a12, b, loose) > 0;
	module.exports = gt;
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS((exports, module) => {
	var compare = require_compare();
	var lt = (a12, b, loose) => compare(a12, b, loose) < 0;
	module.exports = lt;
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS((exports, module) => {
	var compare = require_compare();
	var eq = (a12, b, loose) => compare(a12, b, loose) === 0;
	module.exports = eq;
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS((exports, module) => {
	var compare = require_compare();
	var neq = (a12, b, loose) => compare(a12, b, loose) !== 0;
	module.exports = neq;
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS((exports, module) => {
	var compare = require_compare();
	var gte = (a12, b, loose) => compare(a12, b, loose) >= 0;
	module.exports = gte;
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS((exports, module) => {
	var compare = require_compare();
	var lte = (a12, b, loose) => compare(a12, b, loose) <= 0;
	module.exports = lte;
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS((exports, module) => {
	var eq = require_eq();
	var neq = require_neq();
	var gt = require_gt();
	var gte = require_gte();
	var lt = require_lt();
	var lte = require_lte();
	var cmp = (a12, op, b, loose) => {
		switch (op) {
			case "===":
				if (typeof a12 === "object") {
					a12 = a12.version;
				}
				if (typeof b === "object") {
					b = b.version;
				}
				return a12 === b;
			case "!==":
				if (typeof a12 === "object") {
					a12 = a12.version;
				}
				if (typeof b === "object") {
					b = b.version;
				}
				return a12 !== b;
			case "":
			case "=":
			case "==":
				return eq(a12, b, loose);
			case "!=":
				return neq(a12, b, loose);
			case ">":
				return gt(a12, b, loose);
			case ">=":
				return gte(a12, b, loose);
			case "<":
				return lt(a12, b, loose);
			case "<=":
				return lte(a12, b, loose);
			default:
				throw new TypeError(`Invalid operator: ${op}`);
		}
	};
	module.exports = cmp;
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS((exports, module) => {
	var SemVer = require_semver();
	var parse2 = require_parse();
	var { safeRe: re, t: t2 } = require_re();
	var coerce2 = (version, options) => {
		if (version instanceof SemVer) {
			return version;
		}
		if (typeof version === "number") {
			version = String(version);
		}
		if (typeof version !== "string") {
			return null;
		}
		options = options || {};
		let match = null;
		if (!options.rtl) {
			match = version.match(options.includePrerelease ? re[t2.COERCEFULL] : re[t2.COERCE]);
		} else {
			const coerceRtlRegex = options.includePrerelease ? re[t2.COERCERTLFULL] : re[t2.COERCERTL];
			let next;
			while (
				(next = coerceRtlRegex.exec(version)) &&
				(!match || match.index + match[0].length !== version.length)
			) {
				if (!match || next.index + next[0].length !== match.index + match[0].length) {
					match = next;
				}
				coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
			}
			coerceRtlRegex.lastIndex = -1;
		}
		if (match === null) {
			return null;
		}
		const major = match[2];
		const minor = match[3] || "0";
		const patch = match[4] || "0";
		const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
		const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
		return parse2(`${major}.${minor}.${patch}${prerelease}${build}`, options);
	};
	module.exports = coerce2;
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS((exports, module) => {
	class LRUCache2 {
		constructor() {
			this.max = 1000;
			this.map = new Map();
		}
		get(key) {
			const value = this.map.get(key);
			if (value === undefined) {
				return;
			} else {
				this.map.delete(key);
				this.map.set(key, value);
				return value;
			}
		}
		delete(key) {
			return this.map.delete(key);
		}
		set(key, value) {
			const deleted = this.delete(key);
			if (!deleted && value !== undefined) {
				if (this.map.size >= this.max) {
					const firstKey = this.map.keys().next().value;
					this.delete(firstKey);
				}
				this.map.set(key, value);
			}
			return this;
		}
	}
	module.exports = LRUCache2;
});

// node_modules/semver/classes/range.js
var require_range2 = __commonJS((exports, module) => {
	var SPACE_CHARACTERS = /\s+/g;

	class Range {
		constructor(range, options) {
			options = parseOptions(options);
			if (range instanceof Range) {
				if (
					range.loose === !!options.loose &&
					range.includePrerelease === !!options.includePrerelease
				) {
					return range;
				} else {
					return new Range(range.raw, options);
				}
			}
			if (range instanceof Comparator) {
				this.raw = range.value;
				this.set = [[range]];
				this.formatted = undefined;
				return this;
			}
			this.options = options;
			this.loose = !!options.loose;
			this.includePrerelease = !!options.includePrerelease;
			this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
			this.set = this.raw
				.split("||")
				.map((r2) => this.parseRange(r2.trim()))
				.filter((c) => c.length);
			if (!this.set.length) {
				throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
			}
			if (this.set.length > 1) {
				const first = this.set[0];
				this.set = this.set.filter((c) => !isNullSet(c[0]));
				if (this.set.length === 0) {
					this.set = [first];
				} else if (this.set.length > 1) {
					for (const c of this.set) {
						if (c.length === 1 && isAny(c[0])) {
							this.set = [c];
							break;
						}
					}
				}
			}
			this.formatted = undefined;
		}
		get range() {
			if (this.formatted === undefined) {
				this.formatted = "";
				for (let i = 0; i < this.set.length; i++) {
					if (i > 0) {
						this.formatted += "||";
					}
					const comps = this.set[i];
					for (let k2 = 0; k2 < comps.length; k2++) {
						if (k2 > 0) {
							this.formatted += " ";
						}
						this.formatted += comps[k2].toString().trim();
					}
				}
			}
			return this.formatted;
		}
		format() {
			return this.range;
		}
		toString() {
			return this.range;
		}
		parseRange(range) {
			const memoOpts =
				(this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |
				(this.options.loose && FLAG_LOOSE);
			const memoKey = memoOpts + ":" + range;
			const cached = cache.get(memoKey);
			if (cached) {
				return cached;
			}
			const loose = this.options.loose;
			const hr = loose ? re[t2.HYPHENRANGELOOSE] : re[t2.HYPHENRANGE];
			range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
			debug2("hyphen replace", range);
			range = range.replace(re[t2.COMPARATORTRIM], comparatorTrimReplace);
			debug2("comparator trim", range);
			range = range.replace(re[t2.TILDETRIM], tildeTrimReplace);
			debug2("tilde trim", range);
			range = range.replace(re[t2.CARETTRIM], caretTrimReplace);
			debug2("caret trim", range);
			let rangeList = range
				.split(" ")
				.map((comp) => parseComparator(comp, this.options))
				.join(" ")
				.split(/\s+/)
				.map((comp) => replaceGTE0(comp, this.options));
			if (loose) {
				rangeList = rangeList.filter((comp) => {
					debug2("loose invalid filter", comp, this.options);
					return !!comp.match(re[t2.COMPARATORLOOSE]);
				});
			}
			debug2("range list", rangeList);
			const rangeMap = new Map();
			const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
			for (const comp of comparators) {
				if (isNullSet(comp)) {
					return [comp];
				}
				rangeMap.set(comp.value, comp);
			}
			if (rangeMap.size > 1 && rangeMap.has("")) {
				rangeMap.delete("");
			}
			const result = [...rangeMap.values()];
			cache.set(memoKey, result);
			return result;
		}
		intersects(range, options) {
			if (!(range instanceof Range)) {
				throw new TypeError("a Range is required");
			}
			return this.set.some((thisComparators) => {
				return (
					isSatisfiable(thisComparators, options) &&
					range.set.some((rangeComparators) => {
						return (
							isSatisfiable(rangeComparators, options) &&
							thisComparators.every((thisComparator) => {
								return rangeComparators.every((rangeComparator) => {
									return thisComparator.intersects(rangeComparator, options);
								});
							})
						);
					})
				);
			});
		}
		test(version) {
			if (!version) {
				return false;
			}
			if (typeof version === "string") {
				try {
					version = new SemVer(version, this.options);
				} catch (er) {
					return false;
				}
			}
			for (let i = 0; i < this.set.length; i++) {
				if (testSet(this.set[i], version, this.options)) {
					return true;
				}
			}
			return false;
		}
	}
	module.exports = Range;
	var LRU = require_lrucache();
	var cache = new LRU();
	var parseOptions = require_parse_options();
	var Comparator = require_comparator();
	var debug2 = require_debug2();
	var SemVer = require_semver();
	var {
		safeRe: re,
		t: t2,
		comparatorTrimReplace,
		tildeTrimReplace,
		caretTrimReplace,
	} = require_re();
	var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
	var isNullSet = (c) => c.value === "<0.0.0-0";
	var isAny = (c) => c.value === "";
	var isSatisfiable = (comparators, options) => {
		let result = true;
		const remainingComparators = comparators.slice();
		let testComparator = remainingComparators.pop();
		while (result && remainingComparators.length) {
			result = remainingComparators.every((otherComparator) => {
				return testComparator.intersects(otherComparator, options);
			});
			testComparator = remainingComparators.pop();
		}
		return result;
	};
	var parseComparator = (comp, options) => {
		comp = comp.replace(re[t2.BUILD], "");
		debug2("comp", comp, options);
		comp = replaceCarets(comp, options);
		debug2("caret", comp);
		comp = replaceTildes(comp, options);
		debug2("tildes", comp);
		comp = replaceXRanges(comp, options);
		debug2("xrange", comp);
		comp = replaceStars(comp, options);
		debug2("stars", comp);
		return comp;
	};
	var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
	var replaceTildes = (comp, options) => {
		return comp
			.trim()
			.split(/\s+/)
			.map((c) => replaceTilde(c, options))
			.join(" ");
	};
	var replaceTilde = (comp, options) => {
		const r2 = options.loose ? re[t2.TILDELOOSE] : re[t2.TILDE];
		return comp.replace(r2, (_2, M, m2, p, pr) => {
			debug2("tilde", comp, _2, M, m2, p, pr);
			let ret;
			if (isX(M)) {
				ret = "";
			} else if (isX(m2)) {
				ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
			} else if (isX(p)) {
				ret = `>=${M}.${m2}.0 <${M}.${+m2 + 1}.0-0`;
			} else if (pr) {
				debug2("replaceTilde pr", pr);
				ret = `>=${M}.${m2}.${p}-${pr} <${M}.${+m2 + 1}.0-0`;
			} else {
				ret = `>=${M}.${m2}.${p} <${M}.${+m2 + 1}.0-0`;
			}
			debug2("tilde return", ret);
			return ret;
		});
	};
	var replaceCarets = (comp, options) => {
		return comp
			.trim()
			.split(/\s+/)
			.map((c) => replaceCaret(c, options))
			.join(" ");
	};
	var replaceCaret = (comp, options) => {
		debug2("caret", comp, options);
		const r2 = options.loose ? re[t2.CARETLOOSE] : re[t2.CARET];
		const z = options.includePrerelease ? "-0" : "";
		return comp.replace(r2, (_2, M, m2, p, pr) => {
			debug2("caret", comp, _2, M, m2, p, pr);
			let ret;
			if (isX(M)) {
				ret = "";
			} else if (isX(m2)) {
				ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
			} else if (isX(p)) {
				if (M === "0") {
					ret = `>=${M}.${m2}.0${z} <${M}.${+m2 + 1}.0-0`;
				} else {
					ret = `>=${M}.${m2}.0${z} <${+M + 1}.0.0-0`;
				}
			} else if (pr) {
				debug2("replaceCaret pr", pr);
				if (M === "0") {
					if (m2 === "0") {
						ret = `>=${M}.${m2}.${p}-${pr} <${M}.${m2}.${+p + 1}-0`;
					} else {
						ret = `>=${M}.${m2}.${p}-${pr} <${M}.${+m2 + 1}.0-0`;
					}
				} else {
					ret = `>=${M}.${m2}.${p}-${pr} <${+M + 1}.0.0-0`;
				}
			} else {
				debug2("no pr");
				if (M === "0") {
					if (m2 === "0") {
						ret = `>=${M}.${m2}.${p}${z} <${M}.${m2}.${+p + 1}-0`;
					} else {
						ret = `>=${M}.${m2}.${p}${z} <${M}.${+m2 + 1}.0-0`;
					}
				} else {
					ret = `>=${M}.${m2}.${p} <${+M + 1}.0.0-0`;
				}
			}
			debug2("caret return", ret);
			return ret;
		});
	};
	var replaceXRanges = (comp, options) => {
		debug2("replaceXRanges", comp, options);
		return comp
			.split(/\s+/)
			.map((c) => replaceXRange(c, options))
			.join(" ");
	};
	var replaceXRange = (comp, options) => {
		comp = comp.trim();
		const r2 = options.loose ? re[t2.XRANGELOOSE] : re[t2.XRANGE];
		return comp.replace(r2, (ret, gtlt, M, m2, p, pr) => {
			debug2("xRange", comp, ret, gtlt, M, m2, p, pr);
			const xM = isX(M);
			const xm = xM || isX(m2);
			const xp = xm || isX(p);
			const anyX = xp;
			if (gtlt === "=" && anyX) {
				gtlt = "";
			}
			pr = options.includePrerelease ? "-0" : "";
			if (xM) {
				if (gtlt === ">" || gtlt === "<") {
					ret = "<0.0.0-0";
				} else {
					ret = "*";
				}
			} else if (gtlt && anyX) {
				if (xm) {
					m2 = 0;
				}
				p = 0;
				if (gtlt === ">") {
					gtlt = ">=";
					if (xm) {
						M = +M + 1;
						m2 = 0;
						p = 0;
					} else {
						m2 = +m2 + 1;
						p = 0;
					}
				} else if (gtlt === "<=") {
					gtlt = "<";
					if (xm) {
						M = +M + 1;
					} else {
						m2 = +m2 + 1;
					}
				}
				if (gtlt === "<") {
					pr = "-0";
				}
				ret = `${gtlt + M}.${m2}.${p}${pr}`;
			} else if (xm) {
				ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
			} else if (xp) {
				ret = `>=${M}.${m2}.0${pr} <${M}.${+m2 + 1}.0-0`;
			}
			debug2("xRange return", ret);
			return ret;
		});
	};
	var replaceStars = (comp, options) => {
		debug2("replaceStars", comp, options);
		return comp.trim().replace(re[t2.STAR], "");
	};
	var replaceGTE0 = (comp, options) => {
		debug2("replaceGTE0", comp, options);
		return comp.trim().replace(re[options.includePrerelease ? t2.GTE0PRE : t2.GTE0], "");
	};
	var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
		if (isX(fM)) {
			from = "";
		} else if (isX(fm)) {
			from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
		} else if (isX(fp)) {
			from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
		} else if (fpr) {
			from = `>=${from}`;
		} else {
			from = `>=${from}${incPr ? "-0" : ""}`;
		}
		if (isX(tM)) {
			to = "";
		} else if (isX(tm)) {
			to = `<${+tM + 1}.0.0-0`;
		} else if (isX(tp)) {
			to = `<${tM}.${+tm + 1}.0-0`;
		} else if (tpr) {
			to = `<=${tM}.${tm}.${tp}-${tpr}`;
		} else if (incPr) {
			to = `<${tM}.${tm}.${+tp + 1}-0`;
		} else {
			to = `<=${to}`;
		}
		return `${from} ${to}`.trim();
	};
	var testSet = (set2, version, options) => {
		for (let i = 0; i < set2.length; i++) {
			if (!set2[i].test(version)) {
				return false;
			}
		}
		if (version.prerelease.length && !options.includePrerelease) {
			for (let i = 0; i < set2.length; i++) {
				debug2(set2[i].semver);
				if (set2[i].semver === Comparator.ANY) {
					continue;
				}
				if (set2[i].semver.prerelease.length > 0) {
					const allowed = set2[i].semver;
					if (
						allowed.major === version.major &&
						allowed.minor === version.minor &&
						allowed.patch === version.patch
					) {
						return true;
					}
				}
			}
			return false;
		}
		return true;
	};
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS((exports, module) => {
	var ANY = Symbol("SemVer ANY");

	class Comparator {
		static get ANY() {
			return ANY;
		}
		constructor(comp, options) {
			options = parseOptions(options);
			if (comp instanceof Comparator) {
				if (comp.loose === !!options.loose) {
					return comp;
				} else {
					comp = comp.value;
				}
			}
			comp = comp.trim().split(/\s+/).join(" ");
			debug2("comparator", comp, options);
			this.options = options;
			this.loose = !!options.loose;
			this.parse(comp);
			if (this.semver === ANY) {
				this.value = "";
			} else {
				this.value = this.operator + this.semver.version;
			}
			debug2("comp", this);
		}
		parse(comp) {
			const r2 = this.options.loose ? re[t2.COMPARATORLOOSE] : re[t2.COMPARATOR];
			const m2 = comp.match(r2);
			if (!m2) {
				throw new TypeError(`Invalid comparator: ${comp}`);
			}
			this.operator = m2[1] !== undefined ? m2[1] : "";
			if (this.operator === "=") {
				this.operator = "";
			}
			if (!m2[2]) {
				this.semver = ANY;
			} else {
				this.semver = new SemVer(m2[2], this.options.loose);
			}
		}
		toString() {
			return this.value;
		}
		test(version) {
			debug2("Comparator.test", version, this.options.loose);
			if (this.semver === ANY || version === ANY) {
				return true;
			}
			if (typeof version === "string") {
				try {
					version = new SemVer(version, this.options);
				} catch (er) {
					return false;
				}
			}
			return cmp(version, this.operator, this.semver, this.options);
		}
		intersects(comp, options) {
			if (!(comp instanceof Comparator)) {
				throw new TypeError("a Comparator is required");
			}
			if (this.operator === "") {
				if (this.value === "") {
					return true;
				}
				return new Range(comp.value, options).test(this.value);
			} else if (comp.operator === "") {
				if (comp.value === "") {
					return true;
				}
				return new Range(this.value, options).test(comp.semver);
			}
			options = parseOptions(options);
			if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
				return false;
			}
			if (
				!options.includePrerelease &&
				(this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))
			) {
				return false;
			}
			if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
				return true;
			}
			if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
				return true;
			}
			if (
				this.semver.version === comp.semver.version &&
				this.operator.includes("=") &&
				comp.operator.includes("=")
			) {
				return true;
			}
			if (
				cmp(this.semver, "<", comp.semver, options) &&
				this.operator.startsWith(">") &&
				comp.operator.startsWith("<")
			) {
				return true;
			}
			if (
				cmp(this.semver, ">", comp.semver, options) &&
				this.operator.startsWith("<") &&
				comp.operator.startsWith(">")
			) {
				return true;
			}
			return false;
		}
	}
	module.exports = Comparator;
	var parseOptions = require_parse_options();
	var { safeRe: re, t: t2 } = require_re();
	var cmp = require_cmp();
	var debug2 = require_debug2();
	var SemVer = require_semver();
	var Range = require_range2();
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS((exports, module) => {
	var Range = require_range2();
	var satisfies = (version, range, options) => {
		try {
			range = new Range(range, options);
		} catch (er) {
			return false;
		}
		return range.test(version);
	};
	module.exports = satisfies;
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS((exports, module) => {
	var Range = require_range2();
	var toComparators = (range, options) =>
		new Range(range, options).set.map((comp) =>
			comp
				.map((c) => c.value)
				.join(" ")
				.trim()
				.split(" "),
		);
	module.exports = toComparators;
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS((exports, module) => {
	var SemVer = require_semver();
	var Range = require_range2();
	var maxSatisfying = (versions, range, options) => {
		let max = null;
		let maxSV = null;
		let rangeObj = null;
		try {
			rangeObj = new Range(range, options);
		} catch (er) {
			return null;
		}
		versions.forEach((v) => {
			if (rangeObj.test(v)) {
				if (!max || maxSV.compare(v) === -1) {
					max = v;
					maxSV = new SemVer(max, options);
				}
			}
		});
		return max;
	};
	module.exports = maxSatisfying;
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS((exports, module) => {
	var SemVer = require_semver();
	var Range = require_range2();
	var minSatisfying = (versions, range, options) => {
		let min = null;
		let minSV = null;
		let rangeObj = null;
		try {
			rangeObj = new Range(range, options);
		} catch (er) {
			return null;
		}
		versions.forEach((v) => {
			if (rangeObj.test(v)) {
				if (!min || minSV.compare(v) === 1) {
					min = v;
					minSV = new SemVer(min, options);
				}
			}
		});
		return min;
	};
	module.exports = minSatisfying;
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS((exports, module) => {
	var SemVer = require_semver();
	var Range = require_range2();
	var gt = require_gt();
	var minVersion = (range, loose) => {
		range = new Range(range, loose);
		let minver = new SemVer("0.0.0");
		if (range.test(minver)) {
			return minver;
		}
		minver = new SemVer("0.0.0-0");
		if (range.test(minver)) {
			return minver;
		}
		minver = null;
		for (let i = 0; i < range.set.length; ++i) {
			const comparators = range.set[i];
			let setMin = null;
			comparators.forEach((comparator) => {
				const compver = new SemVer(comparator.semver.version);
				switch (comparator.operator) {
					case ">":
						if (compver.prerelease.length === 0) {
							compver.patch++;
						} else {
							compver.prerelease.push(0);
						}
						compver.raw = compver.format();
					case "":
					case ">=":
						if (!setMin || gt(compver, setMin)) {
							setMin = compver;
						}
						break;
					case "<":
					case "<=":
						break;
					default:
						throw new Error(`Unexpected operation: ${comparator.operator}`);
				}
			});
			if (setMin && (!minver || gt(minver, setMin))) {
				minver = setMin;
			}
		}
		if (minver && range.test(minver)) {
			return minver;
		}
		return null;
	};
	module.exports = minVersion;
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS((exports, module) => {
	var Range = require_range2();
	var validRange = (range, options) => {
		try {
			return new Range(range, options).range || "*";
		} catch (er) {
			return null;
		}
	};
	module.exports = validRange;
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS((exports, module) => {
	var SemVer = require_semver();
	var Comparator = require_comparator();
	var { ANY } = Comparator;
	var Range = require_range2();
	var satisfies = require_satisfies();
	var gt = require_gt();
	var lt = require_lt();
	var lte = require_lte();
	var gte = require_gte();
	var outside = (version, range, hilo, options) => {
		version = new SemVer(version, options);
		range = new Range(range, options);
		let gtfn, ltefn, ltfn, comp, ecomp;
		switch (hilo) {
			case ">":
				gtfn = gt;
				ltefn = lte;
				ltfn = lt;
				comp = ">";
				ecomp = ">=";
				break;
			case "<":
				gtfn = lt;
				ltefn = gte;
				ltfn = gt;
				comp = "<";
				ecomp = "<=";
				break;
			default:
				throw new TypeError('Must provide a hilo val of "<" or ">"');
		}
		if (satisfies(version, range, options)) {
			return false;
		}
		for (let i = 0; i < range.set.length; ++i) {
			const comparators = range.set[i];
			let high = null;
			let low = null;
			comparators.forEach((comparator) => {
				if (comparator.semver === ANY) {
					comparator = new Comparator(">=0.0.0");
				}
				high = high || comparator;
				low = low || comparator;
				if (gtfn(comparator.semver, high.semver, options)) {
					high = comparator;
				} else if (ltfn(comparator.semver, low.semver, options)) {
					low = comparator;
				}
			});
			if (high.operator === comp || high.operator === ecomp) {
				return false;
			}
			if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
				return false;
			} else if (low.operator === ecomp && ltfn(version, low.semver)) {
				return false;
			}
		}
		return true;
	};
	module.exports = outside;
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS((exports, module) => {
	var outside = require_outside();
	var gtr = (version, range, options) => outside(version, range, ">", options);
	module.exports = gtr;
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS((exports, module) => {
	var outside = require_outside();
	var ltr = (version, range, options) => outside(version, range, "<", options);
	module.exports = ltr;
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS((exports, module) => {
	var Range = require_range2();
	var intersects = (r1, r2, options) => {
		r1 = new Range(r1, options);
		r2 = new Range(r2, options);
		return r1.intersects(r2, options);
	};
	module.exports = intersects;
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS((exports, module) => {
	var satisfies = require_satisfies();
	var compare = require_compare();
	module.exports = (versions, range, options) => {
		const set2 = [];
		let first = null;
		let prev = null;
		const v = versions.sort((a12, b) => compare(a12, b, options));
		for (const version of v) {
			const included = satisfies(version, range, options);
			if (included) {
				prev = version;
				if (!first) {
					first = version;
				}
			} else {
				if (prev) {
					set2.push([first, prev]);
				}
				prev = null;
				first = null;
			}
		}
		if (first) {
			set2.push([first, null]);
		}
		const ranges = [];
		for (const [min, max] of set2) {
			if (min === max) {
				ranges.push(min);
			} else if (!max && min === v[0]) {
				ranges.push("*");
			} else if (!max) {
				ranges.push(`>=${min}`);
			} else if (min === v[0]) {
				ranges.push(`<=${max}`);
			} else {
				ranges.push(`${min} - ${max}`);
			}
		}
		const simplified = ranges.join(" || ");
		const original = typeof range.raw === "string" ? range.raw : String(range);
		return simplified.length < original.length ? simplified : range;
	};
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS((exports, module) => {
	var Range = require_range2();
	var Comparator = require_comparator();
	var { ANY } = Comparator;
	var satisfies = require_satisfies();
	var compare = require_compare();
	var subset = (sub, dom, options = {}) => {
		if (sub === dom) {
			return true;
		}
		sub = new Range(sub, options);
		dom = new Range(dom, options);
		let sawNonNull = false;
		OUTER: for (const simpleSub of sub.set) {
			for (const simpleDom of dom.set) {
				const isSub = simpleSubset(simpleSub, simpleDom, options);
				sawNonNull = sawNonNull || isSub !== null;
				if (isSub) {
					continue OUTER;
				}
			}
			if (sawNonNull) {
				return false;
			}
		}
		return true;
	};
	var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
	var minimumVersion = [new Comparator(">=0.0.0")];
	var simpleSubset = (sub, dom, options) => {
		if (sub === dom) {
			return true;
		}
		if (sub.length === 1 && sub[0].semver === ANY) {
			if (dom.length === 1 && dom[0].semver === ANY) {
				return true;
			} else if (options.includePrerelease) {
				sub = minimumVersionWithPreRelease;
			} else {
				sub = minimumVersion;
			}
		}
		if (dom.length === 1 && dom[0].semver === ANY) {
			if (options.includePrerelease) {
				return true;
			} else {
				dom = minimumVersion;
			}
		}
		const eqSet = new Set();
		let gt, lt;
		for (const c of sub) {
			if (c.operator === ">" || c.operator === ">=") {
				gt = higherGT(gt, c, options);
			} else if (c.operator === "<" || c.operator === "<=") {
				lt = lowerLT(lt, c, options);
			} else {
				eqSet.add(c.semver);
			}
		}
		if (eqSet.size > 1) {
			return null;
		}
		let gtltComp;
		if (gt && lt) {
			gtltComp = compare(gt.semver, lt.semver, options);
			if (gtltComp > 0) {
				return null;
			} else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
				return null;
			}
		}
		for (const eq of eqSet) {
			if (gt && !satisfies(eq, String(gt), options)) {
				return null;
			}
			if (lt && !satisfies(eq, String(lt), options)) {
				return null;
			}
			for (const c of dom) {
				if (!satisfies(eq, String(c), options)) {
					return false;
				}
			}
			return true;
		}
		let higher, lower;
		let hasDomLT, hasDomGT;
		let needDomLTPre =
			lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
		let needDomGTPre =
			gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
		if (
			needDomLTPre &&
			needDomLTPre.prerelease.length === 1 &&
			lt.operator === "<" &&
			needDomLTPre.prerelease[0] === 0
		) {
			needDomLTPre = false;
		}
		for (const c of dom) {
			hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
			hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
			if (gt) {
				if (needDomGTPre) {
					if (
						c.semver.prerelease &&
						c.semver.prerelease.length &&
						c.semver.major === needDomGTPre.major &&
						c.semver.minor === needDomGTPre.minor &&
						c.semver.patch === needDomGTPre.patch
					) {
						needDomGTPre = false;
					}
				}
				if (c.operator === ">" || c.operator === ">=") {
					higher = higherGT(gt, c, options);
					if (higher === c && higher !== gt) {
						return false;
					}
				} else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
					return false;
				}
			}
			if (lt) {
				if (needDomLTPre) {
					if (
						c.semver.prerelease &&
						c.semver.prerelease.length &&
						c.semver.major === needDomLTPre.major &&
						c.semver.minor === needDomLTPre.minor &&
						c.semver.patch === needDomLTPre.patch
					) {
						needDomLTPre = false;
					}
				}
				if (c.operator === "<" || c.operator === "<=") {
					lower = lowerLT(lt, c, options);
					if (lower === c && lower !== lt) {
						return false;
					}
				} else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
					return false;
				}
			}
			if (!c.operator && (lt || gt) && gtltComp !== 0) {
				return false;
			}
		}
		if (gt && hasDomLT && !lt && gtltComp !== 0) {
			return false;
		}
		if (lt && hasDomGT && !gt && gtltComp !== 0) {
			return false;
		}
		if (needDomGTPre || needDomLTPre) {
			return false;
		}
		return true;
	};
	var higherGT = (a12, b, options) => {
		if (!a12) {
			return b;
		}
		const comp = compare(a12.semver, b.semver, options);
		return comp > 0 ? a12 : comp < 0 ? b : b.operator === ">" && a12.operator === ">=" ? b : a12;
	};
	var lowerLT = (a12, b, options) => {
		if (!a12) {
			return b;
		}
		const comp = compare(a12.semver, b.semver, options);
		return comp < 0 ? a12 : comp > 0 ? b : b.operator === "<" && a12.operator === "<=" ? b : a12;
	};
	module.exports = subset;
});

// node_modules/semver/index.js
var require_semver2 = __commonJS((exports, module) => {
	var internalRe = require_re();
	var constants = require_constants();
	var SemVer = require_semver();
	var identifiers = require_identifiers();
	var parse2 = require_parse();
	var valid = require_valid();
	var clean2 = require_clean();
	var inc = require_inc();
	var diff = require_diff();
	var major = require_major();
	var minor = require_minor();
	var patch = require_patch();
	var prerelease = require_prerelease();
	var compare = require_compare();
	var rcompare = require_rcompare();
	var compareLoose = require_compare_loose();
	var compareBuild = require_compare_build();
	var sort = require_sort();
	var rsort = require_rsort();
	var gt = require_gt();
	var lt = require_lt();
	var eq = require_eq();
	var neq = require_neq();
	var gte = require_gte();
	var lte = require_lte();
	var cmp = require_cmp();
	var coerce2 = require_coerce();
	var Comparator = require_comparator();
	var Range = require_range2();
	var satisfies = require_satisfies();
	var toComparators = require_to_comparators();
	var maxSatisfying = require_max_satisfying();
	var minSatisfying = require_min_satisfying();
	var minVersion = require_min_version();
	var validRange = require_valid2();
	var outside = require_outside();
	var gtr = require_gtr();
	var ltr = require_ltr();
	var intersects = require_intersects();
	var simplifyRange = require_simplify();
	var subset = require_subset();
	module.exports = {
		parse: parse2,
		valid,
		clean: clean2,
		inc,
		diff,
		major,
		minor,
		patch,
		prerelease,
		compare,
		rcompare,
		compareLoose,
		compareBuild,
		sort,
		rsort,
		gt,
		lt,
		eq,
		neq,
		gte,
		lte,
		cmp,
		coerce: coerce2,
		Comparator,
		Range,
		satisfies,
		toComparators,
		maxSatisfying,
		minSatisfying,
		minVersion,
		validRange,
		outside,
		gtr,
		ltr,
		intersects,
		simplifyRange,
		subset,
		SemVer,
		re: internalRe.re,
		src: internalRe.src,
		tokens: internalRe.t,
		SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
		RELEASE_TYPES: constants.RELEASE_TYPES,
		compareIdentifiers: identifiers.compareIdentifiers,
		rcompareIdentifiers: identifiers.rcompareIdentifiers,
	};
});

// node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js
var require_asymmetricKeyDetailsSupported = __commonJS((exports, module) => {
	var semver = require_semver2();
	module.exports = semver.satisfies(process.version, ">=15.7.0");
});

// node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js
var require_rsaPssKeyDetailsSupported = __commonJS((exports, module) => {
	var semver = require_semver2();
	module.exports = semver.satisfies(process.version, ">=16.9.0");
});

// node_modules/jsonwebtoken/lib/validateAsymmetricKey.js
var require_validateAsymmetricKey = __commonJS((exports, module) => {
	var ASYMMETRIC_KEY_DETAILS_SUPPORTED = require_asymmetricKeyDetailsSupported();
	var RSA_PSS_KEY_DETAILS_SUPPORTED = require_rsaPssKeyDetailsSupported();
	var allowedAlgorithmsForKeys = {
		ec: ["ES256", "ES384", "ES512"],
		rsa: ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"],
		"rsa-pss": ["PS256", "PS384", "PS512"],
	};
	var allowedCurves = {
		ES256: "prime256v1",
		ES384: "secp384r1",
		ES512: "secp521r1",
	};
	module.exports = function (algorithm, key) {
		if (!algorithm || !key) return;
		const keyType = key.asymmetricKeyType;
		if (!keyType) return;
		const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
		if (!allowedAlgorithms) {
			throw new Error(`Unknown key type "${keyType}".`);
		}
		if (!allowedAlgorithms.includes(algorithm)) {
			throw new Error(
				`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(", ")}.`,
			);
		}
		if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
			switch (keyType) {
				case "ec":
					const keyCurve = key.asymmetricKeyDetails.namedCurve;
					const allowedCurve = allowedCurves[algorithm];
					if (keyCurve !== allowedCurve) {
						throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
					}
					break;
				case "rsa-pss":
					if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
						const length = parseInt(algorithm.slice(-3), 10);
						const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
						if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
							throw new Error(
								`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`,
							);
						}
						if (saltLength !== undefined && saltLength > length >> 3) {
							throw new Error(
								`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`,
							);
						}
					}
					break;
			}
		}
	};
});

// node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS((exports, module) => {
	var semver = require_semver2();
	module.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
});

// node_modules/jsonwebtoken/verify.js
var require_verify = __commonJS((exports, module) => {
	var JsonWebTokenError = require_JsonWebTokenError();
	var NotBeforeError = require_NotBeforeError();
	var TokenExpiredError = require_TokenExpiredError();
	var decode2 = require_decode();
	var timespan = require_timespan();
	var validateAsymmetricKey = require_validateAsymmetricKey();
	var PS_SUPPORTED = require_psSupported();
	var jws = require_jws();
	var { KeyObject, createSecretKey, createPublicKey } = __require("crypto");
	var PUB_KEY_ALGS = ["RS256", "RS384", "RS512"];
	var EC_KEY_ALGS = ["ES256", "ES384", "ES512"];
	var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
	var HS_ALGS = ["HS256", "HS384", "HS512"];
	if (PS_SUPPORTED) {
		PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
		RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
	}
	module.exports = function (jwtString, secretOrPublicKey, options, callback) {
		if (typeof options === "function" && !callback) {
			callback = options;
			options = {};
		}
		if (!options) {
			options = {};
		}
		options = Object.assign({}, options);
		let done;
		if (callback) {
			done = callback;
		} else {
			done = function (err, data) {
				if (err) throw err;
				return data;
			};
		}
		if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
			return done(new JsonWebTokenError("clockTimestamp must be a number"));
		}
		if (
			options.nonce !== undefined &&
			(typeof options.nonce !== "string" || options.nonce.trim() === "")
		) {
			return done(new JsonWebTokenError("nonce must be a non-empty string"));
		}
		if (
			options.allowInvalidAsymmetricKeyTypes !== undefined &&
			typeof options.allowInvalidAsymmetricKeyTypes !== "boolean"
		) {
			return done(new JsonWebTokenError("allowInvalidAsymmetricKeyTypes must be a boolean"));
		}
		const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);
		if (!jwtString) {
			return done(new JsonWebTokenError("jwt must be provided"));
		}
		if (typeof jwtString !== "string") {
			return done(new JsonWebTokenError("jwt must be a string"));
		}
		const parts = jwtString.split(".");
		if (parts.length !== 3) {
			return done(new JsonWebTokenError("jwt malformed"));
		}
		let decodedToken;
		try {
			decodedToken = decode2(jwtString, { complete: true });
		} catch (err) {
			return done(err);
		}
		if (!decodedToken) {
			return done(new JsonWebTokenError("invalid token"));
		}
		const header = decodedToken.header;
		let getSecret;
		if (typeof secretOrPublicKey === "function") {
			if (!callback) {
				return done(
					new JsonWebTokenError(
						"verify must be called asynchronous if secret or public key is provided as a callback",
					),
				);
			}
			getSecret = secretOrPublicKey;
		} else {
			getSecret = function (header2, secretCallback) {
				return secretCallback(null, secretOrPublicKey);
			};
		}
		return getSecret(header, function (err, secretOrPublicKey2) {
			if (err) {
				return done(
					new JsonWebTokenError("error in secret or public key callback: " + err.message),
				);
			}
			const hasSignature = parts[2].trim() !== "";
			if (!hasSignature && secretOrPublicKey2) {
				return done(new JsonWebTokenError("jwt signature is required"));
			}
			if (hasSignature && !secretOrPublicKey2) {
				return done(new JsonWebTokenError("secret or public key must be provided"));
			}
			if (!hasSignature && !options.algorithms) {
				return done(
					new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'),
				);
			}
			if (secretOrPublicKey2 != null && !(secretOrPublicKey2 instanceof KeyObject)) {
				try {
					secretOrPublicKey2 = createPublicKey(secretOrPublicKey2);
				} catch (_2) {
					try {
						secretOrPublicKey2 = createSecretKey(
							typeof secretOrPublicKey2 === "string"
								? Buffer.from(secretOrPublicKey2)
								: secretOrPublicKey2,
						);
					} catch (_3) {
						return done(new JsonWebTokenError("secretOrPublicKey is not valid key material"));
					}
				}
			}
			if (!options.algorithms) {
				if (secretOrPublicKey2.type === "secret") {
					options.algorithms = HS_ALGS;
				} else if (["rsa", "rsa-pss"].includes(secretOrPublicKey2.asymmetricKeyType)) {
					options.algorithms = RSA_KEY_ALGS;
				} else if (secretOrPublicKey2.asymmetricKeyType === "ec") {
					options.algorithms = EC_KEY_ALGS;
				} else {
					options.algorithms = PUB_KEY_ALGS;
				}
			}
			if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
				return done(new JsonWebTokenError("invalid algorithm"));
			}
			if (header.alg.startsWith("HS") && secretOrPublicKey2.type !== "secret") {
				return done(
					new JsonWebTokenError(
						`secretOrPublicKey must be a symmetric key when using ${header.alg}`,
					),
				);
			} else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey2.type !== "public") {
				return done(
					new JsonWebTokenError(
						`secretOrPublicKey must be an asymmetric key when using ${header.alg}`,
					),
				);
			}
			if (!options.allowInvalidAsymmetricKeyTypes) {
				try {
					validateAsymmetricKey(header.alg, secretOrPublicKey2);
				} catch (e) {
					return done(e);
				}
			}
			let valid;
			try {
				valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
			} catch (e) {
				return done(e);
			}
			if (!valid) {
				return done(new JsonWebTokenError("invalid signature"));
			}
			const payload = decodedToken.payload;
			if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
				if (typeof payload.nbf !== "number") {
					return done(new JsonWebTokenError("invalid nbf value"));
				}
				if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
					return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1000)));
				}
			}
			if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
				if (typeof payload.exp !== "number") {
					return done(new JsonWebTokenError("invalid exp value"));
				}
				if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
					return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1000)));
				}
			}
			if (options.audience) {
				const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
				const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
				const match = target.some(function (targetAudience) {
					return audiences.some(function (audience) {
						return audience instanceof RegExp
							? audience.test(targetAudience)
							: audience === targetAudience;
					});
				});
				if (!match) {
					return done(
						new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")),
					);
				}
			}
			if (options.issuer) {
				const invalid_issuer =
					(typeof options.issuer === "string" && payload.iss !== options.issuer) ||
					(Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1);
				if (invalid_issuer) {
					return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
				}
			}
			if (options.subject) {
				if (payload.sub !== options.subject) {
					return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
				}
			}
			if (options.jwtid) {
				if (payload.jti !== options.jwtid) {
					return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
				}
			}
			if (options.nonce) {
				if (payload.nonce !== options.nonce) {
					return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
				}
			}
			if (options.maxAge) {
				if (typeof payload.iat !== "number") {
					return done(new JsonWebTokenError("iat required when maxAge is specified"));
				}
				const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
				if (typeof maxAgeTimestamp === "undefined") {
					return done(
						new JsonWebTokenError(
							'"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60',
						),
					);
				}
				if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
					return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1000)));
				}
			}
			if (options.complete === true) {
				const signature = decodedToken.signature;
				return done(null, {
					header,
					payload,
					signature,
				});
			}
			return done(null, payload);
		});
	};
});

// node_modules/lodash.includes/index.js
var require_lodash = __commonJS((exports, module) => {
	var INFINITY = 1 / 0;
	var MAX_SAFE_INTEGER = 9007199254740991;
	var MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
	var NAN = 0 / 0;
	var argsTag = "[object Arguments]";
	var funcTag = "[object Function]";
	var genTag = "[object GeneratorFunction]";
	var stringTag = "[object String]";
	var symbolTag = "[object Symbol]";
	var reTrim = /^\s+|\s+$/g;
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
	var reIsBinary = /^0b[01]+$/i;
	var reIsOctal = /^0o[0-7]+$/i;
	var reIsUint = /^(?:0|[1-9]\d*)$/;
	var freeParseInt = parseInt;
	function arrayMap(array, iteratee) {
		var index = -1,
			length = array ? array.length : 0,
			result = Array(length);
		while (++index < length) {
			result[index] = iteratee(array[index], index, array);
		}
		return result;
	}
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
		var length = array.length,
			index = fromIndex + (fromRight ? 1 : -1);
		while (fromRight ? index-- : ++index < length) {
			if (predicate(array[index], index, array)) {
				return index;
			}
		}
		return -1;
	}
	function baseIndexOf(array, value, fromIndex) {
		if (value !== value) {
			return baseFindIndex(array, baseIsNaN, fromIndex);
		}
		var index = fromIndex - 1,
			length = array.length;
		while (++index < length) {
			if (array[index] === value) {
				return index;
			}
		}
		return -1;
	}
	function baseIsNaN(value) {
		return value !== value;
	}
	function baseTimes(n2, iteratee) {
		var index = -1,
			result = Array(n2);
		while (++index < n2) {
			result[index] = iteratee(index);
		}
		return result;
	}
	function baseValues(object, props) {
		return arrayMap(props, function (key) {
			return object[key];
		});
	}
	function overArg(func, transform2) {
		return function (arg) {
			return func(transform2(arg));
		};
	}
	var objectProto = Object.prototype;
	var hasOwnProperty2 = objectProto.hasOwnProperty;
	var objectToString = objectProto.toString;
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;
	var nativeKeys = overArg(Object.keys, Object);
	var nativeMax = Math.max;
	function arrayLikeKeys(value, inherited) {
		var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
		var length = result.length,
			skipIndexes = !!length;
		for (var key in value) {
			if (
				(inherited || hasOwnProperty2.call(value, key)) &&
				!(skipIndexes && (key == "length" || isIndex(key, length)))
			) {
				result.push(key);
			}
		}
		return result;
	}
	function baseKeys(object) {
		if (!isPrototype(object)) {
			return nativeKeys(object);
		}
		var result = [];
		for (var key in Object(object)) {
			if (hasOwnProperty2.call(object, key) && key != "constructor") {
				result.push(key);
			}
		}
		return result;
	}
	function isIndex(value, length) {
		length = length == null ? MAX_SAFE_INTEGER : length;
		return (
			!!length &&
			(typeof value == "number" || reIsUint.test(value)) &&
			value > -1 &&
			value % 1 == 0 &&
			value < length
		);
	}
	function isPrototype(value) {
		var Ctor = value && value.constructor,
			proto = (typeof Ctor == "function" && Ctor.prototype) || objectProto;
		return value === proto;
	}
	function includes(collection, value, fromIndex, guard2) {
		collection = isArrayLike(collection) ? collection : values(collection);
		fromIndex = fromIndex && !guard2 ? toInteger(fromIndex) : 0;
		var length = collection.length;
		if (fromIndex < 0) {
			fromIndex = nativeMax(length + fromIndex, 0);
		}
		return isString2(collection)
			? fromIndex <= length && collection.indexOf(value, fromIndex) > -1
			: !!length && baseIndexOf(collection, value, fromIndex) > -1;
	}
	function isArguments(value) {
		return (
			isArrayLikeObject(value) &&
			hasOwnProperty2.call(value, "callee") &&
			(!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag)
		);
	}
	var isArray2 = Array.isArray;
	function isArrayLike(value) {
		return value != null && isLength(value.length) && !isFunction3(value);
	}
	function isArrayLikeObject(value) {
		return isObjectLike(value) && isArrayLike(value);
	}
	function isFunction3(value) {
		var tag = isObject3(value) ? objectToString.call(value) : "";
		return tag == funcTag || tag == genTag;
	}
	function isLength(value) {
		return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	function isObject3(value) {
		var type = typeof value;
		return !!value && (type == "object" || type == "function");
	}
	function isObjectLike(value) {
		return !!value && typeof value == "object";
	}
	function isString2(value) {
		return (
			typeof value == "string" ||
			(!isArray2(value) && isObjectLike(value) && objectToString.call(value) == stringTag)
		);
	}
	function isSymbol(value) {
		return (
			typeof value == "symbol" || (isObjectLike(value) && objectToString.call(value) == symbolTag)
		);
	}
	function toFinite(value) {
		if (!value) {
			return value === 0 ? value : 0;
		}
		value = toNumber(value);
		if (value === INFINITY || value === -INFINITY) {
			var sign = value < 0 ? -1 : 1;
			return sign * MAX_INTEGER;
		}
		return value === value ? value : 0;
	}
	function toInteger(value) {
		var result = toFinite(value),
			remainder = result % 1;
		return result === result ? (remainder ? result - remainder : result) : 0;
	}
	function toNumber(value) {
		if (typeof value == "number") {
			return value;
		}
		if (isSymbol(value)) {
			return NAN;
		}
		if (isObject3(value)) {
			var other = typeof value.valueOf == "function" ? value.valueOf() : value;
			value = isObject3(other) ? other + "" : other;
		}
		if (typeof value != "string") {
			return value === 0 ? value : +value;
		}
		value = value.replace(reTrim, "");
		var isBinary = reIsBinary.test(value);
		return isBinary || reIsOctal.test(value)
			? freeParseInt(value.slice(2), isBinary ? 2 : 8)
			: reIsBadHex.test(value)
				? NAN
				: +value;
	}
	function keys(object) {
		return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}
	function values(object) {
		return object ? baseValues(object, keys(object)) : [];
	}
	module.exports = includes;
});

// node_modules/lodash.isboolean/index.js
var require_lodash2 = __commonJS((exports, module) => {
	var boolTag = "[object Boolean]";
	var objectProto = Object.prototype;
	var objectToString = objectProto.toString;
	function isBoolean2(value) {
		return (
			value === true ||
			value === false ||
			(isObjectLike(value) && objectToString.call(value) == boolTag)
		);
	}
	function isObjectLike(value) {
		return !!value && typeof value == "object";
	}
	module.exports = isBoolean2;
});

// node_modules/lodash.isinteger/index.js
var require_lodash3 = __commonJS((exports, module) => {
	var INFINITY = 1 / 0;
	var MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
	var NAN = 0 / 0;
	var symbolTag = "[object Symbol]";
	var reTrim = /^\s+|\s+$/g;
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
	var reIsBinary = /^0b[01]+$/i;
	var reIsOctal = /^0o[0-7]+$/i;
	var freeParseInt = parseInt;
	var objectProto = Object.prototype;
	var objectToString = objectProto.toString;
	function isInteger(value) {
		return typeof value == "number" && value == toInteger(value);
	}
	function isObject3(value) {
		var type = typeof value;
		return !!value && (type == "object" || type == "function");
	}
	function isObjectLike(value) {
		return !!value && typeof value == "object";
	}
	function isSymbol(value) {
		return (
			typeof value == "symbol" || (isObjectLike(value) && objectToString.call(value) == symbolTag)
		);
	}
	function toFinite(value) {
		if (!value) {
			return value === 0 ? value : 0;
		}
		value = toNumber(value);
		if (value === INFINITY || value === -INFINITY) {
			var sign = value < 0 ? -1 : 1;
			return sign * MAX_INTEGER;
		}
		return value === value ? value : 0;
	}
	function toInteger(value) {
		var result = toFinite(value),
			remainder = result % 1;
		return result === result ? (remainder ? result - remainder : result) : 0;
	}
	function toNumber(value) {
		if (typeof value == "number") {
			return value;
		}
		if (isSymbol(value)) {
			return NAN;
		}
		if (isObject3(value)) {
			var other = typeof value.valueOf == "function" ? value.valueOf() : value;
			value = isObject3(other) ? other + "" : other;
		}
		if (typeof value != "string") {
			return value === 0 ? value : +value;
		}
		value = value.replace(reTrim, "");
		var isBinary = reIsBinary.test(value);
		return isBinary || reIsOctal.test(value)
			? freeParseInt(value.slice(2), isBinary ? 2 : 8)
			: reIsBadHex.test(value)
				? NAN
				: +value;
	}
	module.exports = isInteger;
});

// node_modules/lodash.isnumber/index.js
var require_lodash4 = __commonJS((exports, module) => {
	var numberTag = "[object Number]";
	var objectProto = Object.prototype;
	var objectToString = objectProto.toString;
	function isObjectLike(value) {
		return !!value && typeof value == "object";
	}
	function isNumber2(value) {
		return (
			typeof value == "number" || (isObjectLike(value) && objectToString.call(value) == numberTag)
		);
	}
	module.exports = isNumber2;
});

// node_modules/lodash.isplainobject/index.js
var require_lodash5 = __commonJS((exports, module) => {
	var objectTag = "[object Object]";
	function isHostObject(value) {
		var result = false;
		if (value != null && typeof value.toString != "function") {
			try {
				result = !!(value + "");
			} catch (e) {}
		}
		return result;
	}
	function overArg(func, transform2) {
		return function (arg) {
			return func(transform2(arg));
		};
	}
	var funcProto = Function.prototype;
	var objectProto = Object.prototype;
	var funcToString = funcProto.toString;
	var hasOwnProperty2 = objectProto.hasOwnProperty;
	var objectCtorString = funcToString.call(Object);
	var objectToString = objectProto.toString;
	var getPrototype = overArg(Object.getPrototypeOf, Object);
	function isObjectLike(value) {
		return !!value && typeof value == "object";
	}
	function isPlainObject2(value) {
		if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
			return false;
		}
		var proto = getPrototype(value);
		if (proto === null) {
			return true;
		}
		var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
		return (
			typeof Ctor == "function" &&
			Ctor instanceof Ctor &&
			funcToString.call(Ctor) == objectCtorString
		);
	}
	module.exports = isPlainObject2;
});

// node_modules/lodash.isstring/index.js
var require_lodash6 = __commonJS((exports, module) => {
	var stringTag = "[object String]";
	var objectProto = Object.prototype;
	var objectToString = objectProto.toString;
	var isArray2 = Array.isArray;
	function isObjectLike(value) {
		return !!value && typeof value == "object";
	}
	function isString2(value) {
		return (
			typeof value == "string" ||
			(!isArray2(value) && isObjectLike(value) && objectToString.call(value) == stringTag)
		);
	}
	module.exports = isString2;
});

// node_modules/lodash.once/index.js
var require_lodash7 = __commonJS((exports, module) => {
	var FUNC_ERROR_TEXT = "Expected a function";
	var INFINITY = 1 / 0;
	var MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
	var NAN = 0 / 0;
	var symbolTag = "[object Symbol]";
	var reTrim = /^\s+|\s+$/g;
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
	var reIsBinary = /^0b[01]+$/i;
	var reIsOctal = /^0o[0-7]+$/i;
	var freeParseInt = parseInt;
	var objectProto = Object.prototype;
	var objectToString = objectProto.toString;
	function before(n2, func) {
		var result;
		if (typeof func != "function") {
			throw new TypeError(FUNC_ERROR_TEXT);
		}
		n2 = toInteger(n2);
		return function () {
			if (--n2 > 0) {
				result = func.apply(this, arguments);
			}
			if (n2 <= 1) {
				func = undefined;
			}
			return result;
		};
	}
	function once(func) {
		return before(2, func);
	}
	function isObject3(value) {
		var type = typeof value;
		return !!value && (type == "object" || type == "function");
	}
	function isObjectLike(value) {
		return !!value && typeof value == "object";
	}
	function isSymbol(value) {
		return (
			typeof value == "symbol" || (isObjectLike(value) && objectToString.call(value) == symbolTag)
		);
	}
	function toFinite(value) {
		if (!value) {
			return value === 0 ? value : 0;
		}
		value = toNumber(value);
		if (value === INFINITY || value === -INFINITY) {
			var sign = value < 0 ? -1 : 1;
			return sign * MAX_INTEGER;
		}
		return value === value ? value : 0;
	}
	function toInteger(value) {
		var result = toFinite(value),
			remainder = result % 1;
		return result === result ? (remainder ? result - remainder : result) : 0;
	}
	function toNumber(value) {
		if (typeof value == "number") {
			return value;
		}
		if (isSymbol(value)) {
			return NAN;
		}
		if (isObject3(value)) {
			var other = typeof value.valueOf == "function" ? value.valueOf() : value;
			value = isObject3(other) ? other + "" : other;
		}
		if (typeof value != "string") {
			return value === 0 ? value : +value;
		}
		value = value.replace(reTrim, "");
		var isBinary = reIsBinary.test(value);
		return isBinary || reIsOctal.test(value)
			? freeParseInt(value.slice(2), isBinary ? 2 : 8)
			: reIsBadHex.test(value)
				? NAN
				: +value;
	}
	module.exports = once;
});

// node_modules/jsonwebtoken/sign.js
var require_sign2 = __commonJS((exports, module) => {
	var timespan = require_timespan();
	var PS_SUPPORTED = require_psSupported();
	var validateAsymmetricKey = require_validateAsymmetricKey();
	var jws = require_jws();
	var includes = require_lodash();
	var isBoolean2 = require_lodash2();
	var isInteger = require_lodash3();
	var isNumber2 = require_lodash4();
	var isPlainObject2 = require_lodash5();
	var isString2 = require_lodash6();
	var once = require_lodash7();
	var { KeyObject, createSecretKey, createPrivateKey } = __require("crypto");
	var SUPPORTED_ALGS = [
		"RS256",
		"RS384",
		"RS512",
		"ES256",
		"ES384",
		"ES512",
		"HS256",
		"HS384",
		"HS512",
		"none",
	];
	if (PS_SUPPORTED) {
		SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
	}
	var sign_options_schema = {
		expiresIn: {
			isValid: function (value) {
				return isInteger(value) || (isString2(value) && value);
			},
			message: '"expiresIn" should be a number of seconds or string representing a timespan',
		},
		notBefore: {
			isValid: function (value) {
				return isInteger(value) || (isString2(value) && value);
			},
			message: '"notBefore" should be a number of seconds or string representing a timespan',
		},
		audience: {
			isValid: function (value) {
				return isString2(value) || Array.isArray(value);
			},
			message: '"audience" must be a string or array',
		},
		algorithm: {
			isValid: includes.bind(null, SUPPORTED_ALGS),
			message: '"algorithm" must be a valid string enum value',
		},
		header: { isValid: isPlainObject2, message: '"header" must be an object' },
		encoding: { isValid: isString2, message: '"encoding" must be a string' },
		issuer: { isValid: isString2, message: '"issuer" must be a string' },
		subject: { isValid: isString2, message: '"subject" must be a string' },
		jwtid: { isValid: isString2, message: '"jwtid" must be a string' },
		noTimestamp: { isValid: isBoolean2, message: '"noTimestamp" must be a boolean' },
		keyid: { isValid: isString2, message: '"keyid" must be a string' },
		mutatePayload: { isValid: isBoolean2, message: '"mutatePayload" must be a boolean' },
		allowInsecureKeySizes: {
			isValid: isBoolean2,
			message: '"allowInsecureKeySizes" must be a boolean',
		},
		allowInvalidAsymmetricKeyTypes: {
			isValid: isBoolean2,
			message: '"allowInvalidAsymmetricKeyTypes" must be a boolean',
		},
	};
	var registered_claims_schema = {
		iat: { isValid: isNumber2, message: '"iat" should be a number of seconds' },
		exp: { isValid: isNumber2, message: '"exp" should be a number of seconds' },
		nbf: { isValid: isNumber2, message: '"nbf" should be a number of seconds' },
	};
	function validate(schema, allowUnknown, object, parameterName) {
		if (!isPlainObject2(object)) {
			throw new Error('Expected "' + parameterName + '" to be a plain object.');
		}
		Object.keys(object).forEach(function (key) {
			const validator = schema[key];
			if (!validator) {
				if (!allowUnknown) {
					throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
				}
				return;
			}
			if (!validator.isValid(object[key])) {
				throw new Error(validator.message);
			}
		});
	}
	function validateOptions(options) {
		return validate(sign_options_schema, false, options, "options");
	}
	function validatePayload(payload) {
		return validate(registered_claims_schema, true, payload, "payload");
	}
	var options_to_payload = {
		audience: "aud",
		issuer: "iss",
		subject: "sub",
		jwtid: "jti",
	};
	var options_for_objects = [
		"expiresIn",
		"notBefore",
		"noTimestamp",
		"audience",
		"issuer",
		"subject",
		"jwtid",
	];
	module.exports = function (payload, secretOrPrivateKey, options, callback) {
		if (typeof options === "function") {
			callback = options;
			options = {};
		} else {
			options = options || {};
		}
		const isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
		const header = Object.assign(
			{
				alg: options.algorithm || "HS256",
				typ: isObjectPayload ? "JWT" : undefined,
				kid: options.keyid,
			},
			options.header,
		);
		function failure(err) {
			if (callback) {
				return callback(err);
			}
			throw err;
		}
		if (!secretOrPrivateKey && options.algorithm !== "none") {
			return failure(new Error("secretOrPrivateKey must have a value"));
		}
		if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {
			try {
				secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);
			} catch (_2) {
				try {
					secretOrPrivateKey = createSecretKey(
						typeof secretOrPrivateKey === "string"
							? Buffer.from(secretOrPrivateKey)
							: secretOrPrivateKey,
					);
				} catch (_3) {
					return failure(new Error("secretOrPrivateKey is not valid key material"));
				}
			}
		}
		if (header.alg.startsWith("HS") && secretOrPrivateKey.type !== "secret") {
			return failure(
				new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`),
			);
		} else if (/^(?:RS|PS|ES)/.test(header.alg)) {
			if (secretOrPrivateKey.type !== "private") {
				return failure(
					new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`),
				);
			}
			if (
				!options.allowInsecureKeySizes &&
				!header.alg.startsWith("ES") &&
				secretOrPrivateKey.asymmetricKeyDetails !== undefined &&
				secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048
			) {
				return failure(
					new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`),
				);
			}
		}
		if (typeof payload === "undefined") {
			return failure(new Error("payload is required"));
		} else if (isObjectPayload) {
			try {
				validatePayload(payload);
			} catch (error) {
				return failure(error);
			}
			if (!options.mutatePayload) {
				payload = Object.assign({}, payload);
			}
		} else {
			const invalid_options = options_for_objects.filter(function (opt) {
				return typeof options[opt] !== "undefined";
			});
			if (invalid_options.length > 0) {
				return failure(
					new Error(
						"invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload",
					),
				);
			}
		}
		if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
			return failure(
				new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'),
			);
		}
		if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
			return failure(
				new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'),
			);
		}
		try {
			validateOptions(options);
		} catch (error) {
			return failure(error);
		}
		if (!options.allowInvalidAsymmetricKeyTypes) {
			try {
				validateAsymmetricKey(header.alg, secretOrPrivateKey);
			} catch (error) {
				return failure(error);
			}
		}
		const timestamp = payload.iat || Math.floor(Date.now() / 1000);
		if (options.noTimestamp) {
			delete payload.iat;
		} else if (isObjectPayload) {
			payload.iat = timestamp;
		}
		if (typeof options.notBefore !== "undefined") {
			try {
				payload.nbf = timespan(options.notBefore, timestamp);
			} catch (err) {
				return failure(err);
			}
			if (typeof payload.nbf === "undefined") {
				return failure(
					new Error(
						'"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60',
					),
				);
			}
		}
		if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
			try {
				payload.exp = timespan(options.expiresIn, timestamp);
			} catch (err) {
				return failure(err);
			}
			if (typeof payload.exp === "undefined") {
				return failure(
					new Error(
						'"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60',
					),
				);
			}
		}
		Object.keys(options_to_payload).forEach(function (key) {
			const claim = options_to_payload[key];
			if (typeof options[key] !== "undefined") {
				if (typeof payload[claim] !== "undefined") {
					return failure(
						new Error(
							'Bad "options.' +
								key +
								'" option. The payload already has an "' +
								claim +
								'" property.',
						),
					);
				}
				payload[claim] = options[key];
			}
		});
		const encoding = options.encoding || "utf8";
		if (typeof callback === "function") {
			callback = callback && once(callback);
			jws
				.createSign({
					header,
					privateKey: secretOrPrivateKey,
					payload,
					encoding,
				})
				.once("error", callback)
				.once("done", function (signature) {
					if (
						!options.allowInsecureKeySizes &&
						/^(?:RS|PS)/.test(header.alg) &&
						signature.length < 256
					) {
						return callback(
							new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`),
						);
					}
					callback(null, signature);
				});
		} else {
			let signature = jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
			if (
				!options.allowInsecureKeySizes &&
				/^(?:RS|PS)/.test(header.alg) &&
				signature.length < 256
			) {
				throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);
			}
			return signature;
		}
	};
});

// node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS((exports, module) => {
	module.exports = {
		decode: require_decode(),
		verify: require_verify(),
		sign: require_sign2(),
		JsonWebTokenError: require_JsonWebTokenError(),
		NotBeforeError: require_NotBeforeError(),
		TokenExpiredError: require_TokenExpiredError(),
	};
});

// node_modules/entities/lib/generated/decode-data-html.js
var require_decode_data_html = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = new Uint16Array(
		'\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\x00\x00\x00\x00\x00\x00\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\uD835\uDD04rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\uD835\uDD38plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\uD835\uDC9Cign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\uD835\uDD05pf;\uC000\uD835\uDD39eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\uD835\uDC9Ep\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\uD835\uDD07\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\x00\x00\x00\u0342\u0354\x00\u0405f;\uC000\uD835\uDD3B\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\x00\x00\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\x00\x00\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\x00\u0446\x00\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\x00\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\uD835\uDC9Frok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\uD835\uDD08rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\x00\x00\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\uD835\uDD3Csilon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\uD835\uDD09lled\u0253\u0597\x00\x00\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\x00\u05BF\x00\x00\u05C4f;\uC000\uD835\uDD3DAll;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\uD835\uDD0A;\u62D9pf;\uC000\uD835\uDD3Eeater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\uD835\uDCA2;\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\x00\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\x00\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\uD835\uDD40a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\x00\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\uD835\uDD0Dpf;\uC000\uD835\uDD41\u01E3\u07C7\x00\u07CCr;\uC000\uD835\uDCA5rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\uD835\uDD0Epf;\uC000\uD835\uDD42cr;\uC000\uD835\uDCA6\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\x00\u08C3bleBracket;\u67E6n\u01D4\u08C8\x00\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\uD835\uDD0F\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\uD835\uDD43er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\uD835\uDD10nusPlus;\u6213pf;\uC000\uD835\uDD44c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\uD835\uDD11\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\uD835\uDCA9ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\uD835\uDD12rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\uD835\uDD46enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\uD835\uDCAAash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\uD835\uDD13i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\uD835\uDCAB;\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\uD835\uDD14pf;\u611Acr;\uC000\uD835\uDCAC\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\x00\u1005bleBracket;\u67E7n\u01D4\u100A\x00\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\uD835\uDD16ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\uD835\uDD4A\u0272\u116D\x00\x00\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\uD835\uDCAEar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\uD835\uDD17\u0100ei\u127B\u1289\u01F2\u1280\x00\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\uD835\uDD4BipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\uD835\uDCAFrok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\x00\u132C\u1331\x00\x00\x00\x00\x00\u1338\u133D\u1377\u1385\x00\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\x00\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\uD835\uDD18rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\uD835\uDD4C\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\uD835\uDCB0ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\uD835\uDD19pf;\uC000\uD835\uDD4Dcr;\uC000\uD835\uDCB1dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\uD835\uDD1Apf;\uC000\uD835\uDD4Ecr;\uC000\uD835\uDCB2\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\uD835\uDD1B;\u439Epf;\uC000\uD835\uDD4Fcr;\uC000\uD835\uDCB3\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\uD835\uDD1Cpf;\uC000\uD835\uDD50cr;\uC000\uD835\uDCB4ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\x00\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\uD835\uDCB5\u0BE1\u1583\u158A\u1590\x00\u15B0\u15B6\u15BF\x00\x00\x00\x00\u15C6\u15DB\u15EB\u165F\u166D\x00\u1695\u169B\u16B2\u16B9\x00\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\uD835\uDD1Erave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\x00\x00\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\uD835\uDD52\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\uD835\uDCB6;\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\uD835\uDD1Fg\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\x00\x00\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\x00\u1833\u01B2\u182F\x00\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\uD835\uDD53\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\uD835\uDCB7mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\x00\u19E8\u1A11\u1A15\u1A32\x00\u1A37\u1A50\x00\x00\u1AB4\x00\x00\u1AC1\x00\x00\u1B21\u1B2E\u1B4D\u1B52\x00\u1BFD\x00\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\x00\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\uD835\uDD20\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\x00\x00\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\x00\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\x00\x00\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\x00\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\uD835\uDD54o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\uD835\uDCB8\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\x00\x00\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\x00\x00\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\uD835\uDD21ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\x00\x00\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\uD835\uDD55\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\x00\x00\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\uD835\uDCB9;\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\uD835\uDD22\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\uD835\uDD56\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\x00\x00\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\x00\u1F9E\x00\u1FA1\u1FA7\x00\x00\u1FC6\u1FCC\x00\u1FD3\x00\u1FE6\u1FEA\u2000\x00\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\x00\x00\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\uD835\uDD23lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\x00\u1FF3f;\uC000\uD835\uDD57\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\x00\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\x00\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\x00\u2036;\u6154;\u6156\u02B4\u203E\u2041\x00\x00\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\x00\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\uD835\uDCBB\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\uD835\uDD24\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\uD835\uDD58\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\x00\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\uD835\uDD25s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\uD835\uDD59bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\uD835\uDCBDas\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\x00\u22AA\x00\u22B8\u22C5\u22CE\x00\u22D5\u22F3\x00\x00\u22F8\u2322\u2367\u2362\u237F\x00\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\uD835\uDD26rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\uD835\uDD5Aa;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\uD835\uDCBEn\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\x00\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\uD835\uDD27ath;\u4237pf;\uC000\uD835\uDD5B\u01E3\u23EC\x00\u23F1r;\uC000\uD835\uDCBFrcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\uD835\uDD28reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\uD835\uDD5Ccr;\uC000\uD835\uDCC0\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\x00\u24AA\x00\u24B1\x00\x00\x00\x00\x00\u24B5\u24BA\x00\u24C6\u24C8\u24CD\x00\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\uD835\uDD29\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\uD835\uDD5Dus;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\uD835\uDCC1m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\uD835\uDD2Ao;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\uD835\uDD5E\u0100ct\u28F8\u28FDr;\uC000\uD835\uDCC2pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\x00\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\x00\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\uD835\uDD2B\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\uD835\uDD5F\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\uD835\uDCC3ort\u026D\u2B05\x00\x00\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\u2D2D\x00\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\x00\x00\u2D8D\u2DAB\x00\u2DC8\u2DCE\x00\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\uD835\uDD2C\u036F\u2D79\x00\x00\u2D7C\x00\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\uD835\uDD60\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\x00\u2E7D\x00\u2E80\u2E9D\x00\u2EA2\u2EB9\x00\x00\u2ECB\u0E9C\x00\u2F13\x00\x00\u2F2B\u2FBC\x00\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\x00\x00\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\uD835\uDD2D\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\uD835\uDD61nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\uD835\uDCC5;\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\uD835\uDD2Epf;\uC000\uD835\uDD62rime;\u6057cr;\uC000\uD835\uDCC6\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\uD835\uDD2F\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\uD835\uDD63us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\uD835\uDCC7\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\x00\u337A\u33A4\x00\x00\u33EC\u33F0\x00\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\x00\u3616\x00\x00\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\x00\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\uD835\uDD30\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\x00\x00\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\uD835\uDD64a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\uD835\uDCC8tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\x00\u367E\u36C2\x00\x00\x00\x00\x00\u36DB\u3703\x00\u3709\u376C\x00\x00\x00\u3787\u0272\u3656\x00\x00\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\uD835\uDD31\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\x00\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\uD835\uDD65rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\uD835\uDCC9;\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\x00\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\uD835\uDD32rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\x00\x00\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\uD835\uDD66\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\x00\x00\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\uD835\uDCCA\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\uD835\uDD33tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\uD835\uDD67ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\uD835\uDCCB\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\uD835\uDD34pf;\uC000\uD835\uDD68\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\uD835\uDCCC\u0AE3\u178E\u3A87\x00\u3A8B\x00\u3A90\u3A9B\x00\x00\u3A9D\u3AA8\u3AAB\u3AAF\x00\x00\u3AC3\u3ACE\x00\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\uD835\uDD35\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\uD835\uDD69im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\uD835\uDCCD\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\uD835\uDD36cy;\u4457pf;\uC000\uD835\uDD6Acr;\uC000\uD835\uDCCE\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\uD835\uDD37cy;\u4436grarr;\u61DDpf;\uC000\uD835\uDD6Bcr;\uC000\uD835\uDCCF\u0100jn\u3B85\u3B87;\u600Dj;\u600C'
			.split("")
			.map(function (c) {
				return c.charCodeAt(0);
			}),
	);
});

// node_modules/entities/lib/generated/decode-data-xml.js
var require_decode_data_xml = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = new Uint16Array(
		"\u0200aglq\t\x15\x18\x1B\u026D\x0F\x00\x00\x12p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022"
			.split("")
			.map(function (c) {
				return c.charCodeAt(0);
			}),
	);
});

// node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS((exports) => {
	var _a;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.replaceCodePoint = exports.fromCodePoint = undefined;
	var decodeMap = new Map([
		[0, 65533],
		[128, 8364],
		[130, 8218],
		[131, 402],
		[132, 8222],
		[133, 8230],
		[134, 8224],
		[135, 8225],
		[136, 710],
		[137, 8240],
		[138, 352],
		[139, 8249],
		[140, 338],
		[142, 381],
		[145, 8216],
		[146, 8217],
		[147, 8220],
		[148, 8221],
		[149, 8226],
		[150, 8211],
		[151, 8212],
		[152, 732],
		[153, 8482],
		[154, 353],
		[155, 8250],
		[156, 339],
		[158, 382],
		[159, 376],
	]);
	exports.fromCodePoint =
		(_a = String.fromCodePoint) !== null && _a !== undefined
			? _a
			: function (codePoint) {
					var output = "";
					if (codePoint > 65535) {
						codePoint -= 65536;
						output += String.fromCharCode(((codePoint >>> 10) & 1023) | 55296);
						codePoint = 56320 | (codePoint & 1023);
					}
					output += String.fromCharCode(codePoint);
					return output;
				};
	function replaceCodePoint(codePoint) {
		var _a2;
		if ((codePoint >= 55296 && codePoint <= 57343) || codePoint > 1114111) {
			return 65533;
		}
		return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== undefined ? _a2 : codePoint;
	}
	exports.replaceCodePoint = replaceCodePoint;
	function decodeCodePoint(codePoint) {
		return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));
	}
	exports.default = decodeCodePoint;
});

// node_modules/entities/lib/decode.js
var require_decode2 = __commonJS((exports) => {
	var __createBinding =
		(exports && exports.__createBinding) ||
		(Object.create
			? function (o, m2, k2, k22) {
					if (k22 === undefined) k22 = k2;
					var desc = Object.getOwnPropertyDescriptor(m2, k2);
					if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
						desc = {
							enumerable: true,
							get: function () {
								return m2[k2];
							},
						};
					}
					Object.defineProperty(o, k22, desc);
				}
			: function (o, m2, k2, k22) {
					if (k22 === undefined) k22 = k2;
					o[k22] = m2[k2];
				});
	var __setModuleDefault =
		(exports && exports.__setModuleDefault) ||
		(Object.create
			? function (o, v) {
					Object.defineProperty(o, "default", { enumerable: true, value: v });
				}
			: function (o, v) {
					o["default"] = v;
				});
	var __importStar =
		(exports && exports.__importStar) ||
		function (mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k2 in mod)
					if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
						__createBinding(result, mod, k2);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	var __importDefault =
		(exports && exports.__importDefault) ||
		function (mod) {
			return mod && mod.__esModule ? mod : { default: mod };
		};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.decodeXML =
		exports.decodeHTMLStrict =
		exports.decodeHTMLAttribute =
		exports.decodeHTML =
		exports.determineBranch =
		exports.EntityDecoder =
		exports.DecodingMode =
		exports.BinTrieFlags =
		exports.fromCodePoint =
		exports.replaceCodePoint =
		exports.decodeCodePoint =
		exports.xmlDecodeTree =
		exports.htmlDecodeTree =
			undefined;
	var decode_data_html_js_1 = __importDefault(require_decode_data_html());
	exports.htmlDecodeTree = decode_data_html_js_1.default;
	var decode_data_xml_js_1 = __importDefault(require_decode_data_xml());
	exports.xmlDecodeTree = decode_data_xml_js_1.default;
	var decode_codepoint_js_1 = __importStar(require_decode_codepoint());
	exports.decodeCodePoint = decode_codepoint_js_1.default;
	var decode_codepoint_js_2 = require_decode_codepoint();
	Object.defineProperty(exports, "replaceCodePoint", {
		enumerable: true,
		get: function () {
			return decode_codepoint_js_2.replaceCodePoint;
		},
	});
	Object.defineProperty(exports, "fromCodePoint", {
		enumerable: true,
		get: function () {
			return decode_codepoint_js_2.fromCodePoint;
		},
	});
	var CharCodes;
	(function (CharCodes2) {
		CharCodes2[(CharCodes2["NUM"] = 35)] = "NUM";
		CharCodes2[(CharCodes2["SEMI"] = 59)] = "SEMI";
		CharCodes2[(CharCodes2["EQUALS"] = 61)] = "EQUALS";
		CharCodes2[(CharCodes2["ZERO"] = 48)] = "ZERO";
		CharCodes2[(CharCodes2["NINE"] = 57)] = "NINE";
		CharCodes2[(CharCodes2["LOWER_A"] = 97)] = "LOWER_A";
		CharCodes2[(CharCodes2["LOWER_F"] = 102)] = "LOWER_F";
		CharCodes2[(CharCodes2["LOWER_X"] = 120)] = "LOWER_X";
		CharCodes2[(CharCodes2["LOWER_Z"] = 122)] = "LOWER_Z";
		CharCodes2[(CharCodes2["UPPER_A"] = 65)] = "UPPER_A";
		CharCodes2[(CharCodes2["UPPER_F"] = 70)] = "UPPER_F";
		CharCodes2[(CharCodes2["UPPER_Z"] = 90)] = "UPPER_Z";
	})(CharCodes || (CharCodes = {}));
	var TO_LOWER_BIT = 32;
	var BinTrieFlags;
	(function (BinTrieFlags2) {
		BinTrieFlags2[(BinTrieFlags2["VALUE_LENGTH"] = 49152)] = "VALUE_LENGTH";
		BinTrieFlags2[(BinTrieFlags2["BRANCH_LENGTH"] = 16256)] = "BRANCH_LENGTH";
		BinTrieFlags2[(BinTrieFlags2["JUMP_TABLE"] = 127)] = "JUMP_TABLE";
	})((BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {})));
	function isNumber2(code) {
		return code >= CharCodes.ZERO && code <= CharCodes.NINE;
	}
	function isHexadecimalCharacter(code) {
		return (
			(code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F) ||
			(code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F)
		);
	}
	function isAsciiAlphaNumeric(code) {
		return (
			(code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z) ||
			(code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z) ||
			isNumber2(code)
		);
	}
	function isEntityInAttributeInvalidEnd(code) {
		return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
	}
	var EntityDecoderState;
	(function (EntityDecoderState2) {
		EntityDecoderState2[(EntityDecoderState2["EntityStart"] = 0)] = "EntityStart";
		EntityDecoderState2[(EntityDecoderState2["NumericStart"] = 1)] = "NumericStart";
		EntityDecoderState2[(EntityDecoderState2["NumericDecimal"] = 2)] = "NumericDecimal";
		EntityDecoderState2[(EntityDecoderState2["NumericHex"] = 3)] = "NumericHex";
		EntityDecoderState2[(EntityDecoderState2["NamedEntity"] = 4)] = "NamedEntity";
	})(EntityDecoderState || (EntityDecoderState = {}));
	var DecodingMode;
	(function (DecodingMode2) {
		DecodingMode2[(DecodingMode2["Legacy"] = 0)] = "Legacy";
		DecodingMode2[(DecodingMode2["Strict"] = 1)] = "Strict";
		DecodingMode2[(DecodingMode2["Attribute"] = 2)] = "Attribute";
	})((DecodingMode = exports.DecodingMode || (exports.DecodingMode = {})));
	var EntityDecoder = (function () {
		function EntityDecoder2(decodeTree, emitCodePoint, errors2) {
			this.decodeTree = decodeTree;
			this.emitCodePoint = emitCodePoint;
			this.errors = errors2;
			this.state = EntityDecoderState.EntityStart;
			this.consumed = 1;
			this.result = 0;
			this.treeIndex = 0;
			this.excess = 1;
			this.decodeMode = DecodingMode.Strict;
		}
		EntityDecoder2.prototype.startEntity = function (decodeMode) {
			this.decodeMode = decodeMode;
			this.state = EntityDecoderState.EntityStart;
			this.result = 0;
			this.treeIndex = 0;
			this.excess = 1;
			this.consumed = 1;
		};
		EntityDecoder2.prototype.write = function (str, offset) {
			switch (this.state) {
				case EntityDecoderState.EntityStart: {
					if (str.charCodeAt(offset) === CharCodes.NUM) {
						this.state = EntityDecoderState.NumericStart;
						this.consumed += 1;
						return this.stateNumericStart(str, offset + 1);
					}
					this.state = EntityDecoderState.NamedEntity;
					return this.stateNamedEntity(str, offset);
				}
				case EntityDecoderState.NumericStart: {
					return this.stateNumericStart(str, offset);
				}
				case EntityDecoderState.NumericDecimal: {
					return this.stateNumericDecimal(str, offset);
				}
				case EntityDecoderState.NumericHex: {
					return this.stateNumericHex(str, offset);
				}
				case EntityDecoderState.NamedEntity: {
					return this.stateNamedEntity(str, offset);
				}
			}
		};
		EntityDecoder2.prototype.stateNumericStart = function (str, offset) {
			if (offset >= str.length) {
				return -1;
			}
			if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
				this.state = EntityDecoderState.NumericHex;
				this.consumed += 1;
				return this.stateNumericHex(str, offset + 1);
			}
			this.state = EntityDecoderState.NumericDecimal;
			return this.stateNumericDecimal(str, offset);
		};
		EntityDecoder2.prototype.addToNumericResult = function (str, start, end, base) {
			if (start !== end) {
				var digitCount = end - start;
				this.result =
					this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
				this.consumed += digitCount;
			}
		};
		EntityDecoder2.prototype.stateNumericHex = function (str, offset) {
			var startIdx = offset;
			while (offset < str.length) {
				var char = str.charCodeAt(offset);
				if (isNumber2(char) || isHexadecimalCharacter(char)) {
					offset += 1;
				} else {
					this.addToNumericResult(str, startIdx, offset, 16);
					return this.emitNumericEntity(char, 3);
				}
			}
			this.addToNumericResult(str, startIdx, offset, 16);
			return -1;
		};
		EntityDecoder2.prototype.stateNumericDecimal = function (str, offset) {
			var startIdx = offset;
			while (offset < str.length) {
				var char = str.charCodeAt(offset);
				if (isNumber2(char)) {
					offset += 1;
				} else {
					this.addToNumericResult(str, startIdx, offset, 10);
					return this.emitNumericEntity(char, 2);
				}
			}
			this.addToNumericResult(str, startIdx, offset, 10);
			return -1;
		};
		EntityDecoder2.prototype.emitNumericEntity = function (lastCp, expectedLength) {
			var _a;
			if (this.consumed <= expectedLength) {
				(_a = this.errors) === null ||
					_a === undefined ||
					_a.absenceOfDigitsInNumericCharacterReference(this.consumed);
				return 0;
			}
			if (lastCp === CharCodes.SEMI) {
				this.consumed += 1;
			} else if (this.decodeMode === DecodingMode.Strict) {
				return 0;
			}
			this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
			if (this.errors) {
				if (lastCp !== CharCodes.SEMI) {
					this.errors.missingSemicolonAfterCharacterReference();
				}
				this.errors.validateNumericCharacterReference(this.result);
			}
			return this.consumed;
		};
		EntityDecoder2.prototype.stateNamedEntity = function (str, offset) {
			var decodeTree = this.decodeTree;
			var current = decodeTree[this.treeIndex];
			var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
			for (; offset < str.length; offset++, this.excess++) {
				var char = str.charCodeAt(offset);
				this.treeIndex = determineBranch(
					decodeTree,
					current,
					this.treeIndex + Math.max(1, valueLength),
					char,
				);
				if (this.treeIndex < 0) {
					return this.result === 0 ||
						(this.decodeMode === DecodingMode.Attribute &&
							(valueLength === 0 || isEntityInAttributeInvalidEnd(char)))
						? 0
						: this.emitNotTerminatedNamedEntity();
				}
				current = decodeTree[this.treeIndex];
				valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
				if (valueLength !== 0) {
					if (char === CharCodes.SEMI) {
						return this.emitNamedEntityData(
							this.treeIndex,
							valueLength,
							this.consumed + this.excess,
						);
					}
					if (this.decodeMode !== DecodingMode.Strict) {
						this.result = this.treeIndex;
						this.consumed += this.excess;
						this.excess = 0;
					}
				}
			}
			return -1;
		};
		EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function () {
			var _a;
			var _b = this,
				result = _b.result,
				decodeTree = _b.decodeTree;
			var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
			this.emitNamedEntityData(result, valueLength, this.consumed);
			(_a = this.errors) === null ||
				_a === undefined ||
				_a.missingSemicolonAfterCharacterReference();
			return this.consumed;
		};
		EntityDecoder2.prototype.emitNamedEntityData = function (result, valueLength, consumed) {
			var decodeTree = this.decodeTree;
			this.emitCodePoint(
				valueLength === 1
					? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH
					: decodeTree[result + 1],
				consumed,
			);
			if (valueLength === 3) {
				this.emitCodePoint(decodeTree[result + 2], consumed);
			}
			return consumed;
		};
		EntityDecoder2.prototype.end = function () {
			var _a;
			switch (this.state) {
				case EntityDecoderState.NamedEntity: {
					return this.result !== 0 &&
						(this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex)
						? this.emitNotTerminatedNamedEntity()
						: 0;
				}
				case EntityDecoderState.NumericDecimal: {
					return this.emitNumericEntity(0, 2);
				}
				case EntityDecoderState.NumericHex: {
					return this.emitNumericEntity(0, 3);
				}
				case EntityDecoderState.NumericStart: {
					(_a = this.errors) === null ||
						_a === undefined ||
						_a.absenceOfDigitsInNumericCharacterReference(this.consumed);
					return 0;
				}
				case EntityDecoderState.EntityStart: {
					return 0;
				}
			}
		};
		return EntityDecoder2;
	})();
	exports.EntityDecoder = EntityDecoder;
	function getDecoder(decodeTree) {
		var ret = "";
		var decoder = new EntityDecoder(decodeTree, function (str) {
			return (ret += (0, decode_codepoint_js_1.fromCodePoint)(str));
		});
		return function decodeWithTrie(str, decodeMode) {
			var lastIndex = 0;
			var offset = 0;
			while ((offset = str.indexOf("&", offset)) >= 0) {
				ret += str.slice(lastIndex, offset);
				decoder.startEntity(decodeMode);
				var len = decoder.write(str, offset + 1);
				if (len < 0) {
					lastIndex = offset + decoder.end();
					break;
				}
				lastIndex = offset + len;
				offset = len === 0 ? lastIndex + 1 : lastIndex;
			}
			var result = ret + str.slice(lastIndex);
			ret = "";
			return result;
		};
	}
	function determineBranch(decodeTree, current, nodeIdx, char) {
		var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
		var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
		if (branchCount === 0) {
			return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
		}
		if (jumpOffset) {
			var value = char - jumpOffset;
			return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
		}
		var lo = nodeIdx;
		var hi = lo + branchCount - 1;
		while (lo <= hi) {
			var mid = (lo + hi) >>> 1;
			var midVal = decodeTree[mid];
			if (midVal < char) {
				lo = mid + 1;
			} else if (midVal > char) {
				hi = mid - 1;
			} else {
				return decodeTree[mid + branchCount];
			}
		}
		return -1;
	}
	exports.determineBranch = determineBranch;
	var htmlDecoder = getDecoder(decode_data_html_js_1.default);
	var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
	function decodeHTML(str, mode) {
		if (mode === undefined) {
			mode = DecodingMode.Legacy;
		}
		return htmlDecoder(str, mode);
	}
	exports.decodeHTML = decodeHTML;
	function decodeHTMLAttribute(str) {
		return htmlDecoder(str, DecodingMode.Attribute);
	}
	exports.decodeHTMLAttribute = decodeHTMLAttribute;
	function decodeHTMLStrict(str) {
		return htmlDecoder(str, DecodingMode.Strict);
	}
	exports.decodeHTMLStrict = decodeHTMLStrict;
	function decodeXML(str) {
		return xmlDecoder(str, DecodingMode.Strict);
	}
	exports.decodeXML = decodeXML;
});

// node_modules/htmlparser2/lib/Tokenizer.js
var require_Tokenizer = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.QuoteType = undefined;
	var decode_js_1 = require_decode2();
	var CharCodes;
	(function (CharCodes2) {
		CharCodes2[(CharCodes2["Tab"] = 9)] = "Tab";
		CharCodes2[(CharCodes2["NewLine"] = 10)] = "NewLine";
		CharCodes2[(CharCodes2["FormFeed"] = 12)] = "FormFeed";
		CharCodes2[(CharCodes2["CarriageReturn"] = 13)] = "CarriageReturn";
		CharCodes2[(CharCodes2["Space"] = 32)] = "Space";
		CharCodes2[(CharCodes2["ExclamationMark"] = 33)] = "ExclamationMark";
		CharCodes2[(CharCodes2["Number"] = 35)] = "Number";
		CharCodes2[(CharCodes2["Amp"] = 38)] = "Amp";
		CharCodes2[(CharCodes2["SingleQuote"] = 39)] = "SingleQuote";
		CharCodes2[(CharCodes2["DoubleQuote"] = 34)] = "DoubleQuote";
		CharCodes2[(CharCodes2["Dash"] = 45)] = "Dash";
		CharCodes2[(CharCodes2["Slash"] = 47)] = "Slash";
		CharCodes2[(CharCodes2["Zero"] = 48)] = "Zero";
		CharCodes2[(CharCodes2["Nine"] = 57)] = "Nine";
		CharCodes2[(CharCodes2["Semi"] = 59)] = "Semi";
		CharCodes2[(CharCodes2["Lt"] = 60)] = "Lt";
		CharCodes2[(CharCodes2["Eq"] = 61)] = "Eq";
		CharCodes2[(CharCodes2["Gt"] = 62)] = "Gt";
		CharCodes2[(CharCodes2["Questionmark"] = 63)] = "Questionmark";
		CharCodes2[(CharCodes2["UpperA"] = 65)] = "UpperA";
		CharCodes2[(CharCodes2["LowerA"] = 97)] = "LowerA";
		CharCodes2[(CharCodes2["UpperF"] = 70)] = "UpperF";
		CharCodes2[(CharCodes2["LowerF"] = 102)] = "LowerF";
		CharCodes2[(CharCodes2["UpperZ"] = 90)] = "UpperZ";
		CharCodes2[(CharCodes2["LowerZ"] = 122)] = "LowerZ";
		CharCodes2[(CharCodes2["LowerX"] = 120)] = "LowerX";
		CharCodes2[(CharCodes2["OpeningSquareBracket"] = 91)] = "OpeningSquareBracket";
	})(CharCodes || (CharCodes = {}));
	var State;
	(function (State2) {
		State2[(State2["Text"] = 1)] = "Text";
		State2[(State2["BeforeTagName"] = 2)] = "BeforeTagName";
		State2[(State2["InTagName"] = 3)] = "InTagName";
		State2[(State2["InSelfClosingTag"] = 4)] = "InSelfClosingTag";
		State2[(State2["BeforeClosingTagName"] = 5)] = "BeforeClosingTagName";
		State2[(State2["InClosingTagName"] = 6)] = "InClosingTagName";
		State2[(State2["AfterClosingTagName"] = 7)] = "AfterClosingTagName";
		State2[(State2["BeforeAttributeName"] = 8)] = "BeforeAttributeName";
		State2[(State2["InAttributeName"] = 9)] = "InAttributeName";
		State2[(State2["AfterAttributeName"] = 10)] = "AfterAttributeName";
		State2[(State2["BeforeAttributeValue"] = 11)] = "BeforeAttributeValue";
		State2[(State2["InAttributeValueDq"] = 12)] = "InAttributeValueDq";
		State2[(State2["InAttributeValueSq"] = 13)] = "InAttributeValueSq";
		State2[(State2["InAttributeValueNq"] = 14)] = "InAttributeValueNq";
		State2[(State2["BeforeDeclaration"] = 15)] = "BeforeDeclaration";
		State2[(State2["InDeclaration"] = 16)] = "InDeclaration";
		State2[(State2["InProcessingInstruction"] = 17)] = "InProcessingInstruction";
		State2[(State2["BeforeComment"] = 18)] = "BeforeComment";
		State2[(State2["CDATASequence"] = 19)] = "CDATASequence";
		State2[(State2["InSpecialComment"] = 20)] = "InSpecialComment";
		State2[(State2["InCommentLike"] = 21)] = "InCommentLike";
		State2[(State2["BeforeSpecialS"] = 22)] = "BeforeSpecialS";
		State2[(State2["SpecialStartSequence"] = 23)] = "SpecialStartSequence";
		State2[(State2["InSpecialTag"] = 24)] = "InSpecialTag";
		State2[(State2["BeforeEntity"] = 25)] = "BeforeEntity";
		State2[(State2["BeforeNumericEntity"] = 26)] = "BeforeNumericEntity";
		State2[(State2["InNamedEntity"] = 27)] = "InNamedEntity";
		State2[(State2["InNumericEntity"] = 28)] = "InNumericEntity";
		State2[(State2["InHexEntity"] = 29)] = "InHexEntity";
	})(State || (State = {}));
	function isWhitespace(c) {
		return (
			c === CharCodes.Space ||
			c === CharCodes.NewLine ||
			c === CharCodes.Tab ||
			c === CharCodes.FormFeed ||
			c === CharCodes.CarriageReturn
		);
	}
	function isEndOfTagSection(c) {
		return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);
	}
	function isNumber2(c) {
		return c >= CharCodes.Zero && c <= CharCodes.Nine;
	}
	function isASCIIAlpha(c) {
		return (
			(c >= CharCodes.LowerA && c <= CharCodes.LowerZ) ||
			(c >= CharCodes.UpperA && c <= CharCodes.UpperZ)
		);
	}
	function isHexDigit(c) {
		return (
			(c >= CharCodes.UpperA && c <= CharCodes.UpperF) ||
			(c >= CharCodes.LowerA && c <= CharCodes.LowerF)
		);
	}
	var QuoteType;
	(function (QuoteType2) {
		QuoteType2[(QuoteType2["NoValue"] = 0)] = "NoValue";
		QuoteType2[(QuoteType2["Unquoted"] = 1)] = "Unquoted";
		QuoteType2[(QuoteType2["Single"] = 2)] = "Single";
		QuoteType2[(QuoteType2["Double"] = 3)] = "Double";
	})((QuoteType = exports.QuoteType || (exports.QuoteType = {})));
	var Sequences = {
		Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
		CdataEnd: new Uint8Array([93, 93, 62]),
		CommentEnd: new Uint8Array([45, 45, 62]),
		ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
		StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
		TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),
	};
	var Tokenizer = (function () {
		function Tokenizer2(_a, cbs) {
			var _b = _a.xmlMode,
				xmlMode = _b === undefined ? false : _b,
				_c = _a.decodeEntities,
				decodeEntities = _c === undefined ? true : _c;
			this.cbs = cbs;
			this.state = State.Text;
			this.buffer = "";
			this.sectionStart = 0;
			this.index = 0;
			this.baseState = State.Text;
			this.isSpecial = false;
			this.running = true;
			this.offset = 0;
			this.currentSequence = undefined;
			this.sequenceIndex = 0;
			this.trieIndex = 0;
			this.trieCurrent = 0;
			this.entityResult = 0;
			this.entityExcess = 0;
			this.xmlMode = xmlMode;
			this.decodeEntities = decodeEntities;
			this.entityTrie = xmlMode ? decode_js_1.xmlDecodeTree : decode_js_1.htmlDecodeTree;
		}
		Tokenizer2.prototype.reset = function () {
			this.state = State.Text;
			this.buffer = "";
			this.sectionStart = 0;
			this.index = 0;
			this.baseState = State.Text;
			this.currentSequence = undefined;
			this.running = true;
			this.offset = 0;
		};
		Tokenizer2.prototype.write = function (chunk) {
			this.offset += this.buffer.length;
			this.buffer = chunk;
			this.parse();
		};
		Tokenizer2.prototype.end = function () {
			if (this.running) this.finish();
		};
		Tokenizer2.prototype.pause = function () {
			this.running = false;
		};
		Tokenizer2.prototype.resume = function () {
			this.running = true;
			if (this.index < this.buffer.length + this.offset) {
				this.parse();
			}
		};
		Tokenizer2.prototype.getIndex = function () {
			return this.index;
		};
		Tokenizer2.prototype.getSectionStart = function () {
			return this.sectionStart;
		};
		Tokenizer2.prototype.stateText = function (c) {
			if (c === CharCodes.Lt || (!this.decodeEntities && this.fastForwardTo(CharCodes.Lt))) {
				if (this.index > this.sectionStart) {
					this.cbs.ontext(this.sectionStart, this.index);
				}
				this.state = State.BeforeTagName;
				this.sectionStart = this.index;
			} else if (this.decodeEntities && c === CharCodes.Amp) {
				this.state = State.BeforeEntity;
			}
		};
		Tokenizer2.prototype.stateSpecialStartSequence = function (c) {
			var isEnd = this.sequenceIndex === this.currentSequence.length;
			var isMatch = isEnd
				? isEndOfTagSection(c)
				: (c | 32) === this.currentSequence[this.sequenceIndex];
			if (!isMatch) {
				this.isSpecial = false;
			} else if (!isEnd) {
				this.sequenceIndex++;
				return;
			}
			this.sequenceIndex = 0;
			this.state = State.InTagName;
			this.stateInTagName(c);
		};
		Tokenizer2.prototype.stateInSpecialTag = function (c) {
			if (this.sequenceIndex === this.currentSequence.length) {
				if (c === CharCodes.Gt || isWhitespace(c)) {
					var endOfText = this.index - this.currentSequence.length;
					if (this.sectionStart < endOfText) {
						var actualIndex = this.index;
						this.index = endOfText;
						this.cbs.ontext(this.sectionStart, endOfText);
						this.index = actualIndex;
					}
					this.isSpecial = false;
					this.sectionStart = endOfText + 2;
					this.stateInClosingTagName(c);
					return;
				}
				this.sequenceIndex = 0;
			}
			if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
				this.sequenceIndex += 1;
			} else if (this.sequenceIndex === 0) {
				if (this.currentSequence === Sequences.TitleEnd) {
					if (this.decodeEntities && c === CharCodes.Amp) {
						this.state = State.BeforeEntity;
					}
				} else if (this.fastForwardTo(CharCodes.Lt)) {
					this.sequenceIndex = 1;
				}
			} else {
				this.sequenceIndex = Number(c === CharCodes.Lt);
			}
		};
		Tokenizer2.prototype.stateCDATASequence = function (c) {
			if (c === Sequences.Cdata[this.sequenceIndex]) {
				if (++this.sequenceIndex === Sequences.Cdata.length) {
					this.state = State.InCommentLike;
					this.currentSequence = Sequences.CdataEnd;
					this.sequenceIndex = 0;
					this.sectionStart = this.index + 1;
				}
			} else {
				this.sequenceIndex = 0;
				this.state = State.InDeclaration;
				this.stateInDeclaration(c);
			}
		};
		Tokenizer2.prototype.fastForwardTo = function (c) {
			while (++this.index < this.buffer.length + this.offset) {
				if (this.buffer.charCodeAt(this.index - this.offset) === c) {
					return true;
				}
			}
			this.index = this.buffer.length + this.offset - 1;
			return false;
		};
		Tokenizer2.prototype.stateInCommentLike = function (c) {
			if (c === this.currentSequence[this.sequenceIndex]) {
				if (++this.sequenceIndex === this.currentSequence.length) {
					if (this.currentSequence === Sequences.CdataEnd) {
						this.cbs.oncdata(this.sectionStart, this.index, 2);
					} else {
						this.cbs.oncomment(this.sectionStart, this.index, 2);
					}
					this.sequenceIndex = 0;
					this.sectionStart = this.index + 1;
					this.state = State.Text;
				}
			} else if (this.sequenceIndex === 0) {
				if (this.fastForwardTo(this.currentSequence[0])) {
					this.sequenceIndex = 1;
				}
			} else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
				this.sequenceIndex = 0;
			}
		};
		Tokenizer2.prototype.isTagStartChar = function (c) {
			return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
		};
		Tokenizer2.prototype.startSpecial = function (sequence, offset) {
			this.isSpecial = true;
			this.currentSequence = sequence;
			this.sequenceIndex = offset;
			this.state = State.SpecialStartSequence;
		};
		Tokenizer2.prototype.stateBeforeTagName = function (c) {
			if (c === CharCodes.ExclamationMark) {
				this.state = State.BeforeDeclaration;
				this.sectionStart = this.index + 1;
			} else if (c === CharCodes.Questionmark) {
				this.state = State.InProcessingInstruction;
				this.sectionStart = this.index + 1;
			} else if (this.isTagStartChar(c)) {
				var lower = c | 32;
				this.sectionStart = this.index;
				if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
					this.startSpecial(Sequences.TitleEnd, 3);
				} else {
					this.state =
						!this.xmlMode && lower === Sequences.ScriptEnd[2]
							? State.BeforeSpecialS
							: State.InTagName;
				}
			} else if (c === CharCodes.Slash) {
				this.state = State.BeforeClosingTagName;
			} else {
				this.state = State.Text;
				this.stateText(c);
			}
		};
		Tokenizer2.prototype.stateInTagName = function (c) {
			if (isEndOfTagSection(c)) {
				this.cbs.onopentagname(this.sectionStart, this.index);
				this.sectionStart = -1;
				this.state = State.BeforeAttributeName;
				this.stateBeforeAttributeName(c);
			}
		};
		Tokenizer2.prototype.stateBeforeClosingTagName = function (c) {
			if (isWhitespace(c)) {
			} else if (c === CharCodes.Gt) {
				this.state = State.Text;
			} else {
				this.state = this.isTagStartChar(c) ? State.InClosingTagName : State.InSpecialComment;
				this.sectionStart = this.index;
			}
		};
		Tokenizer2.prototype.stateInClosingTagName = function (c) {
			if (c === CharCodes.Gt || isWhitespace(c)) {
				this.cbs.onclosetag(this.sectionStart, this.index);
				this.sectionStart = -1;
				this.state = State.AfterClosingTagName;
				this.stateAfterClosingTagName(c);
			}
		};
		Tokenizer2.prototype.stateAfterClosingTagName = function (c) {
			if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
				this.state = State.Text;
				this.baseState = State.Text;
				this.sectionStart = this.index + 1;
			}
		};
		Tokenizer2.prototype.stateBeforeAttributeName = function (c) {
			if (c === CharCodes.Gt) {
				this.cbs.onopentagend(this.index);
				if (this.isSpecial) {
					this.state = State.InSpecialTag;
					this.sequenceIndex = 0;
				} else {
					this.state = State.Text;
				}
				this.baseState = this.state;
				this.sectionStart = this.index + 1;
			} else if (c === CharCodes.Slash) {
				this.state = State.InSelfClosingTag;
			} else if (!isWhitespace(c)) {
				this.state = State.InAttributeName;
				this.sectionStart = this.index;
			}
		};
		Tokenizer2.prototype.stateInSelfClosingTag = function (c) {
			if (c === CharCodes.Gt) {
				this.cbs.onselfclosingtag(this.index);
				this.state = State.Text;
				this.baseState = State.Text;
				this.sectionStart = this.index + 1;
				this.isSpecial = false;
			} else if (!isWhitespace(c)) {
				this.state = State.BeforeAttributeName;
				this.stateBeforeAttributeName(c);
			}
		};
		Tokenizer2.prototype.stateInAttributeName = function (c) {
			if (c === CharCodes.Eq || isEndOfTagSection(c)) {
				this.cbs.onattribname(this.sectionStart, this.index);
				this.sectionStart = -1;
				this.state = State.AfterAttributeName;
				this.stateAfterAttributeName(c);
			}
		};
		Tokenizer2.prototype.stateAfterAttributeName = function (c) {
			if (c === CharCodes.Eq) {
				this.state = State.BeforeAttributeValue;
			} else if (c === CharCodes.Slash || c === CharCodes.Gt) {
				this.cbs.onattribend(QuoteType.NoValue, this.index);
				this.state = State.BeforeAttributeName;
				this.stateBeforeAttributeName(c);
			} else if (!isWhitespace(c)) {
				this.cbs.onattribend(QuoteType.NoValue, this.index);
				this.state = State.InAttributeName;
				this.sectionStart = this.index;
			}
		};
		Tokenizer2.prototype.stateBeforeAttributeValue = function (c) {
			if (c === CharCodes.DoubleQuote) {
				this.state = State.InAttributeValueDq;
				this.sectionStart = this.index + 1;
			} else if (c === CharCodes.SingleQuote) {
				this.state = State.InAttributeValueSq;
				this.sectionStart = this.index + 1;
			} else if (!isWhitespace(c)) {
				this.sectionStart = this.index;
				this.state = State.InAttributeValueNq;
				this.stateInAttributeValueNoQuotes(c);
			}
		};
		Tokenizer2.prototype.handleInAttributeValue = function (c, quote) {
			if (c === quote || (!this.decodeEntities && this.fastForwardTo(quote))) {
				this.cbs.onattribdata(this.sectionStart, this.index);
				this.sectionStart = -1;
				this.cbs.onattribend(
					quote === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single,
					this.index,
				);
				this.state = State.BeforeAttributeName;
			} else if (this.decodeEntities && c === CharCodes.Amp) {
				this.baseState = this.state;
				this.state = State.BeforeEntity;
			}
		};
		Tokenizer2.prototype.stateInAttributeValueDoubleQuotes = function (c) {
			this.handleInAttributeValue(c, CharCodes.DoubleQuote);
		};
		Tokenizer2.prototype.stateInAttributeValueSingleQuotes = function (c) {
			this.handleInAttributeValue(c, CharCodes.SingleQuote);
		};
		Tokenizer2.prototype.stateInAttributeValueNoQuotes = function (c) {
			if (isWhitespace(c) || c === CharCodes.Gt) {
				this.cbs.onattribdata(this.sectionStart, this.index);
				this.sectionStart = -1;
				this.cbs.onattribend(QuoteType.Unquoted, this.index);
				this.state = State.BeforeAttributeName;
				this.stateBeforeAttributeName(c);
			} else if (this.decodeEntities && c === CharCodes.Amp) {
				this.baseState = this.state;
				this.state = State.BeforeEntity;
			}
		};
		Tokenizer2.prototype.stateBeforeDeclaration = function (c) {
			if (c === CharCodes.OpeningSquareBracket) {
				this.state = State.CDATASequence;
				this.sequenceIndex = 0;
			} else {
				this.state = c === CharCodes.Dash ? State.BeforeComment : State.InDeclaration;
			}
		};
		Tokenizer2.prototype.stateInDeclaration = function (c) {
			if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
				this.cbs.ondeclaration(this.sectionStart, this.index);
				this.state = State.Text;
				this.sectionStart = this.index + 1;
			}
		};
		Tokenizer2.prototype.stateInProcessingInstruction = function (c) {
			if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
				this.cbs.onprocessinginstruction(this.sectionStart, this.index);
				this.state = State.Text;
				this.sectionStart = this.index + 1;
			}
		};
		Tokenizer2.prototype.stateBeforeComment = function (c) {
			if (c === CharCodes.Dash) {
				this.state = State.InCommentLike;
				this.currentSequence = Sequences.CommentEnd;
				this.sequenceIndex = 2;
				this.sectionStart = this.index + 1;
			} else {
				this.state = State.InDeclaration;
			}
		};
		Tokenizer2.prototype.stateInSpecialComment = function (c) {
			if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
				this.cbs.oncomment(this.sectionStart, this.index, 0);
				this.state = State.Text;
				this.sectionStart = this.index + 1;
			}
		};
		Tokenizer2.prototype.stateBeforeSpecialS = function (c) {
			var lower = c | 32;
			if (lower === Sequences.ScriptEnd[3]) {
				this.startSpecial(Sequences.ScriptEnd, 4);
			} else if (lower === Sequences.StyleEnd[3]) {
				this.startSpecial(Sequences.StyleEnd, 4);
			} else {
				this.state = State.InTagName;
				this.stateInTagName(c);
			}
		};
		Tokenizer2.prototype.stateBeforeEntity = function (c) {
			this.entityExcess = 1;
			this.entityResult = 0;
			if (c === CharCodes.Number) {
				this.state = State.BeforeNumericEntity;
			} else if (c === CharCodes.Amp) {
			} else {
				this.trieIndex = 0;
				this.trieCurrent = this.entityTrie[0];
				this.state = State.InNamedEntity;
				this.stateInNamedEntity(c);
			}
		};
		Tokenizer2.prototype.stateInNamedEntity = function (c) {
			this.entityExcess += 1;
			this.trieIndex = (0, decode_js_1.determineBranch)(
				this.entityTrie,
				this.trieCurrent,
				this.trieIndex + 1,
				c,
			);
			if (this.trieIndex < 0) {
				this.emitNamedEntity();
				this.index--;
				return;
			}
			this.trieCurrent = this.entityTrie[this.trieIndex];
			var masked = this.trieCurrent & decode_js_1.BinTrieFlags.VALUE_LENGTH;
			if (masked) {
				var valueLength = (masked >> 14) - 1;
				if (!this.allowLegacyEntity() && c !== CharCodes.Semi) {
					this.trieIndex += valueLength;
				} else {
					var entityStart = this.index - this.entityExcess + 1;
					if (entityStart > this.sectionStart) {
						this.emitPartial(this.sectionStart, entityStart);
					}
					this.entityResult = this.trieIndex;
					this.trieIndex += valueLength;
					this.entityExcess = 0;
					this.sectionStart = this.index + 1;
					if (valueLength === 0) {
						this.emitNamedEntity();
					}
				}
			}
		};
		Tokenizer2.prototype.emitNamedEntity = function () {
			this.state = this.baseState;
			if (this.entityResult === 0) {
				return;
			}
			var valueLength =
				(this.entityTrie[this.entityResult] & decode_js_1.BinTrieFlags.VALUE_LENGTH) >> 14;
			switch (valueLength) {
				case 1: {
					this.emitCodePoint(
						this.entityTrie[this.entityResult] & ~decode_js_1.BinTrieFlags.VALUE_LENGTH,
					);
					break;
				}
				case 2: {
					this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
					break;
				}
				case 3: {
					this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
					this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
				}
			}
		};
		Tokenizer2.prototype.stateBeforeNumericEntity = function (c) {
			if ((c | 32) === CharCodes.LowerX) {
				this.entityExcess++;
				this.state = State.InHexEntity;
			} else {
				this.state = State.InNumericEntity;
				this.stateInNumericEntity(c);
			}
		};
		Tokenizer2.prototype.emitNumericEntity = function (strict) {
			var entityStart = this.index - this.entityExcess - 1;
			var numberStart = entityStart + 2 + Number(this.state === State.InHexEntity);
			if (numberStart !== this.index) {
				if (entityStart > this.sectionStart) {
					this.emitPartial(this.sectionStart, entityStart);
				}
				this.sectionStart = this.index + Number(strict);
				this.emitCodePoint((0, decode_js_1.replaceCodePoint)(this.entityResult));
			}
			this.state = this.baseState;
		};
		Tokenizer2.prototype.stateInNumericEntity = function (c) {
			if (c === CharCodes.Semi) {
				this.emitNumericEntity(true);
			} else if (isNumber2(c)) {
				this.entityResult = this.entityResult * 10 + (c - CharCodes.Zero);
				this.entityExcess++;
			} else {
				if (this.allowLegacyEntity()) {
					this.emitNumericEntity(false);
				} else {
					this.state = this.baseState;
				}
				this.index--;
			}
		};
		Tokenizer2.prototype.stateInHexEntity = function (c) {
			if (c === CharCodes.Semi) {
				this.emitNumericEntity(true);
			} else if (isNumber2(c)) {
				this.entityResult = this.entityResult * 16 + (c - CharCodes.Zero);
				this.entityExcess++;
			} else if (isHexDigit(c)) {
				this.entityResult = this.entityResult * 16 + ((c | 32) - CharCodes.LowerA + 10);
				this.entityExcess++;
			} else {
				if (this.allowLegacyEntity()) {
					this.emitNumericEntity(false);
				} else {
					this.state = this.baseState;
				}
				this.index--;
			}
		};
		Tokenizer2.prototype.allowLegacyEntity = function () {
			return (
				!this.xmlMode && (this.baseState === State.Text || this.baseState === State.InSpecialTag)
			);
		};
		Tokenizer2.prototype.cleanup = function () {
			if (this.running && this.sectionStart !== this.index) {
				if (
					this.state === State.Text ||
					(this.state === State.InSpecialTag && this.sequenceIndex === 0)
				) {
					this.cbs.ontext(this.sectionStart, this.index);
					this.sectionStart = this.index;
				} else if (
					this.state === State.InAttributeValueDq ||
					this.state === State.InAttributeValueSq ||
					this.state === State.InAttributeValueNq
				) {
					this.cbs.onattribdata(this.sectionStart, this.index);
					this.sectionStart = this.index;
				}
			}
		};
		Tokenizer2.prototype.shouldContinue = function () {
			return this.index < this.buffer.length + this.offset && this.running;
		};
		Tokenizer2.prototype.parse = function () {
			while (this.shouldContinue()) {
				var c = this.buffer.charCodeAt(this.index - this.offset);
				switch (this.state) {
					case State.Text: {
						this.stateText(c);
						break;
					}
					case State.SpecialStartSequence: {
						this.stateSpecialStartSequence(c);
						break;
					}
					case State.InSpecialTag: {
						this.stateInSpecialTag(c);
						break;
					}
					case State.CDATASequence: {
						this.stateCDATASequence(c);
						break;
					}
					case State.InAttributeValueDq: {
						this.stateInAttributeValueDoubleQuotes(c);
						break;
					}
					case State.InAttributeName: {
						this.stateInAttributeName(c);
						break;
					}
					case State.InCommentLike: {
						this.stateInCommentLike(c);
						break;
					}
					case State.InSpecialComment: {
						this.stateInSpecialComment(c);
						break;
					}
					case State.BeforeAttributeName: {
						this.stateBeforeAttributeName(c);
						break;
					}
					case State.InTagName: {
						this.stateInTagName(c);
						break;
					}
					case State.InClosingTagName: {
						this.stateInClosingTagName(c);
						break;
					}
					case State.BeforeTagName: {
						this.stateBeforeTagName(c);
						break;
					}
					case State.AfterAttributeName: {
						this.stateAfterAttributeName(c);
						break;
					}
					case State.InAttributeValueSq: {
						this.stateInAttributeValueSingleQuotes(c);
						break;
					}
					case State.BeforeAttributeValue: {
						this.stateBeforeAttributeValue(c);
						break;
					}
					case State.BeforeClosingTagName: {
						this.stateBeforeClosingTagName(c);
						break;
					}
					case State.AfterClosingTagName: {
						this.stateAfterClosingTagName(c);
						break;
					}
					case State.BeforeSpecialS: {
						this.stateBeforeSpecialS(c);
						break;
					}
					case State.InAttributeValueNq: {
						this.stateInAttributeValueNoQuotes(c);
						break;
					}
					case State.InSelfClosingTag: {
						this.stateInSelfClosingTag(c);
						break;
					}
					case State.InDeclaration: {
						this.stateInDeclaration(c);
						break;
					}
					case State.BeforeDeclaration: {
						this.stateBeforeDeclaration(c);
						break;
					}
					case State.BeforeComment: {
						this.stateBeforeComment(c);
						break;
					}
					case State.InProcessingInstruction: {
						this.stateInProcessingInstruction(c);
						break;
					}
					case State.InNamedEntity: {
						this.stateInNamedEntity(c);
						break;
					}
					case State.BeforeEntity: {
						this.stateBeforeEntity(c);
						break;
					}
					case State.InHexEntity: {
						this.stateInHexEntity(c);
						break;
					}
					case State.InNumericEntity: {
						this.stateInNumericEntity(c);
						break;
					}
					default: {
						this.stateBeforeNumericEntity(c);
					}
				}
				this.index++;
			}
			this.cleanup();
		};
		Tokenizer2.prototype.finish = function () {
			if (this.state === State.InNamedEntity) {
				this.emitNamedEntity();
			}
			if (this.sectionStart < this.index) {
				this.handleTrailingData();
			}
			this.cbs.onend();
		};
		Tokenizer2.prototype.handleTrailingData = function () {
			var endIndex = this.buffer.length + this.offset;
			if (this.state === State.InCommentLike) {
				if (this.currentSequence === Sequences.CdataEnd) {
					this.cbs.oncdata(this.sectionStart, endIndex, 0);
				} else {
					this.cbs.oncomment(this.sectionStart, endIndex, 0);
				}
			} else if (this.state === State.InNumericEntity && this.allowLegacyEntity()) {
				this.emitNumericEntity(false);
			} else if (this.state === State.InHexEntity && this.allowLegacyEntity()) {
				this.emitNumericEntity(false);
			} else if (
				this.state === State.InTagName ||
				this.state === State.BeforeAttributeName ||
				this.state === State.BeforeAttributeValue ||
				this.state === State.AfterAttributeName ||
				this.state === State.InAttributeName ||
				this.state === State.InAttributeValueSq ||
				this.state === State.InAttributeValueDq ||
				this.state === State.InAttributeValueNq ||
				this.state === State.InClosingTagName
			) {
			} else {
				this.cbs.ontext(this.sectionStart, endIndex);
			}
		};
		Tokenizer2.prototype.emitPartial = function (start, endIndex) {
			if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
				this.cbs.onattribdata(start, endIndex);
			} else {
				this.cbs.ontext(start, endIndex);
			}
		};
		Tokenizer2.prototype.emitCodePoint = function (cp) {
			if (this.baseState !== State.Text && this.baseState !== State.InSpecialTag) {
				this.cbs.onattribentity(cp);
			} else {
				this.cbs.ontextentity(cp);
			}
		};
		return Tokenizer2;
	})();
	exports.default = Tokenizer;
});

// node_modules/htmlparser2/lib/Parser.js
var require_Parser = __commonJS((exports) => {
	var __createBinding =
		(exports && exports.__createBinding) ||
		(Object.create
			? function (o, m2, k2, k22) {
					if (k22 === undefined) k22 = k2;
					var desc = Object.getOwnPropertyDescriptor(m2, k2);
					if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
						desc = {
							enumerable: true,
							get: function () {
								return m2[k2];
							},
						};
					}
					Object.defineProperty(o, k22, desc);
				}
			: function (o, m2, k2, k22) {
					if (k22 === undefined) k22 = k2;
					o[k22] = m2[k2];
				});
	var __setModuleDefault =
		(exports && exports.__setModuleDefault) ||
		(Object.create
			? function (o, v) {
					Object.defineProperty(o, "default", { enumerable: true, value: v });
				}
			: function (o, v) {
					o["default"] = v;
				});
	var __importStar =
		(exports && exports.__importStar) ||
		function (mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k2 in mod)
					if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
						__createBinding(result, mod, k2);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Parser = undefined;
	var Tokenizer_js_1 = __importStar(require_Tokenizer());
	var decode_js_1 = require_decode2();
	var formTags = new Set([
		"input",
		"option",
		"optgroup",
		"select",
		"button",
		"datalist",
		"textarea",
	]);
	var pTag = new Set(["p"]);
	var tableSectionTags = new Set(["thead", "tbody"]);
	var ddtTags = new Set(["dd", "dt"]);
	var rtpTags = new Set(["rt", "rp"]);
	var openImpliesClose = new Map([
		["tr", new Set(["tr", "th", "td"])],
		["th", new Set(["th"])],
		["td", new Set(["thead", "th", "td"])],
		["body", new Set(["head", "link", "script"])],
		["li", new Set(["li"])],
		["p", pTag],
		["h1", pTag],
		["h2", pTag],
		["h3", pTag],
		["h4", pTag],
		["h5", pTag],
		["h6", pTag],
		["select", formTags],
		["input", formTags],
		["output", formTags],
		["button", formTags],
		["datalist", formTags],
		["textarea", formTags],
		["option", new Set(["option"])],
		["optgroup", new Set(["optgroup", "option"])],
		["dd", ddtTags],
		["dt", ddtTags],
		["address", pTag],
		["article", pTag],
		["aside", pTag],
		["blockquote", pTag],
		["details", pTag],
		["div", pTag],
		["dl", pTag],
		["fieldset", pTag],
		["figcaption", pTag],
		["figure", pTag],
		["footer", pTag],
		["form", pTag],
		["header", pTag],
		["hr", pTag],
		["main", pTag],
		["nav", pTag],
		["ol", pTag],
		["pre", pTag],
		["section", pTag],
		["table", pTag],
		["ul", pTag],
		["rt", rtpTags],
		["rp", rtpTags],
		["tbody", tableSectionTags],
		["tfoot", tableSectionTags],
	]);
	var voidElements = new Set([
		"area",
		"base",
		"basefont",
		"br",
		"col",
		"command",
		"embed",
		"frame",
		"hr",
		"img",
		"input",
		"isindex",
		"keygen",
		"link",
		"meta",
		"param",
		"source",
		"track",
		"wbr",
	]);
	var foreignContextElements = new Set(["math", "svg"]);
	var htmlIntegrationElements = new Set([
		"mi",
		"mo",
		"mn",
		"ms",
		"mtext",
		"annotation-xml",
		"foreignobject",
		"desc",
		"title",
	]);
	var reNameEnd = /\s|\//;
	var Parser = (function () {
		function Parser2(cbs, options) {
			if (options === undefined) {
				options = {};
			}
			var _a, _b, _c, _d, _e;
			this.options = options;
			this.startIndex = 0;
			this.endIndex = 0;
			this.openTagStart = 0;
			this.tagname = "";
			this.attribname = "";
			this.attribvalue = "";
			this.attribs = null;
			this.stack = [];
			this.foreignContext = [];
			this.buffers = [];
			this.bufferOffset = 0;
			this.writeIndex = 0;
			this.ended = false;
			this.cbs = cbs !== null && cbs !== undefined ? cbs : {};
			this.lowerCaseTagNames =
				(_a = options.lowerCaseTags) !== null && _a !== undefined ? _a : !options.xmlMode;
			this.lowerCaseAttributeNames =
				(_b = options.lowerCaseAttributeNames) !== null && _b !== undefined ? _b : !options.xmlMode;
			this.tokenizer = new (
				(_c = options.Tokenizer) !== null && _c !== undefined ? _c : Tokenizer_js_1.default
			)(this.options, this);
			(_e = (_d = this.cbs).onparserinit) === null || _e === undefined || _e.call(_d, this);
		}
		Parser2.prototype.ontext = function (start, endIndex) {
			var _a, _b;
			var data = this.getSlice(start, endIndex);
			this.endIndex = endIndex - 1;
			(_b = (_a = this.cbs).ontext) === null || _b === undefined || _b.call(_a, data);
			this.startIndex = endIndex;
		};
		Parser2.prototype.ontextentity = function (cp) {
			var _a, _b;
			var index = this.tokenizer.getSectionStart();
			this.endIndex = index - 1;
			(_b = (_a = this.cbs).ontext) === null ||
				_b === undefined ||
				_b.call(_a, (0, decode_js_1.fromCodePoint)(cp));
			this.startIndex = index;
		};
		Parser2.prototype.isVoidElement = function (name) {
			return !this.options.xmlMode && voidElements.has(name);
		};
		Parser2.prototype.onopentagname = function (start, endIndex) {
			this.endIndex = endIndex;
			var name = this.getSlice(start, endIndex);
			if (this.lowerCaseTagNames) {
				name = name.toLowerCase();
			}
			this.emitOpenTag(name);
		};
		Parser2.prototype.emitOpenTag = function (name) {
			var _a, _b, _c, _d;
			this.openTagStart = this.startIndex;
			this.tagname = name;
			var impliesClose = !this.options.xmlMode && openImpliesClose.get(name);
			if (impliesClose) {
				while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
					var element = this.stack.pop();
					(_b = (_a = this.cbs).onclosetag) === null ||
						_b === undefined ||
						_b.call(_a, element, true);
				}
			}
			if (!this.isVoidElement(name)) {
				this.stack.push(name);
				if (foreignContextElements.has(name)) {
					this.foreignContext.push(true);
				} else if (htmlIntegrationElements.has(name)) {
					this.foreignContext.push(false);
				}
			}
			(_d = (_c = this.cbs).onopentagname) === null || _d === undefined || _d.call(_c, name);
			if (this.cbs.onopentag) this.attribs = {};
		};
		Parser2.prototype.endOpenTag = function (isImplied) {
			var _a, _b;
			this.startIndex = this.openTagStart;
			if (this.attribs) {
				(_b = (_a = this.cbs).onopentag) === null ||
					_b === undefined ||
					_b.call(_a, this.tagname, this.attribs, isImplied);
				this.attribs = null;
			}
			if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
				this.cbs.onclosetag(this.tagname, true);
			}
			this.tagname = "";
		};
		Parser2.prototype.onopentagend = function (endIndex) {
			this.endIndex = endIndex;
			this.endOpenTag(false);
			this.startIndex = endIndex + 1;
		};
		Parser2.prototype.onclosetag = function (start, endIndex) {
			var _a, _b, _c, _d, _e, _f;
			this.endIndex = endIndex;
			var name = this.getSlice(start, endIndex);
			if (this.lowerCaseTagNames) {
				name = name.toLowerCase();
			}
			if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
				this.foreignContext.pop();
			}
			if (!this.isVoidElement(name)) {
				var pos = this.stack.lastIndexOf(name);
				if (pos !== -1) {
					if (this.cbs.onclosetag) {
						var count = this.stack.length - pos;
						while (count--) {
							this.cbs.onclosetag(this.stack.pop(), count !== 0);
						}
					} else this.stack.length = pos;
				} else if (!this.options.xmlMode && name === "p") {
					this.emitOpenTag("p");
					this.closeCurrentTag(true);
				}
			} else if (!this.options.xmlMode && name === "br") {
				(_b = (_a = this.cbs).onopentagname) === null || _b === undefined || _b.call(_a, "br");
				(_d = (_c = this.cbs).onopentag) === null ||
					_d === undefined ||
					_d.call(_c, "br", {}, true);
				(_f = (_e = this.cbs).onclosetag) === null || _f === undefined || _f.call(_e, "br", false);
			}
			this.startIndex = endIndex + 1;
		};
		Parser2.prototype.onselfclosingtag = function (endIndex) {
			this.endIndex = endIndex;
			if (
				this.options.xmlMode ||
				this.options.recognizeSelfClosing ||
				this.foreignContext[this.foreignContext.length - 1]
			) {
				this.closeCurrentTag(false);
				this.startIndex = endIndex + 1;
			} else {
				this.onopentagend(endIndex);
			}
		};
		Parser2.prototype.closeCurrentTag = function (isOpenImplied) {
			var _a, _b;
			var name = this.tagname;
			this.endOpenTag(isOpenImplied);
			if (this.stack[this.stack.length - 1] === name) {
				(_b = (_a = this.cbs).onclosetag) === null ||
					_b === undefined ||
					_b.call(_a, name, !isOpenImplied);
				this.stack.pop();
			}
		};
		Parser2.prototype.onattribname = function (start, endIndex) {
			this.startIndex = start;
			var name = this.getSlice(start, endIndex);
			this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;
		};
		Parser2.prototype.onattribdata = function (start, endIndex) {
			this.attribvalue += this.getSlice(start, endIndex);
		};
		Parser2.prototype.onattribentity = function (cp) {
			this.attribvalue += (0, decode_js_1.fromCodePoint)(cp);
		};
		Parser2.prototype.onattribend = function (quote, endIndex) {
			var _a, _b;
			this.endIndex = endIndex;
			(_b = (_a = this.cbs).onattribute) === null ||
				_b === undefined ||
				_b.call(
					_a,
					this.attribname,
					this.attribvalue,
					quote === Tokenizer_js_1.QuoteType.Double
						? '"'
						: quote === Tokenizer_js_1.QuoteType.Single
							? "'"
							: quote === Tokenizer_js_1.QuoteType.NoValue
								? undefined
								: null,
				);
			if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
				this.attribs[this.attribname] = this.attribvalue;
			}
			this.attribvalue = "";
		};
		Parser2.prototype.getInstructionName = function (value) {
			var index = value.search(reNameEnd);
			var name = index < 0 ? value : value.substr(0, index);
			if (this.lowerCaseTagNames) {
				name = name.toLowerCase();
			}
			return name;
		};
		Parser2.prototype.ondeclaration = function (start, endIndex) {
			this.endIndex = endIndex;
			var value = this.getSlice(start, endIndex);
			if (this.cbs.onprocessinginstruction) {
				var name = this.getInstructionName(value);
				this.cbs.onprocessinginstruction("!".concat(name), "!".concat(value));
			}
			this.startIndex = endIndex + 1;
		};
		Parser2.prototype.onprocessinginstruction = function (start, endIndex) {
			this.endIndex = endIndex;
			var value = this.getSlice(start, endIndex);
			if (this.cbs.onprocessinginstruction) {
				var name = this.getInstructionName(value);
				this.cbs.onprocessinginstruction("?".concat(name), "?".concat(value));
			}
			this.startIndex = endIndex + 1;
		};
		Parser2.prototype.oncomment = function (start, endIndex, offset) {
			var _a, _b, _c, _d;
			this.endIndex = endIndex;
			(_b = (_a = this.cbs).oncomment) === null ||
				_b === undefined ||
				_b.call(_a, this.getSlice(start, endIndex - offset));
			(_d = (_c = this.cbs).oncommentend) === null || _d === undefined || _d.call(_c);
			this.startIndex = endIndex + 1;
		};
		Parser2.prototype.oncdata = function (start, endIndex, offset) {
			var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
			this.endIndex = endIndex;
			var value = this.getSlice(start, endIndex - offset);
			if (this.options.xmlMode || this.options.recognizeCDATA) {
				(_b = (_a = this.cbs).oncdatastart) === null || _b === undefined || _b.call(_a);
				(_d = (_c = this.cbs).ontext) === null || _d === undefined || _d.call(_c, value);
				(_f = (_e = this.cbs).oncdataend) === null || _f === undefined || _f.call(_e);
			} else {
				(_h = (_g = this.cbs).oncomment) === null ||
					_h === undefined ||
					_h.call(_g, "[CDATA[".concat(value, "]]"));
				(_k = (_j = this.cbs).oncommentend) === null || _k === undefined || _k.call(_j);
			}
			this.startIndex = endIndex + 1;
		};
		Parser2.prototype.onend = function () {
			var _a, _b;
			if (this.cbs.onclosetag) {
				this.endIndex = this.startIndex;
				for (
					var index = this.stack.length;
					index > 0;
					this.cbs.onclosetag(this.stack[--index], true)
				);
			}
			(_b = (_a = this.cbs).onend) === null || _b === undefined || _b.call(_a);
		};
		Parser2.prototype.reset = function () {
			var _a, _b, _c, _d;
			(_b = (_a = this.cbs).onreset) === null || _b === undefined || _b.call(_a);
			this.tokenizer.reset();
			this.tagname = "";
			this.attribname = "";
			this.attribs = null;
			this.stack.length = 0;
			this.startIndex = 0;
			this.endIndex = 0;
			(_d = (_c = this.cbs).onparserinit) === null || _d === undefined || _d.call(_c, this);
			this.buffers.length = 0;
			this.bufferOffset = 0;
			this.writeIndex = 0;
			this.ended = false;
		};
		Parser2.prototype.parseComplete = function (data) {
			this.reset();
			this.end(data);
		};
		Parser2.prototype.getSlice = function (start, end) {
			while (start - this.bufferOffset >= this.buffers[0].length) {
				this.shiftBuffer();
			}
			var slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
			while (end - this.bufferOffset > this.buffers[0].length) {
				this.shiftBuffer();
				slice += this.buffers[0].slice(0, end - this.bufferOffset);
			}
			return slice;
		};
		Parser2.prototype.shiftBuffer = function () {
			this.bufferOffset += this.buffers[0].length;
			this.writeIndex--;
			this.buffers.shift();
		};
		Parser2.prototype.write = function (chunk) {
			var _a, _b;
			if (this.ended) {
				(_b = (_a = this.cbs).onerror) === null ||
					_b === undefined ||
					_b.call(_a, new Error(".write() after done!"));
				return;
			}
			this.buffers.push(chunk);
			if (this.tokenizer.running) {
				this.tokenizer.write(chunk);
				this.writeIndex++;
			}
		};
		Parser2.prototype.end = function (chunk) {
			var _a, _b;
			if (this.ended) {
				(_b = (_a = this.cbs).onerror) === null ||
					_b === undefined ||
					_b.call(_a, new Error(".end() after done!"));
				return;
			}
			if (chunk) this.write(chunk);
			this.ended = true;
			this.tokenizer.end();
		};
		Parser2.prototype.pause = function () {
			this.tokenizer.pause();
		};
		Parser2.prototype.resume = function () {
			this.tokenizer.resume();
			while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
				this.tokenizer.write(this.buffers[this.writeIndex++]);
			}
			if (this.ended) this.tokenizer.end();
		};
		Parser2.prototype.parseChunk = function (chunk) {
			this.write(chunk);
		};
		Parser2.prototype.done = function (chunk) {
			this.end(chunk);
		};
		return Parser2;
	})();
	exports.Parser = Parser;
});

// node_modules/domelementtype/lib/index.js
var require_lib = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Doctype =
		exports.CDATA =
		exports.Tag =
		exports.Style =
		exports.Script =
		exports.Comment =
		exports.Directive =
		exports.Text =
		exports.Root =
		exports.isTag =
		exports.ElementType =
			undefined;
	var ElementType;
	(function (ElementType2) {
		ElementType2["Root"] = "root";
		ElementType2["Text"] = "text";
		ElementType2["Directive"] = "directive";
		ElementType2["Comment"] = "comment";
		ElementType2["Script"] = "script";
		ElementType2["Style"] = "style";
		ElementType2["Tag"] = "tag";
		ElementType2["CDATA"] = "cdata";
		ElementType2["Doctype"] = "doctype";
	})((ElementType = exports.ElementType || (exports.ElementType = {})));
	function isTag(elem) {
		return (
			elem.type === ElementType.Tag ||
			elem.type === ElementType.Script ||
			elem.type === ElementType.Style
		);
	}
	exports.isTag = isTag;
	exports.Root = ElementType.Root;
	exports.Text = ElementType.Text;
	exports.Directive = ElementType.Directive;
	exports.Comment = ElementType.Comment;
	exports.Script = ElementType.Script;
	exports.Style = ElementType.Style;
	exports.Tag = ElementType.Tag;
	exports.CDATA = ElementType.CDATA;
	exports.Doctype = ElementType.Doctype;
});

// node_modules/domhandler/lib/node.js
var require_node2 = __commonJS((exports) => {
	var __extends =
		(exports && exports.__extends) ||
		(function () {
			var extendStatics = function (d, b) {
				extendStatics =
					Object.setPrototypeOf ||
					({ __proto__: [] } instanceof Array &&
						function (d2, b2) {
							d2.__proto__ = b2;
						}) ||
					function (d2, b2) {
						for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
					};
				return extendStatics(d, b);
			};
			return function (d, b) {
				if (typeof b !== "function" && b !== null)
					throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
				extendStatics(d, b);
				function __() {
					this.constructor = d;
				}
				d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
			};
		})();
	var __assign =
		(exports && exports.__assign) ||
		function () {
			__assign =
				Object.assign ||
				function (t2) {
					for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
						s = arguments[i];
						for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t2[p] = s[p];
					}
					return t2;
				};
			return __assign.apply(this, arguments);
		};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.cloneNode =
		exports.hasChildren =
		exports.isDocument =
		exports.isDirective =
		exports.isComment =
		exports.isText =
		exports.isCDATA =
		exports.isTag =
		exports.Element =
		exports.Document =
		exports.CDATA =
		exports.NodeWithChildren =
		exports.ProcessingInstruction =
		exports.Comment =
		exports.Text =
		exports.DataNode =
		exports.Node =
			undefined;
	var domelementtype_1 = require_lib();
	var Node = (function () {
		function Node2() {
			this.parent = null;
			this.prev = null;
			this.next = null;
			this.startIndex = null;
			this.endIndex = null;
		}
		Object.defineProperty(Node2.prototype, "parentNode", {
			get: function () {
				return this.parent;
			},
			set: function (parent) {
				this.parent = parent;
			},
			enumerable: false,
			configurable: true,
		});
		Object.defineProperty(Node2.prototype, "previousSibling", {
			get: function () {
				return this.prev;
			},
			set: function (prev) {
				this.prev = prev;
			},
			enumerable: false,
			configurable: true,
		});
		Object.defineProperty(Node2.prototype, "nextSibling", {
			get: function () {
				return this.next;
			},
			set: function (next) {
				this.next = next;
			},
			enumerable: false,
			configurable: true,
		});
		Node2.prototype.cloneNode = function (recursive) {
			if (recursive === undefined) {
				recursive = false;
			}
			return cloneNode(this, recursive);
		};
		return Node2;
	})();
	exports.Node = Node;
	var DataNode = (function (_super) {
		__extends(DataNode2, _super);
		function DataNode2(data) {
			var _this = _super.call(this) || this;
			_this.data = data;
			return _this;
		}
		Object.defineProperty(DataNode2.prototype, "nodeValue", {
			get: function () {
				return this.data;
			},
			set: function (data) {
				this.data = data;
			},
			enumerable: false,
			configurable: true,
		});
		return DataNode2;
	})(Node);
	exports.DataNode = DataNode;
	var Text = (function (_super) {
		__extends(Text2, _super);
		function Text2() {
			var _this = (_super !== null && _super.apply(this, arguments)) || this;
			_this.type = domelementtype_1.ElementType.Text;
			return _this;
		}
		Object.defineProperty(Text2.prototype, "nodeType", {
			get: function () {
				return 3;
			},
			enumerable: false,
			configurable: true,
		});
		return Text2;
	})(DataNode);
	exports.Text = Text;
	var Comment = (function (_super) {
		__extends(Comment2, _super);
		function Comment2() {
			var _this = (_super !== null && _super.apply(this, arguments)) || this;
			_this.type = domelementtype_1.ElementType.Comment;
			return _this;
		}
		Object.defineProperty(Comment2.prototype, "nodeType", {
			get: function () {
				return 8;
			},
			enumerable: false,
			configurable: true,
		});
		return Comment2;
	})(DataNode);
	exports.Comment = Comment;
	var ProcessingInstruction = (function (_super) {
		__extends(ProcessingInstruction2, _super);
		function ProcessingInstruction2(name, data) {
			var _this = _super.call(this, data) || this;
			_this.name = name;
			_this.type = domelementtype_1.ElementType.Directive;
			return _this;
		}
		Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
			get: function () {
				return 1;
			},
			enumerable: false,
			configurable: true,
		});
		return ProcessingInstruction2;
	})(DataNode);
	exports.ProcessingInstruction = ProcessingInstruction;
	var NodeWithChildren = (function (_super) {
		__extends(NodeWithChildren2, _super);
		function NodeWithChildren2(children) {
			var _this = _super.call(this) || this;
			_this.children = children;
			return _this;
		}
		Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
			get: function () {
				var _a;
				return (_a = this.children[0]) !== null && _a !== undefined ? _a : null;
			},
			enumerable: false,
			configurable: true,
		});
		Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
			get: function () {
				return this.children.length > 0 ? this.children[this.children.length - 1] : null;
			},
			enumerable: false,
			configurable: true,
		});
		Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
			get: function () {
				return this.children;
			},
			set: function (children) {
				this.children = children;
			},
			enumerable: false,
			configurable: true,
		});
		return NodeWithChildren2;
	})(Node);
	exports.NodeWithChildren = NodeWithChildren;
	var CDATA = (function (_super) {
		__extends(CDATA2, _super);
		function CDATA2() {
			var _this = (_super !== null && _super.apply(this, arguments)) || this;
			_this.type = domelementtype_1.ElementType.CDATA;
			return _this;
		}
		Object.defineProperty(CDATA2.prototype, "nodeType", {
			get: function () {
				return 4;
			},
			enumerable: false,
			configurable: true,
		});
		return CDATA2;
	})(NodeWithChildren);
	exports.CDATA = CDATA;
	var Document = (function (_super) {
		__extends(Document2, _super);
		function Document2() {
			var _this = (_super !== null && _super.apply(this, arguments)) || this;
			_this.type = domelementtype_1.ElementType.Root;
			return _this;
		}
		Object.defineProperty(Document2.prototype, "nodeType", {
			get: function () {
				return 9;
			},
			enumerable: false,
			configurable: true,
		});
		return Document2;
	})(NodeWithChildren);
	exports.Document = Document;
	var Element = (function (_super) {
		__extends(Element2, _super);
		function Element2(name, attribs, children, type) {
			if (children === undefined) {
				children = [];
			}
			if (type === undefined) {
				type =
					name === "script"
						? domelementtype_1.ElementType.Script
						: name === "style"
							? domelementtype_1.ElementType.Style
							: domelementtype_1.ElementType.Tag;
			}
			var _this = _super.call(this, children) || this;
			_this.name = name;
			_this.attribs = attribs;
			_this.type = type;
			return _this;
		}
		Object.defineProperty(Element2.prototype, "nodeType", {
			get: function () {
				return 1;
			},
			enumerable: false,
			configurable: true,
		});
		Object.defineProperty(Element2.prototype, "tagName", {
			get: function () {
				return this.name;
			},
			set: function (name) {
				this.name = name;
			},
			enumerable: false,
			configurable: true,
		});
		Object.defineProperty(Element2.prototype, "attributes", {
			get: function () {
				var _this = this;
				return Object.keys(this.attribs).map(function (name) {
					var _a, _b;
					return {
						name,
						value: _this.attribs[name],
						namespace:
							(_a = _this["x-attribsNamespace"]) === null || _a === undefined
								? undefined
								: _a[name],
						prefix:
							(_b = _this["x-attribsPrefix"]) === null || _b === undefined ? undefined : _b[name],
					};
				});
			},
			enumerable: false,
			configurable: true,
		});
		return Element2;
	})(NodeWithChildren);
	exports.Element = Element;
	function isTag(node) {
		return (0, domelementtype_1.isTag)(node);
	}
	exports.isTag = isTag;
	function isCDATA(node) {
		return node.type === domelementtype_1.ElementType.CDATA;
	}
	exports.isCDATA = isCDATA;
	function isText(node) {
		return node.type === domelementtype_1.ElementType.Text;
	}
	exports.isText = isText;
	function isComment(node) {
		return node.type === domelementtype_1.ElementType.Comment;
	}
	exports.isComment = isComment;
	function isDirective(node) {
		return node.type === domelementtype_1.ElementType.Directive;
	}
	exports.isDirective = isDirective;
	function isDocument(node) {
		return node.type === domelementtype_1.ElementType.Root;
	}
	exports.isDocument = isDocument;
	function hasChildren(node) {
		return Object.prototype.hasOwnProperty.call(node, "children");
	}
	exports.hasChildren = hasChildren;
	function cloneNode(node, recursive) {
		if (recursive === undefined) {
			recursive = false;
		}
		var result;
		if (isText(node)) {
			result = new Text(node.data);
		} else if (isComment(node)) {
			result = new Comment(node.data);
		} else if (isTag(node)) {
			var children = recursive ? cloneChildren(node.children) : [];
			var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
			children.forEach(function (child) {
				return (child.parent = clone_1);
			});
			if (node.namespace != null) {
				clone_1.namespace = node.namespace;
			}
			if (node["x-attribsNamespace"]) {
				clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
			}
			if (node["x-attribsPrefix"]) {
				clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
			}
			result = clone_1;
		} else if (isCDATA(node)) {
			var children = recursive ? cloneChildren(node.children) : [];
			var clone_2 = new CDATA(children);
			children.forEach(function (child) {
				return (child.parent = clone_2);
			});
			result = clone_2;
		} else if (isDocument(node)) {
			var children = recursive ? cloneChildren(node.children) : [];
			var clone_3 = new Document(children);
			children.forEach(function (child) {
				return (child.parent = clone_3);
			});
			if (node["x-mode"]) {
				clone_3["x-mode"] = node["x-mode"];
			}
			result = clone_3;
		} else if (isDirective(node)) {
			var instruction = new ProcessingInstruction(node.name, node.data);
			if (node["x-name"] != null) {
				instruction["x-name"] = node["x-name"];
				instruction["x-publicId"] = node["x-publicId"];
				instruction["x-systemId"] = node["x-systemId"];
			}
			result = instruction;
		} else {
			throw new Error("Not implemented yet: ".concat(node.type));
		}
		result.startIndex = node.startIndex;
		result.endIndex = node.endIndex;
		if (node.sourceCodeLocation != null) {
			result.sourceCodeLocation = node.sourceCodeLocation;
		}
		return result;
	}
	exports.cloneNode = cloneNode;
	function cloneChildren(childs) {
		var children = childs.map(function (child) {
			return cloneNode(child, true);
		});
		for (var i = 1; i < children.length; i++) {
			children[i].prev = children[i - 1];
			children[i - 1].next = children[i];
		}
		return children;
	}
});

// node_modules/domhandler/lib/index.js
var require_lib2 = __commonJS((exports) => {
	var __createBinding =
		(exports && exports.__createBinding) ||
		(Object.create
			? function (o, m2, k2, k22) {
					if (k22 === undefined) k22 = k2;
					var desc = Object.getOwnPropertyDescriptor(m2, k2);
					if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
						desc = {
							enumerable: true,
							get: function () {
								return m2[k2];
							},
						};
					}
					Object.defineProperty(o, k22, desc);
				}
			: function (o, m2, k2, k22) {
					if (k22 === undefined) k22 = k2;
					o[k22] = m2[k2];
				});
	var __exportStar =
		(exports && exports.__exportStar) ||
		function (m2, exports2) {
			for (var p in m2)
				if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
					__createBinding(exports2, m2, p);
		};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DomHandler = undefined;
	var domelementtype_1 = require_lib();
	var node_js_1 = require_node2();
	__exportStar(require_node2(), exports);
	var defaultOpts = {
		withStartIndices: false,
		withEndIndices: false,
		xmlMode: false,
	};
	var DomHandler = (function () {
		function DomHandler2(callback, options, elementCB) {
			this.dom = [];
			this.root = new node_js_1.Document(this.dom);
			this.done = false;
			this.tagStack = [this.root];
			this.lastNode = null;
			this.parser = null;
			if (typeof options === "function") {
				elementCB = options;
				options = defaultOpts;
			}
			if (typeof callback === "object") {
				options = callback;
				callback = undefined;
			}
			this.callback = callback !== null && callback !== undefined ? callback : null;
			this.options = options !== null && options !== undefined ? options : defaultOpts;
			this.elementCB = elementCB !== null && elementCB !== undefined ? elementCB : null;
		}
		DomHandler2.prototype.onparserinit = function (parser) {
			this.parser = parser;
		};
		DomHandler2.prototype.onreset = function () {
			this.dom = [];
			this.root = new node_js_1.Document(this.dom);
			this.done = false;
			this.tagStack = [this.root];
			this.lastNode = null;
			this.parser = null;
		};
		DomHandler2.prototype.onend = function () {
			if (this.done) return;
			this.done = true;
			this.parser = null;
			this.handleCallback(null);
		};
		DomHandler2.prototype.onerror = function (error) {
			this.handleCallback(error);
		};
		DomHandler2.prototype.onclosetag = function () {
			this.lastNode = null;
			var elem = this.tagStack.pop();
			if (this.options.withEndIndices) {
				elem.endIndex = this.parser.endIndex;
			}
			if (this.elementCB) this.elementCB(elem);
		};
		DomHandler2.prototype.onopentag = function (name, attribs) {
			var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;
			var element = new node_js_1.Element(name, attribs, undefined, type);
			this.addNode(element);
			this.tagStack.push(element);
		};
		DomHandler2.prototype.ontext = function (data) {
			var lastNode = this.lastNode;
			if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
				lastNode.data += data;
				if (this.options.withEndIndices) {
					lastNode.endIndex = this.parser.endIndex;
				}
			} else {
				var node = new node_js_1.Text(data);
				this.addNode(node);
				this.lastNode = node;
			}
		};
		DomHandler2.prototype.oncomment = function (data) {
			if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
				this.lastNode.data += data;
				return;
			}
			var node = new node_js_1.Comment(data);
			this.addNode(node);
			this.lastNode = node;
		};
		DomHandler2.prototype.oncommentend = function () {
			this.lastNode = null;
		};
		DomHandler2.prototype.oncdatastart = function () {
			var text = new node_js_1.Text("");
			var node = new node_js_1.CDATA([text]);
			this.addNode(node);
			text.parent = node;
			this.lastNode = text;
		};
		DomHandler2.prototype.oncdataend = function () {
			this.lastNode = null;
		};
		DomHandler2.prototype.onprocessinginstruction = function (name, data) {
			var node = new node_js_1.ProcessingInstruction(name, data);
			this.addNode(node);
		};
		DomHandler2.prototype.handleCallback = function (error) {
			if (typeof this.callback === "function") {
				this.callback(error, this.dom);
			} else if (error) {
				throw error;
			}
		};
		DomHandler2.prototype.addNode = function (node) {
			var parent = this.tagStack[this.tagStack.length - 1];
			var previousSibling = parent.children[parent.children.length - 1];
			if (this.options.withStartIndices) {
				node.startIndex = this.parser.startIndex;
			}
			if (this.options.withEndIndices) {
				node.endIndex = this.parser.endIndex;
			}
			parent.children.push(node);
			if (previousSibling) {
				node.prev = previousSibling;
				previousSibling.next = node;
			}
			node.parent = parent;
			this.lastNode = null;
		};
		return DomHandler2;
	})();
	exports.DomHandler = DomHandler;
	exports.default = DomHandler;
});

// node_modules/entities/lib/generated/encode-html.js
var require_encode_html = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function restoreDiff(arr) {
		for (var i = 1; i < arr.length; i++) {
			arr[i][0] += arr[i - 1][0] + 1;
		}
		return arr;
	}
	exports.default = new Map(
		/* @__PURE__ */ restoreDiff([
			[9, "&Tab;"],
			[0, "&NewLine;"],
			[22, "&excl;"],
			[0, "&quot;"],
			[0, "&num;"],
			[0, "&dollar;"],
			[0, "&percnt;"],
			[0, "&amp;"],
			[0, "&apos;"],
			[0, "&lpar;"],
			[0, "&rpar;"],
			[0, "&ast;"],
			[0, "&plus;"],
			[0, "&comma;"],
			[1, "&period;"],
			[0, "&sol;"],
			[10, "&colon;"],
			[0, "&semi;"],
			[0, { v: "&lt;", n: 8402, o: "&nvlt;" }],
			[0, { v: "&equals;", n: 8421, o: "&bne;" }],
			[0, { v: "&gt;", n: 8402, o: "&nvgt;" }],
			[0, "&quest;"],
			[0, "&commat;"],
			[26, "&lbrack;"],
			[0, "&bsol;"],
			[0, "&rbrack;"],
			[0, "&Hat;"],
			[0, "&lowbar;"],
			[0, "&DiacriticalGrave;"],
			[5, { n: 106, o: "&fjlig;" }],
			[20, "&lbrace;"],
			[0, "&verbar;"],
			[0, "&rbrace;"],
			[34, "&nbsp;"],
			[0, "&iexcl;"],
			[0, "&cent;"],
			[0, "&pound;"],
			[0, "&curren;"],
			[0, "&yen;"],
			[0, "&brvbar;"],
			[0, "&sect;"],
			[0, "&die;"],
			[0, "&copy;"],
			[0, "&ordf;"],
			[0, "&laquo;"],
			[0, "&not;"],
			[0, "&shy;"],
			[0, "&circledR;"],
			[0, "&macr;"],
			[0, "&deg;"],
			[0, "&PlusMinus;"],
			[0, "&sup2;"],
			[0, "&sup3;"],
			[0, "&acute;"],
			[0, "&micro;"],
			[0, "&para;"],
			[0, "&centerdot;"],
			[0, "&cedil;"],
			[0, "&sup1;"],
			[0, "&ordm;"],
			[0, "&raquo;"],
			[0, "&frac14;"],
			[0, "&frac12;"],
			[0, "&frac34;"],
			[0, "&iquest;"],
			[0, "&Agrave;"],
			[0, "&Aacute;"],
			[0, "&Acirc;"],
			[0, "&Atilde;"],
			[0, "&Auml;"],
			[0, "&angst;"],
			[0, "&AElig;"],
			[0, "&Ccedil;"],
			[0, "&Egrave;"],
			[0, "&Eacute;"],
			[0, "&Ecirc;"],
			[0, "&Euml;"],
			[0, "&Igrave;"],
			[0, "&Iacute;"],
			[0, "&Icirc;"],
			[0, "&Iuml;"],
			[0, "&ETH;"],
			[0, "&Ntilde;"],
			[0, "&Ograve;"],
			[0, "&Oacute;"],
			[0, "&Ocirc;"],
			[0, "&Otilde;"],
			[0, "&Ouml;"],
			[0, "&times;"],
			[0, "&Oslash;"],
			[0, "&Ugrave;"],
			[0, "&Uacute;"],
			[0, "&Ucirc;"],
			[0, "&Uuml;"],
			[0, "&Yacute;"],
			[0, "&THORN;"],
			[0, "&szlig;"],
			[0, "&agrave;"],
			[0, "&aacute;"],
			[0, "&acirc;"],
			[0, "&atilde;"],
			[0, "&auml;"],
			[0, "&aring;"],
			[0, "&aelig;"],
			[0, "&ccedil;"],
			[0, "&egrave;"],
			[0, "&eacute;"],
			[0, "&ecirc;"],
			[0, "&euml;"],
			[0, "&igrave;"],
			[0, "&iacute;"],
			[0, "&icirc;"],
			[0, "&iuml;"],
			[0, "&eth;"],
			[0, "&ntilde;"],
			[0, "&ograve;"],
			[0, "&oacute;"],
			[0, "&ocirc;"],
			[0, "&otilde;"],
			[0, "&ouml;"],
			[0, "&div;"],
			[0, "&oslash;"],
			[0, "&ugrave;"],
			[0, "&uacute;"],
			[0, "&ucirc;"],
			[0, "&uuml;"],
			[0, "&yacute;"],
			[0, "&thorn;"],
			[0, "&yuml;"],
			[0, "&Amacr;"],
			[0, "&amacr;"],
			[0, "&Abreve;"],
			[0, "&abreve;"],
			[0, "&Aogon;"],
			[0, "&aogon;"],
			[0, "&Cacute;"],
			[0, "&cacute;"],
			[0, "&Ccirc;"],
			[0, "&ccirc;"],
			[0, "&Cdot;"],
			[0, "&cdot;"],
			[0, "&Ccaron;"],
			[0, "&ccaron;"],
			[0, "&Dcaron;"],
			[0, "&dcaron;"],
			[0, "&Dstrok;"],
			[0, "&dstrok;"],
			[0, "&Emacr;"],
			[0, "&emacr;"],
			[2, "&Edot;"],
			[0, "&edot;"],
			[0, "&Eogon;"],
			[0, "&eogon;"],
			[0, "&Ecaron;"],
			[0, "&ecaron;"],
			[0, "&Gcirc;"],
			[0, "&gcirc;"],
			[0, "&Gbreve;"],
			[0, "&gbreve;"],
			[0, "&Gdot;"],
			[0, "&gdot;"],
			[0, "&Gcedil;"],
			[1, "&Hcirc;"],
			[0, "&hcirc;"],
			[0, "&Hstrok;"],
			[0, "&hstrok;"],
			[0, "&Itilde;"],
			[0, "&itilde;"],
			[0, "&Imacr;"],
			[0, "&imacr;"],
			[2, "&Iogon;"],
			[0, "&iogon;"],
			[0, "&Idot;"],
			[0, "&imath;"],
			[0, "&IJlig;"],
			[0, "&ijlig;"],
			[0, "&Jcirc;"],
			[0, "&jcirc;"],
			[0, "&Kcedil;"],
			[0, "&kcedil;"],
			[0, "&kgreen;"],
			[0, "&Lacute;"],
			[0, "&lacute;"],
			[0, "&Lcedil;"],
			[0, "&lcedil;"],
			[0, "&Lcaron;"],
			[0, "&lcaron;"],
			[0, "&Lmidot;"],
			[0, "&lmidot;"],
			[0, "&Lstrok;"],
			[0, "&lstrok;"],
			[0, "&Nacute;"],
			[0, "&nacute;"],
			[0, "&Ncedil;"],
			[0, "&ncedil;"],
			[0, "&Ncaron;"],
			[0, "&ncaron;"],
			[0, "&napos;"],
			[0, "&ENG;"],
			[0, "&eng;"],
			[0, "&Omacr;"],
			[0, "&omacr;"],
			[2, "&Odblac;"],
			[0, "&odblac;"],
			[0, "&OElig;"],
			[0, "&oelig;"],
			[0, "&Racute;"],
			[0, "&racute;"],
			[0, "&Rcedil;"],
			[0, "&rcedil;"],
			[0, "&Rcaron;"],
			[0, "&rcaron;"],
			[0, "&Sacute;"],
			[0, "&sacute;"],
			[0, "&Scirc;"],
			[0, "&scirc;"],
			[0, "&Scedil;"],
			[0, "&scedil;"],
			[0, "&Scaron;"],
			[0, "&scaron;"],
			[0, "&Tcedil;"],
			[0, "&tcedil;"],
			[0, "&Tcaron;"],
			[0, "&tcaron;"],
			[0, "&Tstrok;"],
			[0, "&tstrok;"],
			[0, "&Utilde;"],
			[0, "&utilde;"],
			[0, "&Umacr;"],
			[0, "&umacr;"],
			[0, "&Ubreve;"],
			[0, "&ubreve;"],
			[0, "&Uring;"],
			[0, "&uring;"],
			[0, "&Udblac;"],
			[0, "&udblac;"],
			[0, "&Uogon;"],
			[0, "&uogon;"],
			[0, "&Wcirc;"],
			[0, "&wcirc;"],
			[0, "&Ycirc;"],
			[0, "&ycirc;"],
			[0, "&Yuml;"],
			[0, "&Zacute;"],
			[0, "&zacute;"],
			[0, "&Zdot;"],
			[0, "&zdot;"],
			[0, "&Zcaron;"],
			[0, "&zcaron;"],
			[19, "&fnof;"],
			[34, "&imped;"],
			[63, "&gacute;"],
			[65, "&jmath;"],
			[142, "&circ;"],
			[0, "&caron;"],
			[16, "&breve;"],
			[0, "&DiacriticalDot;"],
			[0, "&ring;"],
			[0, "&ogon;"],
			[0, "&DiacriticalTilde;"],
			[0, "&dblac;"],
			[51, "&DownBreve;"],
			[127, "&Alpha;"],
			[0, "&Beta;"],
			[0, "&Gamma;"],
			[0, "&Delta;"],
			[0, "&Epsilon;"],
			[0, "&Zeta;"],
			[0, "&Eta;"],
			[0, "&Theta;"],
			[0, "&Iota;"],
			[0, "&Kappa;"],
			[0, "&Lambda;"],
			[0, "&Mu;"],
			[0, "&Nu;"],
			[0, "&Xi;"],
			[0, "&Omicron;"],
			[0, "&Pi;"],
			[0, "&Rho;"],
			[1, "&Sigma;"],
			[0, "&Tau;"],
			[0, "&Upsilon;"],
			[0, "&Phi;"],
			[0, "&Chi;"],
			[0, "&Psi;"],
			[0, "&ohm;"],
			[7, "&alpha;"],
			[0, "&beta;"],
			[0, "&gamma;"],
			[0, "&delta;"],
			[0, "&epsi;"],
			[0, "&zeta;"],
			[0, "&eta;"],
			[0, "&theta;"],
			[0, "&iota;"],
			[0, "&kappa;"],
			[0, "&lambda;"],
			[0, "&mu;"],
			[0, "&nu;"],
			[0, "&xi;"],
			[0, "&omicron;"],
			[0, "&pi;"],
			[0, "&rho;"],
			[0, "&sigmaf;"],
			[0, "&sigma;"],
			[0, "&tau;"],
			[0, "&upsi;"],
			[0, "&phi;"],
			[0, "&chi;"],
			[0, "&psi;"],
			[0, "&omega;"],
			[7, "&thetasym;"],
			[0, "&Upsi;"],
			[2, "&phiv;"],
			[0, "&piv;"],
			[5, "&Gammad;"],
			[0, "&digamma;"],
			[18, "&kappav;"],
			[0, "&rhov;"],
			[3, "&epsiv;"],
			[0, "&backepsilon;"],
			[10, "&IOcy;"],
			[0, "&DJcy;"],
			[0, "&GJcy;"],
			[0, "&Jukcy;"],
			[0, "&DScy;"],
			[0, "&Iukcy;"],
			[0, "&YIcy;"],
			[0, "&Jsercy;"],
			[0, "&LJcy;"],
			[0, "&NJcy;"],
			[0, "&TSHcy;"],
			[0, "&KJcy;"],
			[1, "&Ubrcy;"],
			[0, "&DZcy;"],
			[0, "&Acy;"],
			[0, "&Bcy;"],
			[0, "&Vcy;"],
			[0, "&Gcy;"],
			[0, "&Dcy;"],
			[0, "&IEcy;"],
			[0, "&ZHcy;"],
			[0, "&Zcy;"],
			[0, "&Icy;"],
			[0, "&Jcy;"],
			[0, "&Kcy;"],
			[0, "&Lcy;"],
			[0, "&Mcy;"],
			[0, "&Ncy;"],
			[0, "&Ocy;"],
			[0, "&Pcy;"],
			[0, "&Rcy;"],
			[0, "&Scy;"],
			[0, "&Tcy;"],
			[0, "&Ucy;"],
			[0, "&Fcy;"],
			[0, "&KHcy;"],
			[0, "&TScy;"],
			[0, "&CHcy;"],
			[0, "&SHcy;"],
			[0, "&SHCHcy;"],
			[0, "&HARDcy;"],
			[0, "&Ycy;"],
			[0, "&SOFTcy;"],
			[0, "&Ecy;"],
			[0, "&YUcy;"],
			[0, "&YAcy;"],
			[0, "&acy;"],
			[0, "&bcy;"],
			[0, "&vcy;"],
			[0, "&gcy;"],
			[0, "&dcy;"],
			[0, "&iecy;"],
			[0, "&zhcy;"],
			[0, "&zcy;"],
			[0, "&icy;"],
			[0, "&jcy;"],
			[0, "&kcy;"],
			[0, "&lcy;"],
			[0, "&mcy;"],
			[0, "&ncy;"],
			[0, "&ocy;"],
			[0, "&pcy;"],
			[0, "&rcy;"],
			[0, "&scy;"],
			[0, "&tcy;"],
			[0, "&ucy;"],
			[0, "&fcy;"],
			[0, "&khcy;"],
			[0, "&tscy;"],
			[0, "&chcy;"],
			[0, "&shcy;"],
			[0, "&shchcy;"],
			[0, "&hardcy;"],
			[0, "&ycy;"],
			[0, "&softcy;"],
			[0, "&ecy;"],
			[0, "&yucy;"],
			[0, "&yacy;"],
			[1, "&iocy;"],
			[0, "&djcy;"],
			[0, "&gjcy;"],
			[0, "&jukcy;"],
			[0, "&dscy;"],
			[0, "&iukcy;"],
			[0, "&yicy;"],
			[0, "&jsercy;"],
			[0, "&ljcy;"],
			[0, "&njcy;"],
			[0, "&tshcy;"],
			[0, "&kjcy;"],
			[1, "&ubrcy;"],
			[0, "&dzcy;"],
			[7074, "&ensp;"],
			[0, "&emsp;"],
			[0, "&emsp13;"],
			[0, "&emsp14;"],
			[1, "&numsp;"],
			[0, "&puncsp;"],
			[0, "&ThinSpace;"],
			[0, "&hairsp;"],
			[0, "&NegativeMediumSpace;"],
			[0, "&zwnj;"],
			[0, "&zwj;"],
			[0, "&lrm;"],
			[0, "&rlm;"],
			[0, "&dash;"],
			[2, "&ndash;"],
			[0, "&mdash;"],
			[0, "&horbar;"],
			[0, "&Verbar;"],
			[1, "&lsquo;"],
			[0, "&CloseCurlyQuote;"],
			[0, "&lsquor;"],
			[1, "&ldquo;"],
			[0, "&CloseCurlyDoubleQuote;"],
			[0, "&bdquo;"],
			[1, "&dagger;"],
			[0, "&Dagger;"],
			[0, "&bull;"],
			[2, "&nldr;"],
			[0, "&hellip;"],
			[9, "&permil;"],
			[0, "&pertenk;"],
			[0, "&prime;"],
			[0, "&Prime;"],
			[0, "&tprime;"],
			[0, "&backprime;"],
			[3, "&lsaquo;"],
			[0, "&rsaquo;"],
			[3, "&oline;"],
			[2, "&caret;"],
			[1, "&hybull;"],
			[0, "&frasl;"],
			[10, "&bsemi;"],
			[7, "&qprime;"],
			[7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }],
			[0, "&NoBreak;"],
			[0, "&af;"],
			[0, "&InvisibleTimes;"],
			[0, "&ic;"],
			[72, "&euro;"],
			[46, "&tdot;"],
			[0, "&DotDot;"],
			[37, "&complexes;"],
			[2, "&incare;"],
			[4, "&gscr;"],
			[0, "&hamilt;"],
			[0, "&Hfr;"],
			[0, "&Hopf;"],
			[0, "&planckh;"],
			[0, "&hbar;"],
			[0, "&imagline;"],
			[0, "&Ifr;"],
			[0, "&lagran;"],
			[0, "&ell;"],
			[1, "&naturals;"],
			[0, "&numero;"],
			[0, "&copysr;"],
			[0, "&weierp;"],
			[0, "&Popf;"],
			[0, "&Qopf;"],
			[0, "&realine;"],
			[0, "&real;"],
			[0, "&reals;"],
			[0, "&rx;"],
			[3, "&trade;"],
			[1, "&integers;"],
			[2, "&mho;"],
			[0, "&zeetrf;"],
			[0, "&iiota;"],
			[2, "&bernou;"],
			[0, "&Cayleys;"],
			[1, "&escr;"],
			[0, "&Escr;"],
			[0, "&Fouriertrf;"],
			[1, "&Mellintrf;"],
			[0, "&order;"],
			[0, "&alefsym;"],
			[0, "&beth;"],
			[0, "&gimel;"],
			[0, "&daleth;"],
			[12, "&CapitalDifferentialD;"],
			[0, "&dd;"],
			[0, "&ee;"],
			[0, "&ii;"],
			[10, "&frac13;"],
			[0, "&frac23;"],
			[0, "&frac15;"],
			[0, "&frac25;"],
			[0, "&frac35;"],
			[0, "&frac45;"],
			[0, "&frac16;"],
			[0, "&frac56;"],
			[0, "&frac18;"],
			[0, "&frac38;"],
			[0, "&frac58;"],
			[0, "&frac78;"],
			[49, "&larr;"],
			[0, "&ShortUpArrow;"],
			[0, "&rarr;"],
			[0, "&darr;"],
			[0, "&harr;"],
			[0, "&updownarrow;"],
			[0, "&nwarr;"],
			[0, "&nearr;"],
			[0, "&LowerRightArrow;"],
			[0, "&LowerLeftArrow;"],
			[0, "&nlarr;"],
			[0, "&nrarr;"],
			[1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }],
			[0, "&Larr;"],
			[0, "&Uarr;"],
			[0, "&Rarr;"],
			[0, "&Darr;"],
			[0, "&larrtl;"],
			[0, "&rarrtl;"],
			[0, "&LeftTeeArrow;"],
			[0, "&mapstoup;"],
			[0, "&map;"],
			[0, "&DownTeeArrow;"],
			[1, "&hookleftarrow;"],
			[0, "&hookrightarrow;"],
			[0, "&larrlp;"],
			[0, "&looparrowright;"],
			[0, "&harrw;"],
			[0, "&nharr;"],
			[1, "&lsh;"],
			[0, "&rsh;"],
			[0, "&ldsh;"],
			[0, "&rdsh;"],
			[1, "&crarr;"],
			[0, "&cularr;"],
			[0, "&curarr;"],
			[2, "&circlearrowleft;"],
			[0, "&circlearrowright;"],
			[0, "&leftharpoonup;"],
			[0, "&DownLeftVector;"],
			[0, "&RightUpVector;"],
			[0, "&LeftUpVector;"],
			[0, "&rharu;"],
			[0, "&DownRightVector;"],
			[0, "&dharr;"],
			[0, "&dharl;"],
			[0, "&RightArrowLeftArrow;"],
			[0, "&udarr;"],
			[0, "&LeftArrowRightArrow;"],
			[0, "&leftleftarrows;"],
			[0, "&upuparrows;"],
			[0, "&rightrightarrows;"],
			[0, "&ddarr;"],
			[0, "&leftrightharpoons;"],
			[0, "&Equilibrium;"],
			[0, "&nlArr;"],
			[0, "&nhArr;"],
			[0, "&nrArr;"],
			[0, "&DoubleLeftArrow;"],
			[0, "&DoubleUpArrow;"],
			[0, "&DoubleRightArrow;"],
			[0, "&dArr;"],
			[0, "&DoubleLeftRightArrow;"],
			[0, "&DoubleUpDownArrow;"],
			[0, "&nwArr;"],
			[0, "&neArr;"],
			[0, "&seArr;"],
			[0, "&swArr;"],
			[0, "&lAarr;"],
			[0, "&rAarr;"],
			[1, "&zigrarr;"],
			[6, "&larrb;"],
			[0, "&rarrb;"],
			[15, "&DownArrowUpArrow;"],
			[7, "&loarr;"],
			[0, "&roarr;"],
			[0, "&hoarr;"],
			[0, "&forall;"],
			[0, "&comp;"],
			[0, { v: "&part;", n: 824, o: "&npart;" }],
			[0, "&exist;"],
			[0, "&nexist;"],
			[0, "&empty;"],
			[1, "&Del;"],
			[0, "&Element;"],
			[0, "&NotElement;"],
			[1, "&ni;"],
			[0, "&notni;"],
			[2, "&prod;"],
			[0, "&coprod;"],
			[0, "&sum;"],
			[0, "&minus;"],
			[0, "&MinusPlus;"],
			[0, "&dotplus;"],
			[1, "&Backslash;"],
			[0, "&lowast;"],
			[0, "&compfn;"],
			[1, "&radic;"],
			[2, "&prop;"],
			[0, "&infin;"],
			[0, "&angrt;"],
			[0, { v: "&ang;", n: 8402, o: "&nang;" }],
			[0, "&angmsd;"],
			[0, "&angsph;"],
			[0, "&mid;"],
			[0, "&nmid;"],
			[0, "&DoubleVerticalBar;"],
			[0, "&NotDoubleVerticalBar;"],
			[0, "&and;"],
			[0, "&or;"],
			[0, { v: "&cap;", n: 65024, o: "&caps;" }],
			[0, { v: "&cup;", n: 65024, o: "&cups;" }],
			[0, "&int;"],
			[0, "&Int;"],
			[0, "&iiint;"],
			[0, "&conint;"],
			[0, "&Conint;"],
			[0, "&Cconint;"],
			[0, "&cwint;"],
			[0, "&ClockwiseContourIntegral;"],
			[0, "&awconint;"],
			[0, "&there4;"],
			[0, "&becaus;"],
			[0, "&ratio;"],
			[0, "&Colon;"],
			[0, "&dotminus;"],
			[1, "&mDDot;"],
			[0, "&homtht;"],
			[0, { v: "&sim;", n: 8402, o: "&nvsim;" }],
			[0, { v: "&backsim;", n: 817, o: "&race;" }],
			[0, { v: "&ac;", n: 819, o: "&acE;" }],
			[0, "&acd;"],
			[0, "&VerticalTilde;"],
			[0, "&NotTilde;"],
			[0, { v: "&eqsim;", n: 824, o: "&nesim;" }],
			[0, "&sime;"],
			[0, "&NotTildeEqual;"],
			[0, "&cong;"],
			[0, "&simne;"],
			[0, "&ncong;"],
			[0, "&ap;"],
			[0, "&nap;"],
			[0, "&ape;"],
			[0, { v: "&apid;", n: 824, o: "&napid;" }],
			[0, "&backcong;"],
			[0, { v: "&asympeq;", n: 8402, o: "&nvap;" }],
			[0, { v: "&bump;", n: 824, o: "&nbump;" }],
			[0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }],
			[0, { v: "&doteq;", n: 824, o: "&nedot;" }],
			[0, "&doteqdot;"],
			[0, "&efDot;"],
			[0, "&erDot;"],
			[0, "&Assign;"],
			[0, "&ecolon;"],
			[0, "&ecir;"],
			[0, "&circeq;"],
			[1, "&wedgeq;"],
			[0, "&veeeq;"],
			[1, "&triangleq;"],
			[2, "&equest;"],
			[0, "&ne;"],
			[0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }],
			[0, "&nequiv;"],
			[1, { v: "&le;", n: 8402, o: "&nvle;" }],
			[0, { v: "&ge;", n: 8402, o: "&nvge;" }],
			[0, { v: "&lE;", n: 824, o: "&nlE;" }],
			[0, { v: "&gE;", n: 824, o: "&ngE;" }],
			[0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }],
			[0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }],
			[
				0,
				{
					v: "&ll;",
					n: new Map(
						/* @__PURE__ */ restoreDiff([
							[824, "&nLtv;"],
							[7577, "&nLt;"],
						]),
					),
				},
			],
			[
				0,
				{
					v: "&gg;",
					n: new Map(
						/* @__PURE__ */ restoreDiff([
							[824, "&nGtv;"],
							[7577, "&nGt;"],
						]),
					),
				},
			],
			[0, "&between;"],
			[0, "&NotCupCap;"],
			[0, "&nless;"],
			[0, "&ngt;"],
			[0, "&nle;"],
			[0, "&nge;"],
			[0, "&lesssim;"],
			[0, "&GreaterTilde;"],
			[0, "&nlsim;"],
			[0, "&ngsim;"],
			[0, "&LessGreater;"],
			[0, "&gl;"],
			[0, "&NotLessGreater;"],
			[0, "&NotGreaterLess;"],
			[0, "&pr;"],
			[0, "&sc;"],
			[0, "&prcue;"],
			[0, "&sccue;"],
			[0, "&PrecedesTilde;"],
			[0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }],
			[0, "&NotPrecedes;"],
			[0, "&NotSucceeds;"],
			[0, { v: "&sub;", n: 8402, o: "&NotSubset;" }],
			[0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }],
			[0, "&nsub;"],
			[0, "&nsup;"],
			[0, "&sube;"],
			[0, "&supe;"],
			[0, "&NotSubsetEqual;"],
			[0, "&NotSupersetEqual;"],
			[0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }],
			[0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }],
			[1, "&cupdot;"],
			[0, "&UnionPlus;"],
			[0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }],
			[0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }],
			[0, "&sqsube;"],
			[0, "&sqsupe;"],
			[0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }],
			[0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }],
			[0, "&CirclePlus;"],
			[0, "&CircleMinus;"],
			[0, "&CircleTimes;"],
			[0, "&osol;"],
			[0, "&CircleDot;"],
			[0, "&circledcirc;"],
			[0, "&circledast;"],
			[1, "&circleddash;"],
			[0, "&boxplus;"],
			[0, "&boxminus;"],
			[0, "&boxtimes;"],
			[0, "&dotsquare;"],
			[0, "&RightTee;"],
			[0, "&dashv;"],
			[0, "&DownTee;"],
			[0, "&bot;"],
			[1, "&models;"],
			[0, "&DoubleRightTee;"],
			[0, "&Vdash;"],
			[0, "&Vvdash;"],
			[0, "&VDash;"],
			[0, "&nvdash;"],
			[0, "&nvDash;"],
			[0, "&nVdash;"],
			[0, "&nVDash;"],
			[0, "&prurel;"],
			[1, "&LeftTriangle;"],
			[0, "&RightTriangle;"],
			[0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }],
			[0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }],
			[0, "&origof;"],
			[0, "&imof;"],
			[0, "&multimap;"],
			[0, "&hercon;"],
			[0, "&intcal;"],
			[0, "&veebar;"],
			[1, "&barvee;"],
			[0, "&angrtvb;"],
			[0, "&lrtri;"],
			[0, "&bigwedge;"],
			[0, "&bigvee;"],
			[0, "&bigcap;"],
			[0, "&bigcup;"],
			[0, "&diam;"],
			[0, "&sdot;"],
			[0, "&sstarf;"],
			[0, "&divideontimes;"],
			[0, "&bowtie;"],
			[0, "&ltimes;"],
			[0, "&rtimes;"],
			[0, "&leftthreetimes;"],
			[0, "&rightthreetimes;"],
			[0, "&backsimeq;"],
			[0, "&curlyvee;"],
			[0, "&curlywedge;"],
			[0, "&Sub;"],
			[0, "&Sup;"],
			[0, "&Cap;"],
			[0, "&Cup;"],
			[0, "&fork;"],
			[0, "&epar;"],
			[0, "&lessdot;"],
			[0, "&gtdot;"],
			[0, { v: "&Ll;", n: 824, o: "&nLl;" }],
			[0, { v: "&Gg;", n: 824, o: "&nGg;" }],
			[0, { v: "&leg;", n: 65024, o: "&lesg;" }],
			[0, { v: "&gel;", n: 65024, o: "&gesl;" }],
			[2, "&cuepr;"],
			[0, "&cuesc;"],
			[0, "&NotPrecedesSlantEqual;"],
			[0, "&NotSucceedsSlantEqual;"],
			[0, "&NotSquareSubsetEqual;"],
			[0, "&NotSquareSupersetEqual;"],
			[2, "&lnsim;"],
			[0, "&gnsim;"],
			[0, "&precnsim;"],
			[0, "&scnsim;"],
			[0, "&nltri;"],
			[0, "&NotRightTriangle;"],
			[0, "&nltrie;"],
			[0, "&NotRightTriangleEqual;"],
			[0, "&vellip;"],
			[0, "&ctdot;"],
			[0, "&utdot;"],
			[0, "&dtdot;"],
			[0, "&disin;"],
			[0, "&isinsv;"],
			[0, "&isins;"],
			[0, { v: "&isindot;", n: 824, o: "&notindot;" }],
			[0, "&notinvc;"],
			[0, "&notinvb;"],
			[1, { v: "&isinE;", n: 824, o: "&notinE;" }],
			[0, "&nisd;"],
			[0, "&xnis;"],
			[0, "&nis;"],
			[0, "&notnivc;"],
			[0, "&notnivb;"],
			[6, "&barwed;"],
			[0, "&Barwed;"],
			[1, "&lceil;"],
			[0, "&rceil;"],
			[0, "&LeftFloor;"],
			[0, "&rfloor;"],
			[0, "&drcrop;"],
			[0, "&dlcrop;"],
			[0, "&urcrop;"],
			[0, "&ulcrop;"],
			[0, "&bnot;"],
			[1, "&profline;"],
			[0, "&profsurf;"],
			[1, "&telrec;"],
			[0, "&target;"],
			[5, "&ulcorn;"],
			[0, "&urcorn;"],
			[0, "&dlcorn;"],
			[0, "&drcorn;"],
			[2, "&frown;"],
			[0, "&smile;"],
			[9, "&cylcty;"],
			[0, "&profalar;"],
			[7, "&topbot;"],
			[6, "&ovbar;"],
			[1, "&solbar;"],
			[60, "&angzarr;"],
			[51, "&lmoustache;"],
			[0, "&rmoustache;"],
			[2, "&OverBracket;"],
			[0, "&bbrk;"],
			[0, "&bbrktbrk;"],
			[37, "&OverParenthesis;"],
			[0, "&UnderParenthesis;"],
			[0, "&OverBrace;"],
			[0, "&UnderBrace;"],
			[2, "&trpezium;"],
			[4, "&elinters;"],
			[59, "&blank;"],
			[164, "&circledS;"],
			[55, "&boxh;"],
			[1, "&boxv;"],
			[9, "&boxdr;"],
			[3, "&boxdl;"],
			[3, "&boxur;"],
			[3, "&boxul;"],
			[3, "&boxvr;"],
			[7, "&boxvl;"],
			[7, "&boxhd;"],
			[7, "&boxhu;"],
			[7, "&boxvh;"],
			[19, "&boxH;"],
			[0, "&boxV;"],
			[0, "&boxdR;"],
			[0, "&boxDr;"],
			[0, "&boxDR;"],
			[0, "&boxdL;"],
			[0, "&boxDl;"],
			[0, "&boxDL;"],
			[0, "&boxuR;"],
			[0, "&boxUr;"],
			[0, "&boxUR;"],
			[0, "&boxuL;"],
			[0, "&boxUl;"],
			[0, "&boxUL;"],
			[0, "&boxvR;"],
			[0, "&boxVr;"],
			[0, "&boxVR;"],
			[0, "&boxvL;"],
			[0, "&boxVl;"],
			[0, "&boxVL;"],
			[0, "&boxHd;"],
			[0, "&boxhD;"],
			[0, "&boxHD;"],
			[0, "&boxHu;"],
			[0, "&boxhU;"],
			[0, "&boxHU;"],
			[0, "&boxvH;"],
			[0, "&boxVh;"],
			[0, "&boxVH;"],
			[19, "&uhblk;"],
			[3, "&lhblk;"],
			[3, "&block;"],
			[8, "&blk14;"],
			[0, "&blk12;"],
			[0, "&blk34;"],
			[13, "&square;"],
			[8, "&blacksquare;"],
			[0, "&EmptyVerySmallSquare;"],
			[1, "&rect;"],
			[0, "&marker;"],
			[2, "&fltns;"],
			[1, "&bigtriangleup;"],
			[0, "&blacktriangle;"],
			[0, "&triangle;"],
			[2, "&blacktriangleright;"],
			[0, "&rtri;"],
			[3, "&bigtriangledown;"],
			[0, "&blacktriangledown;"],
			[0, "&dtri;"],
			[2, "&blacktriangleleft;"],
			[0, "&ltri;"],
			[6, "&loz;"],
			[0, "&cir;"],
			[32, "&tridot;"],
			[2, "&bigcirc;"],
			[8, "&ultri;"],
			[0, "&urtri;"],
			[0, "&lltri;"],
			[0, "&EmptySmallSquare;"],
			[0, "&FilledSmallSquare;"],
			[8, "&bigstar;"],
			[0, "&star;"],
			[7, "&phone;"],
			[49, "&female;"],
			[1, "&male;"],
			[29, "&spades;"],
			[2, "&clubs;"],
			[1, "&hearts;"],
			[0, "&diamondsuit;"],
			[3, "&sung;"],
			[2, "&flat;"],
			[0, "&natural;"],
			[0, "&sharp;"],
			[163, "&check;"],
			[3, "&cross;"],
			[8, "&malt;"],
			[21, "&sext;"],
			[33, "&VerticalSeparator;"],
			[25, "&lbbrk;"],
			[0, "&rbbrk;"],
			[84, "&bsolhsub;"],
			[0, "&suphsol;"],
			[28, "&LeftDoubleBracket;"],
			[0, "&RightDoubleBracket;"],
			[0, "&lang;"],
			[0, "&rang;"],
			[0, "&Lang;"],
			[0, "&Rang;"],
			[0, "&loang;"],
			[0, "&roang;"],
			[7, "&longleftarrow;"],
			[0, "&longrightarrow;"],
			[0, "&longleftrightarrow;"],
			[0, "&DoubleLongLeftArrow;"],
			[0, "&DoubleLongRightArrow;"],
			[0, "&DoubleLongLeftRightArrow;"],
			[1, "&longmapsto;"],
			[2, "&dzigrarr;"],
			[258, "&nvlArr;"],
			[0, "&nvrArr;"],
			[0, "&nvHarr;"],
			[0, "&Map;"],
			[6, "&lbarr;"],
			[0, "&bkarow;"],
			[0, "&lBarr;"],
			[0, "&dbkarow;"],
			[0, "&drbkarow;"],
			[0, "&DDotrahd;"],
			[0, "&UpArrowBar;"],
			[0, "&DownArrowBar;"],
			[2, "&Rarrtl;"],
			[2, "&latail;"],
			[0, "&ratail;"],
			[0, "&lAtail;"],
			[0, "&rAtail;"],
			[0, "&larrfs;"],
			[0, "&rarrfs;"],
			[0, "&larrbfs;"],
			[0, "&rarrbfs;"],
			[2, "&nwarhk;"],
			[0, "&nearhk;"],
			[0, "&hksearow;"],
			[0, "&hkswarow;"],
			[0, "&nwnear;"],
			[0, "&nesear;"],
			[0, "&seswar;"],
			[0, "&swnwar;"],
			[8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }],
			[1, "&cudarrr;"],
			[0, "&ldca;"],
			[0, "&rdca;"],
			[0, "&cudarrl;"],
			[0, "&larrpl;"],
			[2, "&curarrm;"],
			[0, "&cularrp;"],
			[7, "&rarrpl;"],
			[2, "&harrcir;"],
			[0, "&Uarrocir;"],
			[0, "&lurdshar;"],
			[0, "&ldrushar;"],
			[2, "&LeftRightVector;"],
			[0, "&RightUpDownVector;"],
			[0, "&DownLeftRightVector;"],
			[0, "&LeftUpDownVector;"],
			[0, "&LeftVectorBar;"],
			[0, "&RightVectorBar;"],
			[0, "&RightUpVectorBar;"],
			[0, "&RightDownVectorBar;"],
			[0, "&DownLeftVectorBar;"],
			[0, "&DownRightVectorBar;"],
			[0, "&LeftUpVectorBar;"],
			[0, "&LeftDownVectorBar;"],
			[0, "&LeftTeeVector;"],
			[0, "&RightTeeVector;"],
			[0, "&RightUpTeeVector;"],
			[0, "&RightDownTeeVector;"],
			[0, "&DownLeftTeeVector;"],
			[0, "&DownRightTeeVector;"],
			[0, "&LeftUpTeeVector;"],
			[0, "&LeftDownTeeVector;"],
			[0, "&lHar;"],
			[0, "&uHar;"],
			[0, "&rHar;"],
			[0, "&dHar;"],
			[0, "&luruhar;"],
			[0, "&ldrdhar;"],
			[0, "&ruluhar;"],
			[0, "&rdldhar;"],
			[0, "&lharul;"],
			[0, "&llhard;"],
			[0, "&rharul;"],
			[0, "&lrhard;"],
			[0, "&udhar;"],
			[0, "&duhar;"],
			[0, "&RoundImplies;"],
			[0, "&erarr;"],
			[0, "&simrarr;"],
			[0, "&larrsim;"],
			[0, "&rarrsim;"],
			[0, "&rarrap;"],
			[0, "&ltlarr;"],
			[1, "&gtrarr;"],
			[0, "&subrarr;"],
			[1, "&suplarr;"],
			[0, "&lfisht;"],
			[0, "&rfisht;"],
			[0, "&ufisht;"],
			[0, "&dfisht;"],
			[5, "&lopar;"],
			[0, "&ropar;"],
			[4, "&lbrke;"],
			[0, "&rbrke;"],
			[0, "&lbrkslu;"],
			[0, "&rbrksld;"],
			[0, "&lbrksld;"],
			[0, "&rbrkslu;"],
			[0, "&langd;"],
			[0, "&rangd;"],
			[0, "&lparlt;"],
			[0, "&rpargt;"],
			[0, "&gtlPar;"],
			[0, "&ltrPar;"],
			[3, "&vzigzag;"],
			[1, "&vangrt;"],
			[0, "&angrtvbd;"],
			[6, "&ange;"],
			[0, "&range;"],
			[0, "&dwangle;"],
			[0, "&uwangle;"],
			[0, "&angmsdaa;"],
			[0, "&angmsdab;"],
			[0, "&angmsdac;"],
			[0, "&angmsdad;"],
			[0, "&angmsdae;"],
			[0, "&angmsdaf;"],
			[0, "&angmsdag;"],
			[0, "&angmsdah;"],
			[0, "&bemptyv;"],
			[0, "&demptyv;"],
			[0, "&cemptyv;"],
			[0, "&raemptyv;"],
			[0, "&laemptyv;"],
			[0, "&ohbar;"],
			[0, "&omid;"],
			[0, "&opar;"],
			[1, "&operp;"],
			[1, "&olcross;"],
			[0, "&odsold;"],
			[1, "&olcir;"],
			[0, "&ofcir;"],
			[0, "&olt;"],
			[0, "&ogt;"],
			[0, "&cirscir;"],
			[0, "&cirE;"],
			[0, "&solb;"],
			[0, "&bsolb;"],
			[3, "&boxbox;"],
			[3, "&trisb;"],
			[0, "&rtriltri;"],
			[0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }],
			[0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }],
			[11, "&iinfin;"],
			[0, "&infintie;"],
			[0, "&nvinfin;"],
			[4, "&eparsl;"],
			[0, "&smeparsl;"],
			[0, "&eqvparsl;"],
			[5, "&blacklozenge;"],
			[8, "&RuleDelayed;"],
			[1, "&dsol;"],
			[9, "&bigodot;"],
			[0, "&bigoplus;"],
			[0, "&bigotimes;"],
			[1, "&biguplus;"],
			[1, "&bigsqcup;"],
			[5, "&iiiint;"],
			[0, "&fpartint;"],
			[2, "&cirfnint;"],
			[0, "&awint;"],
			[0, "&rppolint;"],
			[0, "&scpolint;"],
			[0, "&npolint;"],
			[0, "&pointint;"],
			[0, "&quatint;"],
			[0, "&intlarhk;"],
			[10, "&pluscir;"],
			[0, "&plusacir;"],
			[0, "&simplus;"],
			[0, "&plusdu;"],
			[0, "&plussim;"],
			[0, "&plustwo;"],
			[1, "&mcomma;"],
			[0, "&minusdu;"],
			[2, "&loplus;"],
			[0, "&roplus;"],
			[0, "&Cross;"],
			[0, "&timesd;"],
			[0, "&timesbar;"],
			[1, "&smashp;"],
			[0, "&lotimes;"],
			[0, "&rotimes;"],
			[0, "&otimesas;"],
			[0, "&Otimes;"],
			[0, "&odiv;"],
			[0, "&triplus;"],
			[0, "&triminus;"],
			[0, "&tritime;"],
			[0, "&intprod;"],
			[2, "&amalg;"],
			[0, "&capdot;"],
			[1, "&ncup;"],
			[0, "&ncap;"],
			[0, "&capand;"],
			[0, "&cupor;"],
			[0, "&cupcap;"],
			[0, "&capcup;"],
			[0, "&cupbrcap;"],
			[0, "&capbrcup;"],
			[0, "&cupcup;"],
			[0, "&capcap;"],
			[0, "&ccups;"],
			[0, "&ccaps;"],
			[2, "&ccupssm;"],
			[2, "&And;"],
			[0, "&Or;"],
			[0, "&andand;"],
			[0, "&oror;"],
			[0, "&orslope;"],
			[0, "&andslope;"],
			[1, "&andv;"],
			[0, "&orv;"],
			[0, "&andd;"],
			[0, "&ord;"],
			[1, "&wedbar;"],
			[6, "&sdote;"],
			[3, "&simdot;"],
			[2, { v: "&congdot;", n: 824, o: "&ncongdot;" }],
			[0, "&easter;"],
			[0, "&apacir;"],
			[0, { v: "&apE;", n: 824, o: "&napE;" }],
			[0, "&eplus;"],
			[0, "&pluse;"],
			[0, "&Esim;"],
			[0, "&Colone;"],
			[0, "&Equal;"],
			[1, "&ddotseq;"],
			[0, "&equivDD;"],
			[0, "&ltcir;"],
			[0, "&gtcir;"],
			[0, "&ltquest;"],
			[0, "&gtquest;"],
			[0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }],
			[0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }],
			[0, "&lesdot;"],
			[0, "&gesdot;"],
			[0, "&lesdoto;"],
			[0, "&gesdoto;"],
			[0, "&lesdotor;"],
			[0, "&gesdotol;"],
			[0, "&lap;"],
			[0, "&gap;"],
			[0, "&lne;"],
			[0, "&gne;"],
			[0, "&lnap;"],
			[0, "&gnap;"],
			[0, "&lEg;"],
			[0, "&gEl;"],
			[0, "&lsime;"],
			[0, "&gsime;"],
			[0, "&lsimg;"],
			[0, "&gsiml;"],
			[0, "&lgE;"],
			[0, "&glE;"],
			[0, "&lesges;"],
			[0, "&gesles;"],
			[0, "&els;"],
			[0, "&egs;"],
			[0, "&elsdot;"],
			[0, "&egsdot;"],
			[0, "&el;"],
			[0, "&eg;"],
			[2, "&siml;"],
			[0, "&simg;"],
			[0, "&simlE;"],
			[0, "&simgE;"],
			[0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }],
			[0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }],
			[1, "&glj;"],
			[0, "&gla;"],
			[0, "&ltcc;"],
			[0, "&gtcc;"],
			[0, "&lescc;"],
			[0, "&gescc;"],
			[0, "&smt;"],
			[0, "&lat;"],
			[0, { v: "&smte;", n: 65024, o: "&smtes;" }],
			[0, { v: "&late;", n: 65024, o: "&lates;" }],
			[0, "&bumpE;"],
			[0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }],
			[0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }],
			[2, "&prE;"],
			[0, "&scE;"],
			[0, "&precneqq;"],
			[0, "&scnE;"],
			[0, "&prap;"],
			[0, "&scap;"],
			[0, "&precnapprox;"],
			[0, "&scnap;"],
			[0, "&Pr;"],
			[0, "&Sc;"],
			[0, "&subdot;"],
			[0, "&supdot;"],
			[0, "&subplus;"],
			[0, "&supplus;"],
			[0, "&submult;"],
			[0, "&supmult;"],
			[0, "&subedot;"],
			[0, "&supedot;"],
			[0, { v: "&subE;", n: 824, o: "&nsubE;" }],
			[0, { v: "&supE;", n: 824, o: "&nsupE;" }],
			[0, "&subsim;"],
			[0, "&supsim;"],
			[2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }],
			[0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }],
			[2, "&csub;"],
			[0, "&csup;"],
			[0, "&csube;"],
			[0, "&csupe;"],
			[0, "&subsup;"],
			[0, "&supsub;"],
			[0, "&subsub;"],
			[0, "&supsup;"],
			[0, "&suphsub;"],
			[0, "&supdsub;"],
			[0, "&forkv;"],
			[0, "&topfork;"],
			[0, "&mlcp;"],
			[8, "&Dashv;"],
			[1, "&Vdashl;"],
			[0, "&Barv;"],
			[0, "&vBar;"],
			[0, "&vBarv;"],
			[1, "&Vbar;"],
			[0, "&Not;"],
			[0, "&bNot;"],
			[0, "&rnmid;"],
			[0, "&cirmid;"],
			[0, "&midcir;"],
			[0, "&topcir;"],
			[0, "&nhpar;"],
			[0, "&parsim;"],
			[9, { v: "&parsl;", n: 8421, o: "&nparsl;" }],
			[
				44343,
				{
					n: new Map(
						/* @__PURE__ */ restoreDiff([
							[56476, "&Ascr;"],
							[1, "&Cscr;"],
							[0, "&Dscr;"],
							[2, "&Gscr;"],
							[2, "&Jscr;"],
							[0, "&Kscr;"],
							[2, "&Nscr;"],
							[0, "&Oscr;"],
							[0, "&Pscr;"],
							[0, "&Qscr;"],
							[1, "&Sscr;"],
							[0, "&Tscr;"],
							[0, "&Uscr;"],
							[0, "&Vscr;"],
							[0, "&Wscr;"],
							[0, "&Xscr;"],
							[0, "&Yscr;"],
							[0, "&Zscr;"],
							[0, "&ascr;"],
							[0, "&bscr;"],
							[0, "&cscr;"],
							[0, "&dscr;"],
							[1, "&fscr;"],
							[1, "&hscr;"],
							[0, "&iscr;"],
							[0, "&jscr;"],
							[0, "&kscr;"],
							[0, "&lscr;"],
							[0, "&mscr;"],
							[0, "&nscr;"],
							[1, "&pscr;"],
							[0, "&qscr;"],
							[0, "&rscr;"],
							[0, "&sscr;"],
							[0, "&tscr;"],
							[0, "&uscr;"],
							[0, "&vscr;"],
							[0, "&wscr;"],
							[0, "&xscr;"],
							[0, "&yscr;"],
							[0, "&zscr;"],
							[52, "&Afr;"],
							[0, "&Bfr;"],
							[1, "&Dfr;"],
							[0, "&Efr;"],
							[0, "&Ffr;"],
							[0, "&Gfr;"],
							[2, "&Jfr;"],
							[0, "&Kfr;"],
							[0, "&Lfr;"],
							[0, "&Mfr;"],
							[0, "&Nfr;"],
							[0, "&Ofr;"],
							[0, "&Pfr;"],
							[0, "&Qfr;"],
							[1, "&Sfr;"],
							[0, "&Tfr;"],
							[0, "&Ufr;"],
							[0, "&Vfr;"],
							[0, "&Wfr;"],
							[0, "&Xfr;"],
							[0, "&Yfr;"],
							[1, "&afr;"],
							[0, "&bfr;"],
							[0, "&cfr;"],
							[0, "&dfr;"],
							[0, "&efr;"],
							[0, "&ffr;"],
							[0, "&gfr;"],
							[0, "&hfr;"],
							[0, "&ifr;"],
							[0, "&jfr;"],
							[0, "&kfr;"],
							[0, "&lfr;"],
							[0, "&mfr;"],
							[0, "&nfr;"],
							[0, "&ofr;"],
							[0, "&pfr;"],
							[0, "&qfr;"],
							[0, "&rfr;"],
							[0, "&sfr;"],
							[0, "&tfr;"],
							[0, "&ufr;"],
							[0, "&vfr;"],
							[0, "&wfr;"],
							[0, "&xfr;"],
							[0, "&yfr;"],
							[0, "&zfr;"],
							[0, "&Aopf;"],
							[0, "&Bopf;"],
							[1, "&Dopf;"],
							[0, "&Eopf;"],
							[0, "&Fopf;"],
							[0, "&Gopf;"],
							[1, "&Iopf;"],
							[0, "&Jopf;"],
							[0, "&Kopf;"],
							[0, "&Lopf;"],
							[0, "&Mopf;"],
							[1, "&Oopf;"],
							[3, "&Sopf;"],
							[0, "&Topf;"],
							[0, "&Uopf;"],
							[0, "&Vopf;"],
							[0, "&Wopf;"],
							[0, "&Xopf;"],
							[0, "&Yopf;"],
							[1, "&aopf;"],
							[0, "&bopf;"],
							[0, "&copf;"],
							[0, "&dopf;"],
							[0, "&eopf;"],
							[0, "&fopf;"],
							[0, "&gopf;"],
							[0, "&hopf;"],
							[0, "&iopf;"],
							[0, "&jopf;"],
							[0, "&kopf;"],
							[0, "&lopf;"],
							[0, "&mopf;"],
							[0, "&nopf;"],
							[0, "&oopf;"],
							[0, "&popf;"],
							[0, "&qopf;"],
							[0, "&ropf;"],
							[0, "&sopf;"],
							[0, "&topf;"],
							[0, "&uopf;"],
							[0, "&vopf;"],
							[0, "&wopf;"],
							[0, "&xopf;"],
							[0, "&yopf;"],
							[0, "&zopf;"],
						]),
					),
				},
			],
			[8906, "&fflig;"],
			[0, "&filig;"],
			[0, "&fllig;"],
			[0, "&ffilig;"],
			[0, "&ffllig;"],
		]),
	);
});

// node_modules/entities/lib/escape.js
var require_escape = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.escapeText =
		exports.escapeAttribute =
		exports.escapeUTF8 =
		exports.escape =
		exports.encodeXML =
		exports.getCodePoint =
		exports.xmlReplacer =
			undefined;
	exports.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
	var xmlCodeMap = new Map([
		[34, "&quot;"],
		[38, "&amp;"],
		[39, "&apos;"],
		[60, "&lt;"],
		[62, "&gt;"],
	]);
	exports.getCodePoint =
		String.prototype.codePointAt != null
			? function (str, index) {
					return str.codePointAt(index);
				}
			: function (c, index) {
					return (c.charCodeAt(index) & 64512) === 55296
						? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536
						: c.charCodeAt(index);
				};
	function encodeXML(str) {
		var ret = "";
		var lastIdx = 0;
		var match;
		while ((match = exports.xmlReplacer.exec(str)) !== null) {
			var i = match.index;
			var char = str.charCodeAt(i);
			var next = xmlCodeMap.get(char);
			if (next !== undefined) {
				ret += str.substring(lastIdx, i) + next;
				lastIdx = i + 1;
			} else {
				ret += ""
					.concat(str.substring(lastIdx, i), "&#x")
					.concat((0, exports.getCodePoint)(str, i).toString(16), ";");
				lastIdx = exports.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
			}
		}
		return ret + str.substr(lastIdx);
	}
	exports.encodeXML = encodeXML;
	exports.escape = encodeXML;
	function getEscaper(regex2, map3) {
		return function escape(data) {
			var match;
			var lastIdx = 0;
			var result = "";
			while ((match = regex2.exec(data))) {
				if (lastIdx !== match.index) {
					result += data.substring(lastIdx, match.index);
				}
				result += map3.get(match[0].charCodeAt(0));
				lastIdx = match.index + 1;
			}
			return result + data.substring(lastIdx);
		};
	}
	exports.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
	exports.escapeAttribute = getEscaper(
		/["&\u00A0]/g,
		new Map([
			[34, "&quot;"],
			[38, "&amp;"],
			[160, "&nbsp;"],
		]),
	);
	exports.escapeText = getEscaper(
		/[&<>\u00A0]/g,
		new Map([
			[38, "&amp;"],
			[60, "&lt;"],
			[62, "&gt;"],
			[160, "&nbsp;"],
		]),
	);
});

// node_modules/entities/lib/encode.js
var require_encode = __commonJS((exports) => {
	var __importDefault =
		(exports && exports.__importDefault) ||
		function (mod) {
			return mod && mod.__esModule ? mod : { default: mod };
		};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.encodeNonAsciiHTML = exports.encodeHTML = undefined;
	var encode_html_js_1 = __importDefault(require_encode_html());
	var escape_js_1 = require_escape();
	var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
	function encodeHTML(data) {
		return encodeHTMLTrieRe(htmlReplacer, data);
	}
	exports.encodeHTML = encodeHTML;
	function encodeNonAsciiHTML(data) {
		return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);
	}
	exports.encodeNonAsciiHTML = encodeNonAsciiHTML;
	function encodeHTMLTrieRe(regExp, str) {
		var ret = "";
		var lastIdx = 0;
		var match;
		while ((match = regExp.exec(str)) !== null) {
			var i = match.index;
			ret += str.substring(lastIdx, i);
			var char = str.charCodeAt(i);
			var next = encode_html_js_1.default.get(char);
			if (typeof next === "object") {
				if (i + 1 < str.length) {
					var nextChar = str.charCodeAt(i + 1);
					var value =
						typeof next.n === "number"
							? next.n === nextChar
								? next.o
								: undefined
							: next.n.get(nextChar);
					if (value !== undefined) {
						ret += value;
						lastIdx = regExp.lastIndex += 1;
						continue;
					}
				}
				next = next.v;
			}
			if (next !== undefined) {
				ret += next;
				lastIdx = i + 1;
			} else {
				var cp = (0, escape_js_1.getCodePoint)(str, i);
				ret += "&#x".concat(cp.toString(16), ";");
				lastIdx = regExp.lastIndex += Number(cp !== char);
			}
		}
		return ret + str.substr(lastIdx);
	}
});

// node_modules/entities/lib/index.js
var require_lib3 = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.decodeXMLStrict =
		exports.decodeHTML5Strict =
		exports.decodeHTML4Strict =
		exports.decodeHTML5 =
		exports.decodeHTML4 =
		exports.decodeHTMLAttribute =
		exports.decodeHTMLStrict =
		exports.decodeHTML =
		exports.decodeXML =
		exports.DecodingMode =
		exports.EntityDecoder =
		exports.encodeHTML5 =
		exports.encodeHTML4 =
		exports.encodeNonAsciiHTML =
		exports.encodeHTML =
		exports.escapeText =
		exports.escapeAttribute =
		exports.escapeUTF8 =
		exports.escape =
		exports.encodeXML =
		exports.encode =
		exports.decodeStrict =
		exports.decode =
		exports.EncodingMode =
		exports.EntityLevel =
			undefined;
	var decode_js_1 = require_decode2();
	var encode_js_1 = require_encode();
	var escape_js_1 = require_escape();
	var EntityLevel;
	(function (EntityLevel2) {
		EntityLevel2[(EntityLevel2["XML"] = 0)] = "XML";
		EntityLevel2[(EntityLevel2["HTML"] = 1)] = "HTML";
	})((EntityLevel = exports.EntityLevel || (exports.EntityLevel = {})));
	var EncodingMode;
	(function (EncodingMode2) {
		EncodingMode2[(EncodingMode2["UTF8"] = 0)] = "UTF8";
		EncodingMode2[(EncodingMode2["ASCII"] = 1)] = "ASCII";
		EncodingMode2[(EncodingMode2["Extensive"] = 2)] = "Extensive";
		EncodingMode2[(EncodingMode2["Attribute"] = 3)] = "Attribute";
		EncodingMode2[(EncodingMode2["Text"] = 4)] = "Text";
	})((EncodingMode = exports.EncodingMode || (exports.EncodingMode = {})));
	function decode2(data, options) {
		if (options === undefined) {
			options = EntityLevel.XML;
		}
		var level = typeof options === "number" ? options : options.level;
		if (level === EntityLevel.HTML) {
			var mode = typeof options === "object" ? options.mode : undefined;
			return (0, decode_js_1.decodeHTML)(data, mode);
		}
		return (0, decode_js_1.decodeXML)(data);
	}
	exports.decode = decode2;
	function decodeStrict(data, options) {
		var _a;
		if (options === undefined) {
			options = EntityLevel.XML;
		}
		var opts = typeof options === "number" ? { level: options } : options;
		((_a = opts.mode) !== null && _a !== undefined) ||
			(opts.mode = decode_js_1.DecodingMode.Strict);
		return decode2(data, opts);
	}
	exports.decodeStrict = decodeStrict;
	function encode4(data, options) {
		if (options === undefined) {
			options = EntityLevel.XML;
		}
		var opts = typeof options === "number" ? { level: options } : options;
		if (opts.mode === EncodingMode.UTF8) return (0, escape_js_1.escapeUTF8)(data);
		if (opts.mode === EncodingMode.Attribute) return (0, escape_js_1.escapeAttribute)(data);
		if (opts.mode === EncodingMode.Text) return (0, escape_js_1.escapeText)(data);
		if (opts.level === EntityLevel.HTML) {
			if (opts.mode === EncodingMode.ASCII) {
				return (0, encode_js_1.encodeNonAsciiHTML)(data);
			}
			return (0, encode_js_1.encodeHTML)(data);
		}
		return (0, escape_js_1.encodeXML)(data);
	}
	exports.encode = encode4;
	var escape_js_2 = require_escape();
	Object.defineProperty(exports, "encodeXML", {
		enumerable: true,
		get: function () {
			return escape_js_2.encodeXML;
		},
	});
	Object.defineProperty(exports, "escape", {
		enumerable: true,
		get: function () {
			return escape_js_2.escape;
		},
	});
	Object.defineProperty(exports, "escapeUTF8", {
		enumerable: true,
		get: function () {
			return escape_js_2.escapeUTF8;
		},
	});
	Object.defineProperty(exports, "escapeAttribute", {
		enumerable: true,
		get: function () {
			return escape_js_2.escapeAttribute;
		},
	});
	Object.defineProperty(exports, "escapeText", {
		enumerable: true,
		get: function () {
			return escape_js_2.escapeText;
		},
	});
	var encode_js_2 = require_encode();
	Object.defineProperty(exports, "encodeHTML", {
		enumerable: true,
		get: function () {
			return encode_js_2.encodeHTML;
		},
	});
	Object.defineProperty(exports, "encodeNonAsciiHTML", {
		enumerable: true,
		get: function () {
			return encode_js_2.encodeNonAsciiHTML;
		},
	});
	Object.defineProperty(exports, "encodeHTML4", {
		enumerable: true,
		get: function () {
			return encode_js_2.encodeHTML;
		},
	});
	Object.defineProperty(exports, "encodeHTML5", {
		enumerable: true,
		get: function () {
			return encode_js_2.encodeHTML;
		},
	});
	var decode_js_2 = require_decode2();
	Object.defineProperty(exports, "EntityDecoder", {
		enumerable: true,
		get: function () {
			return decode_js_2.EntityDecoder;
		},
	});
	Object.defineProperty(exports, "DecodingMode", {
		enumerable: true,
		get: function () {
			return decode_js_2.DecodingMode;
		},
	});
	Object.defineProperty(exports, "decodeXML", {
		enumerable: true,
		get: function () {
			return decode_js_2.decodeXML;
		},
	});
	Object.defineProperty(exports, "decodeHTML", {
		enumerable: true,
		get: function () {
			return decode_js_2.decodeHTML;
		},
	});
	Object.defineProperty(exports, "decodeHTMLStrict", {
		enumerable: true,
		get: function () {
			return decode_js_2.decodeHTMLStrict;
		},
	});
	Object.defineProperty(exports, "decodeHTMLAttribute", {
		enumerable: true,
		get: function () {
			return decode_js_2.decodeHTMLAttribute;
		},
	});
	Object.defineProperty(exports, "decodeHTML4", {
		enumerable: true,
		get: function () {
			return decode_js_2.decodeHTML;
		},
	});
	Object.defineProperty(exports, "decodeHTML5", {
		enumerable: true,
		get: function () {
			return decode_js_2.decodeHTML;
		},
	});
	Object.defineProperty(exports, "decodeHTML4Strict", {
		enumerable: true,
		get: function () {
			return decode_js_2.decodeHTMLStrict;
		},
	});
	Object.defineProperty(exports, "decodeHTML5Strict", {
		enumerable: true,
		get: function () {
			return decode_js_2.decodeHTMLStrict;
		},
	});
	Object.defineProperty(exports, "decodeXMLStrict", {
		enumerable: true,
		get: function () {
			return decode_js_2.decodeXML;
		},
	});
});

// node_modules/dom-serializer/lib/foreignNames.js
var require_foreignNames = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.attributeNames = exports.elementNames = undefined;
	exports.elementNames = new Map(
		[
			"altGlyph",
			"altGlyphDef",
			"altGlyphItem",
			"animateColor",
			"animateMotion",
			"animateTransform",
			"clipPath",
			"feBlend",
			"feColorMatrix",
			"feComponentTransfer",
			"feComposite",
			"feConvolveMatrix",
			"feDiffuseLighting",
			"feDisplacementMap",
			"feDistantLight",
			"feDropShadow",
			"feFlood",
			"feFuncA",
			"feFuncB",
			"feFuncG",
			"feFuncR",
			"feGaussianBlur",
			"feImage",
			"feMerge",
			"feMergeNode",
			"feMorphology",
			"feOffset",
			"fePointLight",
			"feSpecularLighting",
			"feSpotLight",
			"feTile",
			"feTurbulence",
			"foreignObject",
			"glyphRef",
			"linearGradient",
			"radialGradient",
			"textPath",
		].map(function (val) {
			return [val.toLowerCase(), val];
		}),
	);
	exports.attributeNames = new Map(
		[
			"definitionURL",
			"attributeName",
			"attributeType",
			"baseFrequency",
			"baseProfile",
			"calcMode",
			"clipPathUnits",
			"diffuseConstant",
			"edgeMode",
			"filterUnits",
			"glyphRef",
			"gradientTransform",
			"gradientUnits",
			"kernelMatrix",
			"kernelUnitLength",
			"keyPoints",
			"keySplines",
			"keyTimes",
			"lengthAdjust",
			"limitingConeAngle",
			"markerHeight",
			"markerUnits",
			"markerWidth",
			"maskContentUnits",
			"maskUnits",
			"numOctaves",
			"pathLength",
			"patternContentUnits",
			"patternTransform",
			"patternUnits",
			"pointsAtX",
			"pointsAtY",
			"pointsAtZ",
			"preserveAlpha",
			"preserveAspectRatio",
			"primitiveUnits",
			"refX",
			"refY",
			"repeatCount",
			"repeatDur",
			"requiredExtensions",
			"requiredFeatures",
			"specularConstant",
			"specularExponent",
			"spreadMethod",
			"startOffset",
			"stdDeviation",
			"stitchTiles",
			"surfaceScale",
			"systemLanguage",
			"tableValues",
			"targetX",
			"targetY",
			"textLength",
			"viewBox",
			"viewTarget",
			"xChannelSelector",
			"yChannelSelector",
			"zoomAndPan",
		].map(function (val) {
			return [val.toLowerCase(), val];
		}),
	);
});

// node_modules/dom-serializer/lib/index.js
var require_lib4 = __commonJS((exports) => {
	var __assign =
		(exports && exports.__assign) ||
		function () {
			__assign =
				Object.assign ||
				function (t2) {
					for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
						s = arguments[i];
						for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t2[p] = s[p];
					}
					return t2;
				};
			return __assign.apply(this, arguments);
		};
	var __createBinding =
		(exports && exports.__createBinding) ||
		(Object.create
			? function (o, m2, k2, k22) {
					if (k22 === undefined) k22 = k2;
					var desc = Object.getOwnPropertyDescriptor(m2, k2);
					if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
						desc = {
							enumerable: true,
							get: function () {
								return m2[k2];
							},
						};
					}
					Object.defineProperty(o, k22, desc);
				}
			: function (o, m2, k2, k22) {
					if (k22 === undefined) k22 = k2;
					o[k22] = m2[k2];
				});
	var __setModuleDefault =
		(exports && exports.__setModuleDefault) ||
		(Object.create
			? function (o, v) {
					Object.defineProperty(o, "default", { enumerable: true, value: v });
				}
			: function (o, v) {
					o["default"] = v;
				});
	var __importStar =
		(exports && exports.__importStar) ||
		function (mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k2 in mod)
					if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
						__createBinding(result, mod, k2);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.render = undefined;
	var ElementType = __importStar(require_lib());
	var entities_1 = require_lib3();
	var foreignNames_js_1 = require_foreignNames();
	var unencodedElements = new Set([
		"style",
		"script",
		"xmp",
		"iframe",
		"noembed",
		"noframes",
		"plaintext",
		"noscript",
	]);
	function replaceQuotes(value) {
		return value.replace(/"/g, "&quot;");
	}
	function formatAttributes(attributes, opts) {
		var _a;
		if (!attributes) return;
		var encode4 =
			((_a = opts.encodeEntities) !== null && _a !== undefined ? _a : opts.decodeEntities) === false
				? replaceQuotes
				: opts.xmlMode || opts.encodeEntities !== "utf8"
					? entities_1.encodeXML
					: entities_1.escapeAttribute;
		return Object.keys(attributes)
			.map(function (key) {
				var _a2, _b;
				var value = (_a2 = attributes[key]) !== null && _a2 !== undefined ? _a2 : "";
				if (opts.xmlMode === "foreign") {
					key =
						(_b = foreignNames_js_1.attributeNames.get(key)) !== null && _b !== undefined
							? _b
							: key;
				}
				if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
					return key;
				}
				return "".concat(key, '="').concat(encode4(value), '"');
			})
			.join(" ");
	}
	var singleTag = new Set([
		"area",
		"base",
		"basefont",
		"br",
		"col",
		"command",
		"embed",
		"frame",
		"hr",
		"img",
		"input",
		"isindex",
		"keygen",
		"link",
		"meta",
		"param",
		"source",
		"track",
		"wbr",
	]);
	function render(node, options) {
		if (options === undefined) {
			options = {};
		}
		var nodes = "length" in node ? node : [node];
		var output = "";
		for (var i = 0; i < nodes.length; i++) {
			output += renderNode(nodes[i], options);
		}
		return output;
	}
	exports.render = render;
	exports.default = render;
	function renderNode(node, options) {
		switch (node.type) {
			case ElementType.Root:
				return render(node.children, options);
			case ElementType.Doctype:
			case ElementType.Directive:
				return renderDirective(node);
			case ElementType.Comment:
				return renderComment(node);
			case ElementType.CDATA:
				return renderCdata(node);
			case ElementType.Script:
			case ElementType.Style:
			case ElementType.Tag:
				return renderTag(node, options);
			case ElementType.Text:
				return renderText(node, options);
		}
	}
	var foreignModeIntegrationPoints = new Set([
		"mi",
		"mo",
		"mn",
		"ms",
		"mtext",
		"annotation-xml",
		"foreignObject",
		"desc",
		"title",
	]);
	var foreignElements = new Set(["svg", "math"]);
	function renderTag(elem, opts) {
		var _a;
		if (opts.xmlMode === "foreign") {
			elem.name =
				(_a = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a !== undefined
					? _a
					: elem.name;
			if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
				opts = __assign(__assign({}, opts), { xmlMode: false });
			}
		}
		if (!opts.xmlMode && foreignElements.has(elem.name)) {
			opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
		}
		var tag = "<".concat(elem.name);
		var attribs = formatAttributes(elem.attribs, opts);
		if (attribs) {
			tag += " ".concat(attribs);
		}
		if (
			elem.children.length === 0 &&
			(opts.xmlMode
				? opts.selfClosingTags !== false
				: opts.selfClosingTags && singleTag.has(elem.name))
		) {
			if (!opts.xmlMode) tag += " ";
			tag += "/>";
		} else {
			tag += ">";
			if (elem.children.length > 0) {
				tag += render(elem.children, opts);
			}
			if (opts.xmlMode || !singleTag.has(elem.name)) {
				tag += "</".concat(elem.name, ">");
			}
		}
		return tag;
	}
	function renderDirective(elem) {
		return "<".concat(elem.data, ">");
	}
	function renderText(elem, opts) {
		var _a;
		var data = elem.data || "";
		if (
			((_a = opts.encodeEntities) !== null && _a !== undefined ? _a : opts.decodeEntities) !==
				false &&
			!(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))
		) {
			data =
				opts.xmlMode || opts.encodeEntities !== "utf8"
					? (0, entities_1.encodeXML)(data)
					: (0, entities_1.escapeText)(data);
		}
		return data;
	}
	function renderCdata(elem) {
		return "<![CDATA[".concat(elem.children[0].data, "]]>");
	}
	function renderComment(elem) {
		return "<!--".concat(elem.data, "-->");
	}
});

// node_modules/domutils/lib/stringify.js
var require_stringify = __commonJS((exports) => {
	var __importDefault =
		(exports && exports.__importDefault) ||
		function (mod) {
			return mod && mod.__esModule ? mod : { default: mod };
		};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getOuterHTML = getOuterHTML;
	exports.getInnerHTML = getInnerHTML;
	exports.getText = getText;
	exports.textContent = textContent;
	exports.innerText = innerText;
	var domhandler_1 = require_lib2();
	var dom_serializer_1 = __importDefault(require_lib4());
	var domelementtype_1 = require_lib();
	function getOuterHTML(node, options) {
		return (0, dom_serializer_1.default)(node, options);
	}
	function getInnerHTML(node, options) {
		return (0, domhandler_1.hasChildren)(node)
			? node.children
					.map(function (node2) {
						return getOuterHTML(node2, options);
					})
					.join("")
			: "";
	}
	function getText(node) {
		if (Array.isArray(node)) return node.map(getText).join("");
		if ((0, domhandler_1.isTag)(node))
			return node.name === "br"
				? `
`
				: getText(node.children);
		if ((0, domhandler_1.isCDATA)(node)) return getText(node.children);
		if ((0, domhandler_1.isText)(node)) return node.data;
		return "";
	}
	function textContent(node) {
		if (Array.isArray(node)) return node.map(textContent).join("");
		if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
			return textContent(node.children);
		}
		if ((0, domhandler_1.isText)(node)) return node.data;
		return "";
	}
	function innerText(node) {
		if (Array.isArray(node)) return node.map(innerText).join("");
		if (
			(0, domhandler_1.hasChildren)(node) &&
			(node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))
		) {
			return innerText(node.children);
		}
		if ((0, domhandler_1.isText)(node)) return node.data;
		return "";
	}
});

// node_modules/domutils/lib/traversal.js
var require_traversal = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getChildren = getChildren;
	exports.getParent = getParent;
	exports.getSiblings = getSiblings;
	exports.getAttributeValue = getAttributeValue;
	exports.hasAttrib = hasAttrib;
	exports.getName = getName;
	exports.nextElementSibling = nextElementSibling;
	exports.prevElementSibling = prevElementSibling;
	var domhandler_1 = require_lib2();
	function getChildren(elem) {
		return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];
	}
	function getParent(elem) {
		return elem.parent || null;
	}
	function getSiblings(elem) {
		var _a, _b;
		var parent = getParent(elem);
		if (parent != null) return getChildren(parent);
		var siblings = [elem];
		var { prev, next } = elem;
		while (prev != null) {
			siblings.unshift(prev);
			((_a = prev), (prev = _a.prev));
		}
		while (next != null) {
			siblings.push(next);
			((_b = next), (next = _b.next));
		}
		return siblings;
	}
	function getAttributeValue(elem, name) {
		var _a;
		return (_a = elem.attribs) === null || _a === undefined ? undefined : _a[name];
	}
	function hasAttrib(elem, name) {
		return (
			elem.attribs != null &&
			Object.prototype.hasOwnProperty.call(elem.attribs, name) &&
			elem.attribs[name] != null
		);
	}
	function getName(elem) {
		return elem.name;
	}
	function nextElementSibling(elem) {
		var _a;
		var next = elem.next;
		while (next !== null && !(0, domhandler_1.isTag)(next)) ((_a = next), (next = _a.next));
		return next;
	}
	function prevElementSibling(elem) {
		var _a;
		var prev = elem.prev;
		while (prev !== null && !(0, domhandler_1.isTag)(prev)) ((_a = prev), (prev = _a.prev));
		return prev;
	}
});

// node_modules/domutils/lib/manipulation.js
var require_manipulation = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.removeElement = removeElement;
	exports.replaceElement = replaceElement;
	exports.appendChild = appendChild;
	exports.append = append2;
	exports.prependChild = prependChild;
	exports.prepend = prepend;
	function removeElement(elem) {
		if (elem.prev) elem.prev.next = elem.next;
		if (elem.next) elem.next.prev = elem.prev;
		if (elem.parent) {
			var childs = elem.parent.children;
			var childsIndex = childs.lastIndexOf(elem);
			if (childsIndex >= 0) {
				childs.splice(childsIndex, 1);
			}
		}
		elem.next = null;
		elem.prev = null;
		elem.parent = null;
	}
	function replaceElement(elem, replacement) {
		var prev = (replacement.prev = elem.prev);
		if (prev) {
			prev.next = replacement;
		}
		var next = (replacement.next = elem.next);
		if (next) {
			next.prev = replacement;
		}
		var parent = (replacement.parent = elem.parent);
		if (parent) {
			var childs = parent.children;
			childs[childs.lastIndexOf(elem)] = replacement;
			elem.parent = null;
		}
	}
	function appendChild(parent, child) {
		removeElement(child);
		child.next = null;
		child.parent = parent;
		if (parent.children.push(child) > 1) {
			var sibling = parent.children[parent.children.length - 2];
			sibling.next = child;
			child.prev = sibling;
		} else {
			child.prev = null;
		}
	}
	function append2(elem, next) {
		removeElement(next);
		var parent = elem.parent;
		var currNext = elem.next;
		next.next = currNext;
		next.prev = elem;
		elem.next = next;
		next.parent = parent;
		if (currNext) {
			currNext.prev = next;
			if (parent) {
				var childs = parent.children;
				childs.splice(childs.lastIndexOf(currNext), 0, next);
			}
		} else if (parent) {
			parent.children.push(next);
		}
	}
	function prependChild(parent, child) {
		removeElement(child);
		child.parent = parent;
		child.prev = null;
		if (parent.children.unshift(child) !== 1) {
			var sibling = parent.children[1];
			sibling.prev = child;
			child.next = sibling;
		} else {
			child.next = null;
		}
	}
	function prepend(elem, prev) {
		removeElement(prev);
		var parent = elem.parent;
		if (parent) {
			var childs = parent.children;
			childs.splice(childs.indexOf(elem), 0, prev);
		}
		if (elem.prev) {
			elem.prev.next = prev;
		}
		prev.parent = parent;
		prev.prev = elem.prev;
		prev.next = elem;
		elem.prev = prev;
	}
});

// node_modules/domutils/lib/querying.js
var require_querying = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.filter = filter2;
	exports.find = find;
	exports.findOneChild = findOneChild;
	exports.findOne = findOne;
	exports.existsOne = existsOne;
	exports.findAll = findAll;
	var domhandler_1 = require_lib2();
	function filter2(test2, node, recurse, limit) {
		if (recurse === undefined) {
			recurse = true;
		}
		if (limit === undefined) {
			limit = Infinity;
		}
		return find(test2, Array.isArray(node) ? node : [node], recurse, limit);
	}
	function find(test2, nodes, recurse, limit) {
		var result = [];
		var nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
		var indexStack = [0];
		for (;;) {
			if (indexStack[0] >= nodeStack[0].length) {
				if (indexStack.length === 1) {
					return result;
				}
				nodeStack.shift();
				indexStack.shift();
				continue;
			}
			var elem = nodeStack[0][indexStack[0]++];
			if (test2(elem)) {
				result.push(elem);
				if (--limit <= 0) return result;
			}
			if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
				indexStack.unshift(0);
				nodeStack.unshift(elem.children);
			}
		}
	}
	function findOneChild(test2, nodes) {
		return nodes.find(test2);
	}
	function findOne(test2, nodes, recurse) {
		if (recurse === undefined) {
			recurse = true;
		}
		var searchedNodes = Array.isArray(nodes) ? nodes : [nodes];
		for (var i = 0; i < searchedNodes.length; i++) {
			var node = searchedNodes[i];
			if ((0, domhandler_1.isTag)(node) && test2(node)) {
				return node;
			}
			if (recurse && (0, domhandler_1.hasChildren)(node) && node.children.length > 0) {
				var found = findOne(test2, node.children, true);
				if (found) return found;
			}
		}
		return null;
	}
	function existsOne(test2, nodes) {
		return (Array.isArray(nodes) ? nodes : [nodes]).some(function (node) {
			return (
				((0, domhandler_1.isTag)(node) && test2(node)) ||
				((0, domhandler_1.hasChildren)(node) && existsOne(test2, node.children))
			);
		});
	}
	function findAll(test2, nodes) {
		var result = [];
		var nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
		var indexStack = [0];
		for (;;) {
			if (indexStack[0] >= nodeStack[0].length) {
				if (nodeStack.length === 1) {
					return result;
				}
				nodeStack.shift();
				indexStack.shift();
				continue;
			}
			var elem = nodeStack[0][indexStack[0]++];
			if ((0, domhandler_1.isTag)(elem) && test2(elem)) result.push(elem);
			if ((0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
				indexStack.unshift(0);
				nodeStack.unshift(elem.children);
			}
		}
	}
});

// node_modules/domutils/lib/legacy.js
var require_legacy = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.testElement = testElement;
	exports.getElements = getElements;
	exports.getElementById = getElementById;
	exports.getElementsByTagName = getElementsByTagName;
	exports.getElementsByClassName = getElementsByClassName;
	exports.getElementsByTagType = getElementsByTagType;
	var domhandler_1 = require_lib2();
	var querying_js_1 = require_querying();
	var Checks = {
		tag_name: function (name) {
			if (typeof name === "function") {
				return function (elem) {
					return (0, domhandler_1.isTag)(elem) && name(elem.name);
				};
			} else if (name === "*") {
				return domhandler_1.isTag;
			}
			return function (elem) {
				return (0, domhandler_1.isTag)(elem) && elem.name === name;
			};
		},
		tag_type: function (type) {
			if (typeof type === "function") {
				return function (elem) {
					return type(elem.type);
				};
			}
			return function (elem) {
				return elem.type === type;
			};
		},
		tag_contains: function (data) {
			if (typeof data === "function") {
				return function (elem) {
					return (0, domhandler_1.isText)(elem) && data(elem.data);
				};
			}
			return function (elem) {
				return (0, domhandler_1.isText)(elem) && elem.data === data;
			};
		},
	};
	function getAttribCheck(attrib, value) {
		if (typeof value === "function") {
			return function (elem) {
				return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
			};
		}
		return function (elem) {
			return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
		};
	}
	function combineFuncs(a12, b) {
		return function (elem) {
			return a12(elem) || b(elem);
		};
	}
	function compileTest(options) {
		var funcs = Object.keys(options).map(function (key) {
			var value = options[key];
			return Object.prototype.hasOwnProperty.call(Checks, key)
				? Checks[key](value)
				: getAttribCheck(key, value);
		});
		return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
	}
	function testElement(options, node) {
		var test2 = compileTest(options);
		return test2 ? test2(node) : true;
	}
	function getElements(options, nodes, recurse, limit) {
		if (limit === undefined) {
			limit = Infinity;
		}
		var test2 = compileTest(options);
		return test2 ? (0, querying_js_1.filter)(test2, nodes, recurse, limit) : [];
	}
	function getElementById(id, nodes, recurse) {
		if (recurse === undefined) {
			recurse = true;
		}
		if (!Array.isArray(nodes)) nodes = [nodes];
		return (0, querying_js_1.findOne)(getAttribCheck("id", id), nodes, recurse);
	}
	function getElementsByTagName(tagName, nodes, recurse, limit) {
		if (recurse === undefined) {
			recurse = true;
		}
		if (limit === undefined) {
			limit = Infinity;
		}
		return (0, querying_js_1.filter)(Checks["tag_name"](tagName), nodes, recurse, limit);
	}
	function getElementsByClassName(className, nodes, recurse, limit) {
		if (recurse === undefined) {
			recurse = true;
		}
		if (limit === undefined) {
			limit = Infinity;
		}
		return (0, querying_js_1.filter)(getAttribCheck("class", className), nodes, recurse, limit);
	}
	function getElementsByTagType(type, nodes, recurse, limit) {
		if (recurse === undefined) {
			recurse = true;
		}
		if (limit === undefined) {
			limit = Infinity;
		}
		return (0, querying_js_1.filter)(Checks["tag_type"](type), nodes, recurse, limit);
	}
});

// node_modules/domutils/lib/helpers.js
var require_helpers = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DocumentPosition = undefined;
	exports.removeSubsets = removeSubsets;
	exports.compareDocumentPosition = compareDocumentPosition;
	exports.uniqueSort = uniqueSort;
	var domhandler_1 = require_lib2();
	function removeSubsets(nodes) {
		var idx = nodes.length;
		while (--idx >= 0) {
			var node = nodes[idx];
			if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
				nodes.splice(idx, 1);
				continue;
			}
			for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
				if (nodes.includes(ancestor)) {
					nodes.splice(idx, 1);
					break;
				}
			}
		}
		return nodes;
	}
	var DocumentPosition;
	(function (DocumentPosition2) {
		DocumentPosition2[(DocumentPosition2["DISCONNECTED"] = 1)] = "DISCONNECTED";
		DocumentPosition2[(DocumentPosition2["PRECEDING"] = 2)] = "PRECEDING";
		DocumentPosition2[(DocumentPosition2["FOLLOWING"] = 4)] = "FOLLOWING";
		DocumentPosition2[(DocumentPosition2["CONTAINS"] = 8)] = "CONTAINS";
		DocumentPosition2[(DocumentPosition2["CONTAINED_BY"] = 16)] = "CONTAINED_BY";
	})(DocumentPosition || (exports.DocumentPosition = DocumentPosition = {}));
	function compareDocumentPosition(nodeA, nodeB) {
		var aParents = [];
		var bParents = [];
		if (nodeA === nodeB) {
			return 0;
		}
		var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
		while (current) {
			aParents.unshift(current);
			current = current.parent;
		}
		current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
		while (current) {
			bParents.unshift(current);
			current = current.parent;
		}
		var maxIdx = Math.min(aParents.length, bParents.length);
		var idx = 0;
		while (idx < maxIdx && aParents[idx] === bParents[idx]) {
			idx++;
		}
		if (idx === 0) {
			return DocumentPosition.DISCONNECTED;
		}
		var sharedParent = aParents[idx - 1];
		var siblings = sharedParent.children;
		var aSibling = aParents[idx];
		var bSibling = bParents[idx];
		if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
			if (sharedParent === nodeB) {
				return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
			}
			return DocumentPosition.FOLLOWING;
		}
		if (sharedParent === nodeA) {
			return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
		}
		return DocumentPosition.PRECEDING;
	}
	function uniqueSort(nodes) {
		nodes = nodes.filter(function (node, i, arr) {
			return !arr.includes(node, i + 1);
		});
		nodes.sort(function (a12, b) {
			var relative = compareDocumentPosition(a12, b);
			if (relative & DocumentPosition.PRECEDING) {
				return -1;
			} else if (relative & DocumentPosition.FOLLOWING) {
				return 1;
			}
			return 0;
		});
		return nodes;
	}
});

// node_modules/domutils/lib/feeds.js
var require_feeds = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getFeed = getFeed;
	var stringify_js_1 = require_stringify();
	var legacy_js_1 = require_legacy();
	function getFeed(doc) {
		var feedRoot = getOneElement(isValidFeed, doc);
		return !feedRoot
			? null
			: feedRoot.name === "feed"
				? getAtomFeed(feedRoot)
				: getRssFeed(feedRoot);
	}
	function getAtomFeed(feedRoot) {
		var _a;
		var childs = feedRoot.children;
		var feed = {
			type: "atom",
			items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(function (item) {
				var _a2;
				var children = item.children;
				var entry = { media: getMediaElements(children) };
				addConditionally(entry, "id", "id", children);
				addConditionally(entry, "title", "title", children);
				var href2 =
					(_a2 = getOneElement("link", children)) === null || _a2 === undefined
						? undefined
						: _a2.attribs["href"];
				if (href2) {
					entry.link = href2;
				}
				var description = fetch2("summary", children) || fetch2("content", children);
				if (description) {
					entry.description = description;
				}
				var pubDate = fetch2("updated", children);
				if (pubDate) {
					entry.pubDate = new Date(pubDate);
				}
				return entry;
			}),
		};
		addConditionally(feed, "id", "id", childs);
		addConditionally(feed, "title", "title", childs);
		var href =
			(_a = getOneElement("link", childs)) === null || _a === undefined
				? undefined
				: _a.attribs["href"];
		if (href) {
			feed.link = href;
		}
		addConditionally(feed, "description", "subtitle", childs);
		var updated = fetch2("updated", childs);
		if (updated) {
			feed.updated = new Date(updated);
		}
		addConditionally(feed, "author", "email", childs, true);
		return feed;
	}
	function getRssFeed(feedRoot) {
		var _a, _b;
		var childs =
			(_b =
				(_a = getOneElement("channel", feedRoot.children)) === null || _a === undefined
					? undefined
					: _a.children) !== null && _b !== undefined
				? _b
				: [];
		var feed = {
			type: feedRoot.name.substr(0, 3),
			id: "",
			items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(function (item) {
				var children = item.children;
				var entry = { media: getMediaElements(children) };
				addConditionally(entry, "id", "guid", children);
				addConditionally(entry, "title", "title", children);
				addConditionally(entry, "link", "link", children);
				addConditionally(entry, "description", "description", children);
				var pubDate = fetch2("pubDate", children) || fetch2("dc:date", children);
				if (pubDate) entry.pubDate = new Date(pubDate);
				return entry;
			}),
		};
		addConditionally(feed, "title", "title", childs);
		addConditionally(feed, "link", "link", childs);
		addConditionally(feed, "description", "description", childs);
		var updated = fetch2("lastBuildDate", childs);
		if (updated) {
			feed.updated = new Date(updated);
		}
		addConditionally(feed, "author", "managingEditor", childs, true);
		return feed;
	}
	var MEDIA_KEYS_STRING = ["url", "type", "lang"];
	var MEDIA_KEYS_INT = [
		"fileSize",
		"bitrate",
		"framerate",
		"samplingrate",
		"channels",
		"duration",
		"height",
		"width",
	];
	function getMediaElements(where) {
		return (0, legacy_js_1.getElementsByTagName)("media:content", where).map(function (elem) {
			var attribs = elem.attribs;
			var media = {
				medium: attribs["medium"],
				isDefault: !!attribs["isDefault"],
			};
			for (
				var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING;
				_i < MEDIA_KEYS_STRING_1.length;
				_i++
			) {
				var attrib = MEDIA_KEYS_STRING_1[_i];
				if (attribs[attrib]) {
					media[attrib] = attribs[attrib];
				}
			}
			for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
				var attrib = MEDIA_KEYS_INT_1[_a];
				if (attribs[attrib]) {
					media[attrib] = parseInt(attribs[attrib], 10);
				}
			}
			if (attribs["expression"]) {
				media.expression = attribs["expression"];
			}
			return media;
		});
	}
	function getOneElement(tagName, node) {
		return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];
	}
	function fetch2(tagName, where, recurse) {
		if (recurse === undefined) {
			recurse = false;
		}
		return (0, stringify_js_1.textContent)(
			(0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1),
		).trim();
	}
	function addConditionally(obj, prop, tagName, where, recurse) {
		if (recurse === undefined) {
			recurse = false;
		}
		var val = fetch2(tagName, where, recurse);
		if (val) obj[prop] = val;
	}
	function isValidFeed(value) {
		return value === "rss" || value === "feed" || value === "rdf:RDF";
	}
});

// node_modules/domutils/lib/index.js
var require_lib5 = __commonJS((exports) => {
	var __createBinding =
		(exports && exports.__createBinding) ||
		(Object.create
			? function (o, m2, k2, k22) {
					if (k22 === undefined) k22 = k2;
					var desc = Object.getOwnPropertyDescriptor(m2, k2);
					if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
						desc = {
							enumerable: true,
							get: function () {
								return m2[k2];
							},
						};
					}
					Object.defineProperty(o, k22, desc);
				}
			: function (o, m2, k2, k22) {
					if (k22 === undefined) k22 = k2;
					o[k22] = m2[k2];
				});
	var __exportStar =
		(exports && exports.__exportStar) ||
		function (m2, exports2) {
			for (var p in m2)
				if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
					__createBinding(exports2, m2, p);
		};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.hasChildren =
		exports.isDocument =
		exports.isComment =
		exports.isText =
		exports.isCDATA =
		exports.isTag =
			undefined;
	__exportStar(require_stringify(), exports);
	__exportStar(require_traversal(), exports);
	__exportStar(require_manipulation(), exports);
	__exportStar(require_querying(), exports);
	__exportStar(require_legacy(), exports);
	__exportStar(require_helpers(), exports);
	__exportStar(require_feeds(), exports);
	var domhandler_1 = require_lib2();
	Object.defineProperty(exports, "isTag", {
		enumerable: true,
		get: function () {
			return domhandler_1.isTag;
		},
	});
	Object.defineProperty(exports, "isCDATA", {
		enumerable: true,
		get: function () {
			return domhandler_1.isCDATA;
		},
	});
	Object.defineProperty(exports, "isText", {
		enumerable: true,
		get: function () {
			return domhandler_1.isText;
		},
	});
	Object.defineProperty(exports, "isComment", {
		enumerable: true,
		get: function () {
			return domhandler_1.isComment;
		},
	});
	Object.defineProperty(exports, "isDocument", {
		enumerable: true,
		get: function () {
			return domhandler_1.isDocument;
		},
	});
	Object.defineProperty(exports, "hasChildren", {
		enumerable: true,
		get: function () {
			return domhandler_1.hasChildren;
		},
	});
});

// node_modules/htmlparser2/lib/index.js
var require_lib6 = __commonJS((exports) => {
	var __createBinding =
		(exports && exports.__createBinding) ||
		(Object.create
			? function (o, m2, k2, k22) {
					if (k22 === undefined) k22 = k2;
					var desc = Object.getOwnPropertyDescriptor(m2, k2);
					if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
						desc = {
							enumerable: true,
							get: function () {
								return m2[k2];
							},
						};
					}
					Object.defineProperty(o, k22, desc);
				}
			: function (o, m2, k2, k22) {
					if (k22 === undefined) k22 = k2;
					o[k22] = m2[k2];
				});
	var __setModuleDefault =
		(exports && exports.__setModuleDefault) ||
		(Object.create
			? function (o, v) {
					Object.defineProperty(o, "default", { enumerable: true, value: v });
				}
			: function (o, v) {
					o["default"] = v;
				});
	var __importStar =
		(exports && exports.__importStar) ||
		function (mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k2 in mod)
					if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2))
						__createBinding(result, mod, k2);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	var __importDefault =
		(exports && exports.__importDefault) ||
		function (mod) {
			return mod && mod.__esModule ? mod : { default: mod };
		};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DomUtils =
		exports.parseFeed =
		exports.getFeed =
		exports.ElementType =
		exports.Tokenizer =
		exports.createDomStream =
		exports.parseDOM =
		exports.parseDocument =
		exports.DefaultHandler =
		exports.DomHandler =
		exports.Parser =
			undefined;
	var Parser_js_1 = require_Parser();
	var Parser_js_2 = require_Parser();
	Object.defineProperty(exports, "Parser", {
		enumerable: true,
		get: function () {
			return Parser_js_2.Parser;
		},
	});
	var domhandler_1 = require_lib2();
	var domhandler_2 = require_lib2();
	Object.defineProperty(exports, "DomHandler", {
		enumerable: true,
		get: function () {
			return domhandler_2.DomHandler;
		},
	});
	Object.defineProperty(exports, "DefaultHandler", {
		enumerable: true,
		get: function () {
			return domhandler_2.DomHandler;
		},
	});
	function parseDocument(data, options) {
		var handler = new domhandler_1.DomHandler(undefined, options);
		new Parser_js_1.Parser(handler, options).end(data);
		return handler.root;
	}
	exports.parseDocument = parseDocument;
	function parseDOM(data, options) {
		return parseDocument(data, options).children;
	}
	exports.parseDOM = parseDOM;
	function createDomStream(callback, options, elementCallback) {
		var handler = new domhandler_1.DomHandler(callback, options, elementCallback);
		return new Parser_js_1.Parser(handler, options);
	}
	exports.createDomStream = createDomStream;
	var Tokenizer_js_1 = require_Tokenizer();
	Object.defineProperty(exports, "Tokenizer", {
		enumerable: true,
		get: function () {
			return __importDefault(Tokenizer_js_1).default;
		},
	});
	exports.ElementType = __importStar(require_lib());
	var domutils_1 = require_lib5();
	var domutils_2 = require_lib5();
	Object.defineProperty(exports, "getFeed", {
		enumerable: true,
		get: function () {
			return domutils_2.getFeed;
		},
	});
	var parseFeedDefaultOptions = { xmlMode: true };
	function parseFeed(feed, options) {
		if (options === undefined) {
			options = parseFeedDefaultOptions;
		}
		return (0, domutils_1.getFeed)(parseDOM(feed, options));
	}
	exports.parseFeed = parseFeed;
	exports.DomUtils = __importStar(require_lib5());
});

// node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS((exports, module) => {
	module.exports = (string) => {
		if (typeof string !== "string") {
			throw new TypeError("Expected a string");
		}
		return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
	};
});

// node_modules/is-plain-object/dist/is-plain-object.js
var require_is_plain_object = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	/*!
	 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
	 *
	 * Copyright (c) 2014-2017, Jon Schlinkert.
	 * Released under the MIT License.
	 */
	function isObject3(o) {
		return Object.prototype.toString.call(o) === "[object Object]";
	}
	function isPlainObject2(o) {
		var ctor, prot;
		if (isObject3(o) === false) return false;
		ctor = o.constructor;
		if (ctor === undefined) return true;
		prot = ctor.prototype;
		if (isObject3(prot) === false) return false;
		if (prot.hasOwnProperty("isPrototypeOf") === false) {
			return false;
		}
		return true;
	}
	exports.isPlainObject = isPlainObject2;
});

// node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS((exports, module) => {
	var isMergeableObject = function isMergeableObject(value) {
		return isNonNullObject(value) && !isSpecial(value);
	};
	function isNonNullObject(value) {
		return !!value && typeof value === "object";
	}
	function isSpecial(value) {
		var stringValue = Object.prototype.toString.call(value);
		return (
			stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value)
		);
	}
	var canUseSymbol = typeof Symbol === "function" && Symbol.for;
	var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
	function isReactElement(value) {
		return value.$$typeof === REACT_ELEMENT_TYPE;
	}
	function emptyTarget(val) {
		return Array.isArray(val) ? [] : {};
	}
	function cloneUnlessOtherwiseSpecified(value, options) {
		return options.clone !== false && options.isMergeableObject(value)
			? deepmerge(emptyTarget(value), value, options)
			: value;
	}
	function defaultArrayMerge(target, source, options) {
		return target.concat(source).map(function (element) {
			return cloneUnlessOtherwiseSpecified(element, options);
		});
	}
	function getMergeFunction(key, options) {
		if (!options.customMerge) {
			return deepmerge;
		}
		var customMerge = options.customMerge(key);
		return typeof customMerge === "function" ? customMerge : deepmerge;
	}
	function getEnumerableOwnPropertySymbols(target) {
		return Object.getOwnPropertySymbols
			? Object.getOwnPropertySymbols(target).filter(function (symbol) {
					return Object.propertyIsEnumerable.call(target, symbol);
				})
			: [];
	}
	function getKeys(target) {
		return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
	}
	function propertyIsOnObject(object, property) {
		try {
			return property in object;
		} catch (_2) {
			return false;
		}
	}
	function propertyIsUnsafe(target, key) {
		return (
			propertyIsOnObject(target, key) &&
			!(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key))
		);
	}
	function mergeObject(target, source, options) {
		var destination = {};
		if (options.isMergeableObject(target)) {
			getKeys(target).forEach(function (key) {
				destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
			});
		}
		getKeys(source).forEach(function (key) {
			if (propertyIsUnsafe(target, key)) {
				return;
			}
			if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
				destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
			} else {
				destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
			}
		});
		return destination;
	}
	function deepmerge(target, source, options) {
		options = options || {};
		options.arrayMerge = options.arrayMerge || defaultArrayMerge;
		options.isMergeableObject = options.isMergeableObject || isMergeableObject;
		options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
		var sourceIsArray = Array.isArray(source);
		var targetIsArray = Array.isArray(target);
		var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
		if (!sourceAndTargetTypesMatch) {
			return cloneUnlessOtherwiseSpecified(source, options);
		} else if (sourceIsArray) {
			return options.arrayMerge(target, source, options);
		} else {
			return mergeObject(target, source, options);
		}
	}
	deepmerge.all = function deepmergeAll(array, options) {
		if (!Array.isArray(array)) {
			throw new Error("first argument should be an array");
		}
		return array.reduce(function (prev, next) {
			return deepmerge(prev, next, options);
		}, {});
	};
	var deepmerge_1 = deepmerge;
	module.exports = deepmerge_1;
});

// node_modules/parse-srcset/src/parse-srcset.js
var require_parse_srcset = __commonJS((exports, module) => {
	(function (root, factory2) {
		if (typeof define === "function" && define.amd) {
			define([], factory2);
		} else if (typeof module === "object" && module.exports) {
			module.exports = factory2();
		} else {
			root.parseSrcset = factory2();
		}
	})(exports, function () {
		return function (input) {
			function isSpace(c2) {
				return (
					c2 === " " ||
					c2 === "\t" ||
					c2 ===
						`
` ||
					c2 === "\f" ||
					c2 === "\r"
				);
			}
			function collectCharacters(regEx) {
				var chars,
					match = regEx.exec(input.substring(pos));
				if (match) {
					chars = match[0];
					pos += chars.length;
					return chars;
				}
			}
			var inputLength = input.length,
				regexLeadingSpaces = /^[ \t\n\r\u000c]+/,
				regexLeadingCommasOrSpaces = /^[, \t\n\r\u000c]+/,
				regexLeadingNotSpaces = /^[^ \t\n\r\u000c]+/,
				regexTrailingCommas = /[,]+$/,
				regexNonNegativeInteger = /^\d+$/,
				regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/,
				url2,
				descriptors2,
				currentDescriptor,
				state,
				c,
				pos = 0,
				candidates = [];
			while (true) {
				collectCharacters(regexLeadingCommasOrSpaces);
				if (pos >= inputLength) {
					return candidates;
				}
				url2 = collectCharacters(regexLeadingNotSpaces);
				descriptors2 = [];
				if (url2.slice(-1) === ",") {
					url2 = url2.replace(regexTrailingCommas, "");
					parseDescriptors();
				} else {
					tokenize();
				}
			}
			function tokenize() {
				collectCharacters(regexLeadingSpaces);
				currentDescriptor = "";
				state = "in descriptor";
				while (true) {
					c = input.charAt(pos);
					if (state === "in descriptor") {
						if (isSpace(c)) {
							if (currentDescriptor) {
								descriptors2.push(currentDescriptor);
								currentDescriptor = "";
								state = "after descriptor";
							}
						} else if (c === ",") {
							pos += 1;
							if (currentDescriptor) {
								descriptors2.push(currentDescriptor);
							}
							parseDescriptors();
							return;
						} else if (c === "(") {
							currentDescriptor = currentDescriptor + c;
							state = "in parens";
						} else if (c === "") {
							if (currentDescriptor) {
								descriptors2.push(currentDescriptor);
							}
							parseDescriptors();
							return;
						} else {
							currentDescriptor = currentDescriptor + c;
						}
					} else if (state === "in parens") {
						if (c === ")") {
							currentDescriptor = currentDescriptor + c;
							state = "in descriptor";
						} else if (c === "") {
							descriptors2.push(currentDescriptor);
							parseDescriptors();
							return;
						} else {
							currentDescriptor = currentDescriptor + c;
						}
					} else if (state === "after descriptor") {
						if (isSpace(c)) {
						} else if (c === "") {
							parseDescriptors();
							return;
						} else {
							state = "in descriptor";
							pos -= 1;
						}
					}
					pos += 1;
				}
			}
			function parseDescriptors() {
				var pError = false,
					w,
					d,
					h,
					i,
					candidate = {},
					desc,
					lastChar,
					value,
					intVal,
					floatVal;
				for (i = 0; i < descriptors2.length; i++) {
					desc = descriptors2[i];
					lastChar = desc[desc.length - 1];
					value = desc.substring(0, desc.length - 1);
					intVal = parseInt(value, 10);
					floatVal = parseFloat(value);
					if (regexNonNegativeInteger.test(value) && lastChar === "w") {
						if (w || d) {
							pError = true;
						}
						if (intVal === 0) {
							pError = true;
						} else {
							w = intVal;
						}
					} else if (regexFloatingPoint.test(value) && lastChar === "x") {
						if (w || d || h) {
							pError = true;
						}
						if (floatVal < 0) {
							pError = true;
						} else {
							d = floatVal;
						}
					} else if (regexNonNegativeInteger.test(value) && lastChar === "h") {
						if (h || d) {
							pError = true;
						}
						if (intVal === 0) {
							pError = true;
						} else {
							h = intVal;
						}
					} else {
						pError = true;
					}
				}
				if (!pError) {
					candidate.url = url2;
					if (w) {
						candidate.w = w;
					}
					if (d) {
						candidate.d = d;
					}
					if (h) {
						candidate.h = h;
					}
					candidates.push(candidate);
				} else if (console && console.log) {
					console.log("Invalid srcset descriptor found in '" + input + "' at '" + desc + "'.");
				}
			}
		};
	});
});

// node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS((exports, module) => {
	var p = process || {};
	var argv = p.argv || [];
	var env3 = p.env || {};
	var isColorSupported =
		!(!!env3.NO_COLOR || argv.includes("--no-color")) &&
		(!!env3.FORCE_COLOR ||
			argv.includes("--color") ||
			p.platform === "win32" ||
			((p.stdout || {}).isTTY && env3.TERM !== "dumb") ||
			!!env3.CI);
	var formatter =
		(open, close, replace = open) =>
		(input) => {
			let string = "" + input,
				index = string.indexOf(close, open.length);
			return ~index
				? open + replaceClose(string, close, replace, index) + close
				: open + string + close;
		};
	var replaceClose = (string, close, replace, index) => {
		let result = "",
			cursor = 0;
		do {
			result += string.substring(cursor, index) + replace;
			cursor = index + close.length;
			index = string.indexOf(close, cursor);
		} while (~index);
		return result + string.substring(cursor);
	};
	var createColors = (enabled = isColorSupported) => {
		let f = enabled ? formatter : () => String;
		return {
			isColorSupported: enabled,
			reset: f("\x1B[0m", "\x1B[0m"),
			bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
			dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
			italic: f("\x1B[3m", "\x1B[23m"),
			underline: f("\x1B[4m", "\x1B[24m"),
			inverse: f("\x1B[7m", "\x1B[27m"),
			hidden: f("\x1B[8m", "\x1B[28m"),
			strikethrough: f("\x1B[9m", "\x1B[29m"),
			black: f("\x1B[30m", "\x1B[39m"),
			red: f("\x1B[31m", "\x1B[39m"),
			green: f("\x1B[32m", "\x1B[39m"),
			yellow: f("\x1B[33m", "\x1B[39m"),
			blue: f("\x1B[34m", "\x1B[39m"),
			magenta: f("\x1B[35m", "\x1B[39m"),
			cyan: f("\x1B[36m", "\x1B[39m"),
			white: f("\x1B[37m", "\x1B[39m"),
			gray: f("\x1B[90m", "\x1B[39m"),
			bgBlack: f("\x1B[40m", "\x1B[49m"),
			bgRed: f("\x1B[41m", "\x1B[49m"),
			bgGreen: f("\x1B[42m", "\x1B[49m"),
			bgYellow: f("\x1B[43m", "\x1B[49m"),
			bgBlue: f("\x1B[44m", "\x1B[49m"),
			bgMagenta: f("\x1B[45m", "\x1B[49m"),
			bgCyan: f("\x1B[46m", "\x1B[49m"),
			bgWhite: f("\x1B[47m", "\x1B[49m"),
			blackBright: f("\x1B[90m", "\x1B[39m"),
			redBright: f("\x1B[91m", "\x1B[39m"),
			greenBright: f("\x1B[92m", "\x1B[39m"),
			yellowBright: f("\x1B[93m", "\x1B[39m"),
			blueBright: f("\x1B[94m", "\x1B[39m"),
			magentaBright: f("\x1B[95m", "\x1B[39m"),
			cyanBright: f("\x1B[96m", "\x1B[39m"),
			whiteBright: f("\x1B[97m", "\x1B[39m"),
			bgBlackBright: f("\x1B[100m", "\x1B[49m"),
			bgRedBright: f("\x1B[101m", "\x1B[49m"),
			bgGreenBright: f("\x1B[102m", "\x1B[49m"),
			bgYellowBright: f("\x1B[103m", "\x1B[49m"),
			bgBlueBright: f("\x1B[104m", "\x1B[49m"),
			bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
			bgCyanBright: f("\x1B[106m", "\x1B[49m"),
			bgWhiteBright: f("\x1B[107m", "\x1B[49m"),
		};
	};
	module.exports = createColors();
	module.exports.createColors = createColors;
});

// node_modules/postcss/lib/tokenize.js
var require_tokenize = __commonJS((exports, module) => {
	var SINGLE_QUOTE = 39;
	var DOUBLE_QUOTE = 34;
	var BACKSLASH = 92;
	var SLASH = 47;
	var NEWLINE = 10;
	var SPACE = 32;
	var FEED = 12;
	var TAB = 9;
	var CR = 13;
	var OPEN_SQUARE = 91;
	var CLOSE_SQUARE = 93;
	var OPEN_PARENTHESES = 40;
	var CLOSE_PARENTHESES = 41;
	var OPEN_CURLY = 123;
	var CLOSE_CURLY = 125;
	var SEMICOLON = 59;
	var ASTERISK = 42;
	var COLON = 58;
	var AT = 64;
	var RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
	var RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
	var RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
	var RE_HEX_ESCAPE = /[\da-f]/i;
	module.exports = function tokenizer(input, options = {}) {
		let css = input.css.valueOf();
		let ignore = options.ignoreErrors;
		let code, content, escape, next, quote;
		let currentToken, escaped, escapePos, n2, prev;
		let length = css.length;
		let pos = 0;
		let buffer = [];
		let returned = [];
		function position() {
			return pos;
		}
		function unclosed(what) {
			throw input.error("Unclosed " + what, pos);
		}
		function endOfFile() {
			return returned.length === 0 && pos >= length;
		}
		function nextToken(opts) {
			if (returned.length) return returned.pop();
			if (pos >= length) return;
			let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
			code = css.charCodeAt(pos);
			switch (code) {
				case NEWLINE:
				case SPACE:
				case TAB:
				case CR:
				case FEED: {
					next = pos;
					do {
						next += 1;
						code = css.charCodeAt(next);
					} while (
						code === SPACE ||
						code === NEWLINE ||
						code === TAB ||
						code === CR ||
						code === FEED
					);
					currentToken = ["space", css.slice(pos, next)];
					pos = next - 1;
					break;
				}
				case OPEN_SQUARE:
				case CLOSE_SQUARE:
				case OPEN_CURLY:
				case CLOSE_CURLY:
				case COLON:
				case SEMICOLON:
				case CLOSE_PARENTHESES: {
					let controlChar = String.fromCharCode(code);
					currentToken = [controlChar, controlChar, pos];
					break;
				}
				case OPEN_PARENTHESES: {
					prev = buffer.length ? buffer.pop()[1] : "";
					n2 = css.charCodeAt(pos + 1);
					if (
						prev === "url" &&
						n2 !== SINGLE_QUOTE &&
						n2 !== DOUBLE_QUOTE &&
						n2 !== SPACE &&
						n2 !== NEWLINE &&
						n2 !== TAB &&
						n2 !== FEED &&
						n2 !== CR
					) {
						next = pos;
						do {
							escaped = false;
							next = css.indexOf(")", next + 1);
							if (next === -1) {
								if (ignore || ignoreUnclosed) {
									next = pos;
									break;
								} else {
									unclosed("bracket");
								}
							}
							escapePos = next;
							while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
								escapePos -= 1;
								escaped = !escaped;
							}
						} while (escaped);
						currentToken = ["brackets", css.slice(pos, next + 1), pos, next];
						pos = next;
					} else {
						next = css.indexOf(")", pos + 1);
						content = css.slice(pos, next + 1);
						if (next === -1 || RE_BAD_BRACKET.test(content)) {
							currentToken = ["(", "(", pos];
						} else {
							currentToken = ["brackets", content, pos, next];
							pos = next;
						}
					}
					break;
				}
				case SINGLE_QUOTE:
				case DOUBLE_QUOTE: {
					quote = code === SINGLE_QUOTE ? "'" : '"';
					next = pos;
					do {
						escaped = false;
						next = css.indexOf(quote, next + 1);
						if (next === -1) {
							if (ignore || ignoreUnclosed) {
								next = pos + 1;
								break;
							} else {
								unclosed("string");
							}
						}
						escapePos = next;
						while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
							escapePos -= 1;
							escaped = !escaped;
						}
					} while (escaped);
					currentToken = ["string", css.slice(pos, next + 1), pos, next];
					pos = next;
					break;
				}
				case AT: {
					RE_AT_END.lastIndex = pos + 1;
					RE_AT_END.test(css);
					if (RE_AT_END.lastIndex === 0) {
						next = css.length - 1;
					} else {
						next = RE_AT_END.lastIndex - 2;
					}
					currentToken = ["at-word", css.slice(pos, next + 1), pos, next];
					pos = next;
					break;
				}
				case BACKSLASH: {
					next = pos;
					escape = true;
					while (css.charCodeAt(next + 1) === BACKSLASH) {
						next += 1;
						escape = !escape;
					}
					code = css.charCodeAt(next + 1);
					if (
						escape &&
						code !== SLASH &&
						code !== SPACE &&
						code !== NEWLINE &&
						code !== TAB &&
						code !== CR &&
						code !== FEED
					) {
						next += 1;
						if (RE_HEX_ESCAPE.test(css.charAt(next))) {
							while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
								next += 1;
							}
							if (css.charCodeAt(next + 1) === SPACE) {
								next += 1;
							}
						}
					}
					currentToken = ["word", css.slice(pos, next + 1), pos, next];
					pos = next;
					break;
				}
				default: {
					if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
						next = css.indexOf("*/", pos + 2) + 1;
						if (next === 0) {
							if (ignore || ignoreUnclosed) {
								next = css.length;
							} else {
								unclosed("comment");
							}
						}
						currentToken = ["comment", css.slice(pos, next + 1), pos, next];
						pos = next;
					} else {
						RE_WORD_END.lastIndex = pos + 1;
						RE_WORD_END.test(css);
						if (RE_WORD_END.lastIndex === 0) {
							next = css.length - 1;
						} else {
							next = RE_WORD_END.lastIndex - 2;
						}
						currentToken = ["word", css.slice(pos, next + 1), pos, next];
						buffer.push(currentToken);
						pos = next;
					}
					break;
				}
			}
			pos++;
			return currentToken;
		}
		function back(token) {
			returned.push(token);
		}
		return {
			back,
			endOfFile,
			nextToken,
			position,
		};
	};
});

// node_modules/postcss/lib/terminal-highlight.js
var require_terminal_highlight = __commonJS((exports, module) => {
	var pico = require_picocolors();
	var tokenizer = require_tokenize();
	var Input;
	function registerInput(dependant) {
		Input = dependant;
	}
	var HIGHLIGHT_THEME = {
		";": pico.yellow,
		":": pico.yellow,
		"(": pico.cyan,
		")": pico.cyan,
		"[": pico.yellow,
		"]": pico.yellow,
		"{": pico.yellow,
		"}": pico.yellow,
		"at-word": pico.cyan,
		brackets: pico.cyan,
		call: pico.cyan,
		class: pico.yellow,
		comment: pico.gray,
		hash: pico.magenta,
		string: pico.green,
	};
	function getTokenType([type, value], processor) {
		if (type === "word") {
			if (value[0] === ".") {
				return "class";
			}
			if (value[0] === "#") {
				return "hash";
			}
		}
		if (!processor.endOfFile()) {
			let next = processor.nextToken();
			processor.back(next);
			if (next[0] === "brackets" || next[0] === "(") return "call";
		}
		return type;
	}
	function terminalHighlight(css) {
		let processor = tokenizer(new Input(css), { ignoreErrors: true });
		let result = "";
		while (!processor.endOfFile()) {
			let token = processor.nextToken();
			let color = HIGHLIGHT_THEME[getTokenType(token, processor)];
			if (color) {
				result += token[1].split(/\r?\n/).map((i) => color(i)).join(`
`);
			} else {
				result += token[1];
			}
		}
		return result;
	}
	terminalHighlight.registerInput = registerInput;
	module.exports = terminalHighlight;
});

// node_modules/postcss/lib/css-syntax-error.js
var require_css_syntax_error = __commonJS((exports, module) => {
	var pico = require_picocolors();
	var terminalHighlight = require_terminal_highlight();

	class CssSyntaxError extends Error {
		constructor(message, line, column, source, file, plugin) {
			super(message);
			this.name = "CssSyntaxError";
			this.reason = message;
			if (file) {
				this.file = file;
			}
			if (source) {
				this.source = source;
			}
			if (plugin) {
				this.plugin = plugin;
			}
			if (typeof line !== "undefined" && typeof column !== "undefined") {
				if (typeof line === "number") {
					this.line = line;
					this.column = column;
				} else {
					this.line = line.line;
					this.column = line.column;
					this.endLine = column.line;
					this.endColumn = column.column;
				}
			}
			this.setMessage();
			if (Error.captureStackTrace) {
				Error.captureStackTrace(this, CssSyntaxError);
			}
		}
		setMessage() {
			this.message = this.plugin ? this.plugin + ": " : "";
			this.message += this.file ? this.file : "<css input>";
			if (typeof this.line !== "undefined") {
				this.message += ":" + this.line + ":" + this.column;
			}
			this.message += ": " + this.reason;
		}
		showSourceCode(color) {
			if (!this.source) return "";
			let css = this.source;
			if (color == null) color = pico.isColorSupported;
			let aside = (text) => text;
			let mark = (text) => text;
			let highlight = (text) => text;
			if (color) {
				let { bold, gray, red } = pico.createColors(true);
				mark = (text) => bold(red(text));
				aside = (text) => gray(text);
				if (terminalHighlight) {
					highlight = (text) => terminalHighlight(text);
				}
			}
			let lines = css.split(/\r?\n/);
			let start = Math.max(this.line - 3, 0);
			let end = Math.min(this.line + 2, lines.length);
			let maxWidth = String(end).length;
			return lines.slice(start, end).map((line, index) => {
				let number = start + 1 + index;
				let gutter = " " + (" " + number).slice(-maxWidth) + " | ";
				if (number === this.line) {
					if (line.length > 160) {
						let padding = 20;
						let subLineStart = Math.max(0, this.column - padding);
						let subLineEnd = Math.max(this.column + padding, this.endColumn + padding);
						let subLine = line.slice(subLineStart, subLineEnd);
						let spacing2 =
							aside(gutter.replace(/\d/g, " ")) +
							line.slice(0, Math.min(this.column - 1, padding - 1)).replace(/[^\t]/g, " ");
						return (
							mark(">") +
							aside(gutter) +
							highlight(subLine) +
							`
 ` +
							spacing2 +
							mark("^")
						);
					}
					let spacing =
						aside(gutter.replace(/\d/g, " ")) +
						line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
					return (
						mark(">") +
						aside(gutter) +
						highlight(line) +
						`
 ` +
						spacing +
						mark("^")
					);
				}
				return " " + aside(gutter) + highlight(line);
			}).join(`
`);
		}
		toString() {
			let code = this.showSourceCode();
			if (code) {
				code =
					`

` +
					code +
					`
`;
			}
			return this.name + ": " + this.message + code;
		}
	}
	module.exports = CssSyntaxError;
	CssSyntaxError.default = CssSyntaxError;
});

// node_modules/postcss/lib/stringifier.js
var require_stringifier = __commonJS((exports, module) => {
	var DEFAULT_RAW = {
		after: `
`,
		beforeClose: `
`,
		beforeComment: `
`,
		beforeDecl: `
`,
		beforeOpen: " ",
		beforeRule: `
`,
		colon: ": ",
		commentLeft: " ",
		commentRight: " ",
		emptyBody: "",
		indent: "    ",
		semicolon: false,
	};
	function capitalize2(str) {
		return str[0].toUpperCase() + str.slice(1);
	}

	class Stringifier {
		constructor(builder) {
			this.builder = builder;
		}
		atrule(node, semicolon) {
			let name = "@" + node.name;
			let params = node.params ? this.rawValue(node, "params") : "";
			if (typeof node.raws.afterName !== "undefined") {
				name += node.raws.afterName;
			} else if (params) {
				name += " ";
			}
			if (node.nodes) {
				this.block(node, name + params);
			} else {
				let end = (node.raws.between || "") + (semicolon ? ";" : "");
				this.builder(name + params + end, node);
			}
		}
		beforeAfter(node, detect) {
			let value;
			if (node.type === "decl") {
				value = this.raw(node, null, "beforeDecl");
			} else if (node.type === "comment") {
				value = this.raw(node, null, "beforeComment");
			} else if (detect === "before") {
				value = this.raw(node, null, "beforeRule");
			} else {
				value = this.raw(node, null, "beforeClose");
			}
			let buf = node.parent;
			let depth = 0;
			while (buf && buf.type !== "root") {
				depth += 1;
				buf = buf.parent;
			}
			if (
				value.includes(`
`)
			) {
				let indent = this.raw(node, null, "indent");
				if (indent.length) {
					for (let step = 0; step < depth; step++) value += indent;
				}
			}
			return value;
		}
		block(node, start) {
			let between = this.raw(node, "between", "beforeOpen");
			this.builder(start + between + "{", node, "start");
			let after;
			if (node.nodes && node.nodes.length) {
				this.body(node);
				after = this.raw(node, "after");
			} else {
				after = this.raw(node, "after", "emptyBody");
			}
			if (after) this.builder(after);
			this.builder("}", node, "end");
		}
		body(node) {
			let last = node.nodes.length - 1;
			while (last > 0) {
				if (node.nodes[last].type !== "comment") break;
				last -= 1;
			}
			let semicolon = this.raw(node, "semicolon");
			for (let i = 0; i < node.nodes.length; i++) {
				let child = node.nodes[i];
				let before = this.raw(child, "before");
				if (before) this.builder(before);
				this.stringify(child, last !== i || semicolon);
			}
		}
		comment(node) {
			let left = this.raw(node, "left", "commentLeft");
			let right = this.raw(node, "right", "commentRight");
			this.builder("/*" + left + node.text + right + "*/", node);
		}
		decl(node, semicolon) {
			let between = this.raw(node, "between", "colon");
			let string = node.prop + between + this.rawValue(node, "value");
			if (node.important) {
				string += node.raws.important || " !important";
			}
			if (semicolon) string += ";";
			this.builder(string, node);
		}
		document(node) {
			this.body(node);
		}
		raw(node, own, detect) {
			let value;
			if (!detect) detect = own;
			if (own) {
				value = node.raws[own];
				if (typeof value !== "undefined") return value;
			}
			let parent = node.parent;
			if (detect === "before") {
				if (!parent || (parent.type === "root" && parent.first === node)) {
					return "";
				}
				if (parent && parent.type === "document") {
					return "";
				}
			}
			if (!parent) return DEFAULT_RAW[detect];
			let root = node.root();
			if (!root.rawCache) root.rawCache = {};
			if (typeof root.rawCache[detect] !== "undefined") {
				return root.rawCache[detect];
			}
			if (detect === "before" || detect === "after") {
				return this.beforeAfter(node, detect);
			} else {
				let method = "raw" + capitalize2(detect);
				if (this[method]) {
					value = this[method](root, node);
				} else {
					root.walk((i) => {
						value = i.raws[own];
						if (typeof value !== "undefined") return false;
					});
				}
			}
			if (typeof value === "undefined") value = DEFAULT_RAW[detect];
			root.rawCache[detect] = value;
			return value;
		}
		rawBeforeClose(root) {
			let value;
			root.walk((i) => {
				if (i.nodes && i.nodes.length > 0) {
					if (typeof i.raws.after !== "undefined") {
						value = i.raws.after;
						if (
							value.includes(`
`)
						) {
							value = value.replace(/[^\n]+$/, "");
						}
						return false;
					}
				}
			});
			if (value) value = value.replace(/\S/g, "");
			return value;
		}
		rawBeforeComment(root, node) {
			let value;
			root.walkComments((i) => {
				if (typeof i.raws.before !== "undefined") {
					value = i.raws.before;
					if (
						value.includes(`
`)
					) {
						value = value.replace(/[^\n]+$/, "");
					}
					return false;
				}
			});
			if (typeof value === "undefined") {
				value = this.raw(node, null, "beforeDecl");
			} else if (value) {
				value = value.replace(/\S/g, "");
			}
			return value;
		}
		rawBeforeDecl(root, node) {
			let value;
			root.walkDecls((i) => {
				if (typeof i.raws.before !== "undefined") {
					value = i.raws.before;
					if (
						value.includes(`
`)
					) {
						value = value.replace(/[^\n]+$/, "");
					}
					return false;
				}
			});
			if (typeof value === "undefined") {
				value = this.raw(node, null, "beforeRule");
			} else if (value) {
				value = value.replace(/\S/g, "");
			}
			return value;
		}
		rawBeforeOpen(root) {
			let value;
			root.walk((i) => {
				if (i.type !== "decl") {
					value = i.raws.between;
					if (typeof value !== "undefined") return false;
				}
			});
			return value;
		}
		rawBeforeRule(root) {
			let value;
			root.walk((i) => {
				if (i.nodes && (i.parent !== root || root.first !== i)) {
					if (typeof i.raws.before !== "undefined") {
						value = i.raws.before;
						if (
							value.includes(`
`)
						) {
							value = value.replace(/[^\n]+$/, "");
						}
						return false;
					}
				}
			});
			if (value) value = value.replace(/\S/g, "");
			return value;
		}
		rawColon(root) {
			let value;
			root.walkDecls((i) => {
				if (typeof i.raws.between !== "undefined") {
					value = i.raws.between.replace(/[^\s:]/g, "");
					return false;
				}
			});
			return value;
		}
		rawEmptyBody(root) {
			let value;
			root.walk((i) => {
				if (i.nodes && i.nodes.length === 0) {
					value = i.raws.after;
					if (typeof value !== "undefined") return false;
				}
			});
			return value;
		}
		rawIndent(root) {
			if (root.raws.indent) return root.raws.indent;
			let value;
			root.walk((i) => {
				let p = i.parent;
				if (p && p !== root && p.parent && p.parent === root) {
					if (typeof i.raws.before !== "undefined") {
						let parts = i.raws.before.split(`
`);
						value = parts[parts.length - 1];
						value = value.replace(/\S/g, "");
						return false;
					}
				}
			});
			return value;
		}
		rawSemicolon(root) {
			let value;
			root.walk((i) => {
				if (i.nodes && i.nodes.length && i.last.type === "decl") {
					value = i.raws.semicolon;
					if (typeof value !== "undefined") return false;
				}
			});
			return value;
		}
		rawValue(node, prop) {
			let value = node[prop];
			let raw = node.raws[prop];
			if (raw && raw.value === value) {
				return raw.raw;
			}
			return value;
		}
		root(node) {
			this.body(node);
			if (node.raws.after) this.builder(node.raws.after);
		}
		rule(node) {
			this.block(node, this.rawValue(node, "selector"));
			if (node.raws.ownSemicolon) {
				this.builder(node.raws.ownSemicolon, node, "end");
			}
		}
		stringify(node, semicolon) {
			if (!this[node.type]) {
				throw new Error(
					"Unknown AST node type " +
						node.type +
						". " +
						"Maybe you need to change PostCSS stringifier.",
				);
			}
			this[node.type](node, semicolon);
		}
	}
	module.exports = Stringifier;
	Stringifier.default = Stringifier;
});

// node_modules/postcss/lib/stringify.js
var require_stringify2 = __commonJS((exports, module) => {
	var Stringifier = require_stringifier();
	function stringify(node, builder) {
		let str = new Stringifier(builder);
		str.stringify(node);
	}
	module.exports = stringify;
	stringify.default = stringify;
});

// node_modules/postcss/lib/symbols.js
var require_symbols = __commonJS((exports, module) => {
	exports.isClean = Symbol("isClean");
	exports.my = Symbol("my");
});

// node_modules/postcss/lib/node.js
var require_node3 = __commonJS((exports, module) => {
	var CssSyntaxError = require_css_syntax_error();
	var Stringifier = require_stringifier();
	var stringify = require_stringify2();
	var { isClean, my } = require_symbols();
	function cloneNode(obj, parent) {
		let cloned = new obj.constructor();
		for (let i in obj) {
			if (!Object.prototype.hasOwnProperty.call(obj, i)) {
				continue;
			}
			if (i === "proxyCache") continue;
			let value = obj[i];
			let type = typeof value;
			if (i === "parent" && type === "object") {
				if (parent) cloned[i] = parent;
			} else if (i === "source") {
				cloned[i] = value;
			} else if (Array.isArray(value)) {
				cloned[i] = value.map((j) => cloneNode(j, cloned));
			} else {
				if (type === "object" && value !== null) value = cloneNode(value);
				cloned[i] = value;
			}
		}
		return cloned;
	}
	function sourceOffset(inputCSS, position) {
		if (position && typeof position.offset !== "undefined") {
			return position.offset;
		}
		let column = 1;
		let line = 1;
		let offset = 0;
		for (let i = 0; i < inputCSS.length; i++) {
			if (line === position.line && column === position.column) {
				offset = i;
				break;
			}
			if (
				inputCSS[i] ===
				`
`
			) {
				column = 1;
				line += 1;
			} else {
				column += 1;
			}
		}
		return offset;
	}

	class Node {
		get proxyOf() {
			return this;
		}
		constructor(defaults2 = {}) {
			this.raws = {};
			this[isClean] = false;
			this[my] = true;
			for (let name in defaults2) {
				if (name === "nodes") {
					this.nodes = [];
					for (let node of defaults2[name]) {
						if (typeof node.clone === "function") {
							this.append(node.clone());
						} else {
							this.append(node);
						}
					}
				} else {
					this[name] = defaults2[name];
				}
			}
		}
		addToError(error) {
			error.postcssNode = this;
			if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
				let s = this.source;
				error.stack = error.stack.replace(
					/\n\s{4}at /,
					`$&${s.input.from}:${s.start.line}:${s.start.column}$&`,
				);
			}
			return error;
		}
		after(add) {
			this.parent.insertAfter(this, add);
			return this;
		}
		assign(overrides = {}) {
			for (let name in overrides) {
				this[name] = overrides[name];
			}
			return this;
		}
		before(add) {
			this.parent.insertBefore(this, add);
			return this;
		}
		cleanRaws(keepBetween) {
			delete this.raws.before;
			delete this.raws.after;
			if (!keepBetween) delete this.raws.between;
		}
		clone(overrides = {}) {
			let cloned = cloneNode(this);
			for (let name in overrides) {
				cloned[name] = overrides[name];
			}
			return cloned;
		}
		cloneAfter(overrides = {}) {
			let cloned = this.clone(overrides);
			this.parent.insertAfter(this, cloned);
			return cloned;
		}
		cloneBefore(overrides = {}) {
			let cloned = this.clone(overrides);
			this.parent.insertBefore(this, cloned);
			return cloned;
		}
		error(message, opts = {}) {
			if (this.source) {
				let { end, start } = this.rangeBy(opts);
				return this.source.input.error(
					message,
					{ column: start.column, line: start.line },
					{ column: end.column, line: end.line },
					opts,
				);
			}
			return new CssSyntaxError(message);
		}
		getProxyProcessor() {
			return {
				get(node, prop) {
					if (prop === "proxyOf") {
						return node;
					} else if (prop === "root") {
						return () => node.root().toProxy();
					} else {
						return node[prop];
					}
				},
				set(node, prop, value) {
					if (node[prop] === value) return true;
					node[prop] = value;
					if (
						prop === "prop" ||
						prop === "value" ||
						prop === "name" ||
						prop === "params" ||
						prop === "important" ||
						prop === "text"
					) {
						node.markDirty();
					}
					return true;
				},
			};
		}
		markClean() {
			this[isClean] = true;
		}
		markDirty() {
			if (this[isClean]) {
				this[isClean] = false;
				let next = this;
				while ((next = next.parent)) {
					next[isClean] = false;
				}
			}
		}
		next() {
			if (!this.parent) return;
			let index = this.parent.index(this);
			return this.parent.nodes[index + 1];
		}
		positionBy(opts = {}) {
			let pos = this.source.start;
			if (opts.index) {
				pos = this.positionInside(opts.index);
			} else if (opts.word) {
				let inputString =
					"document" in this.source.input ? this.source.input.document : this.source.input.css;
				let stringRepresentation = inputString.slice(
					sourceOffset(inputString, this.source.start),
					sourceOffset(inputString, this.source.end),
				);
				let index = stringRepresentation.indexOf(opts.word);
				if (index !== -1) pos = this.positionInside(index);
			}
			return pos;
		}
		positionInside(index) {
			let column = this.source.start.column;
			let line = this.source.start.line;
			let inputString =
				"document" in this.source.input ? this.source.input.document : this.source.input.css;
			let offset = sourceOffset(inputString, this.source.start);
			let end = offset + index;
			for (let i = offset; i < end; i++) {
				if (
					inputString[i] ===
					`
`
				) {
					column = 1;
					line += 1;
				} else {
					column += 1;
				}
			}
			return { column, line, offset: end };
		}
		prev() {
			if (!this.parent) return;
			let index = this.parent.index(this);
			return this.parent.nodes[index - 1];
		}
		rangeBy(opts = {}) {
			let inputString =
				"document" in this.source.input ? this.source.input.document : this.source.input.css;
			let start = {
				column: this.source.start.column,
				line: this.source.start.line,
				offset: sourceOffset(inputString, this.source.start),
			};
			let end = this.source.end
				? {
						column: this.source.end.column + 1,
						line: this.source.end.line,
						offset:
							typeof this.source.end.offset === "number"
								? this.source.end.offset
								: sourceOffset(inputString, this.source.end) + 1,
					}
				: {
						column: start.column + 1,
						line: start.line,
						offset: start.offset + 1,
					};
			if (opts.word) {
				let stringRepresentation = inputString.slice(
					sourceOffset(inputString, this.source.start),
					sourceOffset(inputString, this.source.end),
				);
				let index = stringRepresentation.indexOf(opts.word);
				if (index !== -1) {
					start = this.positionInside(index);
					end = this.positionInside(index + opts.word.length);
				}
			} else {
				if (opts.start) {
					start = {
						column: opts.start.column,
						line: opts.start.line,
						offset: sourceOffset(inputString, opts.start),
					};
				} else if (opts.index) {
					start = this.positionInside(opts.index);
				}
				if (opts.end) {
					end = {
						column: opts.end.column,
						line: opts.end.line,
						offset: sourceOffset(inputString, opts.end),
					};
				} else if (typeof opts.endIndex === "number") {
					end = this.positionInside(opts.endIndex);
				} else if (opts.index) {
					end = this.positionInside(opts.index + 1);
				}
			}
			if (end.line < start.line || (end.line === start.line && end.column <= start.column)) {
				end = {
					column: start.column + 1,
					line: start.line,
					offset: start.offset + 1,
				};
			}
			return { end, start };
		}
		raw(prop, defaultType) {
			let str = new Stringifier();
			return str.raw(this, prop, defaultType);
		}
		remove() {
			if (this.parent) {
				this.parent.removeChild(this);
			}
			this.parent = undefined;
			return this;
		}
		replaceWith(...nodes) {
			if (this.parent) {
				let bookmark = this;
				let foundSelf = false;
				for (let node of nodes) {
					if (node === this) {
						foundSelf = true;
					} else if (foundSelf) {
						this.parent.insertAfter(bookmark, node);
						bookmark = node;
					} else {
						this.parent.insertBefore(bookmark, node);
					}
				}
				if (!foundSelf) {
					this.remove();
				}
			}
			return this;
		}
		root() {
			let result = this;
			while (result.parent && result.parent.type !== "document") {
				result = result.parent;
			}
			return result;
		}
		toJSON(_2, inputs) {
			let fixed = {};
			let emitInputs = inputs == null;
			inputs = inputs || new Map();
			let inputsNextIndex = 0;
			for (let name in this) {
				if (!Object.prototype.hasOwnProperty.call(this, name)) {
					continue;
				}
				if (name === "parent" || name === "proxyCache") continue;
				let value = this[name];
				if (Array.isArray(value)) {
					fixed[name] = value.map((i) => {
						if (typeof i === "object" && i.toJSON) {
							return i.toJSON(null, inputs);
						} else {
							return i;
						}
					});
				} else if (typeof value === "object" && value.toJSON) {
					fixed[name] = value.toJSON(null, inputs);
				} else if (name === "source") {
					if (value == null) continue;
					let inputId = inputs.get(value.input);
					if (inputId == null) {
						inputId = inputsNextIndex;
						inputs.set(value.input, inputsNextIndex);
						inputsNextIndex++;
					}
					fixed[name] = {
						end: value.end,
						inputId,
						start: value.start,
					};
				} else {
					fixed[name] = value;
				}
			}
			if (emitInputs) {
				fixed.inputs = [...inputs.keys()].map((input) => input.toJSON());
			}
			return fixed;
		}
		toProxy() {
			if (!this.proxyCache) {
				this.proxyCache = new Proxy(this, this.getProxyProcessor());
			}
			return this.proxyCache;
		}
		toString(stringifier = stringify) {
			if (stringifier.stringify) stringifier = stringifier.stringify;
			let result = "";
			stringifier(this, (i) => {
				result += i;
			});
			return result;
		}
		warn(result, text, opts = {}) {
			let data = { node: this };
			for (let i in opts) data[i] = opts[i];
			return result.warn(text, data);
		}
	}
	module.exports = Node;
	Node.default = Node;
});

// node_modules/postcss/lib/comment.js
var require_comment = __commonJS((exports, module) => {
	var Node = require_node3();

	class Comment extends Node {
		constructor(defaults2) {
			super(defaults2);
			this.type = "comment";
		}
	}
	module.exports = Comment;
	Comment.default = Comment;
});

// node_modules/postcss/lib/declaration.js
var require_declaration = __commonJS((exports, module) => {
	var Node = require_node3();

	class Declaration extends Node {
		get variable() {
			return this.prop.startsWith("--") || this.prop[0] === "$";
		}
		constructor(defaults2) {
			if (
				defaults2 &&
				typeof defaults2.value !== "undefined" &&
				typeof defaults2.value !== "string"
			) {
				defaults2 = { ...defaults2, value: String(defaults2.value) };
			}
			super(defaults2);
			this.type = "decl";
		}
	}
	module.exports = Declaration;
	Declaration.default = Declaration;
});

// node_modules/postcss/lib/container.js
var require_container = __commonJS((exports, module) => {
	var Comment = require_comment();
	var Declaration = require_declaration();
	var Node = require_node3();
	var { isClean, my } = require_symbols();
	var AtRule;
	var parse2;
	var Root;
	var Rule;
	function cleanSource(nodes) {
		return nodes.map((i) => {
			if (i.nodes) i.nodes = cleanSource(i.nodes);
			delete i.source;
			return i;
		});
	}
	function markTreeDirty(node) {
		node[isClean] = false;
		if (node.proxyOf.nodes) {
			for (let i of node.proxyOf.nodes) {
				markTreeDirty(i);
			}
		}
	}

	class Container extends Node {
		get first() {
			if (!this.proxyOf.nodes) return;
			return this.proxyOf.nodes[0];
		}
		get last() {
			if (!this.proxyOf.nodes) return;
			return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
		}
		append(...children) {
			for (let child of children) {
				let nodes = this.normalize(child, this.last);
				for (let node of nodes) this.proxyOf.nodes.push(node);
			}
			this.markDirty();
			return this;
		}
		cleanRaws(keepBetween) {
			super.cleanRaws(keepBetween);
			if (this.nodes) {
				for (let node of this.nodes) node.cleanRaws(keepBetween);
			}
		}
		each(callback) {
			if (!this.proxyOf.nodes) return;
			let iterator2 = this.getIterator();
			let index, result;
			while (this.indexes[iterator2] < this.proxyOf.nodes.length) {
				index = this.indexes[iterator2];
				result = callback(this.proxyOf.nodes[index], index);
				if (result === false) break;
				this.indexes[iterator2] += 1;
			}
			delete this.indexes[iterator2];
			return result;
		}
		every(condition) {
			return this.nodes.every(condition);
		}
		getIterator() {
			if (!this.lastEach) this.lastEach = 0;
			if (!this.indexes) this.indexes = {};
			this.lastEach += 1;
			let iterator2 = this.lastEach;
			this.indexes[iterator2] = 0;
			return iterator2;
		}
		getProxyProcessor() {
			return {
				get(node, prop) {
					if (prop === "proxyOf") {
						return node;
					} else if (!node[prop]) {
						return node[prop];
					} else if (prop === "each" || (typeof prop === "string" && prop.startsWith("walk"))) {
						return (...args) => {
							return node[prop](
								...args.map((i) => {
									if (typeof i === "function") {
										return (child, index) => i(child.toProxy(), index);
									} else {
										return i;
									}
								}),
							);
						};
					} else if (prop === "every" || prop === "some") {
						return (cb) => {
							return node[prop]((child, ...other) => cb(child.toProxy(), ...other));
						};
					} else if (prop === "root") {
						return () => node.root().toProxy();
					} else if (prop === "nodes") {
						return node.nodes.map((i) => i.toProxy());
					} else if (prop === "first" || prop === "last") {
						return node[prop].toProxy();
					} else {
						return node[prop];
					}
				},
				set(node, prop, value) {
					if (node[prop] === value) return true;
					node[prop] = value;
					if (prop === "name" || prop === "params" || prop === "selector") {
						node.markDirty();
					}
					return true;
				},
			};
		}
		index(child) {
			if (typeof child === "number") return child;
			if (child.proxyOf) child = child.proxyOf;
			return this.proxyOf.nodes.indexOf(child);
		}
		insertAfter(exist, add) {
			let existIndex = this.index(exist);
			let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
			existIndex = this.index(exist);
			for (let node of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node);
			let index;
			for (let id in this.indexes) {
				index = this.indexes[id];
				if (existIndex < index) {
					this.indexes[id] = index + nodes.length;
				}
			}
			this.markDirty();
			return this;
		}
		insertBefore(exist, add) {
			let existIndex = this.index(exist);
			let type = existIndex === 0 ? "prepend" : false;
			let nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();
			existIndex = this.index(exist);
			for (let node of nodes) this.proxyOf.nodes.splice(existIndex, 0, node);
			let index;
			for (let id in this.indexes) {
				index = this.indexes[id];
				if (existIndex <= index) {
					this.indexes[id] = index + nodes.length;
				}
			}
			this.markDirty();
			return this;
		}
		normalize(nodes, sample) {
			if (typeof nodes === "string") {
				nodes = cleanSource(parse2(nodes).nodes);
			} else if (typeof nodes === "undefined") {
				nodes = [];
			} else if (Array.isArray(nodes)) {
				nodes = nodes.slice(0);
				for (let i of nodes) {
					if (i.parent) i.parent.removeChild(i, "ignore");
				}
			} else if (nodes.type === "root" && this.type !== "document") {
				nodes = nodes.nodes.slice(0);
				for (let i of nodes) {
					if (i.parent) i.parent.removeChild(i, "ignore");
				}
			} else if (nodes.type) {
				nodes = [nodes];
			} else if (nodes.prop) {
				if (typeof nodes.value === "undefined") {
					throw new Error("Value field is missed in node creation");
				} else if (typeof nodes.value !== "string") {
					nodes.value = String(nodes.value);
				}
				nodes = [new Declaration(nodes)];
			} else if (nodes.selector || nodes.selectors) {
				nodes = [new Rule(nodes)];
			} else if (nodes.name) {
				nodes = [new AtRule(nodes)];
			} else if (nodes.text) {
				nodes = [new Comment(nodes)];
			} else {
				throw new Error("Unknown node type in node creation");
			}
			let processed = nodes.map((i) => {
				if (!i[my]) Container.rebuild(i);
				i = i.proxyOf;
				if (i.parent) i.parent.removeChild(i);
				if (i[isClean]) markTreeDirty(i);
				if (!i.raws) i.raws = {};
				if (typeof i.raws.before === "undefined") {
					if (sample && typeof sample.raws.before !== "undefined") {
						i.raws.before = sample.raws.before.replace(/\S/g, "");
					}
				}
				i.parent = this.proxyOf;
				return i;
			});
			return processed;
		}
		prepend(...children) {
			children = children.reverse();
			for (let child of children) {
				let nodes = this.normalize(child, this.first, "prepend").reverse();
				for (let node of nodes) this.proxyOf.nodes.unshift(node);
				for (let id in this.indexes) {
					this.indexes[id] = this.indexes[id] + nodes.length;
				}
			}
			this.markDirty();
			return this;
		}
		push(child) {
			child.parent = this;
			this.proxyOf.nodes.push(child);
			return this;
		}
		removeAll() {
			for (let node of this.proxyOf.nodes) node.parent = undefined;
			this.proxyOf.nodes = [];
			this.markDirty();
			return this;
		}
		removeChild(child) {
			child = this.index(child);
			this.proxyOf.nodes[child].parent = undefined;
			this.proxyOf.nodes.splice(child, 1);
			let index;
			for (let id in this.indexes) {
				index = this.indexes[id];
				if (index >= child) {
					this.indexes[id] = index - 1;
				}
			}
			this.markDirty();
			return this;
		}
		replaceValues(pattern, opts, callback) {
			if (!callback) {
				callback = opts;
				opts = {};
			}
			this.walkDecls((decl) => {
				if (opts.props && !opts.props.includes(decl.prop)) return;
				if (opts.fast && !decl.value.includes(opts.fast)) return;
				decl.value = decl.value.replace(pattern, callback);
			});
			this.markDirty();
			return this;
		}
		some(condition) {
			return this.nodes.some(condition);
		}
		walk(callback) {
			return this.each((child, i) => {
				let result;
				try {
					result = callback(child, i);
				} catch (e) {
					throw child.addToError(e);
				}
				if (result !== false && child.walk) {
					result = child.walk(callback);
				}
				return result;
			});
		}
		walkAtRules(name, callback) {
			if (!callback) {
				callback = name;
				return this.walk((child, i) => {
					if (child.type === "atrule") {
						return callback(child, i);
					}
				});
			}
			if (name instanceof RegExp) {
				return this.walk((child, i) => {
					if (child.type === "atrule" && name.test(child.name)) {
						return callback(child, i);
					}
				});
			}
			return this.walk((child, i) => {
				if (child.type === "atrule" && child.name === name) {
					return callback(child, i);
				}
			});
		}
		walkComments(callback) {
			return this.walk((child, i) => {
				if (child.type === "comment") {
					return callback(child, i);
				}
			});
		}
		walkDecls(prop, callback) {
			if (!callback) {
				callback = prop;
				return this.walk((child, i) => {
					if (child.type === "decl") {
						return callback(child, i);
					}
				});
			}
			if (prop instanceof RegExp) {
				return this.walk((child, i) => {
					if (child.type === "decl" && prop.test(child.prop)) {
						return callback(child, i);
					}
				});
			}
			return this.walk((child, i) => {
				if (child.type === "decl" && child.prop === prop) {
					return callback(child, i);
				}
			});
		}
		walkRules(selector, callback) {
			if (!callback) {
				callback = selector;
				return this.walk((child, i) => {
					if (child.type === "rule") {
						return callback(child, i);
					}
				});
			}
			if (selector instanceof RegExp) {
				return this.walk((child, i) => {
					if (child.type === "rule" && selector.test(child.selector)) {
						return callback(child, i);
					}
				});
			}
			return this.walk((child, i) => {
				if (child.type === "rule" && child.selector === selector) {
					return callback(child, i);
				}
			});
		}
	}
	Container.registerParse = (dependant) => {
		parse2 = dependant;
	};
	Container.registerRule = (dependant) => {
		Rule = dependant;
	};
	Container.registerAtRule = (dependant) => {
		AtRule = dependant;
	};
	Container.registerRoot = (dependant) => {
		Root = dependant;
	};
	module.exports = Container;
	Container.default = Container;
	Container.rebuild = (node) => {
		if (node.type === "atrule") {
			Object.setPrototypeOf(node, AtRule.prototype);
		} else if (node.type === "rule") {
			Object.setPrototypeOf(node, Rule.prototype);
		} else if (node.type === "decl") {
			Object.setPrototypeOf(node, Declaration.prototype);
		} else if (node.type === "comment") {
			Object.setPrototypeOf(node, Comment.prototype);
		} else if (node.type === "root") {
			Object.setPrototypeOf(node, Root.prototype);
		}
		node[my] = true;
		if (node.nodes) {
			node.nodes.forEach((child) => {
				Container.rebuild(child);
			});
		}
	};
});

// node_modules/postcss/lib/at-rule.js
var require_at_rule = __commonJS((exports, module) => {
	var Container = require_container();

	class AtRule extends Container {
		constructor(defaults2) {
			super(defaults2);
			this.type = "atrule";
		}
		append(...children) {
			if (!this.proxyOf.nodes) this.nodes = [];
			return super.append(...children);
		}
		prepend(...children) {
			if (!this.proxyOf.nodes) this.nodes = [];
			return super.prepend(...children);
		}
	}
	module.exports = AtRule;
	AtRule.default = AtRule;
	Container.registerAtRule(AtRule);
});

// node_modules/postcss/lib/document.js
var require_document = __commonJS((exports, module) => {
	var Container = require_container();
	var LazyResult;
	var Processor;

	class Document extends Container {
		constructor(defaults2) {
			super({ type: "document", ...defaults2 });
			if (!this.nodes) {
				this.nodes = [];
			}
		}
		toResult(opts = {}) {
			let lazy = new LazyResult(new Processor(), this, opts);
			return lazy.stringify();
		}
	}
	Document.registerLazyResult = (dependant) => {
		LazyResult = dependant;
	};
	Document.registerProcessor = (dependant) => {
		Processor = dependant;
	};
	module.exports = Document;
	Document.default = Document;
});

// node_modules/postcss/node_modules/nanoid/non-secure/index.cjs
var require_non_secure = __commonJS((exports, module) => {
	var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
	var customAlphabet = (alphabet, defaultSize = 21) => {
		return (size = defaultSize) => {
			let id = "";
			let i = size | 0;
			while (i--) {
				id += alphabet[(Math.random() * alphabet.length) | 0];
			}
			return id;
		};
	};
	var nanoid = (size = 21) => {
		let id = "";
		let i = size | 0;
		while (i--) {
			id += urlAlphabet[(Math.random() * 64) | 0];
		}
		return id;
	};
	module.exports = { nanoid, customAlphabet };
});

// node_modules/source-map-js/lib/base64.js
var require_base64 = __commonJS((exports) => {
	var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
	exports.encode = function (number) {
		if (0 <= number && number < intToCharMap.length) {
			return intToCharMap[number];
		}
		throw new TypeError("Must be between 0 and 63: " + number);
	};
	exports.decode = function (charCode) {
		var bigA = 65;
		var bigZ = 90;
		var littleA = 97;
		var littleZ = 122;
		var zero = 48;
		var nine = 57;
		var plus = 43;
		var slash = 47;
		var littleOffset = 26;
		var numberOffset = 52;
		if (bigA <= charCode && charCode <= bigZ) {
			return charCode - bigA;
		}
		if (littleA <= charCode && charCode <= littleZ) {
			return charCode - littleA + littleOffset;
		}
		if (zero <= charCode && charCode <= nine) {
			return charCode - zero + numberOffset;
		}
		if (charCode == plus) {
			return 62;
		}
		if (charCode == slash) {
			return 63;
		}
		return -1;
	};
});

// node_modules/source-map-js/lib/base64-vlq.js
var require_base64_vlq = __commonJS((exports) => {
	var base64 = require_base64();
	var VLQ_BASE_SHIFT = 5;
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
	var VLQ_BASE_MASK = VLQ_BASE - 1;
	var VLQ_CONTINUATION_BIT = VLQ_BASE;
	function toVLQSigned(aValue) {
		return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
	}
	function fromVLQSigned(aValue) {
		var isNegative = (aValue & 1) === 1;
		var shifted = aValue >> 1;
		return isNegative ? -shifted : shifted;
	}
	exports.encode = function base64VLQ_encode(aValue) {
		var encoded = "";
		var digit;
		var vlq = toVLQSigned(aValue);
		do {
			digit = vlq & VLQ_BASE_MASK;
			vlq >>>= VLQ_BASE_SHIFT;
			if (vlq > 0) {
				digit |= VLQ_CONTINUATION_BIT;
			}
			encoded += base64.encode(digit);
		} while (vlq > 0);
		return encoded;
	};
	exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
		var strLen = aStr.length;
		var result = 0;
		var shift = 0;
		var continuation, digit;
		do {
			if (aIndex >= strLen) {
				throw new Error("Expected more digits in base 64 VLQ value.");
			}
			digit = base64.decode(aStr.charCodeAt(aIndex++));
			if (digit === -1) {
				throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
			}
			continuation = !!(digit & VLQ_CONTINUATION_BIT);
			digit &= VLQ_BASE_MASK;
			result = result + (digit << shift);
			shift += VLQ_BASE_SHIFT;
		} while (continuation);
		aOutParam.value = fromVLQSigned(result);
		aOutParam.rest = aIndex;
	};
});

// node_modules/source-map-js/lib/util.js
var require_util = __commonJS((exports) => {
	function getArg(aArgs, aName, aDefaultValue) {
		if (aName in aArgs) {
			return aArgs[aName];
		} else if (arguments.length === 3) {
			return aDefaultValue;
		} else {
			throw new Error('"' + aName + '" is a required argument.');
		}
	}
	exports.getArg = getArg;
	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;
	function urlParse(aUrl) {
		var match = aUrl.match(urlRegexp);
		if (!match) {
			return null;
		}
		return {
			scheme: match[1],
			auth: match[2],
			host: match[3],
			port: match[4],
			path: match[5],
		};
	}
	exports.urlParse = urlParse;
	function urlGenerate(aParsedUrl) {
		var url2 = "";
		if (aParsedUrl.scheme) {
			url2 += aParsedUrl.scheme + ":";
		}
		url2 += "//";
		if (aParsedUrl.auth) {
			url2 += aParsedUrl.auth + "@";
		}
		if (aParsedUrl.host) {
			url2 += aParsedUrl.host;
		}
		if (aParsedUrl.port) {
			url2 += ":" + aParsedUrl.port;
		}
		if (aParsedUrl.path) {
			url2 += aParsedUrl.path;
		}
		return url2;
	}
	exports.urlGenerate = urlGenerate;
	var MAX_CACHED_INPUTS = 32;
	function lruMemoize(f) {
		var cache = [];
		return function (input) {
			for (var i = 0; i < cache.length; i++) {
				if (cache[i].input === input) {
					var temp = cache[0];
					cache[0] = cache[i];
					cache[i] = temp;
					return cache[0].result;
				}
			}
			var result = f(input);
			cache.unshift({
				input,
				result,
			});
			if (cache.length > MAX_CACHED_INPUTS) {
				cache.pop();
			}
			return result;
		};
	}
	var normalize = lruMemoize(function normalize(aPath) {
		var path2 = aPath;
		var url2 = urlParse(aPath);
		if (url2) {
			if (!url2.path) {
				return aPath;
			}
			path2 = url2.path;
		}
		var isAbsolute = exports.isAbsolute(path2);
		var parts = [];
		var start = 0;
		var i = 0;
		while (true) {
			start = i;
			i = path2.indexOf("/", start);
			if (i === -1) {
				parts.push(path2.slice(start));
				break;
			} else {
				parts.push(path2.slice(start, i));
				while (i < path2.length && path2[i] === "/") {
					i++;
				}
			}
		}
		for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
			part = parts[i];
			if (part === ".") {
				parts.splice(i, 1);
			} else if (part === "..") {
				up++;
			} else if (up > 0) {
				if (part === "") {
					parts.splice(i + 1, up);
					up = 0;
				} else {
					parts.splice(i, 2);
					up--;
				}
			}
		}
		path2 = parts.join("/");
		if (path2 === "") {
			path2 = isAbsolute ? "/" : ".";
		}
		if (url2) {
			url2.path = path2;
			return urlGenerate(url2);
		}
		return path2;
	});
	exports.normalize = normalize;
	function join(aRoot, aPath) {
		if (aRoot === "") {
			aRoot = ".";
		}
		if (aPath === "") {
			aPath = ".";
		}
		var aPathUrl = urlParse(aPath);
		var aRootUrl = urlParse(aRoot);
		if (aRootUrl) {
			aRoot = aRootUrl.path || "/";
		}
		if (aPathUrl && !aPathUrl.scheme) {
			if (aRootUrl) {
				aPathUrl.scheme = aRootUrl.scheme;
			}
			return urlGenerate(aPathUrl);
		}
		if (aPathUrl || aPath.match(dataUrlRegexp)) {
			return aPath;
		}
		if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
			aRootUrl.host = aPath;
			return urlGenerate(aRootUrl);
		}
		var joined =
			aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
		if (aRootUrl) {
			aRootUrl.path = joined;
			return urlGenerate(aRootUrl);
		}
		return joined;
	}
	exports.join = join;
	exports.isAbsolute = function (aPath) {
		return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
	};
	function relative(aRoot, aPath) {
		if (aRoot === "") {
			aRoot = ".";
		}
		aRoot = aRoot.replace(/\/$/, "");
		var level = 0;
		while (aPath.indexOf(aRoot + "/") !== 0) {
			var index = aRoot.lastIndexOf("/");
			if (index < 0) {
				return aPath;
			}
			aRoot = aRoot.slice(0, index);
			if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
				return aPath;
			}
			++level;
		}
		return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;
	var supportsNullProto = (function () {
		var obj = Object.create(null);
		return !("__proto__" in obj);
	})();
	function identity(s) {
		return s;
	}
	function toSetString(aStr) {
		if (isProtoString(aStr)) {
			return "$" + aStr;
		}
		return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;
	function fromSetString(aStr) {
		if (isProtoString(aStr)) {
			return aStr.slice(1);
		}
		return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;
	function isProtoString(s) {
		if (!s) {
			return false;
		}
		var length = s.length;
		if (length < 9) {
			return false;
		}
		if (
			s.charCodeAt(length - 1) !== 95 ||
			s.charCodeAt(length - 2) !== 95 ||
			s.charCodeAt(length - 3) !== 111 ||
			s.charCodeAt(length - 4) !== 116 ||
			s.charCodeAt(length - 5) !== 111 ||
			s.charCodeAt(length - 6) !== 114 ||
			s.charCodeAt(length - 7) !== 112 ||
			s.charCodeAt(length - 8) !== 95 ||
			s.charCodeAt(length - 9) !== 95
		) {
			return false;
		}
		for (var i = length - 10; i >= 0; i--) {
			if (s.charCodeAt(i) !== 36) {
				return false;
			}
		}
		return true;
	}
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
		var cmp = strcmp(mappingA.source, mappingB.source);
		if (cmp !== 0) {
			return cmp;
		}
		cmp = mappingA.originalLine - mappingB.originalLine;
		if (cmp !== 0) {
			return cmp;
		}
		cmp = mappingA.originalColumn - mappingB.originalColumn;
		if (cmp !== 0 || onlyCompareOriginal) {
			return cmp;
		}
		cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		if (cmp !== 0) {
			return cmp;
		}
		cmp = mappingA.generatedLine - mappingB.generatedLine;
		if (cmp !== 0) {
			return cmp;
		}
		return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;
	function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
		var cmp;
		cmp = mappingA.originalLine - mappingB.originalLine;
		if (cmp !== 0) {
			return cmp;
		}
		cmp = mappingA.originalColumn - mappingB.originalColumn;
		if (cmp !== 0 || onlyCompareOriginal) {
			return cmp;
		}
		cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		if (cmp !== 0) {
			return cmp;
		}
		cmp = mappingA.generatedLine - mappingB.generatedLine;
		if (cmp !== 0) {
			return cmp;
		}
		return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
		var cmp = mappingA.generatedLine - mappingB.generatedLine;
		if (cmp !== 0) {
			return cmp;
		}
		cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		if (cmp !== 0 || onlyCompareGenerated) {
			return cmp;
		}
		cmp = strcmp(mappingA.source, mappingB.source);
		if (cmp !== 0) {
			return cmp;
		}
		cmp = mappingA.originalLine - mappingB.originalLine;
		if (cmp !== 0) {
			return cmp;
		}
		cmp = mappingA.originalColumn - mappingB.originalColumn;
		if (cmp !== 0) {
			return cmp;
		}
		return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
	function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
		var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		if (cmp !== 0 || onlyCompareGenerated) {
			return cmp;
		}
		cmp = strcmp(mappingA.source, mappingB.source);
		if (cmp !== 0) {
			return cmp;
		}
		cmp = mappingA.originalLine - mappingB.originalLine;
		if (cmp !== 0) {
			return cmp;
		}
		cmp = mappingA.originalColumn - mappingB.originalColumn;
		if (cmp !== 0) {
			return cmp;
		}
		return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
	function strcmp(aStr1, aStr2) {
		if (aStr1 === aStr2) {
			return 0;
		}
		if (aStr1 === null) {
			return 1;
		}
		if (aStr2 === null) {
			return -1;
		}
		if (aStr1 > aStr2) {
			return 1;
		}
		return -1;
	}
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
		var cmp = mappingA.generatedLine - mappingB.generatedLine;
		if (cmp !== 0) {
			return cmp;
		}
		cmp = mappingA.generatedColumn - mappingB.generatedColumn;
		if (cmp !== 0) {
			return cmp;
		}
		cmp = strcmp(mappingA.source, mappingB.source);
		if (cmp !== 0) {
			return cmp;
		}
		cmp = mappingA.originalLine - mappingB.originalLine;
		if (cmp !== 0) {
			return cmp;
		}
		cmp = mappingA.originalColumn - mappingB.originalColumn;
		if (cmp !== 0) {
			return cmp;
		}
		return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
	function parseSourceMapInput(str) {
		return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
	}
	exports.parseSourceMapInput = parseSourceMapInput;
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
		sourceURL = sourceURL || "";
		if (sourceRoot) {
			if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
				sourceRoot += "/";
			}
			sourceURL = sourceRoot + sourceURL;
		}
		if (sourceMapURL) {
			var parsed = urlParse(sourceMapURL);
			if (!parsed) {
				throw new Error("sourceMapURL could not be parsed");
			}
			if (parsed.path) {
				var index = parsed.path.lastIndexOf("/");
				if (index >= 0) {
					parsed.path = parsed.path.substring(0, index + 1);
				}
			}
			sourceURL = join(urlGenerate(parsed), sourceURL);
		}
		return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
});

// node_modules/source-map-js/lib/array-set.js
var require_array_set = __commonJS((exports) => {
	var util5 = require_util();
	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";
	function ArraySet() {
		this._array = [];
		this._set = hasNativeMap ? new Map() : Object.create(null);
	}
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
		var set2 = new ArraySet();
		for (var i = 0, len = aArray.length; i < len; i++) {
			set2.add(aArray[i], aAllowDuplicates);
		}
		return set2;
	};
	ArraySet.prototype.size = function ArraySet_size() {
		return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
		var sStr = hasNativeMap ? aStr : util5.toSetString(aStr);
		var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
		var idx = this._array.length;
		if (!isDuplicate || aAllowDuplicates) {
			this._array.push(aStr);
		}
		if (!isDuplicate) {
			if (hasNativeMap) {
				this._set.set(aStr, idx);
			} else {
				this._set[sStr] = idx;
			}
		}
	};
	ArraySet.prototype.has = function ArraySet_has(aStr) {
		if (hasNativeMap) {
			return this._set.has(aStr);
		} else {
			var sStr = util5.toSetString(aStr);
			return has.call(this._set, sStr);
		}
	};
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
		if (hasNativeMap) {
			var idx = this._set.get(aStr);
			if (idx >= 0) {
				return idx;
			}
		} else {
			var sStr = util5.toSetString(aStr);
			if (has.call(this._set, sStr)) {
				return this._set[sStr];
			}
		}
		throw new Error('"' + aStr + '" is not in the set.');
	};
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
		if (aIdx >= 0 && aIdx < this._array.length) {
			return this._array[aIdx];
		}
		throw new Error("No element indexed by " + aIdx);
	};
	ArraySet.prototype.toArray = function ArraySet_toArray() {
		return this._array.slice();
	};
	exports.ArraySet = ArraySet;
});

// node_modules/source-map-js/lib/mapping-list.js
var require_mapping_list = __commonJS((exports) => {
	var util5 = require_util();
	function generatedPositionAfter(mappingA, mappingB) {
		var lineA = mappingA.generatedLine;
		var lineB = mappingB.generatedLine;
		var columnA = mappingA.generatedColumn;
		var columnB = mappingB.generatedColumn;
		return (
			lineB > lineA ||
			(lineB == lineA && columnB >= columnA) ||
			util5.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0
		);
	}
	function MappingList() {
		this._array = [];
		this._sorted = true;
		this._last = { generatedLine: -1, generatedColumn: 0 };
	}
	MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
		this._array.forEach(aCallback, aThisArg);
	};
	MappingList.prototype.add = function MappingList_add(aMapping) {
		if (generatedPositionAfter(this._last, aMapping)) {
			this._last = aMapping;
			this._array.push(aMapping);
		} else {
			this._sorted = false;
			this._array.push(aMapping);
		}
	};
	MappingList.prototype.toArray = function MappingList_toArray() {
		if (!this._sorted) {
			this._array.sort(util5.compareByGeneratedPositionsInflated);
			this._sorted = true;
		}
		return this._array;
	};
	exports.MappingList = MappingList;
});

// node_modules/source-map-js/lib/source-map-generator.js
var require_source_map_generator = __commonJS((exports) => {
	var base64VLQ = require_base64_vlq();
	var util5 = require_util();
	var ArraySet = require_array_set().ArraySet;
	var MappingList = require_mapping_list().MappingList;
	function SourceMapGenerator(aArgs) {
		if (!aArgs) {
			aArgs = {};
		}
		this._file = util5.getArg(aArgs, "file", null);
		this._sourceRoot = util5.getArg(aArgs, "sourceRoot", null);
		this._skipValidation = util5.getArg(aArgs, "skipValidation", false);
		this._ignoreInvalidMapping = util5.getArg(aArgs, "ignoreInvalidMapping", false);
		this._sources = new ArraySet();
		this._names = new ArraySet();
		this._mappings = new MappingList();
		this._sourcesContents = null;
	}
	SourceMapGenerator.prototype._version = 3;
	SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(
		aSourceMapConsumer,
		generatorOps,
	) {
		var sourceRoot = aSourceMapConsumer.sourceRoot;
		var generator = new SourceMapGenerator(
			Object.assign(generatorOps || {}, {
				file: aSourceMapConsumer.file,
				sourceRoot,
			}),
		);
		aSourceMapConsumer.eachMapping(function (mapping) {
			var newMapping = {
				generated: {
					line: mapping.generatedLine,
					column: mapping.generatedColumn,
				},
			};
			if (mapping.source != null) {
				newMapping.source = mapping.source;
				if (sourceRoot != null) {
					newMapping.source = util5.relative(sourceRoot, newMapping.source);
				}
				newMapping.original = {
					line: mapping.originalLine,
					column: mapping.originalColumn,
				};
				if (mapping.name != null) {
					newMapping.name = mapping.name;
				}
			}
			generator.addMapping(newMapping);
		});
		aSourceMapConsumer.sources.forEach(function (sourceFile) {
			var sourceRelative = sourceFile;
			if (sourceRoot !== null) {
				sourceRelative = util5.relative(sourceRoot, sourceFile);
			}
			if (!generator._sources.has(sourceRelative)) {
				generator._sources.add(sourceRelative);
			}
			var content = aSourceMapConsumer.sourceContentFor(sourceFile);
			if (content != null) {
				generator.setSourceContent(sourceFile, content);
			}
		});
		return generator;
	};
	SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
		var generated = util5.getArg(aArgs, "generated");
		var original = util5.getArg(aArgs, "original", null);
		var source = util5.getArg(aArgs, "source", null);
		var name = util5.getArg(aArgs, "name", null);
		if (!this._skipValidation) {
			if (this._validateMapping(generated, original, source, name) === false) {
				return;
			}
		}
		if (source != null) {
			source = String(source);
			if (!this._sources.has(source)) {
				this._sources.add(source);
			}
		}
		if (name != null) {
			name = String(name);
			if (!this._names.has(name)) {
				this._names.add(name);
			}
		}
		this._mappings.add({
			generatedLine: generated.line,
			generatedColumn: generated.column,
			originalLine: original != null && original.line,
			originalColumn: original != null && original.column,
			source,
			name,
		});
	};
	SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(
		aSourceFile,
		aSourceContent,
	) {
		var source = aSourceFile;
		if (this._sourceRoot != null) {
			source = util5.relative(this._sourceRoot, source);
		}
		if (aSourceContent != null) {
			if (!this._sourcesContents) {
				this._sourcesContents = Object.create(null);
			}
			this._sourcesContents[util5.toSetString(source)] = aSourceContent;
		} else if (this._sourcesContents) {
			delete this._sourcesContents[util5.toSetString(source)];
			if (Object.keys(this._sourcesContents).length === 0) {
				this._sourcesContents = null;
			}
		}
	};
	SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(
		aSourceMapConsumer,
		aSourceFile,
		aSourceMapPath,
	) {
		var sourceFile = aSourceFile;
		if (aSourceFile == null) {
			if (aSourceMapConsumer.file == null) {
				throw new Error(
					"SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, " +
						'or the source map\'s "file" property. Both were omitted.',
				);
			}
			sourceFile = aSourceMapConsumer.file;
		}
		var sourceRoot = this._sourceRoot;
		if (sourceRoot != null) {
			sourceFile = util5.relative(sourceRoot, sourceFile);
		}
		var newSources = new ArraySet();
		var newNames = new ArraySet();
		this._mappings.unsortedForEach(function (mapping) {
			if (mapping.source === sourceFile && mapping.originalLine != null) {
				var original = aSourceMapConsumer.originalPositionFor({
					line: mapping.originalLine,
					column: mapping.originalColumn,
				});
				if (original.source != null) {
					mapping.source = original.source;
					if (aSourceMapPath != null) {
						mapping.source = util5.join(aSourceMapPath, mapping.source);
					}
					if (sourceRoot != null) {
						mapping.source = util5.relative(sourceRoot, mapping.source);
					}
					mapping.originalLine = original.line;
					mapping.originalColumn = original.column;
					if (original.name != null) {
						mapping.name = original.name;
					}
				}
			}
			var source = mapping.source;
			if (source != null && !newSources.has(source)) {
				newSources.add(source);
			}
			var name = mapping.name;
			if (name != null && !newNames.has(name)) {
				newNames.add(name);
			}
		}, this);
		this._sources = newSources;
		this._names = newNames;
		aSourceMapConsumer.sources.forEach(function (sourceFile2) {
			var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
			if (content != null) {
				if (aSourceMapPath != null) {
					sourceFile2 = util5.join(aSourceMapPath, sourceFile2);
				}
				if (sourceRoot != null) {
					sourceFile2 = util5.relative(sourceRoot, sourceFile2);
				}
				this.setSourceContent(sourceFile2, content);
			}
		}, this);
	};
	SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(
		aGenerated,
		aOriginal,
		aSource,
		aName,
	) {
		if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
			var message =
				"original.line and original.column are not numbers -- you probably meant to omit " +
				"the original mapping entirely and only map the generated position. If so, pass " +
				"null for the original mapping instead of an object with empty or null values.";
			if (this._ignoreInvalidMapping) {
				if (typeof console !== "undefined" && console.warn) {
					console.warn(message);
				}
				return false;
			} else {
				throw new Error(message);
			}
		}
		if (
			aGenerated &&
			"line" in aGenerated &&
			"column" in aGenerated &&
			aGenerated.line > 0 &&
			aGenerated.column >= 0 &&
			!aOriginal &&
			!aSource &&
			!aName
		) {
			return;
		} else if (
			aGenerated &&
			"line" in aGenerated &&
			"column" in aGenerated &&
			aOriginal &&
			"line" in aOriginal &&
			"column" in aOriginal &&
			aGenerated.line > 0 &&
			aGenerated.column >= 0 &&
			aOriginal.line > 0 &&
			aOriginal.column >= 0 &&
			aSource
		) {
			return;
		} else {
			var message =
				"Invalid mapping: " +
				JSON.stringify({
					generated: aGenerated,
					source: aSource,
					original: aOriginal,
					name: aName,
				});
			if (this._ignoreInvalidMapping) {
				if (typeof console !== "undefined" && console.warn) {
					console.warn(message);
				}
				return false;
			} else {
				throw new Error(message);
			}
		}
	};
	SourceMapGenerator.prototype._serializeMappings =
		function SourceMapGenerator_serializeMappings() {
			var previousGeneratedColumn = 0;
			var previousGeneratedLine = 1;
			var previousOriginalColumn = 0;
			var previousOriginalLine = 0;
			var previousName = 0;
			var previousSource = 0;
			var result = "";
			var next;
			var mapping;
			var nameIdx;
			var sourceIdx;
			var mappings = this._mappings.toArray();
			for (var i = 0, len = mappings.length; i < len; i++) {
				mapping = mappings[i];
				next = "";
				if (mapping.generatedLine !== previousGeneratedLine) {
					previousGeneratedColumn = 0;
					while (mapping.generatedLine !== previousGeneratedLine) {
						next += ";";
						previousGeneratedLine++;
					}
				} else {
					if (i > 0) {
						if (!util5.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
							continue;
						}
						next += ",";
					}
				}
				next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
				previousGeneratedColumn = mapping.generatedColumn;
				if (mapping.source != null) {
					sourceIdx = this._sources.indexOf(mapping.source);
					next += base64VLQ.encode(sourceIdx - previousSource);
					previousSource = sourceIdx;
					next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
					previousOriginalLine = mapping.originalLine - 1;
					next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
					previousOriginalColumn = mapping.originalColumn;
					if (mapping.name != null) {
						nameIdx = this._names.indexOf(mapping.name);
						next += base64VLQ.encode(nameIdx - previousName);
						previousName = nameIdx;
					}
				}
				result += next;
			}
			return result;
		};
	SourceMapGenerator.prototype._generateSourcesContent =
		function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
			return aSources.map(function (source) {
				if (!this._sourcesContents) {
					return null;
				}
				if (aSourceRoot != null) {
					source = util5.relative(aSourceRoot, source);
				}
				var key = util5.toSetString(source);
				return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
					? this._sourcesContents[key]
					: null;
			}, this);
		};
	SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
		var map3 = {
			version: this._version,
			sources: this._sources.toArray(),
			names: this._names.toArray(),
			mappings: this._serializeMappings(),
		};
		if (this._file != null) {
			map3.file = this._file;
		}
		if (this._sourceRoot != null) {
			map3.sourceRoot = this._sourceRoot;
		}
		if (this._sourcesContents) {
			map3.sourcesContent = this._generateSourcesContent(map3.sources, map3.sourceRoot);
		}
		return map3;
	};
	SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
		return JSON.stringify(this.toJSON());
	};
	exports.SourceMapGenerator = SourceMapGenerator;
});

// node_modules/source-map-js/lib/binary-search.js
var require_binary_search = __commonJS((exports) => {
	exports.GREATEST_LOWER_BOUND = 1;
	exports.LEAST_UPPER_BOUND = 2;
	function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
		var mid = Math.floor((aHigh - aLow) / 2) + aLow;
		var cmp = aCompare(aNeedle, aHaystack[mid], true);
		if (cmp === 0) {
			return mid;
		} else if (cmp > 0) {
			if (aHigh - mid > 1) {
				return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
			}
			if (aBias == exports.LEAST_UPPER_BOUND) {
				return aHigh < aHaystack.length ? aHigh : -1;
			} else {
				return mid;
			}
		} else {
			if (mid - aLow > 1) {
				return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
			}
			if (aBias == exports.LEAST_UPPER_BOUND) {
				return mid;
			} else {
				return aLow < 0 ? -1 : aLow;
			}
		}
	}
	exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
		if (aHaystack.length === 0) {
			return -1;
		}
		var index = recursiveSearch(
			-1,
			aHaystack.length,
			aNeedle,
			aHaystack,
			aCompare,
			aBias || exports.GREATEST_LOWER_BOUND,
		);
		if (index < 0) {
			return -1;
		}
		while (index - 1 >= 0) {
			if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
				break;
			}
			--index;
		}
		return index;
	};
});

// node_modules/source-map-js/lib/quick-sort.js
var require_quick_sort = __commonJS((exports) => {
	function SortTemplate(comparator) {
		function swap(ary, x, y) {
			var temp = ary[x];
			ary[x] = ary[y];
			ary[y] = temp;
		}
		function randomIntInRange(low, high) {
			return Math.round(low + Math.random() * (high - low));
		}
		function doQuickSort(ary, comparator2, p, r2) {
			if (p < r2) {
				var pivotIndex = randomIntInRange(p, r2);
				var i = p - 1;
				swap(ary, pivotIndex, r2);
				var pivot = ary[r2];
				for (var j = p; j < r2; j++) {
					if (comparator2(ary[j], pivot, false) <= 0) {
						i += 1;
						swap(ary, i, j);
					}
				}
				swap(ary, i + 1, j);
				var q = i + 1;
				doQuickSort(ary, comparator2, p, q - 1);
				doQuickSort(ary, comparator2, q + 1, r2);
			}
		}
		return doQuickSort;
	}
	function cloneSort(comparator) {
		let template = SortTemplate.toString();
		let templateFn = new Function(`return ${template}`)();
		return templateFn(comparator);
	}
	var sortCache = new WeakMap();
	exports.quickSort = function (ary, comparator, start = 0) {
		let doQuickSort = sortCache.get(comparator);
		if (doQuickSort === undefined) {
			doQuickSort = cloneSort(comparator);
			sortCache.set(comparator, doQuickSort);
		}
		doQuickSort(ary, comparator, start, ary.length - 1);
	};
});

// node_modules/source-map-js/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS((exports) => {
	var util5 = require_util();
	var binarySearch = require_binary_search();
	var ArraySet = require_array_set().ArraySet;
	var base64VLQ = require_base64_vlq();
	var quickSort = require_quick_sort().quickSort;
	function SourceMapConsumer(aSourceMap, aSourceMapURL) {
		var sourceMap = aSourceMap;
		if (typeof aSourceMap === "string") {
			sourceMap = util5.parseSourceMapInput(aSourceMap);
		}
		return sourceMap.sections != null
			? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
			: new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
	}
	SourceMapConsumer.fromSourceMap = function (aSourceMap, aSourceMapURL) {
		return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
	};
	SourceMapConsumer.prototype._version = 3;
	SourceMapConsumer.prototype.__generatedMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
		configurable: true,
		enumerable: true,
		get: function () {
			if (!this.__generatedMappings) {
				this._parseMappings(this._mappings, this.sourceRoot);
			}
			return this.__generatedMappings;
		},
	});
	SourceMapConsumer.prototype.__originalMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
		configurable: true,
		enumerable: true,
		get: function () {
			if (!this.__originalMappings) {
				this._parseMappings(this._mappings, this.sourceRoot);
			}
			return this.__originalMappings;
		},
	});
	SourceMapConsumer.prototype._charIsMappingSeparator =
		function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
			var c = aStr.charAt(index);
			return c === ";" || c === ",";
		};
	SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(
		aStr,
		aSourceRoot,
	) {
		throw new Error("Subclasses must implement _parseMappings");
	};
	SourceMapConsumer.GENERATED_ORDER = 1;
	SourceMapConsumer.ORIGINAL_ORDER = 2;
	SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	SourceMapConsumer.LEAST_UPPER_BOUND = 2;
	SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(
		aCallback,
		aContext,
		aOrder,
	) {
		var context = aContext || null;
		var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
		var mappings;
		switch (order) {
			case SourceMapConsumer.GENERATED_ORDER:
				mappings = this._generatedMappings;
				break;
			case SourceMapConsumer.ORIGINAL_ORDER:
				mappings = this._originalMappings;
				break;
			default:
				throw new Error("Unknown order of iteration.");
		}
		var sourceRoot = this.sourceRoot;
		var boundCallback = aCallback.bind(context);
		var names = this._names;
		var sources = this._sources;
		var sourceMapURL = this._sourceMapURL;
		for (var i = 0, n2 = mappings.length; i < n2; i++) {
			var mapping = mappings[i];
			var source = mapping.source === null ? null : sources.at(mapping.source);
			if (source !== null) {
				source = util5.computeSourceURL(sourceRoot, source, sourceMapURL);
			}
			boundCallback({
				source,
				generatedLine: mapping.generatedLine,
				generatedColumn: mapping.generatedColumn,
				originalLine: mapping.originalLine,
				originalColumn: mapping.originalColumn,
				name: mapping.name === null ? null : names.at(mapping.name),
			});
		}
	};
	SourceMapConsumer.prototype.allGeneratedPositionsFor =
		function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
			var line = util5.getArg(aArgs, "line");
			var needle = {
				source: util5.getArg(aArgs, "source"),
				originalLine: line,
				originalColumn: util5.getArg(aArgs, "column", 0),
			};
			needle.source = this._findSourceIndex(needle.source);
			if (needle.source < 0) {
				return [];
			}
			var mappings = [];
			var index = this._findMapping(
				needle,
				this._originalMappings,
				"originalLine",
				"originalColumn",
				util5.compareByOriginalPositions,
				binarySearch.LEAST_UPPER_BOUND,
			);
			if (index >= 0) {
				var mapping = this._originalMappings[index];
				if (aArgs.column === undefined) {
					var originalLine = mapping.originalLine;
					while (mapping && mapping.originalLine === originalLine) {
						mappings.push({
							line: util5.getArg(mapping, "generatedLine", null),
							column: util5.getArg(mapping, "generatedColumn", null),
							lastColumn: util5.getArg(mapping, "lastGeneratedColumn", null),
						});
						mapping = this._originalMappings[++index];
					}
				} else {
					var originalColumn = mapping.originalColumn;
					while (
						mapping &&
						mapping.originalLine === line &&
						mapping.originalColumn == originalColumn
					) {
						mappings.push({
							line: util5.getArg(mapping, "generatedLine", null),
							column: util5.getArg(mapping, "generatedColumn", null),
							lastColumn: util5.getArg(mapping, "lastGeneratedColumn", null),
						});
						mapping = this._originalMappings[++index];
					}
				}
			}
			return mappings;
		};
	exports.SourceMapConsumer = SourceMapConsumer;
	function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
		var sourceMap = aSourceMap;
		if (typeof aSourceMap === "string") {
			sourceMap = util5.parseSourceMapInput(aSourceMap);
		}
		var version = util5.getArg(sourceMap, "version");
		var sources = util5.getArg(sourceMap, "sources");
		var names = util5.getArg(sourceMap, "names", []);
		var sourceRoot = util5.getArg(sourceMap, "sourceRoot", null);
		var sourcesContent = util5.getArg(sourceMap, "sourcesContent", null);
		var mappings = util5.getArg(sourceMap, "mappings");
		var file = util5.getArg(sourceMap, "file", null);
		if (version != this._version) {
			throw new Error("Unsupported version: " + version);
		}
		if (sourceRoot) {
			sourceRoot = util5.normalize(sourceRoot);
		}
		sources = sources
			.map(String)
			.map(util5.normalize)
			.map(function (source) {
				return sourceRoot && util5.isAbsolute(sourceRoot) && util5.isAbsolute(source)
					? util5.relative(sourceRoot, source)
					: source;
			});
		this._names = ArraySet.fromArray(names.map(String), true);
		this._sources = ArraySet.fromArray(sources, true);
		this._absoluteSources = this._sources.toArray().map(function (s) {
			return util5.computeSourceURL(sourceRoot, s, aSourceMapURL);
		});
		this.sourceRoot = sourceRoot;
		this.sourcesContent = sourcesContent;
		this._mappings = mappings;
		this._sourceMapURL = aSourceMapURL;
		this.file = file;
	}
	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
	BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {
		var relativeSource = aSource;
		if (this.sourceRoot != null) {
			relativeSource = util5.relative(this.sourceRoot, relativeSource);
		}
		if (this._sources.has(relativeSource)) {
			return this._sources.indexOf(relativeSource);
		}
		var i;
		for (i = 0; i < this._absoluteSources.length; ++i) {
			if (this._absoluteSources[i] == aSource) {
				return i;
			}
		}
		return -1;
	};
	BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(
		aSourceMap,
		aSourceMapURL,
	) {
		var smc = Object.create(BasicSourceMapConsumer.prototype);
		var names = (smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true));
		var sources = (smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true));
		smc.sourceRoot = aSourceMap._sourceRoot;
		smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
		smc.file = aSourceMap._file;
		smc._sourceMapURL = aSourceMapURL;
		smc._absoluteSources = smc._sources.toArray().map(function (s) {
			return util5.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
		});
		var generatedMappings = aSourceMap._mappings.toArray().slice();
		var destGeneratedMappings = (smc.__generatedMappings = []);
		var destOriginalMappings = (smc.__originalMappings = []);
		for (var i = 0, length = generatedMappings.length; i < length; i++) {
			var srcMapping = generatedMappings[i];
			var destMapping = new Mapping();
			destMapping.generatedLine = srcMapping.generatedLine;
			destMapping.generatedColumn = srcMapping.generatedColumn;
			if (srcMapping.source) {
				destMapping.source = sources.indexOf(srcMapping.source);
				destMapping.originalLine = srcMapping.originalLine;
				destMapping.originalColumn = srcMapping.originalColumn;
				if (srcMapping.name) {
					destMapping.name = names.indexOf(srcMapping.name);
				}
				destOriginalMappings.push(destMapping);
			}
			destGeneratedMappings.push(destMapping);
		}
		quickSort(smc.__originalMappings, util5.compareByOriginalPositions);
		return smc;
	};
	BasicSourceMapConsumer.prototype._version = 3;
	Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
		get: function () {
			return this._absoluteSources.slice();
		},
	});
	function Mapping() {
		this.generatedLine = 0;
		this.generatedColumn = 0;
		this.source = null;
		this.originalLine = null;
		this.originalColumn = null;
		this.name = null;
	}
	var compareGenerated = util5.compareByGeneratedPositionsDeflatedNoLine;
	function sortGenerated(array, start) {
		let l2 = array.length;
		let n2 = array.length - start;
		if (n2 <= 1) {
			return;
		} else if (n2 == 2) {
			let a12 = array[start];
			let b = array[start + 1];
			if (compareGenerated(a12, b) > 0) {
				array[start] = b;
				array[start + 1] = a12;
			}
		} else if (n2 < 20) {
			for (let i = start; i < l2; i++) {
				for (let j = i; j > start; j--) {
					let a12 = array[j - 1];
					let b = array[j];
					if (compareGenerated(a12, b) <= 0) {
						break;
					}
					array[j - 1] = b;
					array[j] = a12;
				}
			}
		} else {
			quickSort(array, compareGenerated, start);
		}
	}
	BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(
		aStr,
		aSourceRoot,
	) {
		var generatedLine = 1;
		var previousGeneratedColumn = 0;
		var previousOriginalLine = 0;
		var previousOriginalColumn = 0;
		var previousSource = 0;
		var previousName = 0;
		var length = aStr.length;
		var index = 0;
		var cachedSegments = {};
		var temp = {};
		var originalMappings = [];
		var generatedMappings = [];
		var mapping, str, segment, end, value;
		let subarrayStart = 0;
		while (index < length) {
			if (aStr.charAt(index) === ";") {
				generatedLine++;
				index++;
				previousGeneratedColumn = 0;
				sortGenerated(generatedMappings, subarrayStart);
				subarrayStart = generatedMappings.length;
			} else if (aStr.charAt(index) === ",") {
				index++;
			} else {
				mapping = new Mapping();
				mapping.generatedLine = generatedLine;
				for (end = index; end < length; end++) {
					if (this._charIsMappingSeparator(aStr, end)) {
						break;
					}
				}
				str = aStr.slice(index, end);
				segment = [];
				while (index < end) {
					base64VLQ.decode(aStr, index, temp);
					value = temp.value;
					index = temp.rest;
					segment.push(value);
				}
				if (segment.length === 2) {
					throw new Error("Found a source, but no line and column");
				}
				if (segment.length === 3) {
					throw new Error("Found a source and line, but no column");
				}
				mapping.generatedColumn = previousGeneratedColumn + segment[0];
				previousGeneratedColumn = mapping.generatedColumn;
				if (segment.length > 1) {
					mapping.source = previousSource + segment[1];
					previousSource += segment[1];
					mapping.originalLine = previousOriginalLine + segment[2];
					previousOriginalLine = mapping.originalLine;
					mapping.originalLine += 1;
					mapping.originalColumn = previousOriginalColumn + segment[3];
					previousOriginalColumn = mapping.originalColumn;
					if (segment.length > 4) {
						mapping.name = previousName + segment[4];
						previousName += segment[4];
					}
				}
				generatedMappings.push(mapping);
				if (typeof mapping.originalLine === "number") {
					let currentSource = mapping.source;
					while (originalMappings.length <= currentSource) {
						originalMappings.push(null);
					}
					if (originalMappings[currentSource] === null) {
						originalMappings[currentSource] = [];
					}
					originalMappings[currentSource].push(mapping);
				}
			}
		}
		sortGenerated(generatedMappings, subarrayStart);
		this.__generatedMappings = generatedMappings;
		for (var i = 0; i < originalMappings.length; i++) {
			if (originalMappings[i] != null) {
				quickSort(originalMappings[i], util5.compareByOriginalPositionsNoSource);
			}
		}
		this.__originalMappings = [].concat(...originalMappings);
	};
	BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(
		aNeedle,
		aMappings,
		aLineName,
		aColumnName,
		aComparator,
		aBias,
	) {
		if (aNeedle[aLineName] <= 0) {
			throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
		}
		if (aNeedle[aColumnName] < 0) {
			throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
		}
		return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	};
	BasicSourceMapConsumer.prototype.computeColumnSpans =
		function SourceMapConsumer_computeColumnSpans() {
			for (var index = 0; index < this._generatedMappings.length; ++index) {
				var mapping = this._generatedMappings[index];
				if (index + 1 < this._generatedMappings.length) {
					var nextMapping = this._generatedMappings[index + 1];
					if (mapping.generatedLine === nextMapping.generatedLine) {
						mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
						continue;
					}
				}
				mapping.lastGeneratedColumn = Infinity;
			}
		};
	BasicSourceMapConsumer.prototype.originalPositionFor =
		function SourceMapConsumer_originalPositionFor(aArgs) {
			var needle = {
				generatedLine: util5.getArg(aArgs, "line"),
				generatedColumn: util5.getArg(aArgs, "column"),
			};
			var index = this._findMapping(
				needle,
				this._generatedMappings,
				"generatedLine",
				"generatedColumn",
				util5.compareByGeneratedPositionsDeflated,
				util5.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND),
			);
			if (index >= 0) {
				var mapping = this._generatedMappings[index];
				if (mapping.generatedLine === needle.generatedLine) {
					var source = util5.getArg(mapping, "source", null);
					if (source !== null) {
						source = this._sources.at(source);
						source = util5.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
					}
					var name = util5.getArg(mapping, "name", null);
					if (name !== null) {
						name = this._names.at(name);
					}
					return {
						source,
						line: util5.getArg(mapping, "originalLine", null),
						column: util5.getArg(mapping, "originalColumn", null),
						name,
					};
				}
			}
			return {
				source: null,
				line: null,
				column: null,
				name: null,
			};
		};
	BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
		function BasicSourceMapConsumer_hasContentsOfAllSources() {
			if (!this.sourcesContent) {
				return false;
			}
			return (
				this.sourcesContent.length >= this._sources.size() &&
				!this.sourcesContent.some(function (sc) {
					return sc == null;
				})
			);
		};
	BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(
		aSource,
		nullOnMissing,
	) {
		if (!this.sourcesContent) {
			return null;
		}
		var index = this._findSourceIndex(aSource);
		if (index >= 0) {
			return this.sourcesContent[index];
		}
		var relativeSource = aSource;
		if (this.sourceRoot != null) {
			relativeSource = util5.relative(this.sourceRoot, relativeSource);
		}
		var url2;
		if (this.sourceRoot != null && (url2 = util5.urlParse(this.sourceRoot))) {
			var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
			if (url2.scheme == "file" && this._sources.has(fileUriAbsPath)) {
				return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
			}
			if ((!url2.path || url2.path == "/") && this._sources.has("/" + relativeSource)) {
				return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
			}
		}
		if (nullOnMissing) {
			return null;
		} else {
			throw new Error('"' + relativeSource + '" is not in the SourceMap.');
		}
	};
	BasicSourceMapConsumer.prototype.generatedPositionFor =
		function SourceMapConsumer_generatedPositionFor(aArgs) {
			var source = util5.getArg(aArgs, "source");
			source = this._findSourceIndex(source);
			if (source < 0) {
				return {
					line: null,
					column: null,
					lastColumn: null,
				};
			}
			var needle = {
				source,
				originalLine: util5.getArg(aArgs, "line"),
				originalColumn: util5.getArg(aArgs, "column"),
			};
			var index = this._findMapping(
				needle,
				this._originalMappings,
				"originalLine",
				"originalColumn",
				util5.compareByOriginalPositions,
				util5.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND),
			);
			if (index >= 0) {
				var mapping = this._originalMappings[index];
				if (mapping.source === needle.source) {
					return {
						line: util5.getArg(mapping, "generatedLine", null),
						column: util5.getArg(mapping, "generatedColumn", null),
						lastColumn: util5.getArg(mapping, "lastGeneratedColumn", null),
					};
				}
			}
			return {
				line: null,
				column: null,
				lastColumn: null,
			};
		};
	exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
	function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
		var sourceMap = aSourceMap;
		if (typeof aSourceMap === "string") {
			sourceMap = util5.parseSourceMapInput(aSourceMap);
		}
		var version = util5.getArg(sourceMap, "version");
		var sections = util5.getArg(sourceMap, "sections");
		if (version != this._version) {
			throw new Error("Unsupported version: " + version);
		}
		this._sources = new ArraySet();
		this._names = new ArraySet();
		var lastOffset = {
			line: -1,
			column: 0,
		};
		this._sections = sections.map(function (s) {
			if (s.url) {
				throw new Error("Support for url field in sections not implemented.");
			}
			var offset = util5.getArg(s, "offset");
			var offsetLine = util5.getArg(offset, "line");
			var offsetColumn = util5.getArg(offset, "column");
			if (
				offsetLine < lastOffset.line ||
				(offsetLine === lastOffset.line && offsetColumn < lastOffset.column)
			) {
				throw new Error("Section offsets must be ordered and non-overlapping.");
			}
			lastOffset = offset;
			return {
				generatedOffset: {
					generatedLine: offsetLine + 1,
					generatedColumn: offsetColumn + 1,
				},
				consumer: new SourceMapConsumer(util5.getArg(s, "map"), aSourceMapURL),
			};
		});
	}
	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
	IndexedSourceMapConsumer.prototype._version = 3;
	Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
		get: function () {
			var sources = [];
			for (var i = 0; i < this._sections.length; i++) {
				for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
					sources.push(this._sections[i].consumer.sources[j]);
				}
			}
			return sources;
		},
	});
	IndexedSourceMapConsumer.prototype.originalPositionFor =
		function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
			var needle = {
				generatedLine: util5.getArg(aArgs, "line"),
				generatedColumn: util5.getArg(aArgs, "column"),
			};
			var sectionIndex = binarySearch.search(needle, this._sections, function (needle2, section2) {
				var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
				if (cmp) {
					return cmp;
				}
				return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
			});
			var section = this._sections[sectionIndex];
			if (!section) {
				return {
					source: null,
					line: null,
					column: null,
					name: null,
				};
			}
			return section.consumer.originalPositionFor({
				line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
				column:
					needle.generatedColumn -
					(section.generatedOffset.generatedLine === needle.generatedLine
						? section.generatedOffset.generatedColumn - 1
						: 0),
				bias: aArgs.bias,
			});
		};
	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
		function IndexedSourceMapConsumer_hasContentsOfAllSources() {
			return this._sections.every(function (s) {
				return s.consumer.hasContentsOfAllSources();
			});
		};
	IndexedSourceMapConsumer.prototype.sourceContentFor =
		function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
			for (var i = 0; i < this._sections.length; i++) {
				var section = this._sections[i];
				var content = section.consumer.sourceContentFor(aSource, true);
				if (content || content === "") {
					return content;
				}
			}
			if (nullOnMissing) {
				return null;
			} else {
				throw new Error('"' + aSource + '" is not in the SourceMap.');
			}
		};
	IndexedSourceMapConsumer.prototype.generatedPositionFor =
		function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
			for (var i = 0; i < this._sections.length; i++) {
				var section = this._sections[i];
				if (section.consumer._findSourceIndex(util5.getArg(aArgs, "source")) === -1) {
					continue;
				}
				var generatedPosition = section.consumer.generatedPositionFor(aArgs);
				if (generatedPosition) {
					var ret = {
						line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
						column:
							generatedPosition.column +
							(section.generatedOffset.generatedLine === generatedPosition.line
								? section.generatedOffset.generatedColumn - 1
								: 0),
					};
					return ret;
				}
			}
			return {
				line: null,
				column: null,
			};
		};
	IndexedSourceMapConsumer.prototype._parseMappings =
		function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
			this.__generatedMappings = [];
			this.__originalMappings = [];
			for (var i = 0; i < this._sections.length; i++) {
				var section = this._sections[i];
				var sectionMappings = section.consumer._generatedMappings;
				for (var j = 0; j < sectionMappings.length; j++) {
					var mapping = sectionMappings[j];
					var source = section.consumer._sources.at(mapping.source);
					if (source !== null) {
						source = util5.computeSourceURL(
							section.consumer.sourceRoot,
							source,
							this._sourceMapURL,
						);
					}
					this._sources.add(source);
					source = this._sources.indexOf(source);
					var name = null;
					if (mapping.name) {
						name = section.consumer._names.at(mapping.name);
						this._names.add(name);
						name = this._names.indexOf(name);
					}
					var adjustedMapping = {
						source,
						generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
						generatedColumn:
							mapping.generatedColumn +
							(section.generatedOffset.generatedLine === mapping.generatedLine
								? section.generatedOffset.generatedColumn - 1
								: 0),
						originalLine: mapping.originalLine,
						originalColumn: mapping.originalColumn,
						name,
					};
					this.__generatedMappings.push(adjustedMapping);
					if (typeof adjustedMapping.originalLine === "number") {
						this.__originalMappings.push(adjustedMapping);
					}
				}
			}
			quickSort(this.__generatedMappings, util5.compareByGeneratedPositionsDeflated);
			quickSort(this.__originalMappings, util5.compareByOriginalPositions);
		};
	exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
});

// node_modules/source-map-js/lib/source-node.js
var require_source_node = __commonJS((exports) => {
	var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
	var util5 = require_util();
	var REGEX_NEWLINE = /(\r?\n)/;
	var NEWLINE_CODE = 10;
	var isSourceNode = "$$$isSourceNode$$$";
	function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
		this.children = [];
		this.sourceContents = {};
		this.line = aLine == null ? null : aLine;
		this.column = aColumn == null ? null : aColumn;
		this.source = aSource == null ? null : aSource;
		this.name = aName == null ? null : aName;
		this[isSourceNode] = true;
		if (aChunks != null) this.add(aChunks);
	}
	SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(
		aGeneratedCode,
		aSourceMapConsumer,
		aRelativePath,
	) {
		var node = new SourceNode();
		var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
		var remainingLinesIndex = 0;
		var shiftNextLine = function () {
			var lineContents = getNextLine();
			var newLine = getNextLine() || "";
			return lineContents + newLine;
			function getNextLine() {
				return remainingLinesIndex < remainingLines.length
					? remainingLines[remainingLinesIndex++]
					: undefined;
			}
		};
		var lastGeneratedLine = 1,
			lastGeneratedColumn = 0;
		var lastMapping = null;
		aSourceMapConsumer.eachMapping(function (mapping) {
			if (lastMapping !== null) {
				if (lastGeneratedLine < mapping.generatedLine) {
					addMappingWithCode(lastMapping, shiftNextLine());
					lastGeneratedLine++;
					lastGeneratedColumn = 0;
				} else {
					var nextLine = remainingLines[remainingLinesIndex] || "";
					var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
					remainingLines[remainingLinesIndex] = nextLine.substr(
						mapping.generatedColumn - lastGeneratedColumn,
					);
					lastGeneratedColumn = mapping.generatedColumn;
					addMappingWithCode(lastMapping, code);
					lastMapping = mapping;
					return;
				}
			}
			while (lastGeneratedLine < mapping.generatedLine) {
				node.add(shiftNextLine());
				lastGeneratedLine++;
			}
			if (lastGeneratedColumn < mapping.generatedColumn) {
				var nextLine = remainingLines[remainingLinesIndex] || "";
				node.add(nextLine.substr(0, mapping.generatedColumn));
				remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
				lastGeneratedColumn = mapping.generatedColumn;
			}
			lastMapping = mapping;
		}, this);
		if (remainingLinesIndex < remainingLines.length) {
			if (lastMapping) {
				addMappingWithCode(lastMapping, shiftNextLine());
			}
			node.add(remainingLines.splice(remainingLinesIndex).join(""));
		}
		aSourceMapConsumer.sources.forEach(function (sourceFile) {
			var content = aSourceMapConsumer.sourceContentFor(sourceFile);
			if (content != null) {
				if (aRelativePath != null) {
					sourceFile = util5.join(aRelativePath, sourceFile);
				}
				node.setSourceContent(sourceFile, content);
			}
		});
		return node;
		function addMappingWithCode(mapping, code) {
			if (mapping === null || mapping.source === undefined) {
				node.add(code);
			} else {
				var source = aRelativePath ? util5.join(aRelativePath, mapping.source) : mapping.source;
				node.add(
					new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name),
				);
			}
		}
	};
	SourceNode.prototype.add = function SourceNode_add(aChunk) {
		if (Array.isArray(aChunk)) {
			aChunk.forEach(function (chunk) {
				this.add(chunk);
			}, this);
		} else if (aChunk[isSourceNode] || typeof aChunk === "string") {
			if (aChunk) {
				this.children.push(aChunk);
			}
		} else {
			throw new TypeError(
				"Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk,
			);
		}
		return this;
	};
	SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
		if (Array.isArray(aChunk)) {
			for (var i = aChunk.length - 1; i >= 0; i--) {
				this.prepend(aChunk[i]);
			}
		} else if (aChunk[isSourceNode] || typeof aChunk === "string") {
			this.children.unshift(aChunk);
		} else {
			throw new TypeError(
				"Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk,
			);
		}
		return this;
	};
	SourceNode.prototype.walk = function SourceNode_walk(aFn) {
		var chunk;
		for (var i = 0, len = this.children.length; i < len; i++) {
			chunk = this.children[i];
			if (chunk[isSourceNode]) {
				chunk.walk(aFn);
			} else {
				if (chunk !== "") {
					aFn(chunk, {
						source: this.source,
						line: this.line,
						column: this.column,
						name: this.name,
					});
				}
			}
		}
	};
	SourceNode.prototype.join = function SourceNode_join(aSep) {
		var newChildren;
		var i;
		var len = this.children.length;
		if (len > 0) {
			newChildren = [];
			for (i = 0; i < len - 1; i++) {
				newChildren.push(this.children[i]);
				newChildren.push(aSep);
			}
			newChildren.push(this.children[i]);
			this.children = newChildren;
		}
		return this;
	};
	SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
		var lastChild = this.children[this.children.length - 1];
		if (lastChild[isSourceNode]) {
			lastChild.replaceRight(aPattern, aReplacement);
		} else if (typeof lastChild === "string") {
			this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
		} else {
			this.children.push("".replace(aPattern, aReplacement));
		}
		return this;
	};
	SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(
		aSourceFile,
		aSourceContent,
	) {
		this.sourceContents[util5.toSetString(aSourceFile)] = aSourceContent;
	};
	SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
		for (var i = 0, len = this.children.length; i < len; i++) {
			if (this.children[i][isSourceNode]) {
				this.children[i].walkSourceContents(aFn);
			}
		}
		var sources = Object.keys(this.sourceContents);
		for (var i = 0, len = sources.length; i < len; i++) {
			aFn(util5.fromSetString(sources[i]), this.sourceContents[sources[i]]);
		}
	};
	SourceNode.prototype.toString = function SourceNode_toString() {
		var str = "";
		this.walk(function (chunk) {
			str += chunk;
		});
		return str;
	};
	SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
		var generated = {
			code: "",
			line: 1,
			column: 0,
		};
		var map3 = new SourceMapGenerator(aArgs);
		var sourceMappingActive = false;
		var lastOriginalSource = null;
		var lastOriginalLine = null;
		var lastOriginalColumn = null;
		var lastOriginalName = null;
		this.walk(function (chunk, original) {
			generated.code += chunk;
			if (original.source !== null && original.line !== null && original.column !== null) {
				if (
					lastOriginalSource !== original.source ||
					lastOriginalLine !== original.line ||
					lastOriginalColumn !== original.column ||
					lastOriginalName !== original.name
				) {
					map3.addMapping({
						source: original.source,
						original: {
							line: original.line,
							column: original.column,
						},
						generated: {
							line: generated.line,
							column: generated.column,
						},
						name: original.name,
					});
				}
				lastOriginalSource = original.source;
				lastOriginalLine = original.line;
				lastOriginalColumn = original.column;
				lastOriginalName = original.name;
				sourceMappingActive = true;
			} else if (sourceMappingActive) {
				map3.addMapping({
					generated: {
						line: generated.line,
						column: generated.column,
					},
				});
				lastOriginalSource = null;
				sourceMappingActive = false;
			}
			for (var idx = 0, length = chunk.length; idx < length; idx++) {
				if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
					generated.line++;
					generated.column = 0;
					if (idx + 1 === length) {
						lastOriginalSource = null;
						sourceMappingActive = false;
					} else if (sourceMappingActive) {
						map3.addMapping({
							source: original.source,
							original: {
								line: original.line,
								column: original.column,
							},
							generated: {
								line: generated.line,
								column: generated.column,
							},
							name: original.name,
						});
					}
				} else {
					generated.column++;
				}
			}
		});
		this.walkSourceContents(function (sourceFile, sourceContent) {
			map3.setSourceContent(sourceFile, sourceContent);
		});
		return { code: generated.code, map: map3 };
	};
	exports.SourceNode = SourceNode;
});

// node_modules/source-map-js/source-map.js
var require_source_map = __commonJS((exports) => {
	exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
	exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
	exports.SourceNode = require_source_node().SourceNode;
});

// node_modules/postcss/lib/previous-map.js
var require_previous_map = __commonJS((exports, module) => {
	var { existsSync, readFileSync } = __require("fs");
	var { dirname, join } = __require("path");
	var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
	function fromBase64(str) {
		if (Buffer) {
			return Buffer.from(str, "base64").toString();
		} else {
			return window.atob(str);
		}
	}

	class PreviousMap {
		constructor(css, opts) {
			if (opts.map === false) return;
			this.loadAnnotation(css);
			this.inline = this.startWith(this.annotation, "data:");
			let prev = opts.map ? opts.map.prev : undefined;
			let text = this.loadMap(opts.from, prev);
			if (!this.mapFile && opts.from) {
				this.mapFile = opts.from;
			}
			if (this.mapFile) this.root = dirname(this.mapFile);
			if (text) this.text = text;
		}
		consumer() {
			if (!this.consumerCache) {
				this.consumerCache = new SourceMapConsumer(this.text);
			}
			return this.consumerCache;
		}
		decodeInline(text) {
			let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
			let baseUri = /^data:application\/json;base64,/;
			let charsetUri = /^data:application\/json;charset=utf-?8,/;
			let uri2 = /^data:application\/json,/;
			let uriMatch = text.match(charsetUri) || text.match(uri2);
			if (uriMatch) {
				return decodeURIComponent(text.substr(uriMatch[0].length));
			}
			let baseUriMatch = text.match(baseCharsetUri) || text.match(baseUri);
			if (baseUriMatch) {
				return fromBase64(text.substr(baseUriMatch[0].length));
			}
			let encoding = text.match(/data:application\/json;([^,]+),/)[1];
			throw new Error("Unsupported source map encoding " + encoding);
		}
		getAnnotationURL(sourceMapString) {
			return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
		}
		isMap(map3) {
			if (typeof map3 !== "object") return false;
			return (
				typeof map3.mappings === "string" ||
				typeof map3._mappings === "string" ||
				Array.isArray(map3.sections)
			);
		}
		loadAnnotation(css) {
			let comments = css.match(/\/\*\s*# sourceMappingURL=/g);
			if (!comments) return;
			let start = css.lastIndexOf(comments.pop());
			let end = css.indexOf("*/", start);
			if (start > -1 && end > -1) {
				this.annotation = this.getAnnotationURL(css.substring(start, end));
			}
		}
		loadFile(path2) {
			this.root = dirname(path2);
			if (existsSync(path2)) {
				this.mapFile = path2;
				return readFileSync(path2, "utf-8").toString().trim();
			}
		}
		loadMap(file, prev) {
			if (prev === false) return false;
			if (prev) {
				if (typeof prev === "string") {
					return prev;
				} else if (typeof prev === "function") {
					let prevPath = prev(file);
					if (prevPath) {
						let map3 = this.loadFile(prevPath);
						if (!map3) {
							throw new Error("Unable to load previous source map: " + prevPath.toString());
						}
						return map3;
					}
				} else if (prev instanceof SourceMapConsumer) {
					return SourceMapGenerator.fromSourceMap(prev).toString();
				} else if (prev instanceof SourceMapGenerator) {
					return prev.toString();
				} else if (this.isMap(prev)) {
					return JSON.stringify(prev);
				} else {
					throw new Error("Unsupported previous source map format: " + prev.toString());
				}
			} else if (this.inline) {
				return this.decodeInline(this.annotation);
			} else if (this.annotation) {
				let map3 = this.annotation;
				if (file) map3 = join(dirname(file), map3);
				return this.loadFile(map3);
			}
		}
		startWith(string, start) {
			if (!string) return false;
			return string.substr(0, start.length) === start;
		}
		withContent() {
			return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
		}
	}
	module.exports = PreviousMap;
	PreviousMap.default = PreviousMap;
});

// node_modules/postcss/lib/input.js
var require_input = __commonJS((exports, module) => {
	var { nanoid } = require_non_secure();
	var { isAbsolute, resolve } = __require("path");
	var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
	var { fileURLToPath, pathToFileURL } = __require("url");
	var CssSyntaxError = require_css_syntax_error();
	var PreviousMap = require_previous_map();
	var terminalHighlight = require_terminal_highlight();
	var lineToIndexCache = Symbol("lineToIndexCache");
	var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
	var pathAvailable = Boolean(resolve && isAbsolute);
	function getLineToIndex(input) {
		if (input[lineToIndexCache]) return input[lineToIndexCache];
		let lines = input.css.split(`
`);
		let lineToIndex = new Array(lines.length);
		let prevIndex = 0;
		for (let i = 0, l2 = lines.length; i < l2; i++) {
			lineToIndex[i] = prevIndex;
			prevIndex += lines[i].length + 1;
		}
		input[lineToIndexCache] = lineToIndex;
		return lineToIndex;
	}

	class Input {
		get from() {
			return this.file || this.id;
		}
		constructor(css, opts = {}) {
			if (
				css === null ||
				typeof css === "undefined" ||
				(typeof css === "object" && !css.toString)
			) {
				throw new Error(`PostCSS received ${css} instead of CSS string`);
			}
			this.css = css.toString();
			if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
				this.hasBOM = true;
				this.css = this.css.slice(1);
			} else {
				this.hasBOM = false;
			}
			this.document = this.css;
			if (opts.document) this.document = opts.document.toString();
			if (opts.from) {
				if (!pathAvailable || /^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
					this.file = opts.from;
				} else {
					this.file = resolve(opts.from);
				}
			}
			if (pathAvailable && sourceMapAvailable) {
				let map3 = new PreviousMap(this.css, opts);
				if (map3.text) {
					this.map = map3;
					let file = map3.consumer().file;
					if (!this.file && file) this.file = this.mapResolve(file);
				}
			}
			if (!this.file) {
				this.id = "<input css " + nanoid(6) + ">";
			}
			if (this.map) this.map.file = this.from;
		}
		error(message, line, column, opts = {}) {
			let endColumn, endLine, endOffset, offset, result;
			if (line && typeof line === "object") {
				let start = line;
				let end = column;
				if (typeof start.offset === "number") {
					offset = start.offset;
					let pos = this.fromOffset(offset);
					line = pos.line;
					column = pos.col;
				} else {
					line = start.line;
					column = start.column;
					offset = this.fromLineAndColumn(line, column);
				}
				if (typeof end.offset === "number") {
					endOffset = end.offset;
					let pos = this.fromOffset(endOffset);
					endLine = pos.line;
					endColumn = pos.col;
				} else {
					endLine = end.line;
					endColumn = end.column;
					endOffset = this.fromLineAndColumn(end.line, end.column);
				}
			} else if (!column) {
				offset = line;
				let pos = this.fromOffset(offset);
				line = pos.line;
				column = pos.col;
			} else {
				offset = this.fromLineAndColumn(line, column);
			}
			let origin2 = this.origin(line, column, endLine, endColumn);
			if (origin2) {
				result = new CssSyntaxError(
					message,
					origin2.endLine === undefined
						? origin2.line
						: { column: origin2.column, line: origin2.line },
					origin2.endLine === undefined
						? origin2.column
						: { column: origin2.endColumn, line: origin2.endLine },
					origin2.source,
					origin2.file,
					opts.plugin,
				);
			} else {
				result = new CssSyntaxError(
					message,
					endLine === undefined ? line : { column, line },
					endLine === undefined ? column : { column: endColumn, line: endLine },
					this.css,
					this.file,
					opts.plugin,
				);
			}
			result.input = { column, endColumn, endLine, endOffset, line, offset, source: this.css };
			if (this.file) {
				if (pathToFileURL) {
					result.input.url = pathToFileURL(this.file).toString();
				}
				result.input.file = this.file;
			}
			return result;
		}
		fromLineAndColumn(line, column) {
			let lineToIndex = getLineToIndex(this);
			let index = lineToIndex[line - 1];
			return index + column - 1;
		}
		fromOffset(offset) {
			let lineToIndex = getLineToIndex(this);
			let lastLine = lineToIndex[lineToIndex.length - 1];
			let min = 0;
			if (offset >= lastLine) {
				min = lineToIndex.length - 1;
			} else {
				let max = lineToIndex.length - 2;
				let mid;
				while (min < max) {
					mid = min + ((max - min) >> 1);
					if (offset < lineToIndex[mid]) {
						max = mid - 1;
					} else if (offset >= lineToIndex[mid + 1]) {
						min = mid + 1;
					} else {
						min = mid;
						break;
					}
				}
			}
			return {
				col: offset - lineToIndex[min] + 1,
				line: min + 1,
			};
		}
		mapResolve(file) {
			if (/^\w+:\/\//.test(file)) {
				return file;
			}
			return resolve(this.map.consumer().sourceRoot || this.map.root || ".", file);
		}
		origin(line, column, endLine, endColumn) {
			if (!this.map) return false;
			let consumer = this.map.consumer();
			let from = consumer.originalPositionFor({ column, line });
			if (!from.source) return false;
			let to;
			if (typeof endLine === "number") {
				to = consumer.originalPositionFor({ column: endColumn, line: endLine });
			}
			let fromUrl;
			if (isAbsolute(from.source)) {
				fromUrl = pathToFileURL(from.source);
			} else {
				fromUrl = new URL(
					from.source,
					this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile),
				);
			}
			let result = {
				column: from.column,
				endColumn: to && to.column,
				endLine: to && to.line,
				line: from.line,
				url: fromUrl.toString(),
			};
			if (fromUrl.protocol === "file:") {
				if (fileURLToPath) {
					result.file = fileURLToPath(fromUrl);
				} else {
					throw new Error("file: protocol is not available in this PostCSS build");
				}
			}
			let source = consumer.sourceContentFor(from.source);
			if (source) result.source = source;
			return result;
		}
		toJSON() {
			let json = {};
			for (let name of ["hasBOM", "css", "file", "id"]) {
				if (this[name] != null) {
					json[name] = this[name];
				}
			}
			if (this.map) {
				json.map = { ...this.map };
				if (json.map.consumerCache) {
					json.map.consumerCache = undefined;
				}
			}
			return json;
		}
	}
	module.exports = Input;
	Input.default = Input;
	if (terminalHighlight && terminalHighlight.registerInput) {
		terminalHighlight.registerInput(Input);
	}
});

// node_modules/postcss/lib/root.js
var require_root = __commonJS((exports, module) => {
	var Container = require_container();
	var LazyResult;
	var Processor;

	class Root extends Container {
		constructor(defaults2) {
			super(defaults2);
			this.type = "root";
			if (!this.nodes) this.nodes = [];
		}
		normalize(child, sample, type) {
			let nodes = super.normalize(child);
			if (sample) {
				if (type === "prepend") {
					if (this.nodes.length > 1) {
						sample.raws.before = this.nodes[1].raws.before;
					} else {
						delete sample.raws.before;
					}
				} else if (this.first !== sample) {
					for (let node of nodes) {
						node.raws.before = sample.raws.before;
					}
				}
			}
			return nodes;
		}
		removeChild(child, ignore) {
			let index = this.index(child);
			if (!ignore && index === 0 && this.nodes.length > 1) {
				this.nodes[1].raws.before = this.nodes[index].raws.before;
			}
			return super.removeChild(child);
		}
		toResult(opts = {}) {
			let lazy = new LazyResult(new Processor(), this, opts);
			return lazy.stringify();
		}
	}
	Root.registerLazyResult = (dependant) => {
		LazyResult = dependant;
	};
	Root.registerProcessor = (dependant) => {
		Processor = dependant;
	};
	module.exports = Root;
	Root.default = Root;
	Container.registerRoot(Root);
});

// node_modules/postcss/lib/list.js
var require_list = __commonJS((exports, module) => {
	var list = {
		comma(string) {
			return list.split(string, [","], true);
		},
		space(string) {
			let spaces = [
				" ",
				`
`,
				"\t",
			];
			return list.split(string, spaces);
		},
		split(string, separators, last) {
			let array = [];
			let current = "";
			let split = false;
			let func = 0;
			let inQuote = false;
			let prevQuote = "";
			let escape = false;
			for (let letter of string) {
				if (escape) {
					escape = false;
				} else if (letter === "\\") {
					escape = true;
				} else if (inQuote) {
					if (letter === prevQuote) {
						inQuote = false;
					}
				} else if (letter === '"' || letter === "'") {
					inQuote = true;
					prevQuote = letter;
				} else if (letter === "(") {
					func += 1;
				} else if (letter === ")") {
					if (func > 0) func -= 1;
				} else if (func === 0) {
					if (separators.includes(letter)) split = true;
				}
				if (split) {
					if (current !== "") array.push(current.trim());
					current = "";
					split = false;
				} else {
					current += letter;
				}
			}
			if (last || current !== "") array.push(current.trim());
			return array;
		},
	};
	module.exports = list;
	list.default = list;
});

// node_modules/postcss/lib/rule.js
var require_rule = __commonJS((exports, module) => {
	var Container = require_container();
	var list = require_list();

	class Rule extends Container {
		get selectors() {
			return list.comma(this.selector);
		}
		set selectors(values) {
			let match = this.selector ? this.selector.match(/,\s*/) : null;
			let sep = match ? match[0] : "," + this.raw("between", "beforeOpen");
			this.selector = values.join(sep);
		}
		constructor(defaults2) {
			super(defaults2);
			this.type = "rule";
			if (!this.nodes) this.nodes = [];
		}
	}
	module.exports = Rule;
	Rule.default = Rule;
	Container.registerRule(Rule);
});

// node_modules/postcss/lib/fromJSON.js
var require_fromJSON = __commonJS((exports, module) => {
	var AtRule = require_at_rule();
	var Comment = require_comment();
	var Declaration = require_declaration();
	var Input = require_input();
	var PreviousMap = require_previous_map();
	var Root = require_root();
	var Rule = require_rule();
	function fromJSON(json, inputs) {
		if (Array.isArray(json)) return json.map((n2) => fromJSON(n2));
		let { inputs: ownInputs, ...defaults2 } = json;
		if (ownInputs) {
			inputs = [];
			for (let input of ownInputs) {
				let inputHydrated = { ...input, __proto__: Input.prototype };
				if (inputHydrated.map) {
					inputHydrated.map = {
						...inputHydrated.map,
						__proto__: PreviousMap.prototype,
					};
				}
				inputs.push(inputHydrated);
			}
		}
		if (defaults2.nodes) {
			defaults2.nodes = json.nodes.map((n2) => fromJSON(n2, inputs));
		}
		if (defaults2.source) {
			let { inputId, ...source } = defaults2.source;
			defaults2.source = source;
			if (inputId != null) {
				defaults2.source.input = inputs[inputId];
			}
		}
		if (defaults2.type === "root") {
			return new Root(defaults2);
		} else if (defaults2.type === "decl") {
			return new Declaration(defaults2);
		} else if (defaults2.type === "rule") {
			return new Rule(defaults2);
		} else if (defaults2.type === "comment") {
			return new Comment(defaults2);
		} else if (defaults2.type === "atrule") {
			return new AtRule(defaults2);
		} else {
			throw new Error("Unknown node type: " + json.type);
		}
	}
	module.exports = fromJSON;
	fromJSON.default = fromJSON;
});

// node_modules/postcss/lib/map-generator.js
var require_map_generator = __commonJS((exports, module) => {
	var { dirname, relative, resolve, sep } = __require("path");
	var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
	var { pathToFileURL } = __require("url");
	var Input = require_input();
	var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
	var pathAvailable = Boolean(dirname && resolve && relative && sep);

	class MapGenerator {
		constructor(stringify, root, opts, cssString) {
			this.stringify = stringify;
			this.mapOpts = opts.map || {};
			this.root = root;
			this.opts = opts;
			this.css = cssString;
			this.originalCSS = cssString;
			this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
			this.memoizedFileURLs = new Map();
			this.memoizedPaths = new Map();
			this.memoizedURLs = new Map();
		}
		addAnnotation() {
			let content;
			if (this.isInline()) {
				content = "data:application/json;base64," + this.toBase64(this.map.toString());
			} else if (typeof this.mapOpts.annotation === "string") {
				content = this.mapOpts.annotation;
			} else if (typeof this.mapOpts.annotation === "function") {
				content = this.mapOpts.annotation(this.opts.to, this.root);
			} else {
				content = this.outputFile() + ".map";
			}
			let eol = `
`;
			if (
				this.css.includes(`\r
`)
			)
				eol = `\r
`;
			this.css += eol + "/*# sourceMappingURL=" + content + " */";
		}
		applyPrevMaps() {
			for (let prev of this.previous()) {
				let from = this.toUrl(this.path(prev.file));
				let root = prev.root || dirname(prev.file);
				let map3;
				if (this.mapOpts.sourcesContent === false) {
					map3 = new SourceMapConsumer(prev.text);
					if (map3.sourcesContent) {
						map3.sourcesContent = null;
					}
				} else {
					map3 = prev.consumer();
				}
				this.map.applySourceMap(map3, from, this.toUrl(this.path(root)));
			}
		}
		clearAnnotation() {
			if (this.mapOpts.annotation === false) return;
			if (this.root) {
				let node;
				for (let i = this.root.nodes.length - 1; i >= 0; i--) {
					node = this.root.nodes[i];
					if (node.type !== "comment") continue;
					if (node.text.startsWith("# sourceMappingURL=")) {
						this.root.removeChild(i);
					}
				}
			} else if (this.css) {
				this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, "");
			}
		}
		generate() {
			this.clearAnnotation();
			if (pathAvailable && sourceMapAvailable && this.isMap()) {
				return this.generateMap();
			} else {
				let result = "";
				this.stringify(this.root, (i) => {
					result += i;
				});
				return [result];
			}
		}
		generateMap() {
			if (this.root) {
				this.generateString();
			} else if (this.previous().length === 1) {
				let prev = this.previous()[0].consumer();
				prev.file = this.outputFile();
				this.map = SourceMapGenerator.fromSourceMap(prev, {
					ignoreInvalidMapping: true,
				});
			} else {
				this.map = new SourceMapGenerator({
					file: this.outputFile(),
					ignoreInvalidMapping: true,
				});
				this.map.addMapping({
					generated: { column: 0, line: 1 },
					original: { column: 0, line: 1 },
					source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>",
				});
			}
			if (this.isSourcesContent()) this.setSourcesContent();
			if (this.root && this.previous().length > 0) this.applyPrevMaps();
			if (this.isAnnotation()) this.addAnnotation();
			if (this.isInline()) {
				return [this.css];
			} else {
				return [this.css, this.map];
			}
		}
		generateString() {
			this.css = "";
			this.map = new SourceMapGenerator({
				file: this.outputFile(),
				ignoreInvalidMapping: true,
			});
			let line = 1;
			let column = 1;
			let noSource = "<no source>";
			let mapping = {
				generated: { column: 0, line: 0 },
				original: { column: 0, line: 0 },
				source: "",
			};
			let last, lines;
			this.stringify(this.root, (str, node, type) => {
				this.css += str;
				if (node && type !== "end") {
					mapping.generated.line = line;
					mapping.generated.column = column - 1;
					if (node.source && node.source.start) {
						mapping.source = this.sourcePath(node);
						mapping.original.line = node.source.start.line;
						mapping.original.column = node.source.start.column - 1;
						this.map.addMapping(mapping);
					} else {
						mapping.source = noSource;
						mapping.original.line = 1;
						mapping.original.column = 0;
						this.map.addMapping(mapping);
					}
				}
				lines = str.match(/\n/g);
				if (lines) {
					line += lines.length;
					last = str.lastIndexOf(`
`);
					column = str.length - last;
				} else {
					column += str.length;
				}
				if (node && type !== "start") {
					let p = node.parent || { raws: {} };
					let childless = node.type === "decl" || (node.type === "atrule" && !node.nodes);
					if (!childless || node !== p.last || p.raws.semicolon) {
						if (node.source && node.source.end) {
							mapping.source = this.sourcePath(node);
							mapping.original.line = node.source.end.line;
							mapping.original.column = node.source.end.column - 1;
							mapping.generated.line = line;
							mapping.generated.column = column - 2;
							this.map.addMapping(mapping);
						} else {
							mapping.source = noSource;
							mapping.original.line = 1;
							mapping.original.column = 0;
							mapping.generated.line = line;
							mapping.generated.column = column - 1;
							this.map.addMapping(mapping);
						}
					}
				}
			});
		}
		isAnnotation() {
			if (this.isInline()) {
				return true;
			}
			if (typeof this.mapOpts.annotation !== "undefined") {
				return this.mapOpts.annotation;
			}
			if (this.previous().length) {
				return this.previous().some((i) => i.annotation);
			}
			return true;
		}
		isInline() {
			if (typeof this.mapOpts.inline !== "undefined") {
				return this.mapOpts.inline;
			}
			let annotation = this.mapOpts.annotation;
			if (typeof annotation !== "undefined" && annotation !== true) {
				return false;
			}
			if (this.previous().length) {
				return this.previous().some((i) => i.inline);
			}
			return true;
		}
		isMap() {
			if (typeof this.opts.map !== "undefined") {
				return !!this.opts.map;
			}
			return this.previous().length > 0;
		}
		isSourcesContent() {
			if (typeof this.mapOpts.sourcesContent !== "undefined") {
				return this.mapOpts.sourcesContent;
			}
			if (this.previous().length) {
				return this.previous().some((i) => i.withContent());
			}
			return true;
		}
		outputFile() {
			if (this.opts.to) {
				return this.path(this.opts.to);
			} else if (this.opts.from) {
				return this.path(this.opts.from);
			} else {
				return "to.css";
			}
		}
		path(file) {
			if (this.mapOpts.absolute) return file;
			if (file.charCodeAt(0) === 60) return file;
			if (/^\w+:\/\//.test(file)) return file;
			let cached = this.memoizedPaths.get(file);
			if (cached) return cached;
			let from = this.opts.to ? dirname(this.opts.to) : ".";
			if (typeof this.mapOpts.annotation === "string") {
				from = dirname(resolve(from, this.mapOpts.annotation));
			}
			let path2 = relative(from, file);
			this.memoizedPaths.set(file, path2);
			return path2;
		}
		previous() {
			if (!this.previousMaps) {
				this.previousMaps = [];
				if (this.root) {
					this.root.walk((node) => {
						if (node.source && node.source.input.map) {
							let map3 = node.source.input.map;
							if (!this.previousMaps.includes(map3)) {
								this.previousMaps.push(map3);
							}
						}
					});
				} else {
					let input = new Input(this.originalCSS, this.opts);
					if (input.map) this.previousMaps.push(input.map);
				}
			}
			return this.previousMaps;
		}
		setSourcesContent() {
			let already = {};
			if (this.root) {
				this.root.walk((node) => {
					if (node.source) {
						let from = node.source.input.from;
						if (from && !already[from]) {
							already[from] = true;
							let fromUrl = this.usesFileUrls ? this.toFileUrl(from) : this.toUrl(this.path(from));
							this.map.setSourceContent(fromUrl, node.source.input.css);
						}
					}
				});
			} else if (this.css) {
				let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
				this.map.setSourceContent(from, this.css);
			}
		}
		sourcePath(node) {
			if (this.mapOpts.from) {
				return this.toUrl(this.mapOpts.from);
			} else if (this.usesFileUrls) {
				return this.toFileUrl(node.source.input.from);
			} else {
				return this.toUrl(this.path(node.source.input.from));
			}
		}
		toBase64(str) {
			if (Buffer) {
				return Buffer.from(str).toString("base64");
			} else {
				return window.btoa(unescape(encodeURIComponent(str)));
			}
		}
		toFileUrl(path2) {
			let cached = this.memoizedFileURLs.get(path2);
			if (cached) return cached;
			if (pathToFileURL) {
				let fileURL = pathToFileURL(path2).toString();
				this.memoizedFileURLs.set(path2, fileURL);
				return fileURL;
			} else {
				throw new Error("`map.absolute` option is not available in this PostCSS build");
			}
		}
		toUrl(path2) {
			let cached = this.memoizedURLs.get(path2);
			if (cached) return cached;
			if (sep === "\\") {
				path2 = path2.replace(/\\/g, "/");
			}
			let url2 = encodeURI(path2).replace(/[#?]/g, encodeURIComponent);
			this.memoizedURLs.set(path2, url2);
			return url2;
		}
	}
	module.exports = MapGenerator;
});

// node_modules/postcss/lib/parser.js
var require_parser = __commonJS((exports, module) => {
	var AtRule = require_at_rule();
	var Comment = require_comment();
	var Declaration = require_declaration();
	var Root = require_root();
	var Rule = require_rule();
	var tokenizer = require_tokenize();
	var SAFE_COMMENT_NEIGHBOR = {
		empty: true,
		space: true,
	};
	function findLastWithPosition(tokens) {
		for (let i = tokens.length - 1; i >= 0; i--) {
			let token = tokens[i];
			let pos = token[3] || token[2];
			if (pos) return pos;
		}
	}

	class Parser {
		constructor(input) {
			this.input = input;
			this.root = new Root();
			this.current = this.root;
			this.spaces = "";
			this.semicolon = false;
			this.createTokenizer();
			this.root.source = { input, start: { column: 1, line: 1, offset: 0 } };
		}
		atrule(token) {
			let node = new AtRule();
			node.name = token[1].slice(1);
			if (node.name === "") {
				this.unnamedAtrule(node, token);
			}
			this.init(node, token[2]);
			let type;
			let prev;
			let shift;
			let last = false;
			let open = false;
			let params = [];
			let brackets = [];
			while (!this.tokenizer.endOfFile()) {
				token = this.tokenizer.nextToken();
				type = token[0];
				if (type === "(" || type === "[") {
					brackets.push(type === "(" ? ")" : "]");
				} else if (type === "{" && brackets.length > 0) {
					brackets.push("}");
				} else if (type === brackets[brackets.length - 1]) {
					brackets.pop();
				}
				if (brackets.length === 0) {
					if (type === ";") {
						node.source.end = this.getPosition(token[2]);
						node.source.end.offset++;
						this.semicolon = true;
						break;
					} else if (type === "{") {
						open = true;
						break;
					} else if (type === "}") {
						if (params.length > 0) {
							shift = params.length - 1;
							prev = params[shift];
							while (prev && prev[0] === "space") {
								prev = params[--shift];
							}
							if (prev) {
								node.source.end = this.getPosition(prev[3] || prev[2]);
								node.source.end.offset++;
							}
						}
						this.end(token);
						break;
					} else {
						params.push(token);
					}
				} else {
					params.push(token);
				}
				if (this.tokenizer.endOfFile()) {
					last = true;
					break;
				}
			}
			node.raws.between = this.spacesAndCommentsFromEnd(params);
			if (params.length) {
				node.raws.afterName = this.spacesAndCommentsFromStart(params);
				this.raw(node, "params", params);
				if (last) {
					token = params[params.length - 1];
					node.source.end = this.getPosition(token[3] || token[2]);
					node.source.end.offset++;
					this.spaces = node.raws.between;
					node.raws.between = "";
				}
			} else {
				node.raws.afterName = "";
				node.params = "";
			}
			if (open) {
				node.nodes = [];
				this.current = node;
			}
		}
		checkMissedSemicolon(tokens) {
			let colon = this.colon(tokens);
			if (colon === false) return;
			let founded = 0;
			let token;
			for (let j = colon - 1; j >= 0; j--) {
				token = tokens[j];
				if (token[0] !== "space") {
					founded += 1;
					if (founded === 2) break;
				}
			}
			throw this.input.error("Missed semicolon", token[0] === "word" ? token[3] + 1 : token[2]);
		}
		colon(tokens) {
			let brackets = 0;
			let prev, token, type;
			for (let [i, element] of tokens.entries()) {
				token = element;
				type = token[0];
				if (type === "(") {
					brackets += 1;
				}
				if (type === ")") {
					brackets -= 1;
				}
				if (brackets === 0 && type === ":") {
					if (!prev) {
						this.doubleColon(token);
					} else if (prev[0] === "word" && prev[1] === "progid") {
						continue;
					} else {
						return i;
					}
				}
				prev = token;
			}
			return false;
		}
		comment(token) {
			let node = new Comment();
			this.init(node, token[2]);
			node.source.end = this.getPosition(token[3] || token[2]);
			node.source.end.offset++;
			let text = token[1].slice(2, -2);
			if (/^\s*$/.test(text)) {
				node.text = "";
				node.raws.left = text;
				node.raws.right = "";
			} else {
				let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
				node.text = match[2];
				node.raws.left = match[1];
				node.raws.right = match[3];
			}
		}
		createTokenizer() {
			this.tokenizer = tokenizer(this.input);
		}
		decl(tokens, customProperty) {
			let node = new Declaration();
			this.init(node, tokens[0][2]);
			let last = tokens[tokens.length - 1];
			if (last[0] === ";") {
				this.semicolon = true;
				tokens.pop();
			}
			node.source.end = this.getPosition(last[3] || last[2] || findLastWithPosition(tokens));
			node.source.end.offset++;
			while (tokens[0][0] !== "word") {
				if (tokens.length === 1) this.unknownWord(tokens);
				node.raws.before += tokens.shift()[1];
			}
			node.source.start = this.getPosition(tokens[0][2]);
			node.prop = "";
			while (tokens.length) {
				let type = tokens[0][0];
				if (type === ":" || type === "space" || type === "comment") {
					break;
				}
				node.prop += tokens.shift()[1];
			}
			node.raws.between = "";
			let token;
			while (tokens.length) {
				token = tokens.shift();
				if (token[0] === ":") {
					node.raws.between += token[1];
					break;
				} else {
					if (token[0] === "word" && /\w/.test(token[1])) {
						this.unknownWord([token]);
					}
					node.raws.between += token[1];
				}
			}
			if (node.prop[0] === "_" || node.prop[0] === "*") {
				node.raws.before += node.prop[0];
				node.prop = node.prop.slice(1);
			}
			let firstSpaces = [];
			let next;
			while (tokens.length) {
				next = tokens[0][0];
				if (next !== "space" && next !== "comment") break;
				firstSpaces.push(tokens.shift());
			}
			this.precheckMissedSemicolon(tokens);
			for (let i = tokens.length - 1; i >= 0; i--) {
				token = tokens[i];
				if (token[1].toLowerCase() === "!important") {
					node.important = true;
					let string = this.stringFrom(tokens, i);
					string = this.spacesFromEnd(tokens) + string;
					if (string !== " !important") node.raws.important = string;
					break;
				} else if (token[1].toLowerCase() === "important") {
					let cache = tokens.slice(0);
					let str = "";
					for (let j = i; j > 0; j--) {
						let type = cache[j][0];
						if (str.trim().startsWith("!") && type !== "space") {
							break;
						}
						str = cache.pop()[1] + str;
					}
					if (str.trim().startsWith("!")) {
						node.important = true;
						node.raws.important = str;
						tokens = cache;
					}
				}
				if (token[0] !== "space" && token[0] !== "comment") {
					break;
				}
			}
			let hasWord = tokens.some((i) => i[0] !== "space" && i[0] !== "comment");
			if (hasWord) {
				node.raws.between += firstSpaces.map((i) => i[1]).join("");
				firstSpaces = [];
			}
			this.raw(node, "value", firstSpaces.concat(tokens), customProperty);
			if (node.value.includes(":") && !customProperty) {
				this.checkMissedSemicolon(tokens);
			}
		}
		doubleColon(token) {
			throw this.input.error(
				"Double colon",
				{ offset: token[2] },
				{ offset: token[2] + token[1].length },
			);
		}
		emptyRule(token) {
			let node = new Rule();
			this.init(node, token[2]);
			node.selector = "";
			node.raws.between = "";
			this.current = node;
		}
		end(token) {
			if (this.current.nodes && this.current.nodes.length) {
				this.current.raws.semicolon = this.semicolon;
			}
			this.semicolon = false;
			this.current.raws.after = (this.current.raws.after || "") + this.spaces;
			this.spaces = "";
			if (this.current.parent) {
				this.current.source.end = this.getPosition(token[2]);
				this.current.source.end.offset++;
				this.current = this.current.parent;
			} else {
				this.unexpectedClose(token);
			}
		}
		endFile() {
			if (this.current.parent) this.unclosedBlock();
			if (this.current.nodes && this.current.nodes.length) {
				this.current.raws.semicolon = this.semicolon;
			}
			this.current.raws.after = (this.current.raws.after || "") + this.spaces;
			this.root.source.end = this.getPosition(this.tokenizer.position());
		}
		freeSemicolon(token) {
			this.spaces += token[1];
			if (this.current.nodes) {
				let prev = this.current.nodes[this.current.nodes.length - 1];
				if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
					prev.raws.ownSemicolon = this.spaces;
					this.spaces = "";
					prev.source.end = this.getPosition(token[2]);
					prev.source.end.offset += prev.raws.ownSemicolon.length;
				}
			}
		}
		getPosition(offset) {
			let pos = this.input.fromOffset(offset);
			return {
				column: pos.col,
				line: pos.line,
				offset,
			};
		}
		init(node, offset) {
			this.current.push(node);
			node.source = {
				input: this.input,
				start: this.getPosition(offset),
			};
			node.raws.before = this.spaces;
			this.spaces = "";
			if (node.type !== "comment") this.semicolon = false;
		}
		other(start) {
			let end = false;
			let type = null;
			let colon = false;
			let bracket = null;
			let brackets = [];
			let customProperty = start[1].startsWith("--");
			let tokens = [];
			let token = start;
			while (token) {
				type = token[0];
				tokens.push(token);
				if (type === "(" || type === "[") {
					if (!bracket) bracket = token;
					brackets.push(type === "(" ? ")" : "]");
				} else if (customProperty && colon && type === "{") {
					if (!bracket) bracket = token;
					brackets.push("}");
				} else if (brackets.length === 0) {
					if (type === ";") {
						if (colon) {
							this.decl(tokens, customProperty);
							return;
						} else {
							break;
						}
					} else if (type === "{") {
						this.rule(tokens);
						return;
					} else if (type === "}") {
						this.tokenizer.back(tokens.pop());
						end = true;
						break;
					} else if (type === ":") {
						colon = true;
					}
				} else if (type === brackets[brackets.length - 1]) {
					brackets.pop();
					if (brackets.length === 0) bracket = null;
				}
				token = this.tokenizer.nextToken();
			}
			if (this.tokenizer.endOfFile()) end = true;
			if (brackets.length > 0) this.unclosedBracket(bracket);
			if (end && colon) {
				if (!customProperty) {
					while (tokens.length) {
						token = tokens[tokens.length - 1][0];
						if (token !== "space" && token !== "comment") break;
						this.tokenizer.back(tokens.pop());
					}
				}
				this.decl(tokens, customProperty);
			} else {
				this.unknownWord(tokens);
			}
		}
		parse() {
			let token;
			while (!this.tokenizer.endOfFile()) {
				token = this.tokenizer.nextToken();
				switch (token[0]) {
					case "space":
						this.spaces += token[1];
						break;
					case ";":
						this.freeSemicolon(token);
						break;
					case "}":
						this.end(token);
						break;
					case "comment":
						this.comment(token);
						break;
					case "at-word":
						this.atrule(token);
						break;
					case "{":
						this.emptyRule(token);
						break;
					default:
						this.other(token);
						break;
				}
			}
			this.endFile();
		}
		precheckMissedSemicolon() {}
		raw(node, prop, tokens, customProperty) {
			let token, type;
			let length = tokens.length;
			let value = "";
			let clean2 = true;
			let next, prev;
			for (let i = 0; i < length; i += 1) {
				token = tokens[i];
				type = token[0];
				if (type === "space" && i === length - 1 && !customProperty) {
					clean2 = false;
				} else if (type === "comment") {
					prev = tokens[i - 1] ? tokens[i - 1][0] : "empty";
					next = tokens[i + 1] ? tokens[i + 1][0] : "empty";
					if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
						if (value.slice(-1) === ",") {
							clean2 = false;
						} else {
							value += token[1];
						}
					} else {
						clean2 = false;
					}
				} else {
					value += token[1];
				}
			}
			if (!clean2) {
				let raw = tokens.reduce((all2, i) => all2 + i[1], "");
				node.raws[prop] = { raw, value };
			}
			node[prop] = value;
		}
		rule(tokens) {
			tokens.pop();
			let node = new Rule();
			this.init(node, tokens[0][2]);
			node.raws.between = this.spacesAndCommentsFromEnd(tokens);
			this.raw(node, "selector", tokens);
			this.current = node;
		}
		spacesAndCommentsFromEnd(tokens) {
			let lastTokenType;
			let spaces = "";
			while (tokens.length) {
				lastTokenType = tokens[tokens.length - 1][0];
				if (lastTokenType !== "space" && lastTokenType !== "comment") break;
				spaces = tokens.pop()[1] + spaces;
			}
			return spaces;
		}
		spacesAndCommentsFromStart(tokens) {
			let next;
			let spaces = "";
			while (tokens.length) {
				next = tokens[0][0];
				if (next !== "space" && next !== "comment") break;
				spaces += tokens.shift()[1];
			}
			return spaces;
		}
		spacesFromEnd(tokens) {
			let lastTokenType;
			let spaces = "";
			while (tokens.length) {
				lastTokenType = tokens[tokens.length - 1][0];
				if (lastTokenType !== "space") break;
				spaces = tokens.pop()[1] + spaces;
			}
			return spaces;
		}
		stringFrom(tokens, from) {
			let result = "";
			for (let i = from; i < tokens.length; i++) {
				result += tokens[i][1];
			}
			tokens.splice(from, tokens.length - from);
			return result;
		}
		unclosedBlock() {
			let pos = this.current.source.start;
			throw this.input.error("Unclosed block", pos.line, pos.column);
		}
		unclosedBracket(bracket) {
			throw this.input.error(
				"Unclosed bracket",
				{ offset: bracket[2] },
				{ offset: bracket[2] + 1 },
			);
		}
		unexpectedClose(token) {
			throw this.input.error("Unexpected }", { offset: token[2] }, { offset: token[2] + 1 });
		}
		unknownWord(tokens) {
			throw this.input.error(
				"Unknown word " + tokens[0][1],
				{ offset: tokens[0][2] },
				{ offset: tokens[0][2] + tokens[0][1].length },
			);
		}
		unnamedAtrule(node, token) {
			throw this.input.error(
				"At-rule without name",
				{ offset: token[2] },
				{ offset: token[2] + token[1].length },
			);
		}
	}
	module.exports = Parser;
});

// node_modules/postcss/lib/parse.js
var require_parse2 = __commonJS((exports, module) => {
	var Container = require_container();
	var Input = require_input();
	var Parser = require_parser();
	function parse2(css, opts) {
		let input = new Input(css, opts);
		let parser = new Parser(input);
		try {
			parser.parse();
		} catch (e) {
			if (true) {
				if (e.name === "CssSyntaxError" && opts && opts.from) {
					if (/\.scss$/i.test(opts.from)) {
						e.message +=
							`
You tried to parse SCSS with ` +
							"the standard CSS parser; " +
							"try again with the postcss-scss parser";
					} else if (/\.sass/i.test(opts.from)) {
						e.message +=
							`
You tried to parse Sass with ` +
							"the standard CSS parser; " +
							"try again with the postcss-sass parser";
					} else if (/\.less$/i.test(opts.from)) {
						e.message +=
							`
You tried to parse Less with ` +
							"the standard CSS parser; " +
							"try again with the postcss-less parser";
					}
				}
			}
			throw e;
		}
		return parser.root;
	}
	module.exports = parse2;
	parse2.default = parse2;
	Container.registerParse(parse2);
});

// node_modules/postcss/lib/warning.js
var require_warning = __commonJS((exports, module) => {
	class Warning {
		constructor(text, opts = {}) {
			this.type = "warning";
			this.text = text;
			if (opts.node && opts.node.source) {
				let range = opts.node.rangeBy(opts);
				this.line = range.start.line;
				this.column = range.start.column;
				this.endLine = range.end.line;
				this.endColumn = range.end.column;
			}
			for (let opt in opts) this[opt] = opts[opt];
		}
		toString() {
			if (this.node) {
				return this.node.error(this.text, {
					index: this.index,
					plugin: this.plugin,
					word: this.word,
				}).message;
			}
			if (this.plugin) {
				return this.plugin + ": " + this.text;
			}
			return this.text;
		}
	}
	module.exports = Warning;
	Warning.default = Warning;
});

// node_modules/postcss/lib/result.js
var require_result = __commonJS((exports, module) => {
	var Warning = require_warning();

	class Result {
		get content() {
			return this.css;
		}
		constructor(processor, root, opts) {
			this.processor = processor;
			this.messages = [];
			this.root = root;
			this.opts = opts;
			this.css = "";
			this.map = undefined;
		}
		toString() {
			return this.css;
		}
		warn(text, opts = {}) {
			if (!opts.plugin) {
				if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
					opts.plugin = this.lastPlugin.postcssPlugin;
				}
			}
			let warning = new Warning(text, opts);
			this.messages.push(warning);
			return warning;
		}
		warnings() {
			return this.messages.filter((i) => i.type === "warning");
		}
	}
	module.exports = Result;
	Result.default = Result;
});

// node_modules/postcss/lib/warn-once.js
var require_warn_once = __commonJS((exports, module) => {
	var printed = {};
	module.exports = function warnOnce(message) {
		if (printed[message]) return;
		printed[message] = true;
		if (typeof console !== "undefined" && console.warn) {
			console.warn(message);
		}
	};
});

// node_modules/postcss/lib/lazy-result.js
var require_lazy_result = __commonJS((exports, module) => {
	var Container = require_container();
	var Document = require_document();
	var MapGenerator = require_map_generator();
	var parse2 = require_parse2();
	var Result = require_result();
	var Root = require_root();
	var stringify = require_stringify2();
	var { isClean, my } = require_symbols();
	var warnOnce = require_warn_once();
	var TYPE_TO_CLASS_NAME = {
		atrule: "AtRule",
		comment: "Comment",
		decl: "Declaration",
		document: "Document",
		root: "Root",
		rule: "Rule",
	};
	var PLUGIN_PROPS = {
		AtRule: true,
		AtRuleExit: true,
		Comment: true,
		CommentExit: true,
		Declaration: true,
		DeclarationExit: true,
		Document: true,
		DocumentExit: true,
		Once: true,
		OnceExit: true,
		postcssPlugin: true,
		prepare: true,
		Root: true,
		RootExit: true,
		Rule: true,
		RuleExit: true,
	};
	var NOT_VISITORS = {
		Once: true,
		postcssPlugin: true,
		prepare: true,
	};
	var CHILDREN = 0;
	function isPromise(obj) {
		return typeof obj === "object" && typeof obj.then === "function";
	}
	function getEvents(node) {
		let key = false;
		let type = TYPE_TO_CLASS_NAME[node.type];
		if (node.type === "decl") {
			key = node.prop.toLowerCase();
		} else if (node.type === "atrule") {
			key = node.name.toLowerCase();
		}
		if (key && node.append) {
			return [type, type + "-" + key, CHILDREN, type + "Exit", type + "Exit-" + key];
		} else if (key) {
			return [type, type + "-" + key, type + "Exit", type + "Exit-" + key];
		} else if (node.append) {
			return [type, CHILDREN, type + "Exit"];
		} else {
			return [type, type + "Exit"];
		}
	}
	function toStack(node) {
		let events;
		if (node.type === "document") {
			events = ["Document", CHILDREN, "DocumentExit"];
		} else if (node.type === "root") {
			events = ["Root", CHILDREN, "RootExit"];
		} else {
			events = getEvents(node);
		}
		return {
			eventIndex: 0,
			events,
			iterator: 0,
			node,
			visitorIndex: 0,
			visitors: [],
		};
	}
	function cleanMarks(node) {
		node[isClean] = false;
		if (node.nodes) node.nodes.forEach((i) => cleanMarks(i));
		return node;
	}
	var postcss = {};

	class LazyResult {
		get content() {
			return this.stringify().content;
		}
		get css() {
			return this.stringify().css;
		}
		get map() {
			return this.stringify().map;
		}
		get messages() {
			return this.sync().messages;
		}
		get opts() {
			return this.result.opts;
		}
		get processor() {
			return this.result.processor;
		}
		get root() {
			return this.sync().root;
		}
		get [Symbol.toStringTag]() {
			return "LazyResult";
		}
		constructor(processor, css, opts) {
			this.stringified = false;
			this.processed = false;
			let root;
			if (
				typeof css === "object" &&
				css !== null &&
				(css.type === "root" || css.type === "document")
			) {
				root = cleanMarks(css);
			} else if (css instanceof LazyResult || css instanceof Result) {
				root = cleanMarks(css.root);
				if (css.map) {
					if (typeof opts.map === "undefined") opts.map = {};
					if (!opts.map.inline) opts.map.inline = false;
					opts.map.prev = css.map;
				}
			} else {
				let parser = parse2;
				if (opts.syntax) parser = opts.syntax.parse;
				if (opts.parser) parser = opts.parser;
				if (parser.parse) parser = parser.parse;
				try {
					root = parser(css, opts);
				} catch (error) {
					this.processed = true;
					this.error = error;
				}
				if (root && !root[my]) {
					Container.rebuild(root);
				}
			}
			this.result = new Result(processor, root, opts);
			this.helpers = { ...postcss, postcss, result: this.result };
			this.plugins = this.processor.plugins.map((plugin) => {
				if (typeof plugin === "object" && plugin.prepare) {
					return { ...plugin, ...plugin.prepare(this.result) };
				} else {
					return plugin;
				}
			});
		}
		async() {
			if (this.error) return Promise.reject(this.error);
			if (this.processed) return Promise.resolve(this.result);
			if (!this.processing) {
				this.processing = this.runAsync();
			}
			return this.processing;
		}
		catch(onRejected) {
			return this.async().catch(onRejected);
		}
		finally(onFinally) {
			return this.async().then(onFinally, onFinally);
		}
		getAsyncError() {
			throw new Error("Use process(css).then(cb) to work with async plugins");
		}
		handleError(error, node) {
			let plugin = this.result.lastPlugin;
			try {
				if (node) node.addToError(error);
				this.error = error;
				if (error.name === "CssSyntaxError" && !error.plugin) {
					error.plugin = plugin.postcssPlugin;
					error.setMessage();
				} else if (plugin.postcssVersion) {
					if (true) {
						let pluginName = plugin.postcssPlugin;
						let pluginVer = plugin.postcssVersion;
						let runtimeVer = this.result.processor.version;
						let a12 = pluginVer.split(".");
						let b = runtimeVer.split(".");
						if (a12[0] !== b[0] || parseInt(a12[1]) > parseInt(b[1])) {
							console.error(
								"Unknown error from PostCSS plugin. Your current PostCSS " +
									"version is " +
									runtimeVer +
									", but " +
									pluginName +
									" uses " +
									pluginVer +
									". Perhaps this is the source of the error below.",
							);
						}
					}
				}
			} catch (err) {
				if (console && console.error) console.error(err);
			}
			return error;
		}
		prepareVisitors() {
			this.listeners = {};
			let add = (plugin, type, cb) => {
				if (!this.listeners[type]) this.listeners[type] = [];
				this.listeners[type].push([plugin, cb]);
			};
			for (let plugin of this.plugins) {
				if (typeof plugin === "object") {
					for (let event in plugin) {
						if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
							throw new Error(
								`Unknown event ${event} in ${plugin.postcssPlugin}. ` +
									`Try to update PostCSS (${this.processor.version} now).`,
							);
						}
						if (!NOT_VISITORS[event]) {
							if (typeof plugin[event] === "object") {
								for (let filter2 in plugin[event]) {
									if (filter2 === "*") {
										add(plugin, event, plugin[event][filter2]);
									} else {
										add(plugin, event + "-" + filter2.toLowerCase(), plugin[event][filter2]);
									}
								}
							} else if (typeof plugin[event] === "function") {
								add(plugin, event, plugin[event]);
							}
						}
					}
				}
			}
			this.hasListener = Object.keys(this.listeners).length > 0;
		}
		async runAsync() {
			this.plugin = 0;
			for (let i = 0; i < this.plugins.length; i++) {
				let plugin = this.plugins[i];
				let promise = this.runOnRoot(plugin);
				if (isPromise(promise)) {
					try {
						await promise;
					} catch (error) {
						throw this.handleError(error);
					}
				}
			}
			this.prepareVisitors();
			if (this.hasListener) {
				let root = this.result.root;
				while (!root[isClean]) {
					root[isClean] = true;
					let stack = [toStack(root)];
					while (stack.length > 0) {
						let promise = this.visitTick(stack);
						if (isPromise(promise)) {
							try {
								await promise;
							} catch (e) {
								let node = stack[stack.length - 1].node;
								throw this.handleError(e, node);
							}
						}
					}
				}
				if (this.listeners.OnceExit) {
					for (let [plugin, visitor] of this.listeners.OnceExit) {
						this.result.lastPlugin = plugin;
						try {
							if (root.type === "document") {
								let roots = root.nodes.map((subRoot) => visitor(subRoot, this.helpers));
								await Promise.all(roots);
							} else {
								await visitor(root, this.helpers);
							}
						} catch (e) {
							throw this.handleError(e);
						}
					}
				}
			}
			this.processed = true;
			return this.stringify();
		}
		runOnRoot(plugin) {
			this.result.lastPlugin = plugin;
			try {
				if (typeof plugin === "object" && plugin.Once) {
					if (this.result.root.type === "document") {
						let roots = this.result.root.nodes.map((root) => plugin.Once(root, this.helpers));
						if (isPromise(roots[0])) {
							return Promise.all(roots);
						}
						return roots;
					}
					return plugin.Once(this.result.root, this.helpers);
				} else if (typeof plugin === "function") {
					return plugin(this.result.root, this.result);
				}
			} catch (error) {
				throw this.handleError(error);
			}
		}
		stringify() {
			if (this.error) throw this.error;
			if (this.stringified) return this.result;
			this.stringified = true;
			this.sync();
			let opts = this.result.opts;
			let str = stringify;
			if (opts.syntax) str = opts.syntax.stringify;
			if (opts.stringifier) str = opts.stringifier;
			if (str.stringify) str = str.stringify;
			let map3 = new MapGenerator(str, this.result.root, this.result.opts);
			let data = map3.generate();
			this.result.css = data[0];
			this.result.map = data[1];
			return this.result;
		}
		sync() {
			if (this.error) throw this.error;
			if (this.processed) return this.result;
			this.processed = true;
			if (this.processing) {
				throw this.getAsyncError();
			}
			for (let plugin of this.plugins) {
				let promise = this.runOnRoot(plugin);
				if (isPromise(promise)) {
					throw this.getAsyncError();
				}
			}
			this.prepareVisitors();
			if (this.hasListener) {
				let root = this.result.root;
				while (!root[isClean]) {
					root[isClean] = true;
					this.walkSync(root);
				}
				if (this.listeners.OnceExit) {
					if (root.type === "document") {
						for (let subRoot of root.nodes) {
							this.visitSync(this.listeners.OnceExit, subRoot);
						}
					} else {
						this.visitSync(this.listeners.OnceExit, root);
					}
				}
			}
			return this.result;
		}
		then(onFulfilled, onRejected) {
			if (true) {
				if (!("from" in this.opts)) {
					warnOnce(
						"Without `from` option PostCSS could generate wrong source map " +
							"and will not find Browserslist config. Set it to CSS file path " +
							"or to `undefined` to prevent this warning.",
					);
				}
			}
			return this.async().then(onFulfilled, onRejected);
		}
		toString() {
			return this.css;
		}
		visitSync(visitors, node) {
			for (let [plugin, visitor] of visitors) {
				this.result.lastPlugin = plugin;
				let promise;
				try {
					promise = visitor(node, this.helpers);
				} catch (e) {
					throw this.handleError(e, node.proxyOf);
				}
				if (node.type !== "root" && node.type !== "document" && !node.parent) {
					return true;
				}
				if (isPromise(promise)) {
					throw this.getAsyncError();
				}
			}
		}
		visitTick(stack) {
			let visit = stack[stack.length - 1];
			let { node, visitors } = visit;
			if (node.type !== "root" && node.type !== "document" && !node.parent) {
				stack.pop();
				return;
			}
			if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
				let [plugin, visitor] = visitors[visit.visitorIndex];
				visit.visitorIndex += 1;
				if (visit.visitorIndex === visitors.length) {
					visit.visitors = [];
					visit.visitorIndex = 0;
				}
				this.result.lastPlugin = plugin;
				try {
					return visitor(node.toProxy(), this.helpers);
				} catch (e) {
					throw this.handleError(e, node);
				}
			}
			if (visit.iterator !== 0) {
				let iterator2 = visit.iterator;
				let child;
				while ((child = node.nodes[node.indexes[iterator2]])) {
					node.indexes[iterator2] += 1;
					if (!child[isClean]) {
						child[isClean] = true;
						stack.push(toStack(child));
						return;
					}
				}
				visit.iterator = 0;
				delete node.indexes[iterator2];
			}
			let events = visit.events;
			while (visit.eventIndex < events.length) {
				let event = events[visit.eventIndex];
				visit.eventIndex += 1;
				if (event === CHILDREN) {
					if (node.nodes && node.nodes.length) {
						node[isClean] = true;
						visit.iterator = node.getIterator();
					}
					return;
				} else if (this.listeners[event]) {
					visit.visitors = this.listeners[event];
					return;
				}
			}
			stack.pop();
		}
		walkSync(node) {
			node[isClean] = true;
			let events = getEvents(node);
			for (let event of events) {
				if (event === CHILDREN) {
					if (node.nodes) {
						node.each((child) => {
							if (!child[isClean]) this.walkSync(child);
						});
					}
				} else {
					let visitors = this.listeners[event];
					if (visitors) {
						if (this.visitSync(visitors, node.toProxy())) return;
					}
				}
			}
		}
		warnings() {
			return this.sync().warnings();
		}
	}
	LazyResult.registerPostcss = (dependant) => {
		postcss = dependant;
	};
	module.exports = LazyResult;
	LazyResult.default = LazyResult;
	Root.registerLazyResult(LazyResult);
	Document.registerLazyResult(LazyResult);
});

// node_modules/postcss/lib/no-work-result.js
var require_no_work_result = __commonJS((exports, module) => {
	var MapGenerator = require_map_generator();
	var parse2 = require_parse2();
	var Result = require_result();
	var stringify = require_stringify2();
	var warnOnce = require_warn_once();

	class NoWorkResult {
		get content() {
			return this.result.css;
		}
		get css() {
			return this.result.css;
		}
		get map() {
			return this.result.map;
		}
		get messages() {
			return [];
		}
		get opts() {
			return this.result.opts;
		}
		get processor() {
			return this.result.processor;
		}
		get root() {
			if (this._root) {
				return this._root;
			}
			let root;
			let parser = parse2;
			try {
				root = parser(this._css, this._opts);
			} catch (error) {
				this.error = error;
			}
			if (this.error) {
				throw this.error;
			} else {
				this._root = root;
				return root;
			}
		}
		get [Symbol.toStringTag]() {
			return "NoWorkResult";
		}
		constructor(processor, css, opts) {
			css = css.toString();
			this.stringified = false;
			this._processor = processor;
			this._css = css;
			this._opts = opts;
			this._map = undefined;
			let root;
			let str = stringify;
			this.result = new Result(this._processor, root, this._opts);
			this.result.css = css;
			let self2 = this;
			Object.defineProperty(this.result, "root", {
				get() {
					return self2.root;
				},
			});
			let map3 = new MapGenerator(str, root, this._opts, css);
			if (map3.isMap()) {
				let [generatedCSS, generatedMap] = map3.generate();
				if (generatedCSS) {
					this.result.css = generatedCSS;
				}
				if (generatedMap) {
					this.result.map = generatedMap;
				}
			} else {
				map3.clearAnnotation();
				this.result.css = map3.css;
			}
		}
		async() {
			if (this.error) return Promise.reject(this.error);
			return Promise.resolve(this.result);
		}
		catch(onRejected) {
			return this.async().catch(onRejected);
		}
		finally(onFinally) {
			return this.async().then(onFinally, onFinally);
		}
		sync() {
			if (this.error) throw this.error;
			return this.result;
		}
		then(onFulfilled, onRejected) {
			if (true) {
				if (!("from" in this._opts)) {
					warnOnce(
						"Without `from` option PostCSS could generate wrong source map " +
							"and will not find Browserslist config. Set it to CSS file path " +
							"or to `undefined` to prevent this warning.",
					);
				}
			}
			return this.async().then(onFulfilled, onRejected);
		}
		toString() {
			return this._css;
		}
		warnings() {
			return [];
		}
	}
	module.exports = NoWorkResult;
	NoWorkResult.default = NoWorkResult;
});

// node_modules/postcss/lib/processor.js
var require_processor = __commonJS((exports, module) => {
	var Document = require_document();
	var LazyResult = require_lazy_result();
	var NoWorkResult = require_no_work_result();
	var Root = require_root();

	class Processor {
		constructor(plugins = []) {
			this.version = "8.5.6";
			this.plugins = this.normalize(plugins);
		}
		normalize(plugins) {
			let normalized = [];
			for (let i of plugins) {
				if (i.postcss === true) {
					i = i();
				} else if (i.postcss) {
					i = i.postcss;
				}
				if (typeof i === "object" && Array.isArray(i.plugins)) {
					normalized = normalized.concat(i.plugins);
				} else if (typeof i === "object" && i.postcssPlugin) {
					normalized.push(i);
				} else if (typeof i === "function") {
					normalized.push(i);
				} else if (typeof i === "object" && (i.parse || i.stringify)) {
					if (true) {
						throw new Error(
							"PostCSS syntaxes cannot be used as plugins. Instead, please use " +
								"one of the syntax/parser/stringifier options as outlined " +
								"in your PostCSS runner documentation.",
						);
					}
				} else {
					throw new Error(i + " is not a PostCSS plugin");
				}
			}
			return normalized;
		}
		process(css, opts = {}) {
			if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {
				return new NoWorkResult(this, css, opts);
			} else {
				return new LazyResult(this, css, opts);
			}
		}
		use(plugin) {
			this.plugins = this.plugins.concat(this.normalize([plugin]));
			return this;
		}
	}
	module.exports = Processor;
	Processor.default = Processor;
	Root.registerProcessor(Processor);
	Document.registerProcessor(Processor);
});

// node_modules/postcss/lib/postcss.js
var require_postcss = __commonJS((exports, module) => {
	var AtRule = require_at_rule();
	var Comment = require_comment();
	var Container = require_container();
	var CssSyntaxError = require_css_syntax_error();
	var Declaration = require_declaration();
	var Document = require_document();
	var fromJSON = require_fromJSON();
	var Input = require_input();
	var LazyResult = require_lazy_result();
	var list = require_list();
	var Node = require_node3();
	var parse2 = require_parse2();
	var Processor = require_processor();
	var Result = require_result();
	var Root = require_root();
	var Rule = require_rule();
	var stringify = require_stringify2();
	var Warning = require_warning();
	function postcss(...plugins) {
		if (plugins.length === 1 && Array.isArray(plugins[0])) {
			plugins = plugins[0];
		}
		return new Processor(plugins);
	}
	postcss.plugin = function plugin(name, initializer) {
		let warningPrinted = false;
		function creator(...args) {
			if (console && console.warn && !warningPrinted) {
				warningPrinted = true;
				console.warn(
					name +
						`: postcss.plugin was deprecated. Migration guide:
` +
						"https://evilmartians.com/chronicles/postcss-8-plugin-migration",
				);
				if (process.env.LANG && process.env.LANG.startsWith("cn")) {
					console.warn(
						name +
							`: \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:
` +
							"https://www.w3ctech.com/topic/2226",
					);
				}
			}
			let transformer = initializer(...args);
			transformer.postcssPlugin = name;
			transformer.postcssVersion = new Processor().version;
			return transformer;
		}
		let cache;
		Object.defineProperty(creator, "postcss", {
			get() {
				if (!cache) cache = creator();
				return cache;
			},
		});
		creator.process = function (css, processOpts, pluginOpts) {
			return postcss([creator(pluginOpts)]).process(css, processOpts);
		};
		return creator;
	};
	postcss.stringify = stringify;
	postcss.parse = parse2;
	postcss.fromJSON = fromJSON;
	postcss.list = list;
	postcss.comment = (defaults2) => new Comment(defaults2);
	postcss.atRule = (defaults2) => new AtRule(defaults2);
	postcss.decl = (defaults2) => new Declaration(defaults2);
	postcss.rule = (defaults2) => new Rule(defaults2);
	postcss.root = (defaults2) => new Root(defaults2);
	postcss.document = (defaults2) => new Document(defaults2);
	postcss.CssSyntaxError = CssSyntaxError;
	postcss.Declaration = Declaration;
	postcss.Container = Container;
	postcss.Processor = Processor;
	postcss.Document = Document;
	postcss.Comment = Comment;
	postcss.Warning = Warning;
	postcss.AtRule = AtRule;
	postcss.Result = Result;
	postcss.Input = Input;
	postcss.Rule = Rule;
	postcss.Root = Root;
	postcss.Node = Node;
	LazyResult.registerPostcss(postcss);
	module.exports = postcss;
	postcss.default = postcss;
});

// node_modules/sanitize-html/index.js
var require_sanitize_html = __commonJS((exports, module) => {
	var htmlparser = require_lib6();
	var escapeStringRegexp = require_escape_string_regexp();
	var { isPlainObject: isPlainObject2 } = require_is_plain_object();
	var deepmerge = require_cjs();
	var parseSrcset = require_parse_srcset();
	var { parse: postcssParse } = require_postcss();
	var mediaTags = ["img", "audio", "video", "picture", "svg", "object", "map", "iframe", "embed"];
	var vulnerableTags = ["script", "style"];
	function each(obj, cb) {
		if (obj) {
			Object.keys(obj).forEach(function (key) {
				cb(obj[key], key);
			});
		}
	}
	function has(obj, key) {
		return {}.hasOwnProperty.call(obj, key);
	}
	function filter2(a12, cb) {
		const n2 = [];
		each(a12, function (v) {
			if (cb(v)) {
				n2.push(v);
			}
		});
		return n2;
	}
	function isEmptyObject2(obj) {
		for (const key in obj) {
			if (has(obj, key)) {
				return false;
			}
		}
		return true;
	}
	function stringifySrcset(parsedSrcset) {
		return parsedSrcset
			.map(function (part) {
				if (!part.url) {
					throw new Error("URL missing");
				}
				return (
					part.url +
					(part.w ? ` ${part.w}w` : "") +
					(part.h ? ` ${part.h}h` : "") +
					(part.d ? ` ${part.d}x` : "")
				);
			})
			.join(", ");
	}
	module.exports = sanitizeHtml;
	var VALID_HTML_ATTRIBUTE_NAME = /^[^\0\t\n\f\r /<=>]+$/;
	function sanitizeHtml(html2, options, _recursing) {
		if (html2 == null) {
			return "";
		}
		if (typeof html2 === "number") {
			html2 = html2.toString();
		}
		let result = "";
		let tempResult = "";
		function Frame(tag, attribs) {
			const that = this;
			this.tag = tag;
			this.attribs = attribs || {};
			this.tagPosition = result.length;
			this.text = "";
			this.openingTagLength = 0;
			this.mediaChildren = [];
			this.updateParentNodeText = function () {
				if (stack.length) {
					const parentFrame = stack[stack.length - 1];
					parentFrame.text += that.text;
				}
			};
			this.updateParentNodeMediaChildren = function () {
				if (stack.length && mediaTags.includes(this.tag)) {
					const parentFrame = stack[stack.length - 1];
					parentFrame.mediaChildren.push(this.tag);
				}
			};
		}
		options = Object.assign({}, sanitizeHtml.defaults, options);
		options.parser = Object.assign({}, htmlParserDefaults, options.parser);
		const tagAllowed = function (name) {
			return options.allowedTags === false || (options.allowedTags || []).indexOf(name) > -1;
		};
		vulnerableTags.forEach(function (tag) {
			if (tagAllowed(tag) && !options.allowVulnerableTags) {
				console.warn(`

\u26A0\uFE0F Your \`allowedTags\` option includes, \`${tag}\`, which is inherently
vulnerable to XSS attacks. Please remove it from \`allowedTags\`.
Or, to disable this warning, add the \`allowVulnerableTags\` option
and ensure you are accounting for this risk.

`);
			}
		});
		const nonTextTagsArray = options.nonTextTags || ["script", "style", "textarea", "option"];
		let allowedAttributesMap;
		let allowedAttributesGlobMap;
		if (options.allowedAttributes) {
			allowedAttributesMap = {};
			allowedAttributesGlobMap = {};
			each(options.allowedAttributes, function (attributes, tag) {
				allowedAttributesMap[tag] = [];
				const globRegex = [];
				attributes.forEach(function (obj) {
					if (typeof obj === "string" && obj.indexOf("*") >= 0) {
						globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, ".*"));
					} else {
						allowedAttributesMap[tag].push(obj);
					}
				});
				if (globRegex.length) {
					allowedAttributesGlobMap[tag] = new RegExp("^(" + globRegex.join("|") + ")$");
				}
			});
		}
		const allowedClassesMap = {};
		const allowedClassesGlobMap = {};
		const allowedClassesRegexMap = {};
		each(options.allowedClasses, function (classes, tag) {
			if (allowedAttributesMap) {
				if (!has(allowedAttributesMap, tag)) {
					allowedAttributesMap[tag] = [];
				}
				allowedAttributesMap[tag].push("class");
			}
			allowedClassesMap[tag] = classes;
			if (Array.isArray(classes)) {
				const globRegex = [];
				allowedClassesMap[tag] = [];
				allowedClassesRegexMap[tag] = [];
				classes.forEach(function (obj) {
					if (typeof obj === "string" && obj.indexOf("*") >= 0) {
						globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, ".*"));
					} else if (obj instanceof RegExp) {
						allowedClassesRegexMap[tag].push(obj);
					} else {
						allowedClassesMap[tag].push(obj);
					}
				});
				if (globRegex.length) {
					allowedClassesGlobMap[tag] = new RegExp("^(" + globRegex.join("|") + ")$");
				}
			}
		});
		const transformTagsMap = {};
		let transformTagsAll;
		each(options.transformTags, function (transform2, tag) {
			let transFun;
			if (typeof transform2 === "function") {
				transFun = transform2;
			} else if (typeof transform2 === "string") {
				transFun = sanitizeHtml.simpleTransform(transform2);
			}
			if (tag === "*") {
				transformTagsAll = transFun;
			} else {
				transformTagsMap[tag] = transFun;
			}
		});
		let depth;
		let stack;
		let skipMap;
		let transformMap;
		let skipText;
		let skipTextDepth;
		let addedText = false;
		initializeState();
		const parser = new htmlparser.Parser(
			{
				onopentag: function (name, attribs) {
					if (options.onOpenTag) {
						options.onOpenTag(name, attribs);
					}
					if (options.enforceHtmlBoundary && name === "html") {
						initializeState();
					}
					if (skipText) {
						skipTextDepth++;
						return;
					}
					const frame = new Frame(name, attribs);
					stack.push(frame);
					let skip = false;
					const hasText = !!frame.text;
					let transformedTag;
					if (has(transformTagsMap, name)) {
						transformedTag = transformTagsMap[name](name, attribs);
						frame.attribs = attribs = transformedTag.attribs;
						if (transformedTag.text !== undefined) {
							frame.innerText = transformedTag.text;
						}
						if (name !== transformedTag.tagName) {
							frame.name = name = transformedTag.tagName;
							transformMap[depth] = transformedTag.tagName;
						}
					}
					if (transformTagsAll) {
						transformedTag = transformTagsAll(name, attribs);
						frame.attribs = attribs = transformedTag.attribs;
						if (name !== transformedTag.tagName) {
							frame.name = name = transformedTag.tagName;
							transformMap[depth] = transformedTag.tagName;
						}
					}
					if (
						!tagAllowed(name) ||
						(options.disallowedTagsMode === "recursiveEscape" && !isEmptyObject2(skipMap)) ||
						(options.nestingLimit != null && depth >= options.nestingLimit)
					) {
						skip = true;
						skipMap[depth] = true;
						if (
							options.disallowedTagsMode === "discard" ||
							options.disallowedTagsMode === "completelyDiscard"
						) {
							if (nonTextTagsArray.indexOf(name) !== -1) {
								skipText = true;
								skipTextDepth = 1;
							}
						}
					}
					depth++;
					if (skip) {
						if (
							options.disallowedTagsMode === "discard" ||
							options.disallowedTagsMode === "completelyDiscard"
						) {
							if (frame.innerText && !hasText) {
								const escaped = escapeHtml(frame.innerText);
								if (options.textFilter) {
									result += options.textFilter(escaped, name);
								} else {
									result += escaped;
								}
								addedText = true;
							}
							return;
						}
						tempResult = result;
						result = "";
					}
					result += "<" + name;
					if (name === "script") {
						if (options.allowedScriptHostnames || options.allowedScriptDomains) {
							frame.innerText = "";
						}
					}
					const isBeingEscaped =
						skip &&
						(options.disallowedTagsMode === "escape" ||
							options.disallowedTagsMode === "recursiveEscape");
					const shouldPreserveEscapedAttributes =
						isBeingEscaped && options.preserveEscapedAttributes;
					if (shouldPreserveEscapedAttributes) {
						each(attribs, function (value, a12) {
							result += " " + a12 + '="' + escapeHtml(value || "", true) + '"';
						});
					} else if (
						!allowedAttributesMap ||
						has(allowedAttributesMap, name) ||
						allowedAttributesMap["*"]
					) {
						each(attribs, function (value, a12) {
							if (!VALID_HTML_ATTRIBUTE_NAME.test(a12)) {
								delete frame.attribs[a12];
								return;
							}
							if (
								value === "" &&
								!options.allowedEmptyAttributes.includes(a12) &&
								(options.nonBooleanAttributes.includes(a12) ||
									options.nonBooleanAttributes.includes("*"))
							) {
								delete frame.attribs[a12];
								return;
							}
							let passedAllowedAttributesMapCheck = false;
							if (
								!allowedAttributesMap ||
								(has(allowedAttributesMap, name) &&
									allowedAttributesMap[name].indexOf(a12) !== -1) ||
								(allowedAttributesMap["*"] && allowedAttributesMap["*"].indexOf(a12) !== -1) ||
								(has(allowedAttributesGlobMap, name) && allowedAttributesGlobMap[name].test(a12)) ||
								(allowedAttributesGlobMap["*"] && allowedAttributesGlobMap["*"].test(a12))
							) {
								passedAllowedAttributesMapCheck = true;
							} else if (allowedAttributesMap && allowedAttributesMap[name]) {
								for (const o of allowedAttributesMap[name]) {
									if (isPlainObject2(o) && o.name && o.name === a12) {
										passedAllowedAttributesMapCheck = true;
										let newValue = "";
										if (o.multiple === true) {
											const splitStrArray = value.split(" ");
											for (const s of splitStrArray) {
												if (o.values.indexOf(s) !== -1) {
													if (newValue === "") {
														newValue = s;
													} else {
														newValue += " " + s;
													}
												}
											}
										} else if (o.values.indexOf(value) >= 0) {
											newValue = value;
										}
										value = newValue;
									}
								}
							}
							if (passedAllowedAttributesMapCheck) {
								if (options.allowedSchemesAppliedToAttributes.indexOf(a12) !== -1) {
									if (naughtyHref(name, value)) {
										delete frame.attribs[a12];
										return;
									}
								}
								if (name === "script" && a12 === "src") {
									let allowed = true;
									try {
										const parsed = parseUrl(value);
										if (options.allowedScriptHostnames || options.allowedScriptDomains) {
											const allowedHostname = (options.allowedScriptHostnames || []).find(
												function (hostname) {
													return hostname === parsed.url.hostname;
												},
											);
											const allowedDomain = (options.allowedScriptDomains || []).find(
												function (domain) {
													return (
														parsed.url.hostname === domain ||
														parsed.url.hostname.endsWith(`.${domain}`)
													);
												},
											);
											allowed = allowedHostname || allowedDomain;
										}
									} catch (e) {
										allowed = false;
									}
									if (!allowed) {
										delete frame.attribs[a12];
										return;
									}
								}
								if (name === "iframe" && a12 === "src") {
									let allowed = true;
									try {
										const parsed = parseUrl(value);
										if (parsed.isRelativeUrl) {
											allowed = has(options, "allowIframeRelativeUrls")
												? options.allowIframeRelativeUrls
												: !options.allowedIframeHostnames && !options.allowedIframeDomains;
										} else if (options.allowedIframeHostnames || options.allowedIframeDomains) {
											const allowedHostname = (options.allowedIframeHostnames || []).find(
												function (hostname) {
													return hostname === parsed.url.hostname;
												},
											);
											const allowedDomain = (options.allowedIframeDomains || []).find(
												function (domain) {
													return (
														parsed.url.hostname === domain ||
														parsed.url.hostname.endsWith(`.${domain}`)
													);
												},
											);
											allowed = allowedHostname || allowedDomain;
										}
									} catch (e) {
										allowed = false;
									}
									if (!allowed) {
										delete frame.attribs[a12];
										return;
									}
								}
								if (a12 === "srcset") {
									try {
										let parsed = parseSrcset(value);
										parsed.forEach(function (value2) {
											if (naughtyHref("srcset", value2.url)) {
												value2.evil = true;
											}
										});
										parsed = filter2(parsed, function (v) {
											return !v.evil;
										});
										if (!parsed.length) {
											delete frame.attribs[a12];
											return;
										} else {
											value = stringifySrcset(
												filter2(parsed, function (v) {
													return !v.evil;
												}),
											);
											frame.attribs[a12] = value;
										}
									} catch (e) {
										delete frame.attribs[a12];
										return;
									}
								}
								if (a12 === "class") {
									const allowedSpecificClasses = allowedClassesMap[name];
									const allowedWildcardClasses = allowedClassesMap["*"];
									const allowedSpecificClassesGlob = allowedClassesGlobMap[name];
									const allowedSpecificClassesRegex = allowedClassesRegexMap[name];
									const allowedWildcardClassesRegex = allowedClassesRegexMap["*"];
									const allowedWildcardClassesGlob = allowedClassesGlobMap["*"];
									const allowedClassesGlobs = [
										allowedSpecificClassesGlob,
										allowedWildcardClassesGlob,
									]
										.concat(allowedSpecificClassesRegex, allowedWildcardClassesRegex)
										.filter(function (t2) {
											return t2;
										});
									if (allowedSpecificClasses && allowedWildcardClasses) {
										value = filterClasses(
											value,
											deepmerge(allowedSpecificClasses, allowedWildcardClasses),
											allowedClassesGlobs,
										);
									} else {
										value = filterClasses(
											value,
											allowedSpecificClasses || allowedWildcardClasses,
											allowedClassesGlobs,
										);
									}
									if (!value.length) {
										delete frame.attribs[a12];
										return;
									}
								}
								if (a12 === "style") {
									if (options.parseStyleAttributes) {
										try {
											const abstractSyntaxTree = postcssParse(name + " {" + value + "}", {
												map: false,
											});
											const filteredAST = filterCss(abstractSyntaxTree, options.allowedStyles);
											value = stringifyStyleAttributes(filteredAST);
											if (value.length === 0) {
												delete frame.attribs[a12];
												return;
											}
										} catch (e) {
											if (typeof window !== "undefined") {
												console.warn(
													'Failed to parse "' +
														name +
														" {" +
														value +
														"}" +
														"\", If you're running this in a browser, we recommend to disable style parsing: options.parseStyleAttributes: false, since this only works in a node environment due to a postcss dependency, More info: https://github.com/apostrophecms/sanitize-html/issues/547",
												);
											}
											delete frame.attribs[a12];
											return;
										}
									} else if (options.allowedStyles) {
										throw new Error(
											"allowedStyles option cannot be used together with parseStyleAttributes: false.",
										);
									}
								}
								result += " " + a12;
								if (value && value.length) {
									result += '="' + escapeHtml(value, true) + '"';
								} else if (options.allowedEmptyAttributes.includes(a12)) {
									result += '=""';
								}
							} else {
								delete frame.attribs[a12];
							}
						});
					}
					if (options.selfClosing.indexOf(name) !== -1) {
						result += " />";
					} else {
						result += ">";
						if (frame.innerText && !hasText && !options.textFilter) {
							result += escapeHtml(frame.innerText);
							addedText = true;
						}
					}
					if (skip) {
						result = tempResult + escapeHtml(result);
						tempResult = "";
					}
					frame.openingTagLength = result.length - frame.tagPosition;
				},
				ontext: function (text) {
					if (skipText) {
						return;
					}
					const lastFrame = stack[stack.length - 1];
					let tag;
					if (lastFrame) {
						tag = lastFrame.tag;
						text = lastFrame.innerText !== undefined ? lastFrame.innerText : text;
					}
					if (options.disallowedTagsMode === "completelyDiscard" && !tagAllowed(tag)) {
						text = "";
					} else if (
						(options.disallowedTagsMode === "discard" ||
							options.disallowedTagsMode === "completelyDiscard") &&
						(tag === "script" || tag === "style")
					) {
						result += text;
					} else if (!addedText) {
						const escaped = escapeHtml(text, false);
						if (options.textFilter) {
							result += options.textFilter(escaped, tag);
						} else {
							result += escaped;
						}
					}
					if (stack.length) {
						const frame = stack[stack.length - 1];
						frame.text += text;
					}
				},
				onclosetag: function (name, isImplied) {
					if (options.onCloseTag) {
						options.onCloseTag(name, isImplied);
					}
					if (skipText) {
						skipTextDepth--;
						if (!skipTextDepth) {
							skipText = false;
						} else {
							return;
						}
					}
					const frame = stack.pop();
					if (!frame) {
						return;
					}
					if (frame.tag !== name) {
						stack.push(frame);
						return;
					}
					skipText = options.enforceHtmlBoundary ? name === "html" : false;
					depth--;
					const skip = skipMap[depth];
					if (skip) {
						delete skipMap[depth];
						if (
							options.disallowedTagsMode === "discard" ||
							options.disallowedTagsMode === "completelyDiscard"
						) {
							frame.updateParentNodeText();
							return;
						}
						tempResult = result;
						result = "";
					}
					if (transformMap[depth]) {
						name = transformMap[depth];
						delete transformMap[depth];
					}
					if (options.exclusiveFilter) {
						const filterResult = options.exclusiveFilter(frame);
						if (filterResult === "excludeTag") {
							if (skip) {
								result = tempResult;
								tempResult = "";
							}
							result =
								result.substring(0, frame.tagPosition) +
								result.substring(frame.tagPosition + frame.openingTagLength);
							return;
						} else if (filterResult) {
							result = result.substring(0, frame.tagPosition);
							return;
						}
					}
					frame.updateParentNodeMediaChildren();
					frame.updateParentNodeText();
					if (
						options.selfClosing.indexOf(name) !== -1 ||
						(isImplied &&
							!tagAllowed(name) &&
							["escape", "recursiveEscape"].indexOf(options.disallowedTagsMode) >= 0)
					) {
						if (skip) {
							result = tempResult;
							tempResult = "";
						}
						return;
					}
					result += "</" + name + ">";
					if (skip) {
						result = tempResult + escapeHtml(result);
						tempResult = "";
					}
					addedText = false;
				},
			},
			options.parser,
		);
		parser.write(html2);
		parser.end();
		return result;
		function initializeState() {
			result = "";
			depth = 0;
			stack = [];
			skipMap = {};
			transformMap = {};
			skipText = false;
			skipTextDepth = 0;
		}
		function escapeHtml(s, quote) {
			if (typeof s !== "string") {
				s = s + "";
			}
			if (options.parser.decodeEntities) {
				s = s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
				if (quote) {
					s = s.replace(/"/g, "&quot;");
				}
			}
			s = s
				.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, "&amp;")
				.replace(/</g, "&lt;")
				.replace(/>/g, "&gt;");
			if (quote) {
				s = s.replace(/"/g, "&quot;");
			}
			return s;
		}
		function naughtyHref(name, href) {
			href = href.replace(/[\x00-\x20]+/g, "");
			while (true) {
				const firstIndex = href.indexOf("<!--");
				if (firstIndex === -1) {
					break;
				}
				const lastIndex = href.indexOf("-->", firstIndex + 4);
				if (lastIndex === -1) {
					break;
				}
				href = href.substring(0, firstIndex) + href.substring(lastIndex + 3);
			}
			const matches = href.match(/^([a-zA-Z][a-zA-Z0-9.\-+]*):/);
			if (!matches) {
				if (href.match(/^[/\\]{2}/)) {
					return !options.allowProtocolRelative;
				}
				return false;
			}
			const scheme = matches[1].toLowerCase();
			if (has(options.allowedSchemesByTag, name)) {
				return options.allowedSchemesByTag[name].indexOf(scheme) === -1;
			}
			return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;
		}
		function parseUrl(value) {
			value = value.replace(/^(\w+:)?\s*[\\/]\s*[\\/]/, "$1//");
			if (value.startsWith("relative:")) {
				throw new Error("relative: exploit attempt");
			}
			let base = "relative://relative-site";
			for (let i = 0; i < 100; i++) {
				base += `/${i}`;
			}
			const parsed = new URL(value, base);
			const isRelativeUrl =
				parsed && parsed.hostname === "relative-site" && parsed.protocol === "relative:";
			return {
				isRelativeUrl,
				url: parsed,
			};
		}
		function filterCss(abstractSyntaxTree, allowedStyles) {
			if (!allowedStyles) {
				return abstractSyntaxTree;
			}
			const astRules = abstractSyntaxTree.nodes[0];
			let selectedRule;
			if (allowedStyles[astRules.selector] && allowedStyles["*"]) {
				selectedRule = deepmerge(allowedStyles[astRules.selector], allowedStyles["*"]);
			} else {
				selectedRule = allowedStyles[astRules.selector] || allowedStyles["*"];
			}
			if (selectedRule) {
				abstractSyntaxTree.nodes[0].nodes = astRules.nodes.reduce(
					filterDeclarations(selectedRule),
					[],
				);
			}
			return abstractSyntaxTree;
		}
		function stringifyStyleAttributes(filteredAST) {
			return filteredAST.nodes[0].nodes
				.reduce(function (extractedAttributes, attrObject) {
					extractedAttributes.push(
						`${attrObject.prop}:${attrObject.value}${attrObject.important ? " !important" : ""}`,
					);
					return extractedAttributes;
				}, [])
				.join(";");
		}
		function filterDeclarations(selectedRule) {
			return function (allowedDeclarationsList, attributeObject) {
				if (has(selectedRule, attributeObject.prop)) {
					const matchesRegex = selectedRule[attributeObject.prop].some(
						function (regularExpression) {
							return regularExpression.test(attributeObject.value);
						},
					);
					if (matchesRegex) {
						allowedDeclarationsList.push(attributeObject);
					}
				}
				return allowedDeclarationsList;
			};
		}
		function filterClasses(classes, allowed, allowedGlobs) {
			if (!allowed) {
				return classes;
			}
			classes = classes.split(/\s+/);
			return classes
				.filter(function (clss) {
					return (
						allowed.indexOf(clss) !== -1 ||
						allowedGlobs.some(function (glob) {
							return glob.test(clss);
						})
					);
				})
				.join(" ");
		}
	}
	var htmlParserDefaults = {
		decodeEntities: true,
	};
	sanitizeHtml.defaults = {
		allowedTags: [
			"address",
			"article",
			"aside",
			"footer",
			"header",
			"h1",
			"h2",
			"h3",
			"h4",
			"h5",
			"h6",
			"hgroup",
			"main",
			"nav",
			"section",
			"blockquote",
			"dd",
			"div",
			"dl",
			"dt",
			"figcaption",
			"figure",
			"hr",
			"li",
			"menu",
			"ol",
			"p",
			"pre",
			"ul",
			"a",
			"abbr",
			"b",
			"bdi",
			"bdo",
			"br",
			"cite",
			"code",
			"data",
			"dfn",
			"em",
			"i",
			"kbd",
			"mark",
			"q",
			"rb",
			"rp",
			"rt",
			"rtc",
			"ruby",
			"s",
			"samp",
			"small",
			"span",
			"strong",
			"sub",
			"sup",
			"time",
			"u",
			"var",
			"wbr",
			"caption",
			"col",
			"colgroup",
			"table",
			"tbody",
			"td",
			"tfoot",
			"th",
			"thead",
			"tr",
		],
		nonBooleanAttributes: [
			"abbr",
			"accept",
			"accept-charset",
			"accesskey",
			"action",
			"allow",
			"alt",
			"as",
			"autocapitalize",
			"autocomplete",
			"blocking",
			"charset",
			"cite",
			"class",
			"color",
			"cols",
			"colspan",
			"content",
			"contenteditable",
			"coords",
			"crossorigin",
			"data",
			"datetime",
			"decoding",
			"dir",
			"dirname",
			"download",
			"draggable",
			"enctype",
			"enterkeyhint",
			"fetchpriority",
			"for",
			"form",
			"formaction",
			"formenctype",
			"formmethod",
			"formtarget",
			"headers",
			"height",
			"hidden",
			"high",
			"href",
			"hreflang",
			"http-equiv",
			"id",
			"imagesizes",
			"imagesrcset",
			"inputmode",
			"integrity",
			"is",
			"itemid",
			"itemprop",
			"itemref",
			"itemtype",
			"kind",
			"label",
			"lang",
			"list",
			"loading",
			"low",
			"max",
			"maxlength",
			"media",
			"method",
			"min",
			"minlength",
			"name",
			"nonce",
			"optimum",
			"pattern",
			"ping",
			"placeholder",
			"popover",
			"popovertarget",
			"popovertargetaction",
			"poster",
			"preload",
			"referrerpolicy",
			"rel",
			"rows",
			"rowspan",
			"sandbox",
			"scope",
			"shape",
			"size",
			"sizes",
			"slot",
			"span",
			"spellcheck",
			"src",
			"srcdoc",
			"srclang",
			"srcset",
			"start",
			"step",
			"style",
			"tabindex",
			"target",
			"title",
			"translate",
			"type",
			"usemap",
			"value",
			"width",
			"wrap",
			"onauxclick",
			"onafterprint",
			"onbeforematch",
			"onbeforeprint",
			"onbeforeunload",
			"onbeforetoggle",
			"onblur",
			"oncancel",
			"oncanplay",
			"oncanplaythrough",
			"onchange",
			"onclick",
			"onclose",
			"oncontextlost",
			"oncontextmenu",
			"oncontextrestored",
			"oncopy",
			"oncuechange",
			"oncut",
			"ondblclick",
			"ondrag",
			"ondragend",
			"ondragenter",
			"ondragleave",
			"ondragover",
			"ondragstart",
			"ondrop",
			"ondurationchange",
			"onemptied",
			"onended",
			"onerror",
			"onfocus",
			"onformdata",
			"onhashchange",
			"oninput",
			"oninvalid",
			"onkeydown",
			"onkeypress",
			"onkeyup",
			"onlanguagechange",
			"onload",
			"onloadeddata",
			"onloadedmetadata",
			"onloadstart",
			"onmessage",
			"onmessageerror",
			"onmousedown",
			"onmouseenter",
			"onmouseleave",
			"onmousemove",
			"onmouseout",
			"onmouseover",
			"onmouseup",
			"onoffline",
			"ononline",
			"onpagehide",
			"onpageshow",
			"onpaste",
			"onpause",
			"onplay",
			"onplaying",
			"onpopstate",
			"onprogress",
			"onratechange",
			"onreset",
			"onresize",
			"onrejectionhandled",
			"onscroll",
			"onscrollend",
			"onsecuritypolicyviolation",
			"onseeked",
			"onseeking",
			"onselect",
			"onslotchange",
			"onstalled",
			"onstorage",
			"onsubmit",
			"onsuspend",
			"ontimeupdate",
			"ontoggle",
			"onunhandledrejection",
			"onunload",
			"onvolumechange",
			"onwaiting",
			"onwheel",
		],
		disallowedTagsMode: "discard",
		allowedAttributes: {
			a: ["href", "name", "target"],
			img: ["src", "srcset", "alt", "title", "width", "height", "loading"],
		},
		allowedEmptyAttributes: ["alt"],
		selfClosing: ["img", "br", "hr", "area", "base", "basefont", "input", "link", "meta"],
		allowedSchemes: ["http", "https", "ftp", "mailto", "tel"],
		allowedSchemesByTag: {},
		allowedSchemesAppliedToAttributes: ["href", "src", "cite"],
		allowProtocolRelative: true,
		enforceHtmlBoundary: false,
		parseStyleAttributes: true,
		preserveEscapedAttributes: false,
	};
	sanitizeHtml.simpleTransform = function (newTagName, newAttribs, merge2) {
		merge2 = merge2 === undefined ? true : merge2;
		newAttribs = newAttribs || {};
		return function (tagName, attribs) {
			let attrib;
			if (merge2) {
				for (attrib in newAttribs) {
					attribs[attrib] = newAttribs[attrib];
				}
			} else {
				attribs = newAttribs;
			}
			return {
				tagName: newTagName,
				attribs,
			};
		};
	};
});

// node_modules/@ioredis/commands/built/commands.json
var require_commands = __commonJS((exports, module) => {
	module.exports = {
		acl: {
			arity: -2,
			flags: [],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		append: {
			arity: 3,
			flags: ["write", "denyoom", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		asking: {
			arity: 1,
			flags: ["fast"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		auth: {
			arity: -2,
			flags: ["noscript", "loading", "stale", "fast", "no_auth", "allow_busy"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		bgrewriteaof: {
			arity: 1,
			flags: ["admin", "noscript", "no_async_loading"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		bgsave: {
			arity: -1,
			flags: ["admin", "noscript", "no_async_loading"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		bitcount: {
			arity: -2,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		bitfield: {
			arity: -2,
			flags: ["write", "denyoom"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		bitfield_ro: {
			arity: -2,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		bitop: {
			arity: -4,
			flags: ["write", "denyoom"],
			keyStart: 2,
			keyStop: -1,
			step: 1,
		},
		bitpos: {
			arity: -3,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		blmove: {
			arity: 6,
			flags: ["write", "denyoom", "noscript", "blocking"],
			keyStart: 1,
			keyStop: 2,
			step: 1,
		},
		blmpop: {
			arity: -5,
			flags: ["write", "blocking", "movablekeys"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		blpop: {
			arity: -3,
			flags: ["write", "noscript", "blocking"],
			keyStart: 1,
			keyStop: -2,
			step: 1,
		},
		brpop: {
			arity: -3,
			flags: ["write", "noscript", "blocking"],
			keyStart: 1,
			keyStop: -2,
			step: 1,
		},
		brpoplpush: {
			arity: 4,
			flags: ["write", "denyoom", "noscript", "blocking"],
			keyStart: 1,
			keyStop: 2,
			step: 1,
		},
		bzmpop: {
			arity: -5,
			flags: ["write", "blocking", "movablekeys"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		bzpopmax: {
			arity: -3,
			flags: ["write", "noscript", "blocking", "fast"],
			keyStart: 1,
			keyStop: -2,
			step: 1,
		},
		bzpopmin: {
			arity: -3,
			flags: ["write", "noscript", "blocking", "fast"],
			keyStart: 1,
			keyStop: -2,
			step: 1,
		},
		client: {
			arity: -2,
			flags: [],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		cluster: {
			arity: -2,
			flags: [],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		command: {
			arity: -1,
			flags: ["loading", "stale"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		config: {
			arity: -2,
			flags: [],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		copy: {
			arity: -3,
			flags: ["write", "denyoom"],
			keyStart: 1,
			keyStop: 2,
			step: 1,
		},
		dbsize: {
			arity: 1,
			flags: ["readonly", "fast"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		debug: {
			arity: -2,
			flags: ["admin", "noscript", "loading", "stale"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		decr: {
			arity: 2,
			flags: ["write", "denyoom", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		decrby: {
			arity: 3,
			flags: ["write", "denyoom", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		del: {
			arity: -2,
			flags: ["write"],
			keyStart: 1,
			keyStop: -1,
			step: 1,
		},
		discard: {
			arity: 1,
			flags: ["noscript", "loading", "stale", "fast", "allow_busy"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		dump: {
			arity: 2,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		echo: {
			arity: 2,
			flags: ["fast"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		eval: {
			arity: -3,
			flags: ["noscript", "stale", "skip_monitor", "no_mandatory_keys", "movablekeys"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		eval_ro: {
			arity: -3,
			flags: ["readonly", "noscript", "stale", "skip_monitor", "no_mandatory_keys", "movablekeys"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		evalsha: {
			arity: -3,
			flags: ["noscript", "stale", "skip_monitor", "no_mandatory_keys", "movablekeys"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		evalsha_ro: {
			arity: -3,
			flags: ["readonly", "noscript", "stale", "skip_monitor", "no_mandatory_keys", "movablekeys"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		exec: {
			arity: 1,
			flags: ["noscript", "loading", "stale", "skip_slowlog"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		exists: {
			arity: -2,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: -1,
			step: 1,
		},
		expire: {
			arity: -3,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		expireat: {
			arity: -3,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		expiretime: {
			arity: 2,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		failover: {
			arity: -1,
			flags: ["admin", "noscript", "stale"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		fcall: {
			arity: -3,
			flags: ["noscript", "stale", "skip_monitor", "no_mandatory_keys", "movablekeys"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		fcall_ro: {
			arity: -3,
			flags: ["readonly", "noscript", "stale", "skip_monitor", "no_mandatory_keys", "movablekeys"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		flushall: {
			arity: -1,
			flags: ["write"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		flushdb: {
			arity: -1,
			flags: ["write"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		function: {
			arity: -2,
			flags: [],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		geoadd: {
			arity: -5,
			flags: ["write", "denyoom"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		geodist: {
			arity: -4,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		geohash: {
			arity: -2,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		geopos: {
			arity: -2,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		georadius: {
			arity: -6,
			flags: ["write", "denyoom", "movablekeys"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		georadius_ro: {
			arity: -6,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		georadiusbymember: {
			arity: -5,
			flags: ["write", "denyoom", "movablekeys"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		georadiusbymember_ro: {
			arity: -5,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		geosearch: {
			arity: -7,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		geosearchstore: {
			arity: -8,
			flags: ["write", "denyoom"],
			keyStart: 1,
			keyStop: 2,
			step: 1,
		},
		get: {
			arity: 2,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		getbit: {
			arity: 3,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		getdel: {
			arity: 2,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		getex: {
			arity: -2,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		getrange: {
			arity: 4,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		getset: {
			arity: 3,
			flags: ["write", "denyoom", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		hdel: {
			arity: -3,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		hello: {
			arity: -1,
			flags: ["noscript", "loading", "stale", "fast", "no_auth", "allow_busy"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		hexists: {
			arity: 3,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		hexpire: {
			arity: -6,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		hpexpire: {
			arity: -6,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		hget: {
			arity: 3,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		hgetall: {
			arity: 2,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		hincrby: {
			arity: 4,
			flags: ["write", "denyoom", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		hincrbyfloat: {
			arity: 4,
			flags: ["write", "denyoom", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		hkeys: {
			arity: 2,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		hlen: {
			arity: 2,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		hmget: {
			arity: -3,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		hmset: {
			arity: -4,
			flags: ["write", "denyoom", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		hrandfield: {
			arity: -2,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		hscan: {
			arity: -3,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		hset: {
			arity: -4,
			flags: ["write", "denyoom", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		hsetnx: {
			arity: 4,
			flags: ["write", "denyoom", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		hstrlen: {
			arity: 3,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		hvals: {
			arity: 2,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		incr: {
			arity: 2,
			flags: ["write", "denyoom", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		incrby: {
			arity: 3,
			flags: ["write", "denyoom", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		incrbyfloat: {
			arity: 3,
			flags: ["write", "denyoom", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		info: {
			arity: -1,
			flags: ["loading", "stale"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		keys: {
			arity: 2,
			flags: ["readonly"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		lastsave: {
			arity: 1,
			flags: ["loading", "stale", "fast"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		latency: {
			arity: -2,
			flags: [],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		lcs: {
			arity: -3,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 2,
			step: 1,
		},
		lindex: {
			arity: 3,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		linsert: {
			arity: 5,
			flags: ["write", "denyoom"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		llen: {
			arity: 2,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		lmove: {
			arity: 5,
			flags: ["write", "denyoom"],
			keyStart: 1,
			keyStop: 2,
			step: 1,
		},
		lmpop: {
			arity: -4,
			flags: ["write", "movablekeys"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		lolwut: {
			arity: -1,
			flags: ["readonly", "fast"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		lpop: {
			arity: -2,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		lpos: {
			arity: -3,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		lpush: {
			arity: -3,
			flags: ["write", "denyoom", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		lpushx: {
			arity: -3,
			flags: ["write", "denyoom", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		lrange: {
			arity: 4,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		lrem: {
			arity: 4,
			flags: ["write"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		lset: {
			arity: 4,
			flags: ["write", "denyoom"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		ltrim: {
			arity: 4,
			flags: ["write"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		memory: {
			arity: -2,
			flags: [],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		mget: {
			arity: -2,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: -1,
			step: 1,
		},
		migrate: {
			arity: -6,
			flags: ["write", "movablekeys"],
			keyStart: 3,
			keyStop: 3,
			step: 1,
		},
		module: {
			arity: -2,
			flags: [],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		monitor: {
			arity: 1,
			flags: ["admin", "noscript", "loading", "stale"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		move: {
			arity: 3,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		mset: {
			arity: -3,
			flags: ["write", "denyoom"],
			keyStart: 1,
			keyStop: -1,
			step: 2,
		},
		msetnx: {
			arity: -3,
			flags: ["write", "denyoom"],
			keyStart: 1,
			keyStop: -1,
			step: 2,
		},
		multi: {
			arity: 1,
			flags: ["noscript", "loading", "stale", "fast", "allow_busy"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		object: {
			arity: -2,
			flags: [],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		persist: {
			arity: 2,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		pexpire: {
			arity: -3,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		pexpireat: {
			arity: -3,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		pexpiretime: {
			arity: 2,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		pfadd: {
			arity: -2,
			flags: ["write", "denyoom", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		pfcount: {
			arity: -2,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: -1,
			step: 1,
		},
		pfdebug: {
			arity: 3,
			flags: ["write", "denyoom", "admin"],
			keyStart: 2,
			keyStop: 2,
			step: 1,
		},
		pfmerge: {
			arity: -2,
			flags: ["write", "denyoom"],
			keyStart: 1,
			keyStop: -1,
			step: 1,
		},
		pfselftest: {
			arity: 1,
			flags: ["admin"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		ping: {
			arity: -1,
			flags: ["fast"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		psetex: {
			arity: 4,
			flags: ["write", "denyoom"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		psubscribe: {
			arity: -2,
			flags: ["pubsub", "noscript", "loading", "stale"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		psync: {
			arity: -3,
			flags: ["admin", "noscript", "no_async_loading", "no_multi"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		pttl: {
			arity: 2,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		publish: {
			arity: 3,
			flags: ["pubsub", "loading", "stale", "fast"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		pubsub: {
			arity: -2,
			flags: [],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		punsubscribe: {
			arity: -1,
			flags: ["pubsub", "noscript", "loading", "stale"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		quit: {
			arity: -1,
			flags: ["noscript", "loading", "stale", "fast", "no_auth", "allow_busy"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		randomkey: {
			arity: 1,
			flags: ["readonly"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		readonly: {
			arity: 1,
			flags: ["loading", "stale", "fast"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		readwrite: {
			arity: 1,
			flags: ["loading", "stale", "fast"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		rename: {
			arity: 3,
			flags: ["write"],
			keyStart: 1,
			keyStop: 2,
			step: 1,
		},
		renamenx: {
			arity: 3,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 2,
			step: 1,
		},
		replconf: {
			arity: -1,
			flags: ["admin", "noscript", "loading", "stale", "allow_busy"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		replicaof: {
			arity: 3,
			flags: ["admin", "noscript", "stale", "no_async_loading"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		reset: {
			arity: 1,
			flags: ["noscript", "loading", "stale", "fast", "no_auth", "allow_busy"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		restore: {
			arity: -4,
			flags: ["write", "denyoom"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		"restore-asking": {
			arity: -4,
			flags: ["write", "denyoom", "asking"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		role: {
			arity: 1,
			flags: ["noscript", "loading", "stale", "fast"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		rpop: {
			arity: -2,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		rpoplpush: {
			arity: 3,
			flags: ["write", "denyoom"],
			keyStart: 1,
			keyStop: 2,
			step: 1,
		},
		rpush: {
			arity: -3,
			flags: ["write", "denyoom", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		rpushx: {
			arity: -3,
			flags: ["write", "denyoom", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		sadd: {
			arity: -3,
			flags: ["write", "denyoom", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		save: {
			arity: 1,
			flags: ["admin", "noscript", "no_async_loading", "no_multi"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		scan: {
			arity: -2,
			flags: ["readonly"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		scard: {
			arity: 2,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		script: {
			arity: -2,
			flags: [],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		sdiff: {
			arity: -2,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: -1,
			step: 1,
		},
		sdiffstore: {
			arity: -3,
			flags: ["write", "denyoom"],
			keyStart: 1,
			keyStop: -1,
			step: 1,
		},
		select: {
			arity: 2,
			flags: ["loading", "stale", "fast"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		set: {
			arity: -3,
			flags: ["write", "denyoom"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		setbit: {
			arity: 4,
			flags: ["write", "denyoom"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		setex: {
			arity: 4,
			flags: ["write", "denyoom"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		setnx: {
			arity: 3,
			flags: ["write", "denyoom", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		setrange: {
			arity: 4,
			flags: ["write", "denyoom"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		shutdown: {
			arity: -1,
			flags: ["admin", "noscript", "loading", "stale", "no_multi", "allow_busy"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		sinter: {
			arity: -2,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: -1,
			step: 1,
		},
		sintercard: {
			arity: -3,
			flags: ["readonly", "movablekeys"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		sinterstore: {
			arity: -3,
			flags: ["write", "denyoom"],
			keyStart: 1,
			keyStop: -1,
			step: 1,
		},
		sismember: {
			arity: 3,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		slaveof: {
			arity: 3,
			flags: ["admin", "noscript", "stale", "no_async_loading"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		slowlog: {
			arity: -2,
			flags: [],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		smembers: {
			arity: 2,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		smismember: {
			arity: -3,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		smove: {
			arity: 4,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 2,
			step: 1,
		},
		sort: {
			arity: -2,
			flags: ["write", "denyoom", "movablekeys"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		sort_ro: {
			arity: -2,
			flags: ["readonly", "movablekeys"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		spop: {
			arity: -2,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		spublish: {
			arity: 3,
			flags: ["pubsub", "loading", "stale", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		srandmember: {
			arity: -2,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		srem: {
			arity: -3,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		sscan: {
			arity: -3,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		ssubscribe: {
			arity: -2,
			flags: ["pubsub", "noscript", "loading", "stale"],
			keyStart: 1,
			keyStop: -1,
			step: 1,
		},
		strlen: {
			arity: 2,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		subscribe: {
			arity: -2,
			flags: ["pubsub", "noscript", "loading", "stale"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		substr: {
			arity: 4,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		sunion: {
			arity: -2,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: -1,
			step: 1,
		},
		sunionstore: {
			arity: -3,
			flags: ["write", "denyoom"],
			keyStart: 1,
			keyStop: -1,
			step: 1,
		},
		sunsubscribe: {
			arity: -1,
			flags: ["pubsub", "noscript", "loading", "stale"],
			keyStart: 1,
			keyStop: -1,
			step: 1,
		},
		swapdb: {
			arity: 3,
			flags: ["write", "fast"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		sync: {
			arity: 1,
			flags: ["admin", "noscript", "no_async_loading", "no_multi"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		time: {
			arity: 1,
			flags: ["loading", "stale", "fast"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		touch: {
			arity: -2,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: -1,
			step: 1,
		},
		ttl: {
			arity: 2,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		type: {
			arity: 2,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		unlink: {
			arity: -2,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: -1,
			step: 1,
		},
		unsubscribe: {
			arity: -1,
			flags: ["pubsub", "noscript", "loading", "stale"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		unwatch: {
			arity: 1,
			flags: ["noscript", "loading", "stale", "fast", "allow_busy"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		wait: {
			arity: 3,
			flags: ["noscript"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		watch: {
			arity: -2,
			flags: ["noscript", "loading", "stale", "fast", "allow_busy"],
			keyStart: 1,
			keyStop: -1,
			step: 1,
		},
		xack: {
			arity: -4,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		xadd: {
			arity: -5,
			flags: ["write", "denyoom", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		xautoclaim: {
			arity: -6,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		xclaim: {
			arity: -6,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		xdel: {
			arity: -3,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		xdelex: {
			arity: -5,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		xgroup: {
			arity: -2,
			flags: [],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		xinfo: {
			arity: -2,
			flags: [],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		xlen: {
			arity: 2,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		xpending: {
			arity: -3,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		xrange: {
			arity: -4,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		xread: {
			arity: -4,
			flags: ["readonly", "blocking", "movablekeys"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		xreadgroup: {
			arity: -7,
			flags: ["write", "blocking", "movablekeys"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		xrevrange: {
			arity: -4,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		xsetid: {
			arity: -3,
			flags: ["write", "denyoom", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		xtrim: {
			arity: -4,
			flags: ["write"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zadd: {
			arity: -4,
			flags: ["write", "denyoom", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zcard: {
			arity: 2,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zcount: {
			arity: 4,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zdiff: {
			arity: -3,
			flags: ["readonly", "movablekeys"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		zdiffstore: {
			arity: -4,
			flags: ["write", "denyoom", "movablekeys"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zincrby: {
			arity: 4,
			flags: ["write", "denyoom", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zinter: {
			arity: -3,
			flags: ["readonly", "movablekeys"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		zintercard: {
			arity: -3,
			flags: ["readonly", "movablekeys"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		zinterstore: {
			arity: -4,
			flags: ["write", "denyoom", "movablekeys"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zlexcount: {
			arity: 4,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zmpop: {
			arity: -4,
			flags: ["write", "movablekeys"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		zmscore: {
			arity: -3,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zpopmax: {
			arity: -2,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zpopmin: {
			arity: -2,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zrandmember: {
			arity: -2,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zrange: {
			arity: -4,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zrangebylex: {
			arity: -4,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zrangebyscore: {
			arity: -4,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zrangestore: {
			arity: -5,
			flags: ["write", "denyoom"],
			keyStart: 1,
			keyStop: 2,
			step: 1,
		},
		zrank: {
			arity: 3,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zrem: {
			arity: -3,
			flags: ["write", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zremrangebylex: {
			arity: 4,
			flags: ["write"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zremrangebyrank: {
			arity: 4,
			flags: ["write"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zremrangebyscore: {
			arity: 4,
			flags: ["write"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zrevrange: {
			arity: -4,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zrevrangebylex: {
			arity: -4,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zrevrangebyscore: {
			arity: -4,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zrevrank: {
			arity: 3,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zscan: {
			arity: -3,
			flags: ["readonly"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zscore: {
			arity: 3,
			flags: ["readonly", "fast"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
		zunion: {
			arity: -3,
			flags: ["readonly", "movablekeys"],
			keyStart: 0,
			keyStop: 0,
			step: 0,
		},
		zunionstore: {
			arity: -4,
			flags: ["write", "denyoom", "movablekeys"],
			keyStart: 1,
			keyStop: 1,
			step: 1,
		},
	};
});

// node_modules/@ioredis/commands/built/index.js
var require_built = __commonJS((exports) => {
	var __importDefault =
		(exports && exports.__importDefault) ||
		function (mod) {
			return mod && mod.__esModule ? mod : { default: mod };
		};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getKeyIndexes = exports.hasFlag = exports.exists = exports.list = undefined;
	var commands_json_1 = __importDefault(require_commands());
	exports.list = Object.keys(commands_json_1.default);
	var flags = {};
	exports.list.forEach((commandName) => {
		flags[commandName] = commands_json_1.default[commandName].flags.reduce(function (flags2, flag) {
			flags2[flag] = true;
			return flags2;
		}, {});
	});
	function exists(commandName) {
		return Boolean(commands_json_1.default[commandName]);
	}
	exports.exists = exists;
	function hasFlag(commandName, flag) {
		if (!flags[commandName]) {
			throw new Error("Unknown command " + commandName);
		}
		return Boolean(flags[commandName][flag]);
	}
	exports.hasFlag = hasFlag;
	function getKeyIndexes(commandName, args, options) {
		const command = commands_json_1.default[commandName];
		if (!command) {
			throw new Error("Unknown command " + commandName);
		}
		if (!Array.isArray(args)) {
			throw new Error("Expect args to be an array");
		}
		const keys = [];
		const parseExternalKey = Boolean(options && options.parseExternalKey);
		const takeDynamicKeys = (args2, startIndex) => {
			const keys2 = [];
			const keyStop = Number(args2[startIndex]);
			for (let i = 0; i < keyStop; i++) {
				keys2.push(i + startIndex + 1);
			}
			return keys2;
		};
		const takeKeyAfterToken = (args2, startIndex, token) => {
			for (let i = startIndex; i < args2.length - 1; i += 1) {
				if (String(args2[i]).toLowerCase() === token.toLowerCase()) {
					return i + 1;
				}
			}
			return null;
		};
		switch (commandName) {
			case "zunionstore":
			case "zinterstore":
			case "zdiffstore":
				keys.push(0, ...takeDynamicKeys(args, 1));
				break;
			case "eval":
			case "evalsha":
			case "eval_ro":
			case "evalsha_ro":
			case "fcall":
			case "fcall_ro":
			case "blmpop":
			case "bzmpop":
				keys.push(...takeDynamicKeys(args, 1));
				break;
			case "sintercard":
			case "lmpop":
			case "zunion":
			case "zinter":
			case "zmpop":
			case "zintercard":
			case "zdiff": {
				keys.push(...takeDynamicKeys(args, 0));
				break;
			}
			case "georadius": {
				keys.push(0);
				const storeKey = takeKeyAfterToken(args, 5, "STORE");
				if (storeKey) keys.push(storeKey);
				const distKey = takeKeyAfterToken(args, 5, "STOREDIST");
				if (distKey) keys.push(distKey);
				break;
			}
			case "georadiusbymember": {
				keys.push(0);
				const storeKey = takeKeyAfterToken(args, 4, "STORE");
				if (storeKey) keys.push(storeKey);
				const distKey = takeKeyAfterToken(args, 4, "STOREDIST");
				if (distKey) keys.push(distKey);
				break;
			}
			case "sort":
			case "sort_ro":
				keys.push(0);
				for (let i = 1; i < args.length - 1; i++) {
					let arg = args[i];
					if (typeof arg !== "string") {
						continue;
					}
					const directive = arg.toUpperCase();
					if (directive === "GET") {
						i += 1;
						arg = args[i];
						if (arg !== "#") {
							if (parseExternalKey) {
								keys.push([i, getExternalKeyNameLength(arg)]);
							} else {
								keys.push(i);
							}
						}
					} else if (directive === "BY") {
						i += 1;
						if (parseExternalKey) {
							keys.push([i, getExternalKeyNameLength(args[i])]);
						} else {
							keys.push(i);
						}
					} else if (directive === "STORE") {
						i += 1;
						keys.push(i);
					}
				}
				break;
			case "migrate":
				if (args[2] === "") {
					for (let i = 5; i < args.length - 1; i++) {
						const arg = args[i];
						if (typeof arg === "string" && arg.toUpperCase() === "KEYS") {
							for (let j = i + 1; j < args.length; j++) {
								keys.push(j);
							}
							break;
						}
					}
				} else {
					keys.push(2);
				}
				break;
			case "xreadgroup":
			case "xread":
				for (let i = commandName === "xread" ? 0 : 3; i < args.length - 1; i++) {
					if (String(args[i]).toUpperCase() === "STREAMS") {
						for (let j = i + 1; j <= i + (args.length - 1 - i) / 2; j++) {
							keys.push(j);
						}
						break;
					}
				}
				break;
			default:
				if (command.step > 0) {
					const keyStart = command.keyStart - 1;
					const keyStop = command.keyStop > 0 ? command.keyStop : args.length + command.keyStop + 1;
					for (let i = keyStart; i < keyStop; i += command.step) {
						keys.push(i);
					}
				}
				break;
		}
		return keys;
	}
	exports.getKeyIndexes = getKeyIndexes;
	function getExternalKeyNameLength(key) {
		if (typeof key !== "string") {
			key = String(key);
		}
		const hashPos = key.indexOf("->");
		return hashPos === -1 ? key.length : hashPos;
	}
});

// node_modules/standard-as-callback/built/utils.js
var require_utils = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.tryCatch = exports.errorObj = undefined;
	exports.errorObj = { e: {} };
	var tryCatchTarget;
	function tryCatcher(err, val) {
		try {
			const target = tryCatchTarget;
			tryCatchTarget = null;
			return target.apply(this, arguments);
		} catch (e) {
			exports.errorObj.e = e;
			return exports.errorObj;
		}
	}
	function tryCatch(fn) {
		tryCatchTarget = fn;
		return tryCatcher;
	}
	exports.tryCatch = tryCatch;
});

// node_modules/standard-as-callback/built/index.js
var require_built2 = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var utils_1 = require_utils();
	function throwLater(e) {
		setTimeout(function () {
			throw e;
		}, 0);
	}
	function asCallback(promise, nodeback, options) {
		if (typeof nodeback === "function") {
			promise.then(
				(val) => {
					let ret;
					if (options !== undefined && Object(options).spread && Array.isArray(val)) {
						ret = utils_1.tryCatch(nodeback).apply(undefined, [null].concat(val));
					} else {
						ret =
							val === undefined
								? utils_1.tryCatch(nodeback)(null)
								: utils_1.tryCatch(nodeback)(null, val);
					}
					if (ret === utils_1.errorObj) {
						throwLater(ret.e);
					}
				},
				(cause) => {
					if (!cause) {
						const newReason = new Error(cause + "");
						Object.assign(newReason, { cause });
						cause = newReason;
					}
					const ret = utils_1.tryCatch(nodeback)(cause);
					if (ret === utils_1.errorObj) {
						throwLater(ret.e);
					}
				},
			);
		}
		return promise;
	}
	exports.default = asCallback;
});

// node_modules/redis-errors/lib/old.js
var require_old = __commonJS((exports, module) => {
	var assert2 = __require("assert");
	var util5 = __require("util");
	function RedisError(message) {
		Object.defineProperty(this, "message", {
			value: message || "",
			configurable: true,
			writable: true,
		});
		Error.captureStackTrace(this, this.constructor);
	}
	util5.inherits(RedisError, Error);
	Object.defineProperty(RedisError.prototype, "name", {
		value: "RedisError",
		configurable: true,
		writable: true,
	});
	function ParserError(message, buffer, offset) {
		assert2(buffer);
		assert2.strictEqual(typeof offset, "number");
		Object.defineProperty(this, "message", {
			value: message || "",
			configurable: true,
			writable: true,
		});
		const tmp = Error.stackTraceLimit;
		Error.stackTraceLimit = 2;
		Error.captureStackTrace(this, this.constructor);
		Error.stackTraceLimit = tmp;
		this.offset = offset;
		this.buffer = buffer;
	}
	util5.inherits(ParserError, RedisError);
	Object.defineProperty(ParserError.prototype, "name", {
		value: "ParserError",
		configurable: true,
		writable: true,
	});
	function ReplyError(message) {
		Object.defineProperty(this, "message", {
			value: message || "",
			configurable: true,
			writable: true,
		});
		const tmp = Error.stackTraceLimit;
		Error.stackTraceLimit = 2;
		Error.captureStackTrace(this, this.constructor);
		Error.stackTraceLimit = tmp;
	}
	util5.inherits(ReplyError, RedisError);
	Object.defineProperty(ReplyError.prototype, "name", {
		value: "ReplyError",
		configurable: true,
		writable: true,
	});
	function AbortError2(message) {
		Object.defineProperty(this, "message", {
			value: message || "",
			configurable: true,
			writable: true,
		});
		Error.captureStackTrace(this, this.constructor);
	}
	util5.inherits(AbortError2, RedisError);
	Object.defineProperty(AbortError2.prototype, "name", {
		value: "AbortError",
		configurable: true,
		writable: true,
	});
	function InterruptError(message) {
		Object.defineProperty(this, "message", {
			value: message || "",
			configurable: true,
			writable: true,
		});
		Error.captureStackTrace(this, this.constructor);
	}
	util5.inherits(InterruptError, AbortError2);
	Object.defineProperty(InterruptError.prototype, "name", {
		value: "InterruptError",
		configurable: true,
		writable: true,
	});
	module.exports = {
		RedisError,
		ParserError,
		ReplyError,
		AbortError: AbortError2,
		InterruptError,
	};
});

// node_modules/redis-errors/lib/modern.js
var require_modern = __commonJS((exports, module) => {
	var assert2 = __require("assert");

	class RedisError extends Error {
		get name() {
			return this.constructor.name;
		}
	}

	class ParserError extends RedisError {
		constructor(message, buffer, offset) {
			assert2(buffer);
			assert2.strictEqual(typeof offset, "number");
			const tmp = Error.stackTraceLimit;
			Error.stackTraceLimit = 2;
			super(message);
			Error.stackTraceLimit = tmp;
			this.offset = offset;
			this.buffer = buffer;
		}
		get name() {
			return this.constructor.name;
		}
	}

	class ReplyError extends RedisError {
		constructor(message) {
			const tmp = Error.stackTraceLimit;
			Error.stackTraceLimit = 2;
			super(message);
			Error.stackTraceLimit = tmp;
		}
		get name() {
			return this.constructor.name;
		}
	}

	class AbortError2 extends RedisError {
		get name() {
			return this.constructor.name;
		}
	}

	class InterruptError extends AbortError2 {
		get name() {
			return this.constructor.name;
		}
	}
	module.exports = {
		RedisError,
		ParserError,
		ReplyError,
		AbortError: AbortError2,
		InterruptError,
	};
});

// node_modules/redis-errors/index.js
var require_redis_errors = __commonJS((exports, module) => {
	var Errors2 =
		process.version.charCodeAt(1) < 55 && process.version.charCodeAt(2) === 46
			? require_old()
			: require_modern();
	module.exports = Errors2;
});

// node_modules/cluster-key-slot/lib/index.js
var require_lib7 = __commonJS((exports, module) => {
	var lookup = [
		0, 4129, 8258, 12387, 16516, 20645, 24774, 28903, 33032, 37161, 41290, 45419, 49548, 53677,
		57806, 61935, 4657, 528, 12915, 8786, 21173, 17044, 29431, 25302, 37689, 33560, 45947, 41818,
		54205, 50076, 62463, 58334, 9314, 13379, 1056, 5121, 25830, 29895, 17572, 21637, 42346, 46411,
		34088, 38153, 58862, 62927, 50604, 54669, 13907, 9842, 5649, 1584, 30423, 26358, 22165, 18100,
		46939, 42874, 38681, 34616, 63455, 59390, 55197, 51132, 18628, 22757, 26758, 30887, 2112, 6241,
		10242, 14371, 51660, 55789, 59790, 63919, 35144, 39273, 43274, 47403, 23285, 19156, 31415,
		27286, 6769, 2640, 14899, 10770, 56317, 52188, 64447, 60318, 39801, 35672, 47931, 43802, 27814,
		31879, 19684, 23749, 11298, 15363, 3168, 7233, 60846, 64911, 52716, 56781, 44330, 48395, 36200,
		40265, 32407, 28342, 24277, 20212, 15891, 11826, 7761, 3696, 65439, 61374, 57309, 53244, 48923,
		44858, 40793, 36728, 37256, 33193, 45514, 41451, 53516, 49453, 61774, 57711, 4224, 161, 12482,
		8419, 20484, 16421, 28742, 24679, 33721, 37784, 41979, 46042, 49981, 54044, 58239, 62302, 689,
		4752, 8947, 13010, 16949, 21012, 25207, 29270, 46570, 42443, 38312, 34185, 62830, 58703, 54572,
		50445, 13538, 9411, 5280, 1153, 29798, 25671, 21540, 17413, 42971, 47098, 34713, 38840, 59231,
		63358, 50973, 55100, 9939, 14066, 1681, 5808, 26199, 30326, 17941, 22068, 55628, 51565, 63758,
		59695, 39368, 35305, 47498, 43435, 22596, 18533, 30726, 26663, 6336, 2273, 14466, 10403, 52093,
		56156, 60223, 64286, 35833, 39896, 43963, 48026, 19061, 23124, 27191, 31254, 2801, 6864, 10931,
		14994, 64814, 60687, 56684, 52557, 48554, 44427, 40424, 36297, 31782, 27655, 23652, 19525,
		15522, 11395, 7392, 3265, 61215, 65342, 53085, 57212, 44955, 49082, 36825, 40952, 28183, 32310,
		20053, 24180, 11923, 16050, 3793, 7920,
	];
	var toUTF8Array = function toUTF8Array(str) {
		var char;
		var i = 0;
		var p = 0;
		var utf8 = [];
		var len = str.length;
		for (; i < len; i++) {
			char = str.charCodeAt(i);
			if (char < 128) {
				utf8[p++] = char;
			} else if (char < 2048) {
				utf8[p++] = (char >> 6) | 192;
				utf8[p++] = (char & 63) | 128;
			} else if (
				(char & 64512) === 55296 &&
				i + 1 < str.length &&
				(str.charCodeAt(i + 1) & 64512) === 56320
			) {
				char = 65536 + ((char & 1023) << 10) + (str.charCodeAt(++i) & 1023);
				utf8[p++] = (char >> 18) | 240;
				utf8[p++] = ((char >> 12) & 63) | 128;
				utf8[p++] = ((char >> 6) & 63) | 128;
				utf8[p++] = (char & 63) | 128;
			} else {
				utf8[p++] = (char >> 12) | 224;
				utf8[p++] = ((char >> 6) & 63) | 128;
				utf8[p++] = (char & 63) | 128;
			}
		}
		return utf8;
	};
	var generate = (module.exports = function generate(str) {
		var char;
		var i = 0;
		var start = -1;
		var result = 0;
		var resultHash = 0;
		var utf8 = typeof str === "string" ? toUTF8Array(str) : str;
		var len = utf8.length;
		while (i < len) {
			char = utf8[i++];
			if (start === -1) {
				if (char === 123) {
					start = i;
				}
			} else if (char !== 125) {
				resultHash = lookup[(char ^ (resultHash >> 8)) & 255] ^ (resultHash << 8);
			} else if (i - 1 !== start) {
				return resultHash & 16383;
			}
			result = lookup[(char ^ (result >> 8)) & 255] ^ (result << 8);
		}
		return result & 16383;
	});
	module.exports.generateMulti = function generateMulti(keys) {
		var i = 1;
		var len = keys.length;
		var base = generate(keys[0]);
		while (i < len) {
			if (generate(keys[i++]) !== base) return -1;
		}
		return base;
	};
});

// node_modules/lodash.defaults/index.js
var require_lodash8 = __commonJS((exports, module) => {
	var MAX_SAFE_INTEGER = 9007199254740991;
	var argsTag = "[object Arguments]";
	var funcTag = "[object Function]";
	var genTag = "[object GeneratorFunction]";
	var reIsUint = /^(?:0|[1-9]\d*)$/;
	function apply(func, thisArg, args) {
		switch (args.length) {
			case 0:
				return func.call(thisArg);
			case 1:
				return func.call(thisArg, args[0]);
			case 2:
				return func.call(thisArg, args[0], args[1]);
			case 3:
				return func.call(thisArg, args[0], args[1], args[2]);
		}
		return func.apply(thisArg, args);
	}
	function baseTimes(n2, iteratee) {
		var index = -1,
			result = Array(n2);
		while (++index < n2) {
			result[index] = iteratee(index);
		}
		return result;
	}
	var objectProto = Object.prototype;
	var hasOwnProperty2 = objectProto.hasOwnProperty;
	var objectToString = objectProto.toString;
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;
	var nativeMax = Math.max;
	function arrayLikeKeys(value, inherited) {
		var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
		var length = result.length,
			skipIndexes = !!length;
		for (var key in value) {
			if (
				(inherited || hasOwnProperty2.call(value, key)) &&
				!(skipIndexes && (key == "length" || isIndex(key, length)))
			) {
				result.push(key);
			}
		}
		return result;
	}
	function assignInDefaults(objValue, srcValue, key, object) {
		if (
			objValue === undefined ||
			(eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key))
		) {
			return srcValue;
		}
		return objValue;
	}
	function assignValue(object, key, value) {
		var objValue = object[key];
		if (
			!(hasOwnProperty2.call(object, key) && eq(objValue, value)) ||
			(value === undefined && !(key in object))
		) {
			object[key] = value;
		}
	}
	function baseKeysIn(object) {
		if (!isObject3(object)) {
			return nativeKeysIn(object);
		}
		var isProto = isPrototype(object),
			result = [];
		for (var key in object) {
			if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
				result.push(key);
			}
		}
		return result;
	}
	function baseRest(func, start) {
		start = nativeMax(start === undefined ? func.length - 1 : start, 0);
		return function () {
			var args = arguments,
				index = -1,
				length = nativeMax(args.length - start, 0),
				array = Array(length);
			while (++index < length) {
				array[index] = args[start + index];
			}
			index = -1;
			var otherArgs = Array(start + 1);
			while (++index < start) {
				otherArgs[index] = args[index];
			}
			otherArgs[start] = array;
			return apply(func, this, otherArgs);
		};
	}
	function copyObject(source, props, object, customizer) {
		object || (object = {});
		var index = -1,
			length = props.length;
		while (++index < length) {
			var key = props[index];
			var newValue = customizer
				? customizer(object[key], source[key], key, object, source)
				: undefined;
			assignValue(object, key, newValue === undefined ? source[key] : newValue);
		}
		return object;
	}
	function createAssigner(assigner) {
		return baseRest(function (object, sources) {
			var index = -1,
				length = sources.length,
				customizer = length > 1 ? sources[length - 1] : undefined,
				guard2 = length > 2 ? sources[2] : undefined;
			customizer =
				assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined;
			if (guard2 && isIterateeCall(sources[0], sources[1], guard2)) {
				customizer = length < 3 ? undefined : customizer;
				length = 1;
			}
			object = Object(object);
			while (++index < length) {
				var source = sources[index];
				if (source) {
					assigner(object, source, index, customizer);
				}
			}
			return object;
		});
	}
	function isIndex(value, length) {
		length = length == null ? MAX_SAFE_INTEGER : length;
		return (
			!!length &&
			(typeof value == "number" || reIsUint.test(value)) &&
			value > -1 &&
			value % 1 == 0 &&
			value < length
		);
	}
	function isIterateeCall(value, index, object) {
		if (!isObject3(object)) {
			return false;
		}
		var type = typeof index;
		if (
			type == "number"
				? isArrayLike(object) && isIndex(index, object.length)
				: type == "string" && index in object
		) {
			return eq(object[index], value);
		}
		return false;
	}
	function isPrototype(value) {
		var Ctor = value && value.constructor,
			proto = (typeof Ctor == "function" && Ctor.prototype) || objectProto;
		return value === proto;
	}
	function nativeKeysIn(object) {
		var result = [];
		if (object != null) {
			for (var key in Object(object)) {
				result.push(key);
			}
		}
		return result;
	}
	function eq(value, other) {
		return value === other || (value !== value && other !== other);
	}
	function isArguments(value) {
		return (
			isArrayLikeObject(value) &&
			hasOwnProperty2.call(value, "callee") &&
			(!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag)
		);
	}
	var isArray2 = Array.isArray;
	function isArrayLike(value) {
		return value != null && isLength(value.length) && !isFunction3(value);
	}
	function isArrayLikeObject(value) {
		return isObjectLike(value) && isArrayLike(value);
	}
	function isFunction3(value) {
		var tag = isObject3(value) ? objectToString.call(value) : "";
		return tag == funcTag || tag == genTag;
	}
	function isLength(value) {
		return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	function isObject3(value) {
		var type = typeof value;
		return !!value && (type == "object" || type == "function");
	}
	function isObjectLike(value) {
		return !!value && typeof value == "object";
	}
	var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
		copyObject(source, keysIn(source), object, customizer);
	});
	var defaults2 = baseRest(function (args) {
		args.push(undefined, assignInDefaults);
		return apply(assignInWith, undefined, args);
	});
	function keysIn(object) {
		return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}
	module.exports = defaults2;
});

// node_modules/lodash.isarguments/index.js
var require_lodash9 = __commonJS((exports, module) => {
	var MAX_SAFE_INTEGER = 9007199254740991;
	var argsTag = "[object Arguments]";
	var funcTag = "[object Function]";
	var genTag = "[object GeneratorFunction]";
	var objectProto = Object.prototype;
	var hasOwnProperty2 = objectProto.hasOwnProperty;
	var objectToString = objectProto.toString;
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;
	function isArguments(value) {
		return (
			isArrayLikeObject(value) &&
			hasOwnProperty2.call(value, "callee") &&
			(!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag)
		);
	}
	function isArrayLike(value) {
		return value != null && isLength(value.length) && !isFunction3(value);
	}
	function isArrayLikeObject(value) {
		return isObjectLike(value) && isArrayLike(value);
	}
	function isFunction3(value) {
		var tag = isObject3(value) ? objectToString.call(value) : "";
		return tag == funcTag || tag == genTag;
	}
	function isLength(value) {
		return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	function isObject3(value) {
		var type = typeof value;
		return !!value && (type == "object" || type == "function");
	}
	function isObjectLike(value) {
		return !!value && typeof value == "object";
	}
	module.exports = isArguments;
});

// node_modules/ioredis/built/utils/lodash.js
var require_lodash10 = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isArguments = exports.defaults = exports.noop = undefined;
	var defaults2 = require_lodash8();
	exports.defaults = defaults2;
	var isArguments = require_lodash9();
	exports.isArguments = isArguments;
	function noop2() {}
	exports.noop = noop2;
});

// node_modules/ioredis/built/utils/debug.js
var require_debug3 = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.genRedactedString = exports.getStringValue = exports.MAX_ARGUMENT_LENGTH = undefined;
	var debug_1 = require_src();
	var MAX_ARGUMENT_LENGTH = 200;
	exports.MAX_ARGUMENT_LENGTH = MAX_ARGUMENT_LENGTH;
	var NAMESPACE_PREFIX = "ioredis";
	function getStringValue(v) {
		if (v === null) {
			return;
		}
		switch (typeof v) {
			case "boolean":
				return;
			case "number":
				return;
			case "object":
				if (Buffer.isBuffer(v)) {
					return v.toString("hex");
				}
				if (Array.isArray(v)) {
					return v.join(",");
				}
				try {
					return JSON.stringify(v);
				} catch (e) {
					return;
				}
			case "string":
				return v;
		}
	}
	exports.getStringValue = getStringValue;
	function genRedactedString(str, maxLen) {
		const { length } = str;
		return length <= maxLen
			? str
			: str.slice(0, maxLen) + ' ... <REDACTED full-length="' + length + '">';
	}
	exports.genRedactedString = genRedactedString;
	function genDebugFunction(namespace) {
		const fn = (0, debug_1.default)(`${NAMESPACE_PREFIX}:${namespace}`);
		function wrappedDebug(...args) {
			if (!fn.enabled) {
				return;
			}
			for (let i = 1; i < args.length; i++) {
				const str = getStringValue(args[i]);
				if (typeof str === "string" && str.length > MAX_ARGUMENT_LENGTH) {
					args[i] = genRedactedString(str, MAX_ARGUMENT_LENGTH);
				}
			}
			return fn.apply(null, args);
		}
		Object.defineProperties(wrappedDebug, {
			namespace: {
				get() {
					return fn.namespace;
				},
			},
			enabled: {
				get() {
					return fn.enabled;
				},
			},
			destroy: {
				get() {
					return fn.destroy;
				},
			},
			log: {
				get() {
					return fn.log;
				},
				set(l2) {
					fn.log = l2;
				},
			},
		});
		return wrappedDebug;
	}
	exports.default = genDebugFunction;
});

// node_modules/ioredis/built/constants/TLSProfiles.js
var require_TLSProfiles = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var RedisCloudCA = `-----BEGIN CERTIFICATE-----
MIIDTzCCAjegAwIBAgIJAKSVpiDswLcwMA0GCSqGSIb3DQEBBQUAMD4xFjAUBgNV
BAoMDUdhcmFudGlhIERhdGExJDAiBgNVBAMMG1NTTCBDZXJ0aWZpY2F0aW9uIEF1
dGhvcml0eTAeFw0xMzEwMDExMjE0NTVaFw0yMzA5MjkxMjE0NTVaMD4xFjAUBgNV
BAoMDUdhcmFudGlhIERhdGExJDAiBgNVBAMMG1NTTCBDZXJ0aWZpY2F0aW9uIEF1
dGhvcml0eTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALZqkh/DczWP
JnxnHLQ7QL0T4B4CDKWBKCcisriGbA6ZePWVNo4hfKQC6JrzfR+081NeD6VcWUiz
rmd+jtPhIY4c+WVQYm5PKaN6DT1imYdxQw7aqO5j2KUCEh/cznpLxeSHoTxlR34E
QwF28Wl3eg2vc5ct8LjU3eozWVk3gb7alx9mSA2SgmuX5lEQawl++rSjsBStemY2
BDwOpAMXIrdEyP/cVn8mkvi/BDs5M5G+09j0gfhyCzRWMQ7Hn71u1eolRxwVxgi3
TMn+/vTaFSqxKjgck6zuAYjBRPaHe7qLxHNr1So/Mc9nPy+3wHebFwbIcnUojwbp
4nctkWbjb2cCAwEAAaNQME4wHQYDVR0OBBYEFP1whtcrydmW3ZJeuSoKZIKjze3w
MB8GA1UdIwQYMBaAFP1whtcrydmW3ZJeuSoKZIKjze3wMAwGA1UdEwQFMAMBAf8w
DQYJKoZIhvcNAQEFBQADggEBAG2erXhwRAa7+ZOBs0B6X57Hwyd1R4kfmXcs0rta
lbPpvgULSiB+TCbf3EbhJnHGyvdCY1tvlffLjdA7HJ0PCOn+YYLBA0pTU/dyvrN6
Su8NuS5yubnt9mb13nDGYo1rnt0YRfxN+8DM3fXIVr038A30UlPX2Ou1ExFJT0MZ
uFKY6ZvLdI6/1cbgmguMlAhM+DhKyV6Sr5699LM3zqeI816pZmlREETYkGr91q7k
BpXJu/dtHaGxg1ZGu6w/PCsYGUcECWENYD4VQPd8N32JjOfu6vEgoEAwfPP+3oGp
Z4m3ewACcWOAenqflb+cQYC4PsF7qbXDmRaWrbKntOlZ3n0=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIGMTCCBBmgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwajELMAkGA1UEBhMCVVMx
CzAJBgNVBAgMAkNBMQswCQYDVQQHDAJDQTESMBAGA1UECgwJUmVkaXNMYWJzMS0w
KwYDVQQDDCRSZWRpc0xhYnMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwHhcN
MTgwMjI1MTUzNzM3WhcNMjgwMjIzMTUzNzM3WjBfMQswCQYDVQQGEwJVUzELMAkG
A1UECAwCQ0ExEjAQBgNVBAoMCVJlZGlzTGFiczEvMC0GA1UEAwwmUkNQIEludGVy
bWVkaWF0ZSBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUA
A4ICDwAwggIKAoICAQDf9dqbxc8Bq7Ctq9rWcxrGNKKHivqLAFpPq02yLPx6fsOv
Tq7GsDChAYBBc4v7Y2Ap9RD5Vs3dIhEANcnolf27QwrG9RMnnvzk8pCvp1o6zSU4
VuOE1W66/O1/7e2rVxyrnTcP7UgK43zNIXu7+tiAqWsO92uSnuMoGPGpeaUm1jym
hjWKtkAwDFSqvHY+XL5qDVBEjeUe+WHkYUg40cAXjusAqgm2hZt29c2wnVrxW25W
P0meNlzHGFdA2AC5z54iRiqj57dTfBTkHoBczQxcyw6hhzxZQ4e5I5zOKjXXEhZN
r0tA3YC14CTabKRus/JmZieyZzRgEy2oti64tmLYTqSlAD78pRL40VNoaSYetXLw
hhNsXCHgWaY6d5bLOc/aIQMAV5oLvZQKvuXAF1IDmhPA+bZbpWipp0zagf1P1H3s
UzsMdn2KM0ejzgotbtNlj5TcrVwpmvE3ktvUAuA+hi3FkVx1US+2Gsp5x4YOzJ7u
P1WPk6ShF0JgnJH2ILdj6kttTWwFzH17keSFICWDfH/+kM+k7Y1v3EXMQXE7y0T9
MjvJskz6d/nv+sQhY04xt64xFMGTnZjlJMzfQNi7zWFLTZnDD0lPowq7l3YiPoTT
t5Xky83lu0KZsZBo0WlWaDG00gLVdtRgVbcuSWxpi5BdLb1kRab66JptWjxwXQID
AQABo4HrMIHoMDoGA1UdHwQzMDEwL6AtoCuGKWh0dHBzOi8vcmwtY2Etc2VydmVy
LnJlZGlzbGFicy5jb20vdjEvY3JsMEYGCCsGAQUFBwEBBDowODA2BggrBgEFBQcw
AYYqaHR0cHM6Ly9ybC1jYS1zZXJ2ZXIucmVkaXNsYWJzLmNvbS92MS9vY3NwMB0G
A1UdDgQWBBQHar5OKvQUpP2qWt6mckzToeCOHDAfBgNVHSMEGDAWgBQi42wH6hM4
L2sujEvLM0/u8lRXTzASBgNVHRMBAf8ECDAGAQH/AgEAMA4GA1UdDwEB/wQEAwIB
hjANBgkqhkiG9w0BAQsFAAOCAgEAirEn/iTsAKyhd+pu2W3Z5NjCko4NPU0EYUbr
AP7+POK2rzjIrJO3nFYQ/LLuC7KCXG+2qwan2SAOGmqWst13Y+WHp44Kae0kaChW
vcYLXXSoGQGC8QuFSNUdaeg3RbMDYFT04dOkqufeWVccoHVxyTSg9eD8LZuHn5jw
7QDLiEECBmIJHk5Eeo2TAZrx4Yx6ufSUX5HeVjlAzqwtAqdt99uCJ/EL8bgpWbe+
XoSpvUv0SEC1I1dCAhCKAvRlIOA6VBcmzg5Am12KzkqTul12/VEFIgzqu0Zy2Jbc
AUPrYVu/+tOGXQaijy7YgwH8P8n3s7ZeUa1VABJHcxrxYduDDJBLZi+MjheUDaZ1
jQRHYevI2tlqeSBqdPKG4zBY5lS0GiAlmuze5oENt0P3XboHoZPHiqcK3VECgTVh
/BkJcuudETSJcZDmQ8YfoKfBzRQNg2sv/hwvUv73Ss51Sco8GEt2lD8uEdib1Q6z
zDT5lXJowSzOD5ZA9OGDjnSRL+2riNtKWKEqvtEG3VBJoBzu9GoxbAc7wIZLxmli
iF5a/Zf5X+UXD3s4TMmy6C4QZJpAA2egsSQCnraWO2ULhh7iXMysSkF/nzVfZn43
iqpaB8++9a37hWq14ZmOv0TJIDz//b2+KC4VFXWQ5W5QC6whsjT+OlG4p5ZYG0jo
616pxqo=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFujCCA6KgAwIBAgIJAJ1aTT1lu2ScMA0GCSqGSIb3DQEBCwUAMGoxCzAJBgNV
BAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCQ0ExEjAQBgNVBAoMCVJlZGlz
TGFiczEtMCsGA1UEAwwkUmVkaXNMYWJzIFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9y
aXR5MB4XDTE4MDIyNTE1MjA0MloXDTM4MDIyMDE1MjA0MlowajELMAkGA1UEBhMC
VVMxCzAJBgNVBAgMAkNBMQswCQYDVQQHDAJDQTESMBAGA1UECgwJUmVkaXNMYWJz
MS0wKwYDVQQDDCRSZWRpc0xhYnMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkw
ggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDLEjXy7YrbN5Waau5cd6g1
G5C2tMmeTpZ0duFAPxNU4oE3RHS5gGiok346fUXuUxbZ6QkuzeN2/2Z+RmRcJhQY
Dm0ZgdG4x59An1TJfnzKKoWj8ISmoHS/TGNBdFzXV7FYNLBuqZouqePI6ReC6Qhl
pp45huV32Q3a6IDrrvx7Wo5ZczEQeFNbCeCOQYNDdTmCyEkHqc2AGo8eoIlSTutT
ULOC7R5gzJVTS0e1hesQ7jmqHjbO+VQS1NAL4/5K6cuTEqUl+XhVhPdLWBXJQ5ag
54qhX4v+ojLzeU1R/Vc6NjMvVtptWY6JihpgplprN0Yh2556ewcXMeturcKgXfGJ
xeYzsjzXerEjrVocX5V8BNrg64NlifzTMKNOOv4fVZszq1SIHR8F9ROrqiOdh8iC
JpUbLpXH9hWCSEO6VRMB2xJoKu3cgl63kF30s77x7wLFMEHiwsQRKxooE1UhgS9K
2sO4TlQ1eWUvFvHSTVDQDlGQ6zu4qjbOpb3Q8bQwoK+ai2alkXVR4Ltxe9QlgYK3
StsnPhruzZGA0wbXdpw0bnM+YdlEm5ffSTpNIfgHeaa7Dtb801FtA71ZlH7A6TaI
SIQuUST9EKmv7xrJyx0W1pGoPOLw5T029aTjnICSLdtV9bLwysrLhIYG5bnPq78B
cS+jZHFGzD7PUVGQD01nOQIDAQABo2MwYTAdBgNVHQ4EFgQUIuNsB+oTOC9rLoxL
yzNP7vJUV08wHwYDVR0jBBgwFoAUIuNsB+oTOC9rLoxLyzNP7vJUV08wDwYDVR0T
AQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQADggIBAHfg
z5pMNUAKdMzK1aS1EDdK9yKz4qicILz5czSLj1mC7HKDRy8cVADUxEICis++CsCu
rYOvyCVergHQLREcxPq4rc5Nq1uj6J6649NEeh4WazOOjL4ZfQ1jVznMbGy+fJm3
3Hoelv6jWRG9iqeJZja7/1s6YC6bWymI/OY1e4wUKeNHAo+Vger7MlHV+RuabaX+
hSJ8bJAM59NCM7AgMTQpJCncrcdLeceYniGy5Q/qt2b5mJkQVkIdy4TPGGB+AXDJ
D0q3I/JDRkDUFNFdeW0js7fHdsvCR7O3tJy5zIgEV/o/BCkmJVtuwPYOrw/yOlKj
TY/U7ATAx9VFF6/vYEOMYSmrZlFX+98L6nJtwDqfLB5VTltqZ4H/KBxGE3IRSt9l
FXy40U+LnXzhhW+7VBAvyYX8GEXhHkKU8Gqk1xitrqfBXY74xKgyUSTolFSfFVgj
mcM/X4K45bka+qpkj7Kfv/8D4j6aZekwhN2ly6hhC1SmQ8qjMjpG/mrWOSSHZFmf
ybu9iD2AYHeIOkshIl6xYIa++Q/00/vs46IzAbQyriOi0XxlSMMVtPx0Q3isp+ji
n8Mq9eOuxYOEQ4of8twUkUDd528iwGtEdwf0Q01UyT84S62N8AySl1ZBKXJz6W4F
UhWfa/HQYOAPDdEjNgnVwLI23b8t0TozyCWw7q8h
-----END CERTIFICATE-----

-----BEGIN CERTIFICATE-----
MIIEjzCCA3egAwIBAgIQe55B/ALCKJDZtdNT8kD6hTANBgkqhkiG9w0BAQsFADBM
MSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEGA1UEChMKR2xv
YmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjAeFw0yMjAxMjYxMjAwMDBaFw0y
NTAxMjYwMDAwMDBaMFgxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWdu
IG52LXNhMS4wLAYDVQQDEyVHbG9iYWxTaWduIEF0bGFzIFIzIE9WIFRMUyBDQSAy
MDIyIFEyMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmGmg1LW9b7Lf
8zDD83yBDTEkt+FOxKJZqF4veWc5KZsQj9HfnUS2e5nj/E+JImlGPsQuoiosLuXD
BVBNAMcUFa11buFMGMeEMwiTmCXoXRrXQmH0qjpOfKgYc5gHG3BsRGaRrf7VR4eg
ofNMG9wUBw4/g/TT7+bQJdA4NfE7Y4d5gEryZiBGB/swaX6Jp/8MF4TgUmOWmalK
dZCKyb4sPGQFRTtElk67F7vU+wdGcrcOx1tDcIB0ncjLPMnaFicagl+daWGsKqTh
counQb6QJtYHa91KvCfKWocMxQ7OIbB5UARLPmC4CJ1/f8YFm35ebfzAeULYdGXu
jE9CLor0OwIDAQABo4IBXzCCAVswDgYDVR0PAQH/BAQDAgGGMB0GA1UdJQQWMBQG
CCsGAQUFBwMBBggrBgEFBQcDAjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQW
BBSH5Zq7a7B/t95GfJWkDBpA8HHqdjAfBgNVHSMEGDAWgBSP8Et/qC5FJK5NUPpj
move4t0bvDB7BggrBgEFBQcBAQRvMG0wLgYIKwYBBQUHMAGGImh0dHA6Ly9vY3Nw
Mi5nbG9iYWxzaWduLmNvbS9yb290cjMwOwYIKwYBBQUHMAKGL2h0dHA6Ly9zZWN1
cmUuZ2xvYmFsc2lnbi5jb20vY2FjZXJ0L3Jvb3QtcjMuY3J0MDYGA1UdHwQvMC0w
K6ApoCeGJWh0dHA6Ly9jcmwuZ2xvYmFsc2lnbi5jb20vcm9vdC1yMy5jcmwwIQYD
VR0gBBowGDAIBgZngQwBAgIwDAYKKwYBBAGgMgoBAjANBgkqhkiG9w0BAQsFAAOC
AQEAKRic9/f+nmhQU/wz04APZLjgG5OgsuUOyUEZjKVhNGDwxGTvKhyXGGAMW2B/
3bRi+aElpXwoxu3pL6fkElbX3B0BeS5LoDtxkyiVEBMZ8m+sXbocwlPyxrPbX6mY
0rVIvnuUeBH8X0L5IwfpNVvKnBIilTbcebfHyXkPezGwz7E1yhUULjJFm2bt0SdX
y+4X/WeiiYIv+fTVgZZgl+/2MKIsu/qdBJc3f3TvJ8nz+Eax1zgZmww+RSQWeOj3
15Iw6Z5FX+NwzY/Ab+9PosR5UosSeq+9HhtaxZttXG1nVh+avYPGYddWmiMT90J5
ZgKnO/Fx2hBgTxhOTMYaD312kg==
-----END CERTIFICATE-----

-----BEGIN CERTIFICATE-----
MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G
A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp
Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4
MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG
A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI
hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8
RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT
gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm
KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd
QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ
XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw
DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o
LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU
RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp
jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK
6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX
mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs
Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH
WD9f
-----END CERTIFICATE-----`;
	var TLSProfiles = {
		RedisCloudFixed: { ca: RedisCloudCA },
		RedisCloudFlexible: { ca: RedisCloudCA },
	};
	exports.default = TLSProfiles;
});

// node_modules/ioredis/built/utils/index.js
var require_utils2 = __commonJS((exports) => {
	var __dirname = "C:\\Users\\hosih\\elysia-ai\\node_modules\\ioredis\\built\\utils";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.noop =
		exports.defaults =
		exports.Debug =
		exports.getPackageMeta =
		exports.zipMap =
		exports.CONNECTION_CLOSED_ERROR_MSG =
		exports.shuffle =
		exports.sample =
		exports.resolveTLSProfile =
		exports.parseURL =
		exports.optimizeErrorStack =
		exports.toArg =
		exports.convertMapToArray =
		exports.convertObjectToArray =
		exports.timeout =
		exports.packObject =
		exports.isInt =
		exports.wrapMultiResult =
		exports.convertBufferToString =
			undefined;
	var fs_1 = __require("fs");
	var path_1 = __require("path");
	var url_1 = __require("url");
	var lodash_1 = require_lodash10();
	Object.defineProperty(exports, "defaults", {
		enumerable: true,
		get: function () {
			return lodash_1.defaults;
		},
	});
	Object.defineProperty(exports, "noop", {
		enumerable: true,
		get: function () {
			return lodash_1.noop;
		},
	});
	var debug_1 = require_debug3();
	exports.Debug = debug_1.default;
	var TLSProfiles_1 = require_TLSProfiles();
	function convertBufferToString(value, encoding) {
		if (value instanceof Buffer) {
			return value.toString(encoding);
		}
		if (Array.isArray(value)) {
			const length = value.length;
			const res = Array(length);
			for (let i = 0; i < length; ++i) {
				res[i] =
					value[i] instanceof Buffer && encoding === "utf8"
						? value[i].toString()
						: convertBufferToString(value[i], encoding);
			}
			return res;
		}
		return value;
	}
	exports.convertBufferToString = convertBufferToString;
	function wrapMultiResult(arr) {
		if (!arr) {
			return null;
		}
		const result = [];
		const length = arr.length;
		for (let i = 0; i < length; ++i) {
			const item = arr[i];
			if (item instanceof Error) {
				result.push([item]);
			} else {
				result.push([null, item]);
			}
		}
		return result;
	}
	exports.wrapMultiResult = wrapMultiResult;
	function isInt(value) {
		const x = parseFloat(value);
		return !isNaN(value) && (x | 0) === x;
	}
	exports.isInt = isInt;
	function packObject(array) {
		const result = {};
		const length = array.length;
		for (let i = 1; i < length; i += 2) {
			result[array[i - 1]] = array[i];
		}
		return result;
	}
	exports.packObject = packObject;
	function timeout(callback, timeout2) {
		let timer = null;
		const run = function () {
			if (timer) {
				clearTimeout(timer);
				timer = null;
				callback.apply(this, arguments);
			}
		};
		timer = setTimeout(run, timeout2, new Error("timeout"));
		return run;
	}
	exports.timeout = timeout;
	function convertObjectToArray(obj) {
		const result = [];
		const keys = Object.keys(obj);
		for (let i = 0, l2 = keys.length; i < l2; i++) {
			result.push(keys[i], obj[keys[i]]);
		}
		return result;
	}
	exports.convertObjectToArray = convertObjectToArray;
	function convertMapToArray(map3) {
		const result = [];
		let pos = 0;
		map3.forEach(function (value, key) {
			result[pos] = key;
			result[pos + 1] = value;
			pos += 2;
		});
		return result;
	}
	exports.convertMapToArray = convertMapToArray;
	function toArg(arg) {
		if (arg === null || typeof arg === "undefined") {
			return "";
		}
		return String(arg);
	}
	exports.toArg = toArg;
	function optimizeErrorStack(error, friendlyStack, filterPath) {
		const stacks = friendlyStack.split(`
`);
		let lines = "";
		let i;
		for (i = 1; i < stacks.length; ++i) {
			if (stacks[i].indexOf(filterPath) === -1) {
				break;
			}
		}
		for (let j = i; j < stacks.length; ++j) {
			lines +=
				`
` + stacks[j];
		}
		if (error.stack) {
			const pos = error.stack.indexOf(`
`);
			error.stack = error.stack.slice(0, pos) + lines;
		}
		return error;
	}
	exports.optimizeErrorStack = optimizeErrorStack;
	function parseURL(url2) {
		if (isInt(url2)) {
			return { port: url2 };
		}
		let parsed = (0, url_1.parse)(url2, true, true);
		if (!parsed.slashes && url2[0] !== "/") {
			url2 = "//" + url2;
			parsed = (0, url_1.parse)(url2, true, true);
		}
		const options = parsed.query || {};
		const result = {};
		if (parsed.auth) {
			const index = parsed.auth.indexOf(":");
			result.username = index === -1 ? parsed.auth : parsed.auth.slice(0, index);
			result.password = index === -1 ? "" : parsed.auth.slice(index + 1);
		}
		if (parsed.pathname) {
			if (parsed.protocol === "redis:" || parsed.protocol === "rediss:") {
				if (parsed.pathname.length > 1) {
					result.db = parsed.pathname.slice(1);
				}
			} else {
				result.path = parsed.pathname;
			}
		}
		if (parsed.host) {
			result.host = parsed.hostname;
		}
		if (parsed.port) {
			result.port = parsed.port;
		}
		if (typeof options.family === "string") {
			const intFamily = Number.parseInt(options.family, 10);
			if (!Number.isNaN(intFamily)) {
				result.family = intFamily;
			}
		}
		(0, lodash_1.defaults)(result, options);
		return result;
	}
	exports.parseURL = parseURL;
	function resolveTLSProfile(options) {
		let tls = options === null || options === undefined ? undefined : options.tls;
		if (typeof tls === "string") tls = { profile: tls };
		const profile =
			TLSProfiles_1.default[tls === null || tls === undefined ? undefined : tls.profile];
		if (profile) {
			tls = Object.assign({}, profile, tls);
			delete tls.profile;
			options = Object.assign({}, options, { tls });
		}
		return options;
	}
	exports.resolveTLSProfile = resolveTLSProfile;
	function sample(array, from = 0) {
		const length = array.length;
		if (from >= length) {
			return null;
		}
		return array[from + Math.floor(Math.random() * (length - from))];
	}
	exports.sample = sample;
	function shuffle(array) {
		let counter = array.length;
		while (counter > 0) {
			const index = Math.floor(Math.random() * counter);
			counter--;
			[array[counter], array[index]] = [array[index], array[counter]];
		}
		return array;
	}
	exports.shuffle = shuffle;
	exports.CONNECTION_CLOSED_ERROR_MSG = "Connection is closed.";
	function zipMap(keys, values) {
		const map3 = new Map();
		keys.forEach((key, index) => {
			map3.set(key, values[index]);
		});
		return map3;
	}
	exports.zipMap = zipMap;
	var cachedPackageMeta = null;
	async function getPackageMeta() {
		if (cachedPackageMeta) {
			return cachedPackageMeta;
		}
		try {
			const filePath = (0, path_1.resolve)(__dirname, "..", "..", "package.json");
			const data = await fs_1.promises.readFile(filePath, "utf8");
			const parsed = JSON.parse(data);
			cachedPackageMeta = {
				version: parsed.version,
			};
			return cachedPackageMeta;
		} catch (err) {
			cachedPackageMeta = {
				version: "error-fetching-version",
			};
			return cachedPackageMeta;
		}
	}
	exports.getPackageMeta = getPackageMeta;
});

// node_modules/ioredis/built/Command.js
var require_Command = __commonJS((exports) => {
	var __dirname = "C:\\Users\\hosih\\elysia-ai\\node_modules\\ioredis\\built";
	Object.defineProperty(exports, "__esModule", { value: true });
	var commands_1 = require_built();
	var calculateSlot = require_lib7();
	var standard_as_callback_1 = require_built2();
	var utils_1 = require_utils2();

	class Command {
		constructor(name, args = [], options = {}, callback) {
			this.name = name;
			this.inTransaction = false;
			this.isResolved = false;
			this.transformed = false;
			this.replyEncoding = options.replyEncoding;
			this.errorStack = options.errorStack;
			this.args = args.flat();
			this.callback = callback;
			this.initPromise();
			if (options.keyPrefix) {
				const isBufferKeyPrefix = options.keyPrefix instanceof Buffer;
				let keyPrefixBuffer = isBufferKeyPrefix ? options.keyPrefix : null;
				this._iterateKeys((key) => {
					if (key instanceof Buffer) {
						if (keyPrefixBuffer === null) {
							keyPrefixBuffer = Buffer.from(options.keyPrefix);
						}
						return Buffer.concat([keyPrefixBuffer, key]);
					} else if (isBufferKeyPrefix) {
						return Buffer.concat([options.keyPrefix, Buffer.from(String(key))]);
					}
					return options.keyPrefix + key;
				});
			}
			if (options.readOnly) {
				this.isReadOnly = true;
			}
		}
		static checkFlag(flagName, commandName) {
			return !!this.getFlagMap()[flagName][commandName];
		}
		static setArgumentTransformer(name, func) {
			this._transformer.argument[name] = func;
		}
		static setReplyTransformer(name, func) {
			this._transformer.reply[name] = func;
		}
		static getFlagMap() {
			if (!this.flagMap) {
				this.flagMap = Object.keys(Command.FLAGS).reduce((map3, flagName) => {
					map3[flagName] = {};
					Command.FLAGS[flagName].forEach((commandName) => {
						map3[flagName][commandName] = true;
					});
					return map3;
				}, {});
			}
			return this.flagMap;
		}
		getSlot() {
			if (typeof this.slot === "undefined") {
				const key = this.getKeys()[0];
				this.slot = key == null ? null : calculateSlot(key);
			}
			return this.slot;
		}
		getKeys() {
			return this._iterateKeys();
		}
		toWritable(_socket) {
			let result;
			const commandStr =
				"*" +
				(this.args.length + 1) +
				`\r
$` +
				Buffer.byteLength(this.name) +
				`\r
` +
				this.name +
				`\r
`;
			if (this.bufferMode) {
				const buffers = new MixedBuffers();
				buffers.push(commandStr);
				for (let i = 0; i < this.args.length; ++i) {
					const arg = this.args[i];
					if (arg instanceof Buffer) {
						if (arg.length === 0) {
							buffers.push(`$0\r
\r
`);
						} else {
							buffers.push(
								"$" +
									arg.length +
									`\r
`,
							);
							buffers.push(arg);
							buffers.push(`\r
`);
						}
					} else {
						buffers.push(
							"$" +
								Buffer.byteLength(arg) +
								`\r
` +
								arg +
								`\r
`,
						);
					}
				}
				result = buffers.toBuffer();
			} else {
				result = commandStr;
				for (let i = 0; i < this.args.length; ++i) {
					const arg = this.args[i];
					result +=
						"$" +
						Buffer.byteLength(arg) +
						`\r
` +
						arg +
						`\r
`;
				}
			}
			return result;
		}
		stringifyArguments() {
			for (let i = 0; i < this.args.length; ++i) {
				const arg = this.args[i];
				if (typeof arg === "string") {
				} else if (arg instanceof Buffer) {
					this.bufferMode = true;
				} else {
					this.args[i] = (0, utils_1.toArg)(arg);
				}
			}
		}
		transformReply(result) {
			if (this.replyEncoding) {
				result = (0, utils_1.convertBufferToString)(result, this.replyEncoding);
			}
			const transformer = Command._transformer.reply[this.name];
			if (transformer) {
				result = transformer(result);
			}
			return result;
		}
		setTimeout(ms) {
			if (!this._commandTimeoutTimer) {
				this._commandTimeoutTimer = setTimeout(() => {
					if (!this.isResolved) {
						this.reject(new Error("Command timed out"));
					}
				}, ms);
			}
		}
		initPromise() {
			const promise = new Promise((resolve, reject) => {
				if (!this.transformed) {
					this.transformed = true;
					const transformer = Command._transformer.argument[this.name];
					if (transformer) {
						this.args = transformer(this.args);
					}
					this.stringifyArguments();
				}
				this.resolve = this._convertValue(resolve);
				if (this.errorStack) {
					this.reject = (err) => {
						reject((0, utils_1.optimizeErrorStack)(err, this.errorStack.stack, __dirname));
					};
				} else {
					this.reject = reject;
				}
			});
			this.promise = (0, standard_as_callback_1.default)(promise, this.callback);
		}
		_iterateKeys(transform2 = (key) => key) {
			if (typeof this.keys === "undefined") {
				this.keys = [];
				if ((0, commands_1.exists)(this.name)) {
					const keyIndexes = (0, commands_1.getKeyIndexes)(this.name, this.args);
					for (const index of keyIndexes) {
						this.args[index] = transform2(this.args[index]);
						this.keys.push(this.args[index]);
					}
				}
			}
			return this.keys;
		}
		_convertValue(resolve) {
			return (value) => {
				try {
					const existingTimer = this._commandTimeoutTimer;
					if (existingTimer) {
						clearTimeout(existingTimer);
						delete this._commandTimeoutTimer;
					}
					resolve(this.transformReply(value));
					this.isResolved = true;
				} catch (err) {
					this.reject(err);
				}
				return this.promise;
			};
		}
	}
	exports.default = Command;
	Command.FLAGS = {
		VALID_IN_SUBSCRIBER_MODE: [
			"subscribe",
			"psubscribe",
			"unsubscribe",
			"punsubscribe",
			"ssubscribe",
			"sunsubscribe",
			"ping",
			"quit",
		],
		VALID_IN_MONITOR_MODE: ["monitor", "auth"],
		ENTER_SUBSCRIBER_MODE: ["subscribe", "psubscribe", "ssubscribe"],
		EXIT_SUBSCRIBER_MODE: ["unsubscribe", "punsubscribe", "sunsubscribe"],
		WILL_DISCONNECT: ["quit"],
		HANDSHAKE_COMMANDS: ["auth", "select", "client", "readonly", "info"],
		IGNORE_RECONNECT_ON_ERROR: ["client"],
	};
	Command._transformer = {
		argument: {},
		reply: {},
	};
	var msetArgumentTransformer = function (args) {
		if (args.length === 1) {
			if (args[0] instanceof Map) {
				return (0, utils_1.convertMapToArray)(args[0]);
			}
			if (typeof args[0] === "object" && args[0] !== null) {
				return (0, utils_1.convertObjectToArray)(args[0]);
			}
		}
		return args;
	};
	var hsetArgumentTransformer = function (args) {
		if (args.length === 2) {
			if (args[1] instanceof Map) {
				return [args[0]].concat((0, utils_1.convertMapToArray)(args[1]));
			}
			if (typeof args[1] === "object" && args[1] !== null) {
				return [args[0]].concat((0, utils_1.convertObjectToArray)(args[1]));
			}
		}
		return args;
	};
	Command.setArgumentTransformer("mset", msetArgumentTransformer);
	Command.setArgumentTransformer("msetnx", msetArgumentTransformer);
	Command.setArgumentTransformer("hset", hsetArgumentTransformer);
	Command.setArgumentTransformer("hmset", hsetArgumentTransformer);
	Command.setReplyTransformer("hgetall", function (result) {
		if (Array.isArray(result)) {
			const obj = {};
			for (let i = 0; i < result.length; i += 2) {
				const key = result[i];
				const value = result[i + 1];
				if (key in obj) {
					Object.defineProperty(obj, key, {
						value,
						configurable: true,
						enumerable: true,
						writable: true,
					});
				} else {
					obj[key] = value;
				}
			}
			return obj;
		}
		return result;
	});

	class MixedBuffers {
		constructor() {
			this.length = 0;
			this.items = [];
		}
		push(x) {
			this.length += Buffer.byteLength(x);
			this.items.push(x);
		}
		toBuffer() {
			const result = Buffer.allocUnsafe(this.length);
			let offset = 0;
			for (const item of this.items) {
				const length = Buffer.byteLength(item);
				Buffer.isBuffer(item) ? item.copy(result, offset) : result.write(item, offset, length);
				offset += length;
			}
			return result;
		}
	}
});

// node_modules/ioredis/built/errors/ClusterAllFailedError.js
var require_ClusterAllFailedError = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var redis_errors_1 = require_redis_errors();

	class ClusterAllFailedError extends redis_errors_1.RedisError {
		constructor(message, lastNodeError) {
			super(message);
			this.lastNodeError = lastNodeError;
			Error.captureStackTrace(this, this.constructor);
		}
		get name() {
			return this.constructor.name;
		}
	}
	exports.default = ClusterAllFailedError;
	ClusterAllFailedError.defaultMessage = "Failed to refresh slots cache.";
});

// node_modules/ioredis/built/ScanStream.js
var require_ScanStream = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var stream_1 = __require("stream");

	class ScanStream extends stream_1.Readable {
		constructor(opt) {
			super(opt);
			this.opt = opt;
			this._redisCursor = "0";
			this._redisDrained = false;
		}
		_read() {
			if (this._redisDrained) {
				this.push(null);
				return;
			}
			const args = [this._redisCursor];
			if (this.opt.key) {
				args.unshift(this.opt.key);
			}
			if (this.opt.match) {
				args.push("MATCH", this.opt.match);
			}
			if (this.opt.type) {
				args.push("TYPE", this.opt.type);
			}
			if (this.opt.count) {
				args.push("COUNT", String(this.opt.count));
			}
			if (this.opt.noValues) {
				args.push("NOVALUES");
			}
			this.opt.redis[this.opt.command](args, (err, res) => {
				if (err) {
					this.emit("error", err);
					return;
				}
				this._redisCursor = res[0] instanceof Buffer ? res[0].toString() : res[0];
				if (this._redisCursor === "0") {
					this._redisDrained = true;
				}
				this.push(res[1]);
			});
		}
		close() {
			this._redisDrained = true;
		}
	}
	exports.default = ScanStream;
});

// node_modules/ioredis/built/autoPipelining.js
var require_autoPipelining = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.executeWithAutoPipelining =
		exports.getFirstValueInFlattenedArray =
		exports.shouldUseAutoPipelining =
		exports.notAllowedAutoPipelineCommands =
		exports.kCallbacks =
		exports.kExec =
			undefined;
	var lodash_1 = require_lodash10();
	var calculateSlot = require_lib7();
	var standard_as_callback_1 = require_built2();
	exports.kExec = Symbol("exec");
	exports.kCallbacks = Symbol("callbacks");
	exports.notAllowedAutoPipelineCommands = [
		"auth",
		"info",
		"script",
		"quit",
		"cluster",
		"pipeline",
		"multi",
		"subscribe",
		"psubscribe",
		"unsubscribe",
		"unpsubscribe",
		"select",
		"client",
	];
	function executeAutoPipeline(client, slotKey) {
		if (client._runningAutoPipelines.has(slotKey)) {
			return;
		}
		if (!client._autoPipelines.has(slotKey)) {
			return;
		}
		client._runningAutoPipelines.add(slotKey);
		const pipeline2 = client._autoPipelines.get(slotKey);
		client._autoPipelines.delete(slotKey);
		const callbacks = pipeline2[exports.kCallbacks];
		pipeline2[exports.kCallbacks] = null;
		pipeline2.exec(function (err, results) {
			client._runningAutoPipelines.delete(slotKey);
			if (err) {
				for (let i = 0; i < callbacks.length; i++) {
					process.nextTick(callbacks[i], err);
				}
			} else {
				for (let i = 0; i < callbacks.length; i++) {
					process.nextTick(callbacks[i], ...results[i]);
				}
			}
			if (client._autoPipelines.has(slotKey)) {
				executeAutoPipeline(client, slotKey);
			}
		});
	}
	function shouldUseAutoPipelining(client, functionName, commandName) {
		return (
			functionName &&
			client.options.enableAutoPipelining &&
			!client.isPipeline &&
			!exports.notAllowedAutoPipelineCommands.includes(commandName) &&
			!client.options.autoPipeliningIgnoredCommands.includes(commandName)
		);
	}
	exports.shouldUseAutoPipelining = shouldUseAutoPipelining;
	function getFirstValueInFlattenedArray(args) {
		for (let i = 0; i < args.length; i++) {
			const arg = args[i];
			if (typeof arg === "string") {
				return arg;
			} else if (Array.isArray(arg) || (0, lodash_1.isArguments)(arg)) {
				if (arg.length === 0) {
					continue;
				}
				return arg[0];
			}
			const flattened = [arg].flat();
			if (flattened.length > 0) {
				return flattened[0];
			}
		}
		return;
	}
	exports.getFirstValueInFlattenedArray = getFirstValueInFlattenedArray;
	function executeWithAutoPipelining(client, functionName, commandName, args, callback) {
		if (client.isCluster && !client.slots.length) {
			if (client.status === "wait") client.connect().catch(lodash_1.noop);
			return (0, standard_as_callback_1.default)(
				new Promise(function (resolve, reject) {
					client.delayUntilReady((err) => {
						if (err) {
							reject(err);
							return;
						}
						executeWithAutoPipelining(client, functionName, commandName, args, null).then(
							resolve,
							reject,
						);
					});
				}),
				callback,
			);
		}
		const prefix = client.options.keyPrefix || "";
		const slotKey = client.isCluster
			? client.slots[calculateSlot(`${prefix}${getFirstValueInFlattenedArray(args)}`)].join(",")
			: "main";
		if (!client._autoPipelines.has(slotKey)) {
			const pipeline3 = client.pipeline();
			pipeline3[exports.kExec] = false;
			pipeline3[exports.kCallbacks] = [];
			client._autoPipelines.set(slotKey, pipeline3);
		}
		const pipeline2 = client._autoPipelines.get(slotKey);
		if (!pipeline2[exports.kExec]) {
			pipeline2[exports.kExec] = true;
			setImmediate(executeAutoPipeline, client, slotKey);
		}
		const autoPipelinePromise = new Promise(function (resolve, reject) {
			pipeline2[exports.kCallbacks].push(function (err, value) {
				if (err) {
					reject(err);
					return;
				}
				resolve(value);
			});
			if (functionName === "call") {
				args.unshift(commandName);
			}
			pipeline2[functionName](...args);
		});
		return (0, standard_as_callback_1.default)(autoPipelinePromise, callback);
	}
	exports.executeWithAutoPipelining = executeWithAutoPipelining;
});

// node_modules/ioredis/built/Script.js
var require_Script = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var crypto_1 = __require("crypto");
	var Command_1 = require_Command();
	var standard_as_callback_1 = require_built2();

	class Script {
		constructor(lua, numberOfKeys = null, keyPrefix = "", readOnly = false) {
			this.lua = lua;
			this.numberOfKeys = numberOfKeys;
			this.keyPrefix = keyPrefix;
			this.readOnly = readOnly;
			this.sha = (0, crypto_1.createHash)("sha1").update(lua).digest("hex");
			const sha = this.sha;
			const socketHasScriptLoaded = new WeakSet();
			this.Command = class CustomScriptCommand extends Command_1.default {
				toWritable(socket) {
					const origReject = this.reject;
					this.reject = (err) => {
						if (err.message.indexOf("NOSCRIPT") !== -1) {
							socketHasScriptLoaded.delete(socket);
						}
						origReject.call(this, err);
					};
					if (!socketHasScriptLoaded.has(socket)) {
						socketHasScriptLoaded.add(socket);
						this.name = "eval";
						this.args[0] = lua;
					} else if (this.name === "eval") {
						this.name = "evalsha";
						this.args[0] = sha;
					}
					return super.toWritable(socket);
				}
			};
		}
		execute(container, args, options, callback) {
			if (typeof this.numberOfKeys === "number") {
				args.unshift(this.numberOfKeys);
			}
			if (this.keyPrefix) {
				options.keyPrefix = this.keyPrefix;
			}
			if (this.readOnly) {
				options.readOnly = true;
			}
			const evalsha = new this.Command("evalsha", [this.sha, ...args], options);
			evalsha.promise = evalsha.promise.catch((err) => {
				if (err.message.indexOf("NOSCRIPT") === -1) {
					throw err;
				}
				const resend = new this.Command("evalsha", [this.sha, ...args], options);
				const client = container.isPipeline ? container.redis : container;
				return client.sendCommand(resend);
			});
			(0, standard_as_callback_1.default)(evalsha.promise, callback);
			return container.sendCommand(evalsha);
		}
	}
	exports.default = Script;
});

// node_modules/ioredis/built/utils/Commander.js
var require_Commander = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var commands_1 = require_built();
	var autoPipelining_1 = require_autoPipelining();
	var Command_1 = require_Command();
	var Script_1 = require_Script();

	class Commander {
		constructor() {
			this.options = {};
			this.scriptsSet = {};
			this.addedBuiltinSet = new Set();
		}
		getBuiltinCommands() {
			return commands.slice(0);
		}
		createBuiltinCommand(commandName) {
			return {
				string: generateFunction(null, commandName, "utf8"),
				buffer: generateFunction(null, commandName, null),
			};
		}
		addBuiltinCommand(commandName) {
			this.addedBuiltinSet.add(commandName);
			this[commandName] = generateFunction(commandName, commandName, "utf8");
			this[commandName + "Buffer"] = generateFunction(commandName + "Buffer", commandName, null);
		}
		defineCommand(name, definition) {
			const script = new Script_1.default(
				definition.lua,
				definition.numberOfKeys,
				this.options.keyPrefix,
				definition.readOnly,
			);
			this.scriptsSet[name] = script;
			this[name] = generateScriptingFunction(name, name, script, "utf8");
			this[name + "Buffer"] = generateScriptingFunction(name + "Buffer", name, script, null);
		}
		sendCommand(command, stream4, node) {
			throw new Error('"sendCommand" is not implemented');
		}
	}
	var commands = commands_1.list.filter((command) => command !== "monitor");
	commands.push("sentinel");
	commands.forEach(function (commandName) {
		Commander.prototype[commandName] = generateFunction(commandName, commandName, "utf8");
		Commander.prototype[commandName + "Buffer"] = generateFunction(
			commandName + "Buffer",
			commandName,
			null,
		);
	});
	Commander.prototype.call = generateFunction("call", "utf8");
	Commander.prototype.callBuffer = generateFunction("callBuffer", null);
	Commander.prototype.send_command = Commander.prototype.call;
	function generateFunction(functionName, _commandName, _encoding) {
		if (typeof _encoding === "undefined") {
			_encoding = _commandName;
			_commandName = null;
		}
		return function (...args) {
			const commandName = _commandName || args.shift();
			let callback = args[args.length - 1];
			if (typeof callback === "function") {
				args.pop();
			} else {
				callback = undefined;
			}
			const options = {
				errorStack: this.options.showFriendlyErrorStack ? new Error() : undefined,
				keyPrefix: this.options.keyPrefix,
				replyEncoding: _encoding,
			};
			if (!(0, autoPipelining_1.shouldUseAutoPipelining)(this, functionName, commandName)) {
				return this.sendCommand(new Command_1.default(commandName, args, options, callback));
			}
			return (0, autoPipelining_1.executeWithAutoPipelining)(
				this,
				functionName,
				commandName,
				args,
				callback,
			);
		};
	}
	function generateScriptingFunction(functionName, commandName, script, encoding) {
		return function (...args) {
			const callback = typeof args[args.length - 1] === "function" ? args.pop() : undefined;
			const options = {
				replyEncoding: encoding,
			};
			if (this.options.showFriendlyErrorStack) {
				options.errorStack = new Error();
			}
			if (!(0, autoPipelining_1.shouldUseAutoPipelining)(this, functionName, commandName)) {
				return script.execute(this, args, options, callback);
			}
			return (0, autoPipelining_1.executeWithAutoPipelining)(
				this,
				functionName,
				commandName,
				args,
				callback,
			);
		};
	}
	exports.default = Commander;
});

// node_modules/ioredis/built/Pipeline.js
var require_Pipeline = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var calculateSlot = require_lib7();
	var commands_1 = require_built();
	var standard_as_callback_1 = require_built2();
	var util_1 = __require("util");
	var Command_1 = require_Command();
	var utils_1 = require_utils2();
	var Commander_1 = require_Commander();
	function generateMultiWithNodes(redis, keys) {
		const slot = calculateSlot(keys[0]);
		const target = redis._groupsBySlot[slot];
		for (let i = 1; i < keys.length; i++) {
			if (redis._groupsBySlot[calculateSlot(keys[i])] !== target) {
				return -1;
			}
		}
		return slot;
	}

	class Pipeline extends Commander_1.default {
		constructor(redis) {
			super();
			this.redis = redis;
			this.isPipeline = true;
			this.replyPending = 0;
			this._queue = [];
			this._result = [];
			this._transactions = 0;
			this._shaToScript = {};
			this.isCluster = this.redis.constructor.name === "Cluster" || this.redis.isCluster;
			this.options = redis.options;
			Object.keys(redis.scriptsSet).forEach((name) => {
				const script = redis.scriptsSet[name];
				this._shaToScript[script.sha] = script;
				this[name] = redis[name];
				this[name + "Buffer"] = redis[name + "Buffer"];
			});
			redis.addedBuiltinSet.forEach((name) => {
				this[name] = redis[name];
				this[name + "Buffer"] = redis[name + "Buffer"];
			});
			this.promise = new Promise((resolve, reject) => {
				this.resolve = resolve;
				this.reject = reject;
			});
			const _this = this;
			Object.defineProperty(this, "length", {
				get: function () {
					return _this._queue.length;
				},
			});
		}
		fillResult(value, position) {
			if (this._queue[position].name === "exec" && Array.isArray(value[1])) {
				const execLength = value[1].length;
				for (let i = 0; i < execLength; i++) {
					if (value[1][i] instanceof Error) {
						continue;
					}
					const cmd = this._queue[position - (execLength - i)];
					try {
						value[1][i] = cmd.transformReply(value[1][i]);
					} catch (err) {
						value[1][i] = err;
					}
				}
			}
			this._result[position] = value;
			if (--this.replyPending) {
				return;
			}
			if (this.isCluster) {
				let retriable = true;
				let commonError;
				for (let i = 0; i < this._result.length; ++i) {
					const error = this._result[i][0];
					const command = this._queue[i];
					if (error) {
						if (
							command.name === "exec" &&
							error.message === "EXECABORT Transaction discarded because of previous errors."
						) {
							continue;
						}
						if (!commonError) {
							commonError = {
								name: error.name,
								message: error.message,
							};
						} else if (commonError.name !== error.name || commonError.message !== error.message) {
							retriable = false;
							break;
						}
					} else if (!command.inTransaction) {
						const isReadOnly =
							(0, commands_1.exists)(command.name) &&
							(0, commands_1.hasFlag)(command.name, "readonly");
						if (!isReadOnly) {
							retriable = false;
							break;
						}
					}
				}
				if (commonError && retriable) {
					const _this = this;
					const errv = commonError.message.split(" ");
					const queue = this._queue;
					let inTransaction = false;
					this._queue = [];
					for (let i = 0; i < queue.length; ++i) {
						if (
							errv[0] === "ASK" &&
							!inTransaction &&
							queue[i].name !== "asking" &&
							(!queue[i - 1] || queue[i - 1].name !== "asking")
						) {
							const asking = new Command_1.default("asking");
							asking.ignore = true;
							this.sendCommand(asking);
						}
						queue[i].initPromise();
						this.sendCommand(queue[i]);
						inTransaction = queue[i].inTransaction;
					}
					let matched = true;
					if (typeof this.leftRedirections === "undefined") {
						this.leftRedirections = {};
					}
					const exec = function () {
						_this.exec();
					};
					const cluster = this.redis;
					cluster.handleError(commonError, this.leftRedirections, {
						moved: function (_slot, key) {
							_this.preferKey = key;
							cluster.slots[errv[1]] = [key];
							cluster._groupsBySlot[errv[1]] = cluster._groupsIds[cluster.slots[errv[1]].join(";")];
							cluster.refreshSlotsCache();
							_this.exec();
						},
						ask: function (_slot, key) {
							_this.preferKey = key;
							_this.exec();
						},
						tryagain: exec,
						clusterDown: exec,
						connectionClosed: exec,
						maxRedirections: () => {
							matched = false;
						},
						defaults: () => {
							matched = false;
						},
					});
					if (matched) {
						return;
					}
				}
			}
			let ignoredCount = 0;
			for (let i = 0; i < this._queue.length - ignoredCount; ++i) {
				if (this._queue[i + ignoredCount].ignore) {
					ignoredCount += 1;
				}
				this._result[i] = this._result[i + ignoredCount];
			}
			this.resolve(this._result.slice(0, this._result.length - ignoredCount));
		}
		sendCommand(command) {
			if (this._transactions > 0) {
				command.inTransaction = true;
			}
			const position = this._queue.length;
			command.pipelineIndex = position;
			command.promise
				.then((result) => {
					this.fillResult([null, result], position);
				})
				.catch((error) => {
					this.fillResult([error], position);
				});
			this._queue.push(command);
			return this;
		}
		addBatch(commands) {
			let command, commandName, args;
			for (let i = 0; i < commands.length; ++i) {
				command = commands[i];
				commandName = command[0];
				args = command.slice(1);
				this[commandName].apply(this, args);
			}
			return this;
		}
	}
	exports.default = Pipeline;
	var multi = Pipeline.prototype.multi;
	Pipeline.prototype.multi = function () {
		this._transactions += 1;
		return multi.apply(this, arguments);
	};
	var execBuffer = Pipeline.prototype.execBuffer;
	Pipeline.prototype.execBuffer = (0, util_1.deprecate)(function () {
		if (this._transactions > 0) {
			this._transactions -= 1;
		}
		return execBuffer.apply(this, arguments);
	}, "Pipeline#execBuffer: Use Pipeline#exec instead");
	Pipeline.prototype.exec = function (callback) {
		if (this.isCluster && !this.redis.slots.length) {
			if (this.redis.status === "wait") this.redis.connect().catch(utils_1.noop);
			if (callback && !this.nodeifiedPromise) {
				this.nodeifiedPromise = true;
				(0, standard_as_callback_1.default)(this.promise, callback);
			}
			this.redis.delayUntilReady((err) => {
				if (err) {
					this.reject(err);
					return;
				}
				this.exec(callback);
			});
			return this.promise;
		}
		if (this._transactions > 0) {
			this._transactions -= 1;
			return execBuffer.apply(this, arguments);
		}
		if (!this.nodeifiedPromise) {
			this.nodeifiedPromise = true;
			(0, standard_as_callback_1.default)(this.promise, callback);
		}
		if (!this._queue.length) {
			this.resolve([]);
		}
		let pipelineSlot;
		if (this.isCluster) {
			const sampleKeys = [];
			for (let i = 0; i < this._queue.length; i++) {
				const keys = this._queue[i].getKeys();
				if (keys.length) {
					sampleKeys.push(keys[0]);
				}
				if (keys.length && calculateSlot.generateMulti(keys) < 0) {
					this.reject(
						new Error("All the keys in a pipeline command should belong to the same slot"),
					);
					return this.promise;
				}
			}
			if (sampleKeys.length) {
				pipelineSlot = generateMultiWithNodes(this.redis, sampleKeys);
				if (pipelineSlot < 0) {
					this.reject(
						new Error("All keys in the pipeline should belong to the same slots allocation group"),
					);
					return this.promise;
				}
			} else {
				pipelineSlot = (Math.random() * 16384) | 0;
			}
		}
		const _this = this;
		execPipeline();
		return this.promise;
		function execPipeline() {
			let writePending = (_this.replyPending = _this._queue.length);
			let node;
			if (_this.isCluster) {
				node = {
					slot: pipelineSlot,
					redis: _this.redis.connectionPool.nodes.all[_this.preferKey],
				};
			}
			let data = "";
			let buffers;
			const stream4 = {
				isPipeline: true,
				destination: _this.isCluster ? node : { redis: _this.redis },
				write(writable) {
					if (typeof writable !== "string") {
						if (!buffers) {
							buffers = [];
						}
						if (data) {
							buffers.push(Buffer.from(data, "utf8"));
							data = "";
						}
						buffers.push(writable);
					} else {
						data += writable;
					}
					if (!--writePending) {
						if (buffers) {
							if (data) {
								buffers.push(Buffer.from(data, "utf8"));
							}
							stream4.destination.redis.stream.write(Buffer.concat(buffers));
						} else {
							stream4.destination.redis.stream.write(data);
						}
						writePending = _this._queue.length;
						data = "";
						buffers = undefined;
					}
				},
			};
			for (let i = 0; i < _this._queue.length; ++i) {
				_this.redis.sendCommand(_this._queue[i], stream4, node);
			}
			return _this.promise;
		}
	};
});

// node_modules/ioredis/built/transaction.js
var require_transaction = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.addTransactionSupport = undefined;
	var utils_1 = require_utils2();
	var standard_as_callback_1 = require_built2();
	var Pipeline_1 = require_Pipeline();
	function addTransactionSupport(redis) {
		redis.pipeline = function (commands) {
			const pipeline2 = new Pipeline_1.default(this);
			if (Array.isArray(commands)) {
				pipeline2.addBatch(commands);
			}
			return pipeline2;
		};
		const { multi } = redis;
		redis.multi = function (commands, options) {
			if (typeof options === "undefined" && !Array.isArray(commands)) {
				options = commands;
				commands = null;
			}
			if (options && options.pipeline === false) {
				return multi.call(this);
			}
			const pipeline2 = new Pipeline_1.default(this);
			pipeline2.multi();
			if (Array.isArray(commands)) {
				pipeline2.addBatch(commands);
			}
			const exec2 = pipeline2.exec;
			pipeline2.exec = function (callback) {
				if (this.isCluster && !this.redis.slots.length) {
					if (this.redis.status === "wait") this.redis.connect().catch(utils_1.noop);
					return (0, standard_as_callback_1.default)(
						new Promise((resolve, reject) => {
							this.redis.delayUntilReady((err) => {
								if (err) {
									reject(err);
									return;
								}
								this.exec(pipeline2).then(resolve, reject);
							});
						}),
						callback,
					);
				}
				if (this._transactions > 0) {
					exec2.call(pipeline2);
				}
				if (this.nodeifiedPromise) {
					return exec2.call(pipeline2);
				}
				const promise = exec2.call(pipeline2);
				return (0, standard_as_callback_1.default)(
					promise.then(function (result) {
						const execResult = result[result.length - 1];
						if (typeof execResult === "undefined") {
							throw new Error(
								"Pipeline cannot be used to send any commands when the `exec()` has been called on it.",
							);
						}
						if (execResult[0]) {
							execResult[0].previousErrors = [];
							for (let i = 0; i < result.length - 1; ++i) {
								if (result[i][0]) {
									execResult[0].previousErrors.push(result[i][0]);
								}
							}
							throw execResult[0];
						}
						return (0, utils_1.wrapMultiResult)(execResult[1]);
					}),
					callback,
				);
			};
			const { execBuffer } = pipeline2;
			pipeline2.execBuffer = function (callback) {
				if (this._transactions > 0) {
					execBuffer.call(pipeline2);
				}
				return pipeline2.exec(callback);
			};
			return pipeline2;
		};
		const { exec } = redis;
		redis.exec = function (callback) {
			return (0, standard_as_callback_1.default)(
				exec.call(this).then(function (results) {
					if (Array.isArray(results)) {
						results = (0, utils_1.wrapMultiResult)(results);
					}
					return results;
				}),
				callback,
			);
		};
	}
	exports.addTransactionSupport = addTransactionSupport;
});

// node_modules/ioredis/built/utils/applyMixin.js
var require_applyMixin = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function applyMixin(derivedConstructor, mixinConstructor) {
		Object.getOwnPropertyNames(mixinConstructor.prototype).forEach((name) => {
			Object.defineProperty(
				derivedConstructor.prototype,
				name,
				Object.getOwnPropertyDescriptor(mixinConstructor.prototype, name),
			);
		});
	}
	exports.default = applyMixin;
});

// node_modules/ioredis/built/cluster/ClusterOptions.js
var require_ClusterOptions = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DEFAULT_CLUSTER_OPTIONS = undefined;
	var dns_1 = __require("dns");
	exports.DEFAULT_CLUSTER_OPTIONS = {
		clusterRetryStrategy: (times) => Math.min(100 + times * 2, 2000),
		enableOfflineQueue: true,
		enableReadyCheck: true,
		scaleReads: "master",
		maxRedirections: 16,
		retryDelayOnMoved: 0,
		retryDelayOnFailover: 100,
		retryDelayOnClusterDown: 100,
		retryDelayOnTryAgain: 100,
		slotsRefreshTimeout: 1000,
		useSRVRecords: false,
		resolveSrv: dns_1.resolveSrv,
		dnsLookup: dns_1.lookup,
		enableAutoPipelining: false,
		autoPipeliningIgnoredCommands: [],
		shardedSubscribers: false,
	};
});

// node_modules/ioredis/built/cluster/util.js
var require_util2 = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getConnectionName =
		exports.weightSrvRecords =
		exports.groupSrvRecords =
		exports.getUniqueHostnamesFromOptions =
		exports.normalizeNodeOptions =
		exports.nodeKeyToRedisOptions =
		exports.getNodeKey =
			undefined;
	var utils_1 = require_utils2();
	var net_1 = __require("net");
	function getNodeKey(node) {
		node.port = node.port || 6379;
		node.host = node.host || "127.0.0.1";
		return node.host + ":" + node.port;
	}
	exports.getNodeKey = getNodeKey;
	function nodeKeyToRedisOptions(nodeKey) {
		const portIndex = nodeKey.lastIndexOf(":");
		if (portIndex === -1) {
			throw new Error(`Invalid node key ${nodeKey}`);
		}
		return {
			host: nodeKey.slice(0, portIndex),
			port: Number(nodeKey.slice(portIndex + 1)),
		};
	}
	exports.nodeKeyToRedisOptions = nodeKeyToRedisOptions;
	function normalizeNodeOptions(nodes) {
		return nodes.map((node) => {
			const options = {};
			if (typeof node === "object") {
				Object.assign(options, node);
			} else if (typeof node === "string") {
				Object.assign(options, (0, utils_1.parseURL)(node));
			} else if (typeof node === "number") {
				options.port = node;
			} else {
				throw new Error("Invalid argument " + node);
			}
			if (typeof options.port === "string") {
				options.port = parseInt(options.port, 10);
			}
			delete options.db;
			if (!options.port) {
				options.port = 6379;
			}
			if (!options.host) {
				options.host = "127.0.0.1";
			}
			return (0, utils_1.resolveTLSProfile)(options);
		});
	}
	exports.normalizeNodeOptions = normalizeNodeOptions;
	function getUniqueHostnamesFromOptions(nodes) {
		const uniqueHostsMap = {};
		nodes.forEach((node) => {
			uniqueHostsMap[node.host] = true;
		});
		return Object.keys(uniqueHostsMap).filter((host) => !(0, net_1.isIP)(host));
	}
	exports.getUniqueHostnamesFromOptions = getUniqueHostnamesFromOptions;
	function groupSrvRecords(records) {
		const recordsByPriority = {};
		for (const record of records) {
			if (!recordsByPriority.hasOwnProperty(record.priority)) {
				recordsByPriority[record.priority] = {
					totalWeight: record.weight,
					records: [record],
				};
			} else {
				recordsByPriority[record.priority].totalWeight += record.weight;
				recordsByPriority[record.priority].records.push(record);
			}
		}
		return recordsByPriority;
	}
	exports.groupSrvRecords = groupSrvRecords;
	function weightSrvRecords(recordsGroup) {
		if (recordsGroup.records.length === 1) {
			recordsGroup.totalWeight = 0;
			return recordsGroup.records.shift();
		}
		const random = Math.floor(
			Math.random() * (recordsGroup.totalWeight + recordsGroup.records.length),
		);
		let total = 0;
		for (const [i, record] of recordsGroup.records.entries()) {
			total += 1 + record.weight;
			if (total > random) {
				recordsGroup.totalWeight -= record.weight;
				recordsGroup.records.splice(i, 1);
				return record;
			}
		}
	}
	exports.weightSrvRecords = weightSrvRecords;
	function getConnectionName(component, nodeConnectionName) {
		const prefix = `ioredis-cluster(${component})`;
		return nodeConnectionName ? `${prefix}:${nodeConnectionName}` : prefix;
	}
	exports.getConnectionName = getConnectionName;
});

// node_modules/ioredis/built/cluster/ClusterSubscriber.js
var require_ClusterSubscriber = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var util_1 = require_util2();
	var utils_1 = require_utils2();
	var Redis_1 = require_Redis();
	var debug2 = (0, utils_1.Debug)("cluster:subscriber");

	class ClusterSubscriber {
		constructor(connectionPool, emitter, isSharded = false) {
			this.connectionPool = connectionPool;
			this.emitter = emitter;
			this.isSharded = isSharded;
			this.started = false;
			this.subscriber = null;
			this.slotRange = [];
			this.onSubscriberEnd = () => {
				if (!this.started) {
					debug2(
						"subscriber has disconnected, but ClusterSubscriber is not started, so not reconnecting.",
					);
					return;
				}
				debug2("subscriber has disconnected, selecting a new one...");
				this.selectSubscriber();
			};
			this.connectionPool.on("-node", (_2, key) => {
				if (!this.started || !this.subscriber) {
					return;
				}
				if ((0, util_1.getNodeKey)(this.subscriber.options) === key) {
					debug2("subscriber has left, selecting a new one...");
					this.selectSubscriber();
				}
			});
			this.connectionPool.on("+node", () => {
				if (!this.started || this.subscriber) {
					return;
				}
				debug2("a new node is discovered and there is no subscriber, selecting a new one...");
				this.selectSubscriber();
			});
		}
		getInstance() {
			return this.subscriber;
		}
		associateSlotRange(range) {
			if (this.isSharded) {
				this.slotRange = range;
			}
			return this.slotRange;
		}
		start() {
			this.started = true;
			this.selectSubscriber();
			debug2("started");
		}
		stop() {
			this.started = false;
			if (this.subscriber) {
				this.subscriber.disconnect();
				this.subscriber = null;
			}
		}
		isStarted() {
			return this.started;
		}
		selectSubscriber() {
			const lastActiveSubscriber = this.lastActiveSubscriber;
			if (lastActiveSubscriber) {
				lastActiveSubscriber.off("end", this.onSubscriberEnd);
				lastActiveSubscriber.disconnect();
			}
			if (this.subscriber) {
				this.subscriber.off("end", this.onSubscriberEnd);
				this.subscriber.disconnect();
			}
			const sampleNode = (0, utils_1.sample)(this.connectionPool.getNodes());
			if (!sampleNode) {
				debug2("selecting subscriber failed since there is no node discovered in the cluster yet");
				this.subscriber = null;
				return;
			}
			const { options } = sampleNode;
			debug2("selected a subscriber %s:%s", options.host, options.port);
			let connectionPrefix = "subscriber";
			if (this.isSharded) connectionPrefix = "ssubscriber";
			this.subscriber = new Redis_1.default({
				port: options.port,
				host: options.host,
				username: options.username,
				password: options.password,
				enableReadyCheck: true,
				connectionName: (0, util_1.getConnectionName)(connectionPrefix, options.connectionName),
				lazyConnect: true,
				tls: options.tls,
				retryStrategy: null,
			});
			this.subscriber.on("error", utils_1.noop);
			this.subscriber.on("moved", () => {
				this.emitter.emit("forceRefresh");
			});
			this.subscriber.once("end", this.onSubscriberEnd);
			const previousChannels = { subscribe: [], psubscribe: [], ssubscribe: [] };
			if (lastActiveSubscriber) {
				const condition = lastActiveSubscriber.condition || lastActiveSubscriber.prevCondition;
				if (condition && condition.subscriber) {
					previousChannels.subscribe = condition.subscriber.channels("subscribe");
					previousChannels.psubscribe = condition.subscriber.channels("psubscribe");
					previousChannels.ssubscribe = condition.subscriber.channels("ssubscribe");
				}
			}
			if (
				previousChannels.subscribe.length ||
				previousChannels.psubscribe.length ||
				previousChannels.ssubscribe.length
			) {
				let pending = 0;
				for (const type of ["subscribe", "psubscribe", "ssubscribe"]) {
					const channels = previousChannels[type];
					if (channels.length == 0) {
						continue;
					}
					debug2("%s %d channels", type, channels.length);
					if (type === "ssubscribe") {
						for (const channel of channels) {
							pending += 1;
							this.subscriber[type](channel)
								.then(() => {
									if (!--pending) {
										this.lastActiveSubscriber = this.subscriber;
									}
								})
								.catch(() => {
									debug2("failed to ssubscribe to channel: %s", channel);
								});
						}
					} else {
						pending += 1;
						this.subscriber[type](channels)
							.then(() => {
								if (!--pending) {
									this.lastActiveSubscriber = this.subscriber;
								}
							})
							.catch(() => {
								debug2("failed to %s %d channels", type, channels.length);
							});
					}
				}
			} else {
				this.lastActiveSubscriber = this.subscriber;
			}
			for (const event of ["message", "messageBuffer"]) {
				this.subscriber.on(event, (arg1, arg2) => {
					this.emitter.emit(event, arg1, arg2);
				});
			}
			for (const event of ["pmessage", "pmessageBuffer"]) {
				this.subscriber.on(event, (arg1, arg2, arg3) => {
					this.emitter.emit(event, arg1, arg2, arg3);
				});
			}
			if (this.isSharded == true) {
				for (const event of ["smessage", "smessageBuffer"]) {
					this.subscriber.on(event, (arg1, arg2) => {
						this.emitter.emit(event, arg1, arg2);
					});
				}
			}
		}
	}
	exports.default = ClusterSubscriber;
});

// node_modules/ioredis/built/cluster/ConnectionPool.js
var require_ConnectionPool = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var events_1 = __require("events");
	var utils_1 = require_utils2();
	var util_1 = require_util2();
	var Redis_1 = require_Redis();
	var debug2 = (0, utils_1.Debug)("cluster:connectionPool");

	class ConnectionPool extends events_1.EventEmitter {
		constructor(redisOptions) {
			super();
			this.redisOptions = redisOptions;
			this.nodes = {
				all: {},
				master: {},
				slave: {},
			};
			this.specifiedOptions = {};
		}
		getNodes(role = "all") {
			const nodes = this.nodes[role];
			return Object.keys(nodes).map((key) => nodes[key]);
		}
		getInstanceByKey(key) {
			return this.nodes.all[key];
		}
		getSampleInstance(role) {
			const keys = Object.keys(this.nodes[role]);
			const sampleKey = (0, utils_1.sample)(keys);
			return this.nodes[role][sampleKey];
		}
		addMasterNode(node) {
			const key = (0, util_1.getNodeKey)(node.options);
			const redis = this.createRedisFromOptions(node, node.options.readOnly);
			if (!node.options.readOnly) {
				this.nodes.all[key] = redis;
				this.nodes.master[key] = redis;
				return true;
			}
			return false;
		}
		createRedisFromOptions(node, readOnly) {
			const redis = new Redis_1.default(
				(0, utils_1.defaults)(
					{
						retryStrategy: null,
						enableOfflineQueue: true,
						readOnly,
					},
					node,
					this.redisOptions,
					{ lazyConnect: true },
				),
			);
			return redis;
		}
		findOrCreate(node, readOnly = false) {
			const key = (0, util_1.getNodeKey)(node);
			readOnly = Boolean(readOnly);
			if (this.specifiedOptions[key]) {
				Object.assign(node, this.specifiedOptions[key]);
			} else {
				this.specifiedOptions[key] = node;
			}
			let redis;
			if (this.nodes.all[key]) {
				redis = this.nodes.all[key];
				if (redis.options.readOnly !== readOnly) {
					redis.options.readOnly = readOnly;
					debug2("Change role of %s to %s", key, readOnly ? "slave" : "master");
					redis[readOnly ? "readonly" : "readwrite"]().catch(utils_1.noop);
					if (readOnly) {
						delete this.nodes.master[key];
						this.nodes.slave[key] = redis;
					} else {
						delete this.nodes.slave[key];
						this.nodes.master[key] = redis;
					}
				}
			} else {
				debug2("Connecting to %s as %s", key, readOnly ? "slave" : "master");
				redis = this.createRedisFromOptions(node, readOnly);
				this.nodes.all[key] = redis;
				this.nodes[readOnly ? "slave" : "master"][key] = redis;
				redis.once("end", () => {
					this.removeNode(key);
					this.emit("-node", redis, key);
					if (!Object.keys(this.nodes.all).length) {
						this.emit("drain");
					}
				});
				this.emit("+node", redis, key);
				redis.on("error", function (error) {
					this.emit("nodeError", error, key);
				});
			}
			return redis;
		}
		reset(nodes) {
			debug2("Reset with %O", nodes);
			const newNodes = {};
			nodes.forEach((node) => {
				const key = (0, util_1.getNodeKey)(node);
				if (!(node.readOnly && newNodes[key])) {
					newNodes[key] = node;
				}
			});
			Object.keys(this.nodes.all).forEach((key) => {
				if (!newNodes[key]) {
					debug2("Disconnect %s because the node does not hold any slot", key);
					this.nodes.all[key].disconnect();
					this.removeNode(key);
				}
			});
			Object.keys(newNodes).forEach((key) => {
				const node = newNodes[key];
				this.findOrCreate(node, node.readOnly);
			});
		}
		removeNode(key) {
			const { nodes } = this;
			if (nodes.all[key]) {
				debug2("Remove %s from the pool", key);
				delete nodes.all[key];
			}
			delete nodes.master[key];
			delete nodes.slave[key];
		}
	}
	exports.default = ConnectionPool;
});

// node_modules/denque/index.js
var require_denque = __commonJS((exports, module) => {
	function Denque(array, options) {
		var options = options || {};
		this._capacity = options.capacity;
		this._head = 0;
		this._tail = 0;
		if (Array.isArray(array)) {
			this._fromArray(array);
		} else {
			this._capacityMask = 3;
			this._list = new Array(4);
		}
	}
	Denque.prototype.peekAt = function peekAt(index) {
		var i = index;
		if (i !== (i | 0)) {
			return;
		}
		var len = this.size();
		if (i >= len || i < -len) return;
		if (i < 0) i += len;
		i = (this._head + i) & this._capacityMask;
		return this._list[i];
	};
	Denque.prototype.get = function get(i) {
		return this.peekAt(i);
	};
	Denque.prototype.peek = function peek() {
		if (this._head === this._tail) return;
		return this._list[this._head];
	};
	Denque.prototype.peekFront = function peekFront() {
		return this.peek();
	};
	Denque.prototype.peekBack = function peekBack() {
		return this.peekAt(-1);
	};
	Object.defineProperty(Denque.prototype, "length", {
		get: function length() {
			return this.size();
		},
	});
	Denque.prototype.size = function size() {
		if (this._head === this._tail) return 0;
		if (this._head < this._tail) return this._tail - this._head;
		else return this._capacityMask + 1 - (this._head - this._tail);
	};
	Denque.prototype.unshift = function unshift(item) {
		if (arguments.length === 0) return this.size();
		var len = this._list.length;
		this._head = (this._head - 1 + len) & this._capacityMask;
		this._list[this._head] = item;
		if (this._tail === this._head) this._growArray();
		if (this._capacity && this.size() > this._capacity) this.pop();
		if (this._head < this._tail) return this._tail - this._head;
		else return this._capacityMask + 1 - (this._head - this._tail);
	};
	Denque.prototype.shift = function shift() {
		var head = this._head;
		if (head === this._tail) return;
		var item = this._list[head];
		this._list[head] = undefined;
		this._head = (head + 1) & this._capacityMask;
		if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2) this._shrinkArray();
		return item;
	};
	Denque.prototype.push = function push(item) {
		if (arguments.length === 0) return this.size();
		var tail = this._tail;
		this._list[tail] = item;
		this._tail = (tail + 1) & this._capacityMask;
		if (this._tail === this._head) {
			this._growArray();
		}
		if (this._capacity && this.size() > this._capacity) {
			this.shift();
		}
		if (this._head < this._tail) return this._tail - this._head;
		else return this._capacityMask + 1 - (this._head - this._tail);
	};
	Denque.prototype.pop = function pop() {
		var tail = this._tail;
		if (tail === this._head) return;
		var len = this._list.length;
		this._tail = (tail - 1 + len) & this._capacityMask;
		var item = this._list[this._tail];
		this._list[this._tail] = undefined;
		if (this._head < 2 && tail > 1e4 && tail <= len >>> 2) this._shrinkArray();
		return item;
	};
	Denque.prototype.removeOne = function removeOne(index) {
		var i = index;
		if (i !== (i | 0)) {
			return;
		}
		if (this._head === this._tail) return;
		var size = this.size();
		var len = this._list.length;
		if (i >= size || i < -size) return;
		if (i < 0) i += size;
		i = (this._head + i) & this._capacityMask;
		var item = this._list[i];
		var k2;
		if (index < size / 2) {
			for (k2 = index; k2 > 0; k2--) {
				this._list[i] = this._list[(i = (i - 1 + len) & this._capacityMask)];
			}
			this._list[i] = undefined;
			this._head = (this._head + 1 + len) & this._capacityMask;
		} else {
			for (k2 = size - 1 - index; k2 > 0; k2--) {
				this._list[i] = this._list[(i = (i + 1 + len) & this._capacityMask)];
			}
			this._list[i] = undefined;
			this._tail = (this._tail - 1 + len) & this._capacityMask;
		}
		return item;
	};
	Denque.prototype.remove = function remove(index, count) {
		var i = index;
		var removed;
		var del_count = count;
		if (i !== (i | 0)) {
			return;
		}
		if (this._head === this._tail) return;
		var size = this.size();
		var len = this._list.length;
		if (i >= size || i < -size || count < 1) return;
		if (i < 0) i += size;
		if (count === 1 || !count) {
			removed = new Array(1);
			removed[0] = this.removeOne(i);
			return removed;
		}
		if (i === 0 && i + count >= size) {
			removed = this.toArray();
			this.clear();
			return removed;
		}
		if (i + count > size) count = size - i;
		var k2;
		removed = new Array(count);
		for (k2 = 0; k2 < count; k2++) {
			removed[k2] = this._list[(this._head + i + k2) & this._capacityMask];
		}
		i = (this._head + i) & this._capacityMask;
		if (index + count === size) {
			this._tail = (this._tail - count + len) & this._capacityMask;
			for (k2 = count; k2 > 0; k2--) {
				this._list[(i = (i + 1 + len) & this._capacityMask)] = undefined;
			}
			return removed;
		}
		if (index === 0) {
			this._head = (this._head + count + len) & this._capacityMask;
			for (k2 = count - 1; k2 > 0; k2--) {
				this._list[(i = (i + 1 + len) & this._capacityMask)] = undefined;
			}
			return removed;
		}
		if (i < size / 2) {
			this._head = (this._head + index + count + len) & this._capacityMask;
			for (k2 = index; k2 > 0; k2--) {
				this.unshift(this._list[(i = (i - 1 + len) & this._capacityMask)]);
			}
			i = (this._head - 1 + len) & this._capacityMask;
			while (del_count > 0) {
				this._list[(i = (i - 1 + len) & this._capacityMask)] = undefined;
				del_count--;
			}
			if (index < 0) this._tail = i;
		} else {
			this._tail = i;
			i = (i + count + len) & this._capacityMask;
			for (k2 = size - (count + index); k2 > 0; k2--) {
				this.push(this._list[i++]);
			}
			i = this._tail;
			while (del_count > 0) {
				this._list[(i = (i + 1 + len) & this._capacityMask)] = undefined;
				del_count--;
			}
		}
		if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2) this._shrinkArray();
		return removed;
	};
	Denque.prototype.splice = function splice(index, count) {
		var i = index;
		if (i !== (i | 0)) {
			return;
		}
		var size = this.size();
		if (i < 0) i += size;
		if (i > size) return;
		if (arguments.length > 2) {
			var k2;
			var temp;
			var removed;
			var arg_len = arguments.length;
			var len = this._list.length;
			var arguments_index = 2;
			if (!size || i < size / 2) {
				temp = new Array(i);
				for (k2 = 0; k2 < i; k2++) {
					temp[k2] = this._list[(this._head + k2) & this._capacityMask];
				}
				if (count === 0) {
					removed = [];
					if (i > 0) {
						this._head = (this._head + i + len) & this._capacityMask;
					}
				} else {
					removed = this.remove(i, count);
					this._head = (this._head + i + len) & this._capacityMask;
				}
				while (arg_len > arguments_index) {
					this.unshift(arguments[--arg_len]);
				}
				for (k2 = i; k2 > 0; k2--) {
					this.unshift(temp[k2 - 1]);
				}
			} else {
				temp = new Array(size - (i + count));
				var leng = temp.length;
				for (k2 = 0; k2 < leng; k2++) {
					temp[k2] = this._list[(this._head + i + count + k2) & this._capacityMask];
				}
				if (count === 0) {
					removed = [];
					if (i != size) {
						this._tail = (this._head + i + len) & this._capacityMask;
					}
				} else {
					removed = this.remove(i, count);
					this._tail = (this._tail - leng + len) & this._capacityMask;
				}
				while (arguments_index < arg_len) {
					this.push(arguments[arguments_index++]);
				}
				for (k2 = 0; k2 < leng; k2++) {
					this.push(temp[k2]);
				}
			}
			return removed;
		} else {
			return this.remove(i, count);
		}
	};
	Denque.prototype.clear = function clear() {
		this._list = new Array(this._list.length);
		this._head = 0;
		this._tail = 0;
	};
	Denque.prototype.isEmpty = function isEmpty() {
		return this._head === this._tail;
	};
	Denque.prototype.toArray = function toArray() {
		return this._copyArray(false);
	};
	Denque.prototype._fromArray = function _fromArray(array) {
		var length = array.length;
		var capacity = this._nextPowerOf2(length);
		this._list = new Array(capacity);
		this._capacityMask = capacity - 1;
		this._tail = length;
		for (var i = 0; i < length; i++) this._list[i] = array[i];
	};
	Denque.prototype._copyArray = function _copyArray(fullCopy, size) {
		var src = this._list;
		var capacity = src.length;
		var length = this.length;
		size = size | length;
		if (size == length && this._head < this._tail) {
			return this._list.slice(this._head, this._tail);
		}
		var dest = new Array(size);
		var k2 = 0;
		var i;
		if (fullCopy || this._head > this._tail) {
			for (i = this._head; i < capacity; i++) dest[k2++] = src[i];
			for (i = 0; i < this._tail; i++) dest[k2++] = src[i];
		} else {
			for (i = this._head; i < this._tail; i++) dest[k2++] = src[i];
		}
		return dest;
	};
	Denque.prototype._growArray = function _growArray() {
		if (this._head != 0) {
			var newList = this._copyArray(true, this._list.length << 1);
			this._tail = this._list.length;
			this._head = 0;
			this._list = newList;
		} else {
			this._tail = this._list.length;
			this._list.length <<= 1;
		}
		this._capacityMask = (this._capacityMask << 1) | 1;
	};
	Denque.prototype._shrinkArray = function _shrinkArray() {
		this._list.length >>>= 1;
		this._capacityMask >>>= 1;
	};
	Denque.prototype._nextPowerOf2 = function _nextPowerOf2(num) {
		var log2 = Math.log(num) / Math.log(2);
		var nextPow2 = 1 << (log2 + 1);
		return Math.max(nextPow2, 4);
	};
	module.exports = Denque;
});

// node_modules/ioredis/built/cluster/DelayQueue.js
var require_DelayQueue = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var utils_1 = require_utils2();
	var Deque = require_denque();
	var debug2 = (0, utils_1.Debug)("delayqueue");

	class DelayQueue {
		constructor() {
			this.queues = {};
			this.timeouts = {};
		}
		push(bucket, item, options) {
			const callback = options.callback || process.nextTick;
			if (!this.queues[bucket]) {
				this.queues[bucket] = new Deque();
			}
			const queue = this.queues[bucket];
			queue.push(item);
			if (!this.timeouts[bucket]) {
				this.timeouts[bucket] = setTimeout(() => {
					callback(() => {
						this.timeouts[bucket] = null;
						this.execute(bucket);
					});
				}, options.timeout);
			}
		}
		execute(bucket) {
			const queue = this.queues[bucket];
			if (!queue) {
				return;
			}
			const { length } = queue;
			if (!length) {
				return;
			}
			debug2("send %d commands in %s queue", length, bucket);
			this.queues[bucket] = null;
			while (queue.length > 0) {
				queue.shift()();
			}
		}
	}
	exports.default = DelayQueue;
});

// node_modules/ioredis/built/cluster/ClusterSubscriberGroup.js
var require_ClusterSubscriberGroup = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var utils_1 = require_utils2();
	var ClusterSubscriber_1 = require_ClusterSubscriber();
	var ConnectionPool_1 = require_ConnectionPool();
	var util_1 = require_util2();
	var calculateSlot = require_lib7();
	var debug2 = (0, utils_1.Debug)("cluster:subscriberGroup");

	class ClusterSubscriberGroup {
		constructor(cluster, refreshSlotsCacheCallback) {
			this.cluster = cluster;
			this.shardedSubscribers = new Map();
			this.clusterSlots = [];
			this.subscriberToSlotsIndex = new Map();
			this.channels = new Map();
			cluster.on("+node", (redis) => {
				this._addSubscriber(redis);
			});
			cluster.on("-node", (redis) => {
				this._removeSubscriber(redis);
			});
			cluster.on("refresh", () => {
				this._refreshSlots(cluster);
			});
			cluster.on("forceRefresh", () => {
				refreshSlotsCacheCallback();
			});
		}
		getResponsibleSubscriber(slot) {
			const nodeKey = this.clusterSlots[slot][0];
			return this.shardedSubscribers.get(nodeKey);
		}
		addChannels(channels) {
			const slot = calculateSlot(channels[0]);
			channels.forEach((c) => {
				if (calculateSlot(c) != slot) return -1;
			});
			const currChannels = this.channels.get(slot);
			if (!currChannels) {
				this.channels.set(slot, channels);
			} else {
				this.channels.set(slot, currChannels.concat(channels));
			}
			return [...this.channels.values()].flatMap((v) => v).length;
		}
		removeChannels(channels) {
			const slot = calculateSlot(channels[0]);
			channels.forEach((c) => {
				if (calculateSlot(c) != slot) return -1;
			});
			const slotChannels = this.channels.get(slot);
			if (slotChannels) {
				const updatedChannels = slotChannels.filter((c) => !channels.includes(c));
				this.channels.set(slot, updatedChannels);
			}
			return [...this.channels.values()].flatMap((v) => v).length;
		}
		stop() {
			for (const s of this.shardedSubscribers.values()) {
				s.stop();
			}
		}
		start() {
			for (const s of this.shardedSubscribers.values()) {
				if (!s.isStarted()) {
					s.start();
				}
			}
		}
		_addSubscriber(redis) {
			const pool = new ConnectionPool_1.default(redis.options);
			if (pool.addMasterNode(redis)) {
				const sub = new ClusterSubscriber_1.default(pool, this.cluster, true);
				const nodeKey = (0, util_1.getNodeKey)(redis.options);
				this.shardedSubscribers.set(nodeKey, sub);
				sub.start();
				this._resubscribe();
				this.cluster.emit("+subscriber");
				return sub;
			}
			return null;
		}
		_removeSubscriber(redis) {
			const nodeKey = (0, util_1.getNodeKey)(redis.options);
			const sub = this.shardedSubscribers.get(nodeKey);
			if (sub) {
				sub.stop();
				this.shardedSubscribers.delete(nodeKey);
				this._resubscribe();
				this.cluster.emit("-subscriber");
			}
			return this.shardedSubscribers;
		}
		_refreshSlots(cluster) {
			if (this._slotsAreEqual(cluster.slots)) {
				debug2("Nothing to refresh because the new cluster map is equal to the previous one.");
			} else {
				debug2("Refreshing the slots of the subscriber group.");
				this.subscriberToSlotsIndex = new Map();
				for (let slot = 0; slot < cluster.slots.length; slot++) {
					const node = cluster.slots[slot][0];
					if (!this.subscriberToSlotsIndex.has(node)) {
						this.subscriberToSlotsIndex.set(node, []);
					}
					this.subscriberToSlotsIndex.get(node).push(Number(slot));
				}
				this._resubscribe();
				this.clusterSlots = JSON.parse(JSON.stringify(cluster.slots));
				this.cluster.emit("subscribersReady");
				return true;
			}
			return false;
		}
		_resubscribe() {
			if (this.shardedSubscribers) {
				this.shardedSubscribers.forEach((s, nodeKey) => {
					const subscriberSlots = this.subscriberToSlotsIndex.get(nodeKey);
					if (subscriberSlots) {
						s.associateSlotRange(subscriberSlots);
						subscriberSlots.forEach((ss) => {
							const redis = s.getInstance();
							const channels = this.channels.get(ss);
							if (channels && channels.length > 0) {
								if (redis) {
									redis.ssubscribe(channels);
									redis.on("ready", () => {
										redis.ssubscribe(channels);
									});
								}
							}
						});
					}
				});
			}
		}
		_slotsAreEqual(other) {
			if (this.clusterSlots === undefined) return false;
			else return JSON.stringify(this.clusterSlots) === JSON.stringify(other);
		}
	}
	exports.default = ClusterSubscriberGroup;
});

// node_modules/ioredis/built/cluster/index.js
var require_cluster = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var commands_1 = require_built();
	var events_1 = __require("events");
	var redis_errors_1 = require_redis_errors();
	var standard_as_callback_1 = require_built2();
	var Command_1 = require_Command();
	var ClusterAllFailedError_1 = require_ClusterAllFailedError();
	var Redis_1 = require_Redis();
	var ScanStream_1 = require_ScanStream();
	var transaction_1 = require_transaction();
	var utils_1 = require_utils2();
	var applyMixin_1 = require_applyMixin();
	var Commander_1 = require_Commander();
	var ClusterOptions_1 = require_ClusterOptions();
	var ClusterSubscriber_1 = require_ClusterSubscriber();
	var ConnectionPool_1 = require_ConnectionPool();
	var DelayQueue_1 = require_DelayQueue();
	var util_1 = require_util2();
	var Deque = require_denque();
	var ClusterSubscriberGroup_1 = require_ClusterSubscriberGroup();
	var debug2 = (0, utils_1.Debug)("cluster");
	var REJECT_OVERWRITTEN_COMMANDS = new WeakSet();

	class Cluster extends Commander_1.default {
		constructor(startupNodes, options = {}) {
			super();
			this.slots = [];
			this._groupsIds = {};
			this._groupsBySlot = Array(16384);
			this.isCluster = true;
			this.retryAttempts = 0;
			this.delayQueue = new DelayQueue_1.default();
			this.offlineQueue = new Deque();
			this.isRefreshing = false;
			this._refreshSlotsCacheCallbacks = [];
			this._autoPipelines = new Map();
			this._runningAutoPipelines = new Set();
			this._readyDelayedCallbacks = [];
			this.connectionEpoch = 0;
			events_1.EventEmitter.call(this);
			this.startupNodes = startupNodes;
			this.options = (0, utils_1.defaults)(
				{},
				options,
				ClusterOptions_1.DEFAULT_CLUSTER_OPTIONS,
				this.options,
			);
			if (this.options.shardedSubscribers == true)
				this.shardedSubscribers = new ClusterSubscriberGroup_1.default(
					this,
					this.refreshSlotsCache.bind(this),
				);
			if (
				this.options.redisOptions &&
				this.options.redisOptions.keyPrefix &&
				!this.options.keyPrefix
			) {
				this.options.keyPrefix = this.options.redisOptions.keyPrefix;
			}
			if (
				typeof this.options.scaleReads !== "function" &&
				["all", "master", "slave"].indexOf(this.options.scaleReads) === -1
			) {
				throw new Error(
					'Invalid option scaleReads "' +
						this.options.scaleReads +
						'". Expected "all", "master", "slave" or a custom function',
				);
			}
			this.connectionPool = new ConnectionPool_1.default(this.options.redisOptions);
			this.connectionPool.on("-node", (redis, key) => {
				this.emit("-node", redis);
			});
			this.connectionPool.on("+node", (redis) => {
				this.emit("+node", redis);
			});
			this.connectionPool.on("drain", () => {
				this.setStatus("close");
			});
			this.connectionPool.on("nodeError", (error, key) => {
				this.emit("node error", error, key);
			});
			this.subscriber = new ClusterSubscriber_1.default(this.connectionPool, this);
			if (this.options.scripts) {
				Object.entries(this.options.scripts).forEach(([name, definition]) => {
					this.defineCommand(name, definition);
				});
			}
			if (this.options.lazyConnect) {
				this.setStatus("wait");
			} else {
				this.connect().catch((err) => {
					debug2("connecting failed: %s", err);
				});
			}
		}
		connect() {
			return new Promise((resolve, reject) => {
				if (this.status === "connecting" || this.status === "connect" || this.status === "ready") {
					reject(new Error("Redis is already connecting/connected"));
					return;
				}
				const epoch = ++this.connectionEpoch;
				this.setStatus("connecting");
				this.resolveStartupNodeHostnames()
					.then((nodes) => {
						if (this.connectionEpoch !== epoch) {
							debug2(
								"discard connecting after resolving startup nodes because epoch not match: %d != %d",
								epoch,
								this.connectionEpoch,
							);
							reject(
								new redis_errors_1.RedisError(
									"Connection is discarded because a new connection is made",
								),
							);
							return;
						}
						if (this.status !== "connecting") {
							debug2(
								"discard connecting after resolving startup nodes because the status changed to %s",
								this.status,
							);
							reject(new redis_errors_1.RedisError("Connection is aborted"));
							return;
						}
						this.connectionPool.reset(nodes);
						const readyHandler = () => {
							this.setStatus("ready");
							this.retryAttempts = 0;
							this.executeOfflineCommands();
							this.resetNodesRefreshInterval();
							resolve();
						};
						let closeListener = undefined;
						const refreshListener = () => {
							this.invokeReadyDelayedCallbacks(undefined);
							this.removeListener("close", closeListener);
							this.manuallyClosing = false;
							this.setStatus("connect");
							if (this.options.enableReadyCheck) {
								this.readyCheck((err, fail) => {
									if (err || fail) {
										debug2("Ready check failed (%s). Reconnecting...", err || fail);
										if (this.status === "connect") {
											this.disconnect(true);
										}
									} else {
										readyHandler();
									}
								});
							} else {
								readyHandler();
							}
						};
						closeListener = () => {
							const error = new Error("None of startup nodes is available");
							this.removeListener("refresh", refreshListener);
							this.invokeReadyDelayedCallbacks(error);
							reject(error);
						};
						this.once("refresh", refreshListener);
						this.once("close", closeListener);
						this.once("close", this.handleCloseEvent.bind(this));
						this.refreshSlotsCache((err) => {
							if (err && err.message === ClusterAllFailedError_1.default.defaultMessage) {
								Redis_1.default.prototype.silentEmit.call(this, "error", err);
								this.connectionPool.reset([]);
							}
						});
						this.subscriber.start();
						if (this.options.shardedSubscribers) {
							this.shardedSubscribers.start();
						}
					})
					.catch((err) => {
						this.setStatus("close");
						this.handleCloseEvent(err);
						this.invokeReadyDelayedCallbacks(err);
						reject(err);
					});
			});
		}
		disconnect(reconnect = false) {
			const status2 = this.status;
			this.setStatus("disconnecting");
			if (!reconnect) {
				this.manuallyClosing = true;
			}
			if (this.reconnectTimeout && !reconnect) {
				clearTimeout(this.reconnectTimeout);
				this.reconnectTimeout = null;
				debug2("Canceled reconnecting attempts");
			}
			this.clearNodesRefreshInterval();
			this.subscriber.stop();
			if (this.options.shardedSubscribers) {
				this.shardedSubscribers.stop();
			}
			if (status2 === "wait") {
				this.setStatus("close");
				this.handleCloseEvent();
			} else {
				this.connectionPool.reset([]);
			}
		}
		quit(callback) {
			const status2 = this.status;
			this.setStatus("disconnecting");
			this.manuallyClosing = true;
			if (this.reconnectTimeout) {
				clearTimeout(this.reconnectTimeout);
				this.reconnectTimeout = null;
			}
			this.clearNodesRefreshInterval();
			this.subscriber.stop();
			if (this.options.shardedSubscribers) {
				this.shardedSubscribers.stop();
			}
			if (status2 === "wait") {
				const ret = (0, standard_as_callback_1.default)(Promise.resolve("OK"), callback);
				setImmediate(
					function () {
						this.setStatus("close");
						this.handleCloseEvent();
					}.bind(this),
				);
				return ret;
			}
			return (0, standard_as_callback_1.default)(
				Promise.all(
					this.nodes().map((node) =>
						node.quit().catch((err) => {
							if (err.message === utils_1.CONNECTION_CLOSED_ERROR_MSG) {
								return "OK";
							}
							throw err;
						}),
					),
				).then(() => "OK"),
				callback,
			);
		}
		duplicate(overrideStartupNodes = [], overrideOptions = {}) {
			const startupNodes =
				overrideStartupNodes.length > 0 ? overrideStartupNodes : this.startupNodes.slice(0);
			const options = Object.assign({}, this.options, overrideOptions);
			return new Cluster(startupNodes, options);
		}
		nodes(role = "all") {
			if (role !== "all" && role !== "master" && role !== "slave") {
				throw new Error('Invalid role "' + role + '". Expected "all", "master" or "slave"');
			}
			return this.connectionPool.getNodes(role);
		}
		delayUntilReady(callback) {
			this._readyDelayedCallbacks.push(callback);
		}
		get autoPipelineQueueSize() {
			let queued = 0;
			for (const pipeline2 of this._autoPipelines.values()) {
				queued += pipeline2.length;
			}
			return queued;
		}
		refreshSlotsCache(callback) {
			if (callback) {
				this._refreshSlotsCacheCallbacks.push(callback);
			}
			if (this.isRefreshing) {
				return;
			}
			this.isRefreshing = true;
			const _this = this;
			const wrapper = (error) => {
				this.isRefreshing = false;
				for (const callback2 of this._refreshSlotsCacheCallbacks) {
					callback2(error);
				}
				this._refreshSlotsCacheCallbacks = [];
			};
			const nodes = (0, utils_1.shuffle)(this.connectionPool.getNodes());
			let lastNodeError = null;
			function tryNode(index) {
				if (index === nodes.length) {
					const error = new ClusterAllFailedError_1.default(
						ClusterAllFailedError_1.default.defaultMessage,
						lastNodeError,
					);
					return wrapper(error);
				}
				const node = nodes[index];
				const key = `${node.options.host}:${node.options.port}`;
				debug2("getting slot cache from %s", key);
				_this.getInfoFromNode(node, function (err) {
					switch (_this.status) {
						case "close":
						case "end":
							return wrapper(new Error("Cluster is disconnected."));
						case "disconnecting":
							return wrapper(new Error("Cluster is disconnecting."));
					}
					if (err) {
						_this.emit("node error", err, key);
						lastNodeError = err;
						tryNode(index + 1);
					} else {
						_this.emit("refresh");
						wrapper();
					}
				});
			}
			tryNode(0);
		}
		sendCommand(command, stream4, node) {
			if (this.status === "wait") {
				this.connect().catch(utils_1.noop);
			}
			if (this.status === "end") {
				command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
				return command.promise;
			}
			let to = this.options.scaleReads;
			if (to !== "master") {
				const isCommandReadOnly =
					command.isReadOnly ||
					((0, commands_1.exists)(command.name) &&
						(0, commands_1.hasFlag)(command.name, "readonly"));
				if (!isCommandReadOnly) {
					to = "master";
				}
			}
			let targetSlot = node ? node.slot : command.getSlot();
			const ttl = {};
			const _this = this;
			if (!node && !REJECT_OVERWRITTEN_COMMANDS.has(command)) {
				REJECT_OVERWRITTEN_COMMANDS.add(command);
				const reject = command.reject;
				command.reject = function (err) {
					const partialTry = tryConnection.bind(null, true);
					_this.handleError(err, ttl, {
						moved: function (slot, key) {
							debug2("command %s is moved to %s", command.name, key);
							targetSlot = Number(slot);
							if (_this.slots[slot]) {
								_this.slots[slot][0] = key;
							} else {
								_this.slots[slot] = [key];
							}
							_this._groupsBySlot[slot] = _this._groupsIds[_this.slots[slot].join(";")];
							_this.connectionPool.findOrCreate(_this.natMapper(key));
							tryConnection();
							debug2("refreshing slot caches... (triggered by MOVED error)");
							_this.refreshSlotsCache();
						},
						ask: function (slot, key) {
							debug2("command %s is required to ask %s:%s", command.name, key);
							const mapped = _this.natMapper(key);
							_this.connectionPool.findOrCreate(mapped);
							tryConnection(false, `${mapped.host}:${mapped.port}`);
						},
						tryagain: partialTry,
						clusterDown: partialTry,
						connectionClosed: partialTry,
						maxRedirections: function (redirectionError) {
							reject.call(command, redirectionError);
						},
						defaults: function () {
							reject.call(command, err);
						},
					});
				};
			}
			tryConnection();
			function tryConnection(random, asking) {
				if (_this.status === "end") {
					command.reject(new redis_errors_1.AbortError("Cluster is ended."));
					return;
				}
				let redis;
				if (_this.status === "ready" || command.name === "cluster") {
					if (node && node.redis) {
						redis = node.redis;
					} else if (
						Command_1.default.checkFlag("ENTER_SUBSCRIBER_MODE", command.name) ||
						Command_1.default.checkFlag("EXIT_SUBSCRIBER_MODE", command.name)
					) {
						if (
							_this.options.shardedSubscribers == true &&
							(command.name == "ssubscribe" || command.name == "sunsubscribe")
						) {
							const sub = _this.shardedSubscribers.getResponsibleSubscriber(targetSlot);
							let status2 = -1;
							if (command.name == "ssubscribe")
								status2 = _this.shardedSubscribers.addChannels(command.getKeys());
							if (command.name == "sunsubscribe")
								status2 = _this.shardedSubscribers.removeChannels(command.getKeys());
							if (status2 !== -1) {
								redis = sub.getInstance();
							} else {
								command.reject(
									new redis_errors_1.AbortError(
										"Can't add or remove the given channels. Are they in the same slot?",
									),
								);
							}
						} else {
							redis = _this.subscriber.getInstance();
						}
						if (!redis) {
							command.reject(new redis_errors_1.AbortError("No subscriber for the cluster"));
							return;
						}
					} else {
						if (!random) {
							if (typeof targetSlot === "number" && _this.slots[targetSlot]) {
								const nodeKeys = _this.slots[targetSlot];
								if (typeof to === "function") {
									const nodes = nodeKeys.map(function (key) {
										return _this.connectionPool.getInstanceByKey(key);
									});
									redis = to(nodes, command);
									if (Array.isArray(redis)) {
										redis = (0, utils_1.sample)(redis);
									}
									if (!redis) {
										redis = nodes[0];
									}
								} else {
									let key;
									if (to === "all") {
										key = (0, utils_1.sample)(nodeKeys);
									} else if (to === "slave" && nodeKeys.length > 1) {
										key = (0, utils_1.sample)(nodeKeys, 1);
									} else {
										key = nodeKeys[0];
									}
									redis = _this.connectionPool.getInstanceByKey(key);
								}
							}
							if (asking) {
								redis = _this.connectionPool.getInstanceByKey(asking);
								redis.asking();
							}
						}
						if (!redis) {
							redis =
								(typeof to === "function" ? null : _this.connectionPool.getSampleInstance(to)) ||
								_this.connectionPool.getSampleInstance("all");
						}
					}
					if (node && !node.redis) {
						node.redis = redis;
					}
				}
				if (redis) {
					redis.sendCommand(command, stream4);
				} else if (_this.options.enableOfflineQueue) {
					_this.offlineQueue.push({
						command,
						stream: stream4,
						node,
					});
				} else {
					command.reject(new Error("Cluster isn't ready and enableOfflineQueue options is false"));
				}
			}
			return command.promise;
		}
		sscanStream(key, options) {
			return this.createScanStream("sscan", { key, options });
		}
		sscanBufferStream(key, options) {
			return this.createScanStream("sscanBuffer", { key, options });
		}
		hscanStream(key, options) {
			return this.createScanStream("hscan", { key, options });
		}
		hscanBufferStream(key, options) {
			return this.createScanStream("hscanBuffer", { key, options });
		}
		zscanStream(key, options) {
			return this.createScanStream("zscan", { key, options });
		}
		zscanBufferStream(key, options) {
			return this.createScanStream("zscanBuffer", { key, options });
		}
		handleError(error, ttl, handlers) {
			if (typeof ttl.value === "undefined") {
				ttl.value = this.options.maxRedirections;
			} else {
				ttl.value -= 1;
			}
			if (ttl.value <= 0) {
				handlers.maxRedirections(new Error("Too many Cluster redirections. Last error: " + error));
				return;
			}
			const errv = error.message.split(" ");
			if (errv[0] === "MOVED") {
				const timeout = this.options.retryDelayOnMoved;
				if (timeout && typeof timeout === "number") {
					this.delayQueue.push("moved", handlers.moved.bind(null, errv[1], errv[2]), { timeout });
				} else {
					handlers.moved(errv[1], errv[2]);
				}
			} else if (errv[0] === "ASK") {
				handlers.ask(errv[1], errv[2]);
			} else if (errv[0] === "TRYAGAIN") {
				this.delayQueue.push("tryagain", handlers.tryagain, {
					timeout: this.options.retryDelayOnTryAgain,
				});
			} else if (errv[0] === "CLUSTERDOWN" && this.options.retryDelayOnClusterDown > 0) {
				this.delayQueue.push("clusterdown", handlers.connectionClosed, {
					timeout: this.options.retryDelayOnClusterDown,
					callback: this.refreshSlotsCache.bind(this),
				});
			} else if (
				error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG &&
				this.options.retryDelayOnFailover > 0 &&
				this.status === "ready"
			) {
				this.delayQueue.push("failover", handlers.connectionClosed, {
					timeout: this.options.retryDelayOnFailover,
					callback: this.refreshSlotsCache.bind(this),
				});
			} else {
				handlers.defaults();
			}
		}
		resetOfflineQueue() {
			this.offlineQueue = new Deque();
		}
		clearNodesRefreshInterval() {
			if (this.slotsTimer) {
				clearTimeout(this.slotsTimer);
				this.slotsTimer = null;
			}
		}
		resetNodesRefreshInterval() {
			if (this.slotsTimer || !this.options.slotsRefreshInterval) {
				return;
			}
			const nextRound = () => {
				this.slotsTimer = setTimeout(() => {
					debug2('refreshing slot caches... (triggered by "slotsRefreshInterval" option)');
					this.refreshSlotsCache(() => {
						nextRound();
					});
				}, this.options.slotsRefreshInterval);
			};
			nextRound();
		}
		setStatus(status2) {
			debug2("status: %s -> %s", this.status || "[empty]", status2);
			this.status = status2;
			process.nextTick(() => {
				this.emit(status2);
			});
		}
		handleCloseEvent(reason) {
			if (reason) {
				debug2("closed because %s", reason);
			}
			let retryDelay;
			if (!this.manuallyClosing && typeof this.options.clusterRetryStrategy === "function") {
				retryDelay = this.options.clusterRetryStrategy.call(this, ++this.retryAttempts, reason);
			}
			if (typeof retryDelay === "number") {
				this.setStatus("reconnecting");
				this.reconnectTimeout = setTimeout(() => {
					this.reconnectTimeout = null;
					debug2("Cluster is disconnected. Retrying after %dms", retryDelay);
					this.connect().catch(function (err) {
						debug2("Got error %s when reconnecting. Ignoring...", err);
					});
				}, retryDelay);
			} else {
				this.setStatus("end");
				this.flushQueue(new Error("None of startup nodes is available"));
			}
		}
		flushQueue(error) {
			let item;
			while ((item = this.offlineQueue.shift())) {
				item.command.reject(error);
			}
		}
		executeOfflineCommands() {
			if (this.offlineQueue.length) {
				debug2("send %d commands in offline queue", this.offlineQueue.length);
				const offlineQueue = this.offlineQueue;
				this.resetOfflineQueue();
				let item;
				while ((item = offlineQueue.shift())) {
					this.sendCommand(item.command, item.stream, item.node);
				}
			}
		}
		natMapper(nodeKey) {
			const key = typeof nodeKey === "string" ? nodeKey : `${nodeKey.host}:${nodeKey.port}`;
			let mapped = null;
			if (this.options.natMap && typeof this.options.natMap === "function") {
				mapped = this.options.natMap(key);
			} else if (this.options.natMap && typeof this.options.natMap === "object") {
				mapped = this.options.natMap[key];
			}
			if (mapped) {
				debug2("NAT mapping %s -> %O", key, mapped);
				return Object.assign({}, mapped);
			}
			return typeof nodeKey === "string" ? (0, util_1.nodeKeyToRedisOptions)(nodeKey) : nodeKey;
		}
		getInfoFromNode(redis, callback) {
			if (!redis) {
				return callback(new Error("Node is disconnected"));
			}
			const duplicatedConnection = redis.duplicate({
				enableOfflineQueue: true,
				enableReadyCheck: false,
				retryStrategy: null,
				connectionName: (0, util_1.getConnectionName)(
					"refresher",
					this.options.redisOptions && this.options.redisOptions.connectionName,
				),
			});
			duplicatedConnection.on("error", utils_1.noop);
			duplicatedConnection.cluster(
				"SLOTS",
				(0, utils_1.timeout)((err, result) => {
					duplicatedConnection.disconnect();
					if (err) {
						debug2("error encountered running CLUSTER.SLOTS: %s", err);
						return callback(err);
					}
					if (this.status === "disconnecting" || this.status === "close" || this.status === "end") {
						debug2(
							"ignore CLUSTER.SLOTS results (count: %d) since cluster status is %s",
							result.length,
							this.status,
						);
						callback();
						return;
					}
					const nodes = [];
					debug2("cluster slots result count: %d", result.length);
					for (let i = 0; i < result.length; ++i) {
						const items = result[i];
						const slotRangeStart = items[0];
						const slotRangeEnd = items[1];
						const keys = [];
						for (let j2 = 2; j2 < items.length; j2++) {
							if (!items[j2][0]) {
								continue;
							}
							const node = this.natMapper({
								host: items[j2][0],
								port: items[j2][1],
							});
							node.readOnly = j2 !== 2;
							nodes.push(node);
							keys.push(node.host + ":" + node.port);
						}
						debug2(
							"cluster slots result [%d]: slots %d~%d served by %s",
							i,
							slotRangeStart,
							slotRangeEnd,
							keys,
						);
						for (let slot = slotRangeStart; slot <= slotRangeEnd; slot++) {
							this.slots[slot] = keys;
						}
					}
					this._groupsIds = Object.create(null);
					let j = 0;
					for (let i = 0; i < 16384; i++) {
						const target = (this.slots[i] || []).join(";");
						if (!target.length) {
							this._groupsBySlot[i] = undefined;
							continue;
						}
						if (!this._groupsIds[target]) {
							this._groupsIds[target] = ++j;
						}
						this._groupsBySlot[i] = this._groupsIds[target];
					}
					this.connectionPool.reset(nodes);
					callback();
				}, this.options.slotsRefreshTimeout),
			);
		}
		invokeReadyDelayedCallbacks(err) {
			for (const c of this._readyDelayedCallbacks) {
				process.nextTick(c, err);
			}
			this._readyDelayedCallbacks = [];
		}
		readyCheck(callback) {
			this.cluster("INFO", (err, res) => {
				if (err) {
					return callback(err);
				}
				if (typeof res !== "string") {
					return callback();
				}
				let state;
				const lines = res.split(`\r
`);
				for (let i = 0; i < lines.length; ++i) {
					const parts = lines[i].split(":");
					if (parts[0] === "cluster_state") {
						state = parts[1];
						break;
					}
				}
				if (state === "fail") {
					debug2("cluster state not ok (%s)", state);
					callback(null, state);
				} else {
					callback();
				}
			});
		}
		resolveSrv(hostname) {
			return new Promise((resolve, reject) => {
				this.options.resolveSrv(hostname, (err, records) => {
					if (err) {
						return reject(err);
					}
					const self2 = this,
						groupedRecords = (0, util_1.groupSrvRecords)(records),
						sortedKeys = Object.keys(groupedRecords).sort((a12, b) => parseInt(a12) - parseInt(b));
					function tryFirstOne(err2) {
						if (!sortedKeys.length) {
							return reject(err2);
						}
						const key = sortedKeys[0],
							group = groupedRecords[key],
							record = (0, util_1.weightSrvRecords)(group);
						if (!group.records.length) {
							sortedKeys.shift();
						}
						self2.dnsLookup(record.name).then(
							(host) =>
								resolve({
									host,
									port: record.port,
								}),
							tryFirstOne,
						);
					}
					tryFirstOne();
				});
			});
		}
		dnsLookup(hostname) {
			return new Promise((resolve, reject) => {
				this.options.dnsLookup(hostname, (err, address) => {
					if (err) {
						debug2("failed to resolve hostname %s to IP: %s", hostname, err.message);
						reject(err);
					} else {
						debug2("resolved hostname %s to IP %s", hostname, address);
						resolve(address);
					}
				});
			});
		}
		async resolveStartupNodeHostnames() {
			if (!Array.isArray(this.startupNodes) || this.startupNodes.length === 0) {
				throw new Error("`startupNodes` should contain at least one node.");
			}
			const startupNodes = (0, util_1.normalizeNodeOptions)(this.startupNodes);
			const hostnames = (0, util_1.getUniqueHostnamesFromOptions)(startupNodes);
			if (hostnames.length === 0) {
				return startupNodes;
			}
			const configs = await Promise.all(
				hostnames.map((this.options.useSRVRecords ? this.resolveSrv : this.dnsLookup).bind(this)),
			);
			const hostnameToConfig = (0, utils_1.zipMap)(hostnames, configs);
			return startupNodes.map((node) => {
				const config = hostnameToConfig.get(node.host);
				if (!config) {
					return node;
				}
				if (this.options.useSRVRecords) {
					return Object.assign({}, node, config);
				}
				return Object.assign({}, node, { host: config });
			});
		}
		createScanStream(command, { key, options = {} }) {
			return new ScanStream_1.default({
				objectMode: true,
				key,
				redis: this,
				command,
				...options,
			});
		}
	}
	(0, applyMixin_1.default)(Cluster, events_1.EventEmitter);
	(0, transaction_1.addTransactionSupport)(Cluster.prototype);
	exports.default = Cluster;
});

// node_modules/ioredis/built/connectors/AbstractConnector.js
var require_AbstractConnector = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var utils_1 = require_utils2();
	var debug2 = (0, utils_1.Debug)("AbstractConnector");

	class AbstractConnector {
		constructor(disconnectTimeout) {
			this.connecting = false;
			this.disconnectTimeout = disconnectTimeout;
		}
		check(info) {
			return true;
		}
		disconnect() {
			this.connecting = false;
			if (this.stream) {
				const stream4 = this.stream;
				const timeout = setTimeout(() => {
					debug2(
						"stream %s:%s still open, destroying it",
						stream4.remoteAddress,
						stream4.remotePort,
					);
					stream4.destroy();
				}, this.disconnectTimeout);
				stream4.on("close", () => clearTimeout(timeout));
				stream4.end();
			}
		}
	}
	exports.default = AbstractConnector;
});

// node_modules/ioredis/built/connectors/StandaloneConnector.js
var require_StandaloneConnector = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var net_1 = __require("net");
	var tls_1 = __require("tls");
	var utils_1 = require_utils2();
	var AbstractConnector_1 = require_AbstractConnector();

	class StandaloneConnector extends AbstractConnector_1.default {
		constructor(options) {
			super(options.disconnectTimeout);
			this.options = options;
		}
		connect(_2) {
			const { options } = this;
			this.connecting = true;
			let connectionOptions;
			if ("path" in options && options.path) {
				connectionOptions = {
					path: options.path,
				};
			} else {
				connectionOptions = {};
				if ("port" in options && options.port != null) {
					connectionOptions.port = options.port;
				}
				if ("host" in options && options.host != null) {
					connectionOptions.host = options.host;
				}
				if ("family" in options && options.family != null) {
					connectionOptions.family = options.family;
				}
			}
			if (options.tls) {
				Object.assign(connectionOptions, options.tls);
			}
			return new Promise((resolve, reject) => {
				process.nextTick(() => {
					if (!this.connecting) {
						reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
						return;
					}
					try {
						if (options.tls) {
							this.stream = (0, tls_1.connect)(connectionOptions);
						} else {
							this.stream = (0, net_1.createConnection)(connectionOptions);
						}
					} catch (err) {
						reject(err);
						return;
					}
					this.stream.once("error", (err) => {
						this.firstError = err;
					});
					resolve(this.stream);
				});
			});
		}
	}
	exports.default = StandaloneConnector;
});

// node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js
var require_SentinelIterator = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	function isSentinelEql(a12, b) {
		return (
			(a12.host || "127.0.0.1") === (b.host || "127.0.0.1") &&
			(a12.port || 26379) === (b.port || 26379)
		);
	}

	class SentinelIterator {
		constructor(sentinels) {
			this.cursor = 0;
			this.sentinels = sentinels.slice(0);
		}
		next() {
			const done = this.cursor >= this.sentinels.length;
			return { done, value: done ? undefined : this.sentinels[this.cursor++] };
		}
		reset(moveCurrentEndpointToFirst) {
			if (moveCurrentEndpointToFirst && this.sentinels.length > 1 && this.cursor !== 1) {
				this.sentinels.unshift(...this.sentinels.splice(this.cursor - 1));
			}
			this.cursor = 0;
		}
		add(sentinel) {
			for (let i = 0; i < this.sentinels.length; i++) {
				if (isSentinelEql(sentinel, this.sentinels[i])) {
					return false;
				}
			}
			this.sentinels.push(sentinel);
			return true;
		}
		toString() {
			return `${JSON.stringify(this.sentinels)} @${this.cursor}`;
		}
	}
	exports.default = SentinelIterator;
});

// node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js
var require_FailoverDetector = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.FailoverDetector = undefined;
	var utils_1 = require_utils2();
	var debug2 = (0, utils_1.Debug)("FailoverDetector");
	var CHANNEL_NAME = "+switch-master";

	class FailoverDetector {
		constructor(connector, sentinels) {
			this.isDisconnected = false;
			this.connector = connector;
			this.sentinels = sentinels;
		}
		cleanup() {
			this.isDisconnected = true;
			for (const sentinel of this.sentinels) {
				sentinel.client.disconnect();
			}
		}
		async subscribe() {
			debug2("Starting FailoverDetector");
			const promises = [];
			for (const sentinel of this.sentinels) {
				const promise = sentinel.client.subscribe(CHANNEL_NAME).catch((err) => {
					debug2(
						"Failed to subscribe to failover messages on sentinel %s:%s (%s)",
						sentinel.address.host || "127.0.0.1",
						sentinel.address.port || 26739,
						err.message,
					);
				});
				promises.push(promise);
				sentinel.client.on("message", (channel) => {
					if (!this.isDisconnected && channel === CHANNEL_NAME) {
						this.disconnect();
					}
				});
			}
			await Promise.all(promises);
		}
		disconnect() {
			this.isDisconnected = true;
			debug2("Failover detected, disconnecting");
			this.connector.disconnect();
		}
	}
	exports.FailoverDetector = FailoverDetector;
});

// node_modules/ioredis/built/connectors/SentinelConnector/index.js
var require_SentinelConnector = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SentinelIterator = undefined;
	var net_1 = __require("net");
	var utils_1 = require_utils2();
	var tls_1 = __require("tls");
	var SentinelIterator_1 = require_SentinelIterator();
	exports.SentinelIterator = SentinelIterator_1.default;
	var AbstractConnector_1 = require_AbstractConnector();
	var Redis_1 = require_Redis();
	var FailoverDetector_1 = require_FailoverDetector();
	var debug2 = (0, utils_1.Debug)("SentinelConnector");

	class SentinelConnector extends AbstractConnector_1.default {
		constructor(options) {
			super(options.disconnectTimeout);
			this.options = options;
			this.emitter = null;
			this.failoverDetector = null;
			if (!this.options.sentinels.length) {
				throw new Error("Requires at least one sentinel to connect to.");
			}
			if (!this.options.name) {
				throw new Error("Requires the name of master.");
			}
			this.sentinelIterator = new SentinelIterator_1.default(this.options.sentinels);
		}
		check(info) {
			const roleMatches = !info.role || this.options.role === info.role;
			if (!roleMatches) {
				debug2("role invalid, expected %s, but got %s", this.options.role, info.role);
				this.sentinelIterator.next();
				this.sentinelIterator.next();
				this.sentinelIterator.reset(true);
			}
			return roleMatches;
		}
		disconnect() {
			super.disconnect();
			if (this.failoverDetector) {
				this.failoverDetector.cleanup();
			}
		}
		connect(eventEmitter) {
			this.connecting = true;
			this.retryAttempts = 0;
			let lastError;
			const connectToNext = async () => {
				const endpoint = this.sentinelIterator.next();
				if (endpoint.done) {
					this.sentinelIterator.reset(false);
					const retryDelay =
						typeof this.options.sentinelRetryStrategy === "function"
							? this.options.sentinelRetryStrategy(++this.retryAttempts)
							: null;
					let errorMsg =
						typeof retryDelay !== "number"
							? "All sentinels are unreachable and retry is disabled."
							: `All sentinels are unreachable. Retrying from scratch after ${retryDelay}ms.`;
					if (lastError) {
						errorMsg += ` Last error: ${lastError.message}`;
					}
					debug2(errorMsg);
					const error = new Error(errorMsg);
					if (typeof retryDelay === "number") {
						eventEmitter("error", error);
						await new Promise((resolve) => setTimeout(resolve, retryDelay));
						return connectToNext();
					} else {
						throw error;
					}
				}
				let resolved = null;
				let err = null;
				try {
					resolved = await this.resolve(endpoint.value);
				} catch (error) {
					err = error;
				}
				if (!this.connecting) {
					throw new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG);
				}
				const endpointAddress = endpoint.value.host + ":" + endpoint.value.port;
				if (resolved) {
					debug2("resolved: %s:%s from sentinel %s", resolved.host, resolved.port, endpointAddress);
					if (this.options.enableTLSForSentinelMode && this.options.tls) {
						Object.assign(resolved, this.options.tls);
						this.stream = (0, tls_1.connect)(resolved);
						this.stream.once("secureConnect", this.initFailoverDetector.bind(this));
					} else {
						this.stream = (0, net_1.createConnection)(resolved);
						this.stream.once("connect", this.initFailoverDetector.bind(this));
					}
					this.stream.once("error", (err2) => {
						this.firstError = err2;
					});
					return this.stream;
				} else {
					const errorMsg = err
						? "failed to connect to sentinel " + endpointAddress + " because " + err.message
						: "connected to sentinel " +
							endpointAddress +
							" successfully, but got an invalid reply: " +
							resolved;
					debug2(errorMsg);
					eventEmitter("sentinelError", new Error(errorMsg));
					if (err) {
						lastError = err;
					}
					return connectToNext();
				}
			};
			return connectToNext();
		}
		async updateSentinels(client) {
			if (!this.options.updateSentinels) {
				return;
			}
			const result = await client.sentinel("sentinels", this.options.name);
			if (!Array.isArray(result)) {
				return;
			}
			result.map(utils_1.packObject).forEach((sentinel) => {
				const flags = sentinel.flags ? sentinel.flags.split(",") : [];
				if (flags.indexOf("disconnected") === -1 && sentinel.ip && sentinel.port) {
					const endpoint = this.sentinelNatResolve(addressResponseToAddress(sentinel));
					if (this.sentinelIterator.add(endpoint)) {
						debug2("adding sentinel %s:%s", endpoint.host, endpoint.port);
					}
				}
			});
			debug2("Updated internal sentinels: %s", this.sentinelIterator);
		}
		async resolveMaster(client) {
			const result = await client.sentinel("get-master-addr-by-name", this.options.name);
			await this.updateSentinels(client);
			return this.sentinelNatResolve(
				Array.isArray(result) ? { host: result[0], port: Number(result[1]) } : null,
			);
		}
		async resolveSlave(client) {
			const result = await client.sentinel("slaves", this.options.name);
			if (!Array.isArray(result)) {
				return null;
			}
			const availableSlaves = result
				.map(utils_1.packObject)
				.filter((slave) => slave.flags && !slave.flags.match(/(disconnected|s_down|o_down)/));
			return this.sentinelNatResolve(
				selectPreferredSentinel(availableSlaves, this.options.preferredSlaves),
			);
		}
		sentinelNatResolve(item) {
			if (!item || !this.options.natMap) return item;
			const key = `${item.host}:${item.port}`;
			let result = item;
			if (typeof this.options.natMap === "function") {
				result = this.options.natMap(key) || item;
			} else if (typeof this.options.natMap === "object") {
				result = this.options.natMap[key] || item;
			}
			return result;
		}
		connectToSentinel(endpoint, options) {
			const redis = new Redis_1.default({
				port: endpoint.port || 26379,
				host: endpoint.host,
				username: this.options.sentinelUsername || null,
				password: this.options.sentinelPassword || null,
				family:
					endpoint.family ||
					("path" in this.options && this.options.path ? undefined : this.options.family),
				tls: this.options.sentinelTLS,
				retryStrategy: null,
				enableReadyCheck: false,
				connectTimeout: this.options.connectTimeout,
				commandTimeout: this.options.sentinelCommandTimeout,
				...options,
			});
			return redis;
		}
		async resolve(endpoint) {
			const client = this.connectToSentinel(endpoint);
			client.on("error", noop2);
			try {
				if (this.options.role === "slave") {
					return await this.resolveSlave(client);
				} else {
					return await this.resolveMaster(client);
				}
			} finally {
				client.disconnect();
			}
		}
		async initFailoverDetector() {
			var _a;
			if (!this.options.failoverDetector) {
				return;
			}
			this.sentinelIterator.reset(true);
			const sentinels = [];
			while (sentinels.length < this.options.sentinelMaxConnections) {
				const { done, value } = this.sentinelIterator.next();
				if (done) {
					break;
				}
				const client = this.connectToSentinel(value, {
					lazyConnect: true,
					retryStrategy: this.options.sentinelReconnectStrategy,
				});
				client.on("reconnecting", () => {
					var _a2;
					(_a2 = this.emitter) === null || _a2 === undefined || _a2.emit("sentinelReconnecting");
				});
				sentinels.push({ address: value, client });
			}
			this.sentinelIterator.reset(false);
			if (this.failoverDetector) {
				this.failoverDetector.cleanup();
			}
			this.failoverDetector = new FailoverDetector_1.FailoverDetector(this, sentinels);
			await this.failoverDetector.subscribe();
			(_a = this.emitter) === null || _a === undefined || _a.emit("failoverSubscribed");
		}
	}
	exports.default = SentinelConnector;
	function selectPreferredSentinel(availableSlaves, preferredSlaves) {
		if (availableSlaves.length === 0) {
			return null;
		}
		let selectedSlave;
		if (typeof preferredSlaves === "function") {
			selectedSlave = preferredSlaves(availableSlaves);
		} else if (preferredSlaves !== null && typeof preferredSlaves === "object") {
			const preferredSlavesArray = Array.isArray(preferredSlaves)
				? preferredSlaves
				: [preferredSlaves];
			preferredSlavesArray.sort((a12, b) => {
				if (!a12.prio) {
					a12.prio = 1;
				}
				if (!b.prio) {
					b.prio = 1;
				}
				if (a12.prio < b.prio) {
					return -1;
				}
				if (a12.prio > b.prio) {
					return 1;
				}
				return 0;
			});
			for (let p = 0; p < preferredSlavesArray.length; p++) {
				for (let a12 = 0; a12 < availableSlaves.length; a12++) {
					const slave = availableSlaves[a12];
					if (slave.ip === preferredSlavesArray[p].ip) {
						if (slave.port === preferredSlavesArray[p].port) {
							selectedSlave = slave;
							break;
						}
					}
				}
				if (selectedSlave) {
					break;
				}
			}
		}
		if (!selectedSlave) {
			selectedSlave = (0, utils_1.sample)(availableSlaves);
		}
		return addressResponseToAddress(selectedSlave);
	}
	function addressResponseToAddress(input) {
		return { host: input.ip, port: Number(input.port) };
	}
	function noop2() {}
});

// node_modules/ioredis/built/connectors/index.js
var require_connectors = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SentinelConnector = exports.StandaloneConnector = undefined;
	var StandaloneConnector_1 = require_StandaloneConnector();
	exports.StandaloneConnector = StandaloneConnector_1.default;
	var SentinelConnector_1 = require_SentinelConnector();
	exports.SentinelConnector = SentinelConnector_1.default;
});

// node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js
var require_MaxRetriesPerRequestError = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var redis_errors_1 = require_redis_errors();

	class MaxRetriesPerRequestError extends redis_errors_1.AbortError {
		constructor(maxRetriesPerRequest) {
			const message = `Reached the max retries per request limit (which is ${maxRetriesPerRequest}). Refer to "maxRetriesPerRequest" option for details.`;
			super(message);
			Error.captureStackTrace(this, this.constructor);
		}
		get name() {
			return this.constructor.name;
		}
	}
	exports.default = MaxRetriesPerRequestError;
});

// node_modules/ioredis/built/errors/index.js
var require_errors = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.MaxRetriesPerRequestError = undefined;
	var MaxRetriesPerRequestError_1 = require_MaxRetriesPerRequestError();
	exports.MaxRetriesPerRequestError = MaxRetriesPerRequestError_1.default;
});

// node_modules/redis-parser/lib/parser.js
var require_parser2 = __commonJS((exports, module) => {
	var Buffer2 = __require("buffer").Buffer;
	var StringDecoder = __require("string_decoder").StringDecoder;
	var decoder = new StringDecoder();
	var errors2 = require_redis_errors();
	var ReplyError = errors2.ReplyError;
	var ParserError = errors2.ParserError;
	var bufferPool = Buffer2.allocUnsafe(32 * 1024);
	var bufferOffset = 0;
	var interval = null;
	var counter = 0;
	var notDecreased = 0;
	function parseSimpleNumbers(parser) {
		const length = parser.buffer.length - 1;
		var offset = parser.offset;
		var number = 0;
		var sign = 1;
		if (parser.buffer[offset] === 45) {
			sign = -1;
			offset++;
		}
		while (offset < length) {
			const c1 = parser.buffer[offset++];
			if (c1 === 13) {
				parser.offset = offset + 1;
				return sign * number;
			}
			number = number * 10 + (c1 - 48);
		}
	}
	function parseStringNumbers(parser) {
		const length = parser.buffer.length - 1;
		var offset = parser.offset;
		var number = 0;
		var res = "";
		if (parser.buffer[offset] === 45) {
			res += "-";
			offset++;
		}
		while (offset < length) {
			var c1 = parser.buffer[offset++];
			if (c1 === 13) {
				parser.offset = offset + 1;
				if (number !== 0) {
					res += number;
				}
				return res;
			} else if (number > 429496728) {
				res += number * 10 + (c1 - 48);
				number = 0;
			} else if (c1 === 48 && number === 0) {
				res += 0;
			} else {
				number = number * 10 + (c1 - 48);
			}
		}
	}
	function parseSimpleString(parser) {
		const start = parser.offset;
		const buffer = parser.buffer;
		const length = buffer.length - 1;
		var offset = start;
		while (offset < length) {
			if (buffer[offset++] === 13) {
				parser.offset = offset + 1;
				if (parser.optionReturnBuffers === true) {
					return parser.buffer.slice(start, offset - 1);
				}
				return parser.buffer.toString("utf8", start, offset - 1);
			}
		}
	}
	function parseLength(parser) {
		const length = parser.buffer.length - 1;
		var offset = parser.offset;
		var number = 0;
		while (offset < length) {
			const c1 = parser.buffer[offset++];
			if (c1 === 13) {
				parser.offset = offset + 1;
				return number;
			}
			number = number * 10 + (c1 - 48);
		}
	}
	function parseInteger(parser) {
		if (parser.optionStringNumbers === true) {
			return parseStringNumbers(parser);
		}
		return parseSimpleNumbers(parser);
	}
	function parseBulkString(parser) {
		const length = parseLength(parser);
		if (length === undefined) {
			return;
		}
		if (length < 0) {
			return null;
		}
		const offset = parser.offset + length;
		if (offset + 2 > parser.buffer.length) {
			parser.bigStrSize = offset + 2;
			parser.totalChunkSize = parser.buffer.length;
			parser.bufferCache.push(parser.buffer);
			return;
		}
		const start = parser.offset;
		parser.offset = offset + 2;
		if (parser.optionReturnBuffers === true) {
			return parser.buffer.slice(start, offset);
		}
		return parser.buffer.toString("utf8", start, offset);
	}
	function parseError(parser) {
		var string = parseSimpleString(parser);
		if (string !== undefined) {
			if (parser.optionReturnBuffers === true) {
				string = string.toString();
			}
			return new ReplyError(string);
		}
	}
	function handleError(parser, type) {
		const err = new ParserError(
			"Protocol error, got " + JSON.stringify(String.fromCharCode(type)) + " as reply type byte",
			JSON.stringify(parser.buffer),
			parser.offset,
		);
		parser.buffer = null;
		parser.returnFatalError(err);
	}
	function parseArray(parser) {
		const length = parseLength(parser);
		if (length === undefined) {
			return;
		}
		if (length < 0) {
			return null;
		}
		const responses = new Array(length);
		return parseArrayElements(parser, responses, 0);
	}
	function pushArrayCache(parser, array, pos) {
		parser.arrayCache.push(array);
		parser.arrayPos.push(pos);
	}
	function parseArrayChunks(parser) {
		const tmp = parser.arrayCache.pop();
		var pos = parser.arrayPos.pop();
		if (parser.arrayCache.length) {
			const res = parseArrayChunks(parser);
			if (res === undefined) {
				pushArrayCache(parser, tmp, pos);
				return;
			}
			tmp[pos++] = res;
		}
		return parseArrayElements(parser, tmp, pos);
	}
	function parseArrayElements(parser, responses, i) {
		const bufferLength = parser.buffer.length;
		while (i < responses.length) {
			const offset = parser.offset;
			if (parser.offset >= bufferLength) {
				pushArrayCache(parser, responses, i);
				return;
			}
			const response = parseType(parser, parser.buffer[parser.offset++]);
			if (response === undefined) {
				if (!(parser.arrayCache.length || parser.bufferCache.length)) {
					parser.offset = offset;
				}
				pushArrayCache(parser, responses, i);
				return;
			}
			responses[i] = response;
			i++;
		}
		return responses;
	}
	function parseType(parser, type) {
		switch (type) {
			case 36:
				return parseBulkString(parser);
			case 43:
				return parseSimpleString(parser);
			case 42:
				return parseArray(parser);
			case 58:
				return parseInteger(parser);
			case 45:
				return parseError(parser);
			default:
				return handleError(parser, type);
		}
	}
	function decreaseBufferPool() {
		if (bufferPool.length > 50 * 1024) {
			if (counter === 1 || notDecreased > counter * 2) {
				const minSliceLen = Math.floor(bufferPool.length / 10);
				const sliceLength = minSliceLen < bufferOffset ? bufferOffset : minSliceLen;
				bufferOffset = 0;
				bufferPool = bufferPool.slice(sliceLength, bufferPool.length);
			} else {
				notDecreased++;
				counter--;
			}
		} else {
			clearInterval(interval);
			counter = 0;
			notDecreased = 0;
			interval = null;
		}
	}
	function resizeBuffer(length) {
		if (bufferPool.length < length + bufferOffset) {
			const multiplier = length > 1024 * 1024 * 75 ? 2 : 3;
			if (bufferOffset > 1024 * 1024 * 111) {
				bufferOffset = 1024 * 1024 * 50;
			}
			bufferPool = Buffer2.allocUnsafe(length * multiplier + bufferOffset);
			bufferOffset = 0;
			counter++;
			if (interval === null) {
				interval = setInterval(decreaseBufferPool, 50);
			}
		}
	}
	function concatBulkString(parser) {
		const list = parser.bufferCache;
		const oldOffset = parser.offset;
		var chunks = list.length;
		var offset = parser.bigStrSize - parser.totalChunkSize;
		parser.offset = offset;
		if (offset <= 2) {
			if (chunks === 2) {
				return list[0].toString("utf8", oldOffset, list[0].length + offset - 2);
			}
			chunks--;
			offset = list[list.length - 2].length + offset;
		}
		var res = decoder.write(list[0].slice(oldOffset));
		for (var i = 1; i < chunks - 1; i++) {
			res += decoder.write(list[i]);
		}
		res += decoder.end(list[i].slice(0, offset - 2));
		return res;
	}
	function concatBulkBuffer(parser) {
		const list = parser.bufferCache;
		const oldOffset = parser.offset;
		const length = parser.bigStrSize - oldOffset - 2;
		var chunks = list.length;
		var offset = parser.bigStrSize - parser.totalChunkSize;
		parser.offset = offset;
		if (offset <= 2) {
			if (chunks === 2) {
				return list[0].slice(oldOffset, list[0].length + offset - 2);
			}
			chunks--;
			offset = list[list.length - 2].length + offset;
		}
		resizeBuffer(length);
		const start = bufferOffset;
		list[0].copy(bufferPool, start, oldOffset, list[0].length);
		bufferOffset += list[0].length - oldOffset;
		for (var i = 1; i < chunks - 1; i++) {
			list[i].copy(bufferPool, bufferOffset);
			bufferOffset += list[i].length;
		}
		list[i].copy(bufferPool, bufferOffset, 0, offset - 2);
		bufferOffset += offset - 2;
		return bufferPool.slice(start, bufferOffset);
	}

	class JavascriptRedisParser {
		constructor(options) {
			if (!options) {
				throw new TypeError("Options are mandatory.");
			}
			if (typeof options.returnError !== "function" || typeof options.returnReply !== "function") {
				throw new TypeError("The returnReply and returnError options have to be functions.");
			}
			this.setReturnBuffers(!!options.returnBuffers);
			this.setStringNumbers(!!options.stringNumbers);
			this.returnError = options.returnError;
			this.returnFatalError = options.returnFatalError || options.returnError;
			this.returnReply = options.returnReply;
			this.reset();
		}
		reset() {
			this.offset = 0;
			this.buffer = null;
			this.bigStrSize = 0;
			this.totalChunkSize = 0;
			this.bufferCache = [];
			this.arrayCache = [];
			this.arrayPos = [];
		}
		setReturnBuffers(returnBuffers) {
			if (typeof returnBuffers !== "boolean") {
				throw new TypeError("The returnBuffers argument has to be a boolean");
			}
			this.optionReturnBuffers = returnBuffers;
		}
		setStringNumbers(stringNumbers) {
			if (typeof stringNumbers !== "boolean") {
				throw new TypeError("The stringNumbers argument has to be a boolean");
			}
			this.optionStringNumbers = stringNumbers;
		}
		execute(buffer) {
			if (this.buffer === null) {
				this.buffer = buffer;
				this.offset = 0;
			} else if (this.bigStrSize === 0) {
				const oldLength = this.buffer.length;
				const remainingLength = oldLength - this.offset;
				const newBuffer = Buffer2.allocUnsafe(remainingLength + buffer.length);
				this.buffer.copy(newBuffer, 0, this.offset, oldLength);
				buffer.copy(newBuffer, remainingLength, 0, buffer.length);
				this.buffer = newBuffer;
				this.offset = 0;
				if (this.arrayCache.length) {
					const arr = parseArrayChunks(this);
					if (arr === undefined) {
						return;
					}
					this.returnReply(arr);
				}
			} else if (this.totalChunkSize + buffer.length >= this.bigStrSize) {
				this.bufferCache.push(buffer);
				var tmp = this.optionReturnBuffers ? concatBulkBuffer(this) : concatBulkString(this);
				this.bigStrSize = 0;
				this.bufferCache = [];
				this.buffer = buffer;
				if (this.arrayCache.length) {
					this.arrayCache[0][this.arrayPos[0]++] = tmp;
					tmp = parseArrayChunks(this);
					if (tmp === undefined) {
						return;
					}
				}
				this.returnReply(tmp);
			} else {
				this.bufferCache.push(buffer);
				this.totalChunkSize += buffer.length;
				return;
			}
			while (this.offset < this.buffer.length) {
				const offset = this.offset;
				const type = this.buffer[this.offset++];
				const response = parseType(this, type);
				if (response === undefined) {
					if (!(this.arrayCache.length || this.bufferCache.length)) {
						this.offset = offset;
					}
					return;
				}
				if (type === 45) {
					this.returnError(response);
				} else {
					this.returnReply(response);
				}
			}
			this.buffer = null;
		}
	}
	module.exports = JavascriptRedisParser;
});

// node_modules/ioredis/built/SubscriptionSet.js
var require_SubscriptionSet = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });

	class SubscriptionSet {
		constructor() {
			this.set = {
				subscribe: {},
				psubscribe: {},
				ssubscribe: {},
			};
		}
		add(set2, channel) {
			this.set[mapSet(set2)][channel] = true;
		}
		del(set2, channel) {
			delete this.set[mapSet(set2)][channel];
		}
		channels(set2) {
			return Object.keys(this.set[mapSet(set2)]);
		}
		isEmpty() {
			return (
				this.channels("subscribe").length === 0 &&
				this.channels("psubscribe").length === 0 &&
				this.channels("ssubscribe").length === 0
			);
		}
	}
	exports.default = SubscriptionSet;
	function mapSet(set2) {
		if (set2 === "unsubscribe") {
			return "subscribe";
		}
		if (set2 === "punsubscribe") {
			return "psubscribe";
		}
		if (set2 === "sunsubscribe") {
			return "ssubscribe";
		}
		return set2;
	}
});

// node_modules/ioredis/built/DataHandler.js
var require_DataHandler = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var Command_1 = require_Command();
	var utils_1 = require_utils2();
	var RedisParser = require_parser2();
	var SubscriptionSet_1 = require_SubscriptionSet();
	var debug2 = (0, utils_1.Debug)("dataHandler");

	class DataHandler {
		constructor(redis, parserOptions) {
			this.redis = redis;
			const parser = new RedisParser({
				stringNumbers: parserOptions.stringNumbers,
				returnBuffers: true,
				returnError: (err) => {
					this.returnError(err);
				},
				returnFatalError: (err) => {
					this.returnFatalError(err);
				},
				returnReply: (reply) => {
					this.returnReply(reply);
				},
			});
			redis.stream.prependListener("data", (data) => {
				parser.execute(data);
			});
			redis.stream.resume();
		}
		returnFatalError(err) {
			err.message += ". Please report this.";
			this.redis.recoverFromFatalError(err, err, { offlineQueue: false });
		}
		returnError(err) {
			const item = this.shiftCommand(err);
			if (!item) {
				return;
			}
			err.command = {
				name: item.command.name,
				args: item.command.args,
			};
			if (item.command.name == "ssubscribe" && err.message.includes("MOVED")) {
				this.redis.emit("moved");
				return;
			}
			this.redis.handleReconnection(err, item);
		}
		returnReply(reply) {
			if (this.handleMonitorReply(reply)) {
				return;
			}
			if (this.handleSubscriberReply(reply)) {
				return;
			}
			const item = this.shiftCommand(reply);
			if (!item) {
				return;
			}
			if (Command_1.default.checkFlag("ENTER_SUBSCRIBER_MODE", item.command.name)) {
				this.redis.condition.subscriber = new SubscriptionSet_1.default();
				this.redis.condition.subscriber.add(item.command.name, reply[1].toString());
				if (!fillSubCommand(item.command, reply[2])) {
					this.redis.commandQueue.unshift(item);
				}
			} else if (Command_1.default.checkFlag("EXIT_SUBSCRIBER_MODE", item.command.name)) {
				if (!fillUnsubCommand(item.command, reply[2])) {
					this.redis.commandQueue.unshift(item);
				}
			} else {
				item.command.resolve(reply);
			}
		}
		handleSubscriberReply(reply) {
			if (!this.redis.condition.subscriber) {
				return false;
			}
			const replyType = Array.isArray(reply) ? reply[0].toString() : null;
			debug2('receive reply "%s" in subscriber mode', replyType);
			switch (replyType) {
				case "message":
					if (this.redis.listeners("message").length > 0) {
						this.redis.emit("message", reply[1].toString(), reply[2] ? reply[2].toString() : "");
					}
					this.redis.emit("messageBuffer", reply[1], reply[2]);
					break;
				case "pmessage": {
					const pattern = reply[1].toString();
					if (this.redis.listeners("pmessage").length > 0) {
						this.redis.emit("pmessage", pattern, reply[2].toString(), reply[3].toString());
					}
					this.redis.emit("pmessageBuffer", pattern, reply[2], reply[3]);
					break;
				}
				case "smessage": {
					if (this.redis.listeners("smessage").length > 0) {
						this.redis.emit("smessage", reply[1].toString(), reply[2] ? reply[2].toString() : "");
					}
					this.redis.emit("smessageBuffer", reply[1], reply[2]);
					break;
				}
				case "ssubscribe":
				case "subscribe":
				case "psubscribe": {
					const channel = reply[1].toString();
					this.redis.condition.subscriber.add(replyType, channel);
					const item = this.shiftCommand(reply);
					if (!item) {
						return;
					}
					if (!fillSubCommand(item.command, reply[2])) {
						this.redis.commandQueue.unshift(item);
					}
					break;
				}
				case "sunsubscribe":
				case "unsubscribe":
				case "punsubscribe": {
					const channel = reply[1] ? reply[1].toString() : null;
					if (channel) {
						this.redis.condition.subscriber.del(replyType, channel);
					}
					const count = reply[2];
					if (Number(count) === 0) {
						this.redis.condition.subscriber = false;
					}
					const item = this.shiftCommand(reply);
					if (!item) {
						return;
					}
					if (!fillUnsubCommand(item.command, count)) {
						this.redis.commandQueue.unshift(item);
					}
					break;
				}
				default: {
					const item = this.shiftCommand(reply);
					if (!item) {
						return;
					}
					item.command.resolve(reply);
				}
			}
			return true;
		}
		handleMonitorReply(reply) {
			if (this.redis.status !== "monitoring") {
				return false;
			}
			const replyStr = reply.toString();
			if (replyStr === "OK") {
				return false;
			}
			const len = replyStr.indexOf(" ");
			const timestamp = replyStr.slice(0, len);
			const argIndex = replyStr.indexOf('"');
			const args = replyStr
				.slice(argIndex + 1, -1)
				.split('" "')
				.map((elem) => elem.replace(/\\"/g, '"'));
			const dbAndSource = replyStr.slice(len + 2, argIndex - 2).split(" ");
			this.redis.emit("monitor", timestamp, args, dbAndSource[1], dbAndSource[0]);
			return true;
		}
		shiftCommand(reply) {
			const item = this.redis.commandQueue.shift();
			if (!item) {
				const message = "Command queue state error. If you can reproduce this, please report it.";
				const error = new Error(
					message +
						(reply instanceof Error
							? ` Last error: ${reply.message}`
							: ` Last reply: ${reply.toString()}`),
				);
				this.redis.emit("error", error);
				return null;
			}
			return item;
		}
	}
	exports.default = DataHandler;
	var remainingRepliesMap = new WeakMap();
	function fillSubCommand(command, count) {
		let remainingReplies = remainingRepliesMap.has(command)
			? remainingRepliesMap.get(command)
			: command.args.length;
		remainingReplies -= 1;
		if (remainingReplies <= 0) {
			command.resolve(count);
			remainingRepliesMap.delete(command);
			return true;
		}
		remainingRepliesMap.set(command, remainingReplies);
		return false;
	}
	function fillUnsubCommand(command, count) {
		let remainingReplies = remainingRepliesMap.has(command)
			? remainingRepliesMap.get(command)
			: command.args.length;
		if (remainingReplies === 0) {
			if (Number(count) === 0) {
				remainingRepliesMap.delete(command);
				command.resolve(count);
				return true;
			}
			return false;
		}
		remainingReplies -= 1;
		if (remainingReplies <= 0) {
			command.resolve(count);
			return true;
		}
		remainingRepliesMap.set(command, remainingReplies);
		return false;
	}
});

// node_modules/ioredis/built/redis/event_handler.js
var require_event_handler = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.readyHandler =
		exports.errorHandler =
		exports.closeHandler =
		exports.connectHandler =
			undefined;
	var redis_errors_1 = require_redis_errors();
	var Command_1 = require_Command();
	var errors_1 = require_errors();
	var utils_1 = require_utils2();
	var DataHandler_1 = require_DataHandler();
	var debug2 = (0, utils_1.Debug)("connection");
	function connectHandler(self2) {
		return function () {
			var _a;
			self2.setStatus("connect");
			self2.resetCommandQueue();
			let flushed = false;
			const { connectionEpoch } = self2;
			if (self2.condition.auth) {
				self2.auth(self2.condition.auth, function (err) {
					if (connectionEpoch !== self2.connectionEpoch) {
						return;
					}
					if (err) {
						if (err.message.indexOf("no password is set") !== -1) {
							console.warn(
								"[WARN] Redis server does not require a password, but a password was supplied.",
							);
						} else if (
							err.message.indexOf("without any password configured for the default user") !== -1
						) {
							console.warn(
								"[WARN] This Redis server's `default` user does not require a password, but a password was supplied",
							);
						} else if (err.message.indexOf("wrong number of arguments for 'auth' command") !== -1) {
							console.warn(
								"[ERROR] The server returned \"wrong number of arguments for 'auth' command\". You are probably passing both username and password to Redis version 5 or below. You should only pass the 'password' option for Redis version 5 and under.",
							);
						} else {
							flushed = true;
							self2.recoverFromFatalError(err, err);
						}
					}
				});
			}
			if (self2.condition.select) {
				self2.select(self2.condition.select).catch((err) => {
					self2.silentEmit("error", err);
				});
			}
			new DataHandler_1.default(self2, {
				stringNumbers: self2.options.stringNumbers,
			});
			const clientCommandPromises = [];
			if (self2.options.connectionName) {
				debug2("set the connection name [%s]", self2.options.connectionName);
				clientCommandPromises.push(
					self2.client("setname", self2.options.connectionName).catch(utils_1.noop),
				);
			}
			if (!self2.options.disableClientInfo) {
				debug2("set the client info");
				clientCommandPromises.push(
					(0, utils_1.getPackageMeta)()
						.then((packageMeta) => {
							return self2.client("SETINFO", "LIB-VER", packageMeta.version).catch(utils_1.noop);
						})
						.catch(utils_1.noop),
				);
				clientCommandPromises.push(
					self2
						.client(
							"SETINFO",
							"LIB-NAME",
							((_a = self2.options) === null || _a === undefined ? undefined : _a.clientInfoTag)
								? `ioredis(${self2.options.clientInfoTag})`
								: "ioredis",
						)
						.catch(utils_1.noop),
				);
			}
			Promise.all(clientCommandPromises)
				.catch(utils_1.noop)
				.finally(() => {
					if (!self2.options.enableReadyCheck) {
						exports.readyHandler(self2)();
					}
					if (self2.options.enableReadyCheck) {
						self2._readyCheck(function (err, info) {
							if (connectionEpoch !== self2.connectionEpoch) {
								return;
							}
							if (err) {
								if (!flushed) {
									self2.recoverFromFatalError(new Error("Ready check failed: " + err.message), err);
								}
							} else {
								if (self2.connector.check(info)) {
									exports.readyHandler(self2)();
								} else {
									self2.disconnect(true);
								}
							}
						});
					}
				});
		};
	}
	exports.connectHandler = connectHandler;
	function abortError(command) {
		const err = new redis_errors_1.AbortError("Command aborted due to connection close");
		err.command = {
			name: command.name,
			args: command.args,
		};
		return err;
	}
	function abortIncompletePipelines(commandQueue) {
		var _a;
		let expectedIndex = 0;
		for (let i = 0; i < commandQueue.length; ) {
			const command =
				(_a = commandQueue.peekAt(i)) === null || _a === undefined ? undefined : _a.command;
			const pipelineIndex = command.pipelineIndex;
			if (pipelineIndex === undefined || pipelineIndex === 0) {
				expectedIndex = 0;
			}
			if (pipelineIndex !== undefined && pipelineIndex !== expectedIndex++) {
				commandQueue.remove(i, 1);
				command.reject(abortError(command));
				continue;
			}
			i++;
		}
	}
	function abortTransactionFragments(commandQueue) {
		var _a;
		for (let i = 0; i < commandQueue.length; ) {
			const command =
				(_a = commandQueue.peekAt(i)) === null || _a === undefined ? undefined : _a.command;
			if (command.name === "multi") {
				break;
			}
			if (command.name === "exec") {
				commandQueue.remove(i, 1);
				command.reject(abortError(command));
				break;
			}
			if (command.inTransaction) {
				commandQueue.remove(i, 1);
				command.reject(abortError(command));
			} else {
				i++;
			}
		}
	}
	function closeHandler(self2) {
		return function () {
			const prevStatus = self2.status;
			self2.setStatus("close");
			if (self2.commandQueue.length) {
				abortIncompletePipelines(self2.commandQueue);
			}
			if (self2.offlineQueue.length) {
				abortTransactionFragments(self2.offlineQueue);
			}
			if (prevStatus === "ready") {
				if (!self2.prevCondition) {
					self2.prevCondition = self2.condition;
				}
				if (self2.commandQueue.length) {
					self2.prevCommandQueue = self2.commandQueue;
				}
			}
			if (self2.manuallyClosing) {
				self2.manuallyClosing = false;
				debug2("skip reconnecting since the connection is manually closed.");
				return close();
			}
			if (typeof self2.options.retryStrategy !== "function") {
				debug2("skip reconnecting because `retryStrategy` is not a function");
				return close();
			}
			const retryDelay = self2.options.retryStrategy(++self2.retryAttempts);
			if (typeof retryDelay !== "number") {
				debug2("skip reconnecting because `retryStrategy` doesn't return a number");
				return close();
			}
			debug2("reconnect in %sms", retryDelay);
			self2.setStatus("reconnecting", retryDelay);
			self2.reconnectTimeout = setTimeout(function () {
				self2.reconnectTimeout = null;
				self2.connect().catch(utils_1.noop);
			}, retryDelay);
			const { maxRetriesPerRequest } = self2.options;
			if (typeof maxRetriesPerRequest === "number") {
				if (maxRetriesPerRequest < 0) {
					debug2("maxRetriesPerRequest is negative, ignoring...");
				} else {
					const remainder = self2.retryAttempts % (maxRetriesPerRequest + 1);
					if (remainder === 0) {
						debug2("reach maxRetriesPerRequest limitation, flushing command queue...");
						self2.flushQueue(new errors_1.MaxRetriesPerRequestError(maxRetriesPerRequest));
					}
				}
			}
		};
		function close() {
			self2.setStatus("end");
			self2.flushQueue(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
		}
	}
	exports.closeHandler = closeHandler;
	function errorHandler(self2) {
		return function (error) {
			debug2("error: %s", error);
			self2.silentEmit("error", error);
		};
	}
	exports.errorHandler = errorHandler;
	function readyHandler(self2) {
		return function () {
			self2.setStatus("ready");
			self2.retryAttempts = 0;
			if (self2.options.monitor) {
				self2.call("monitor").then(
					() => self2.setStatus("monitoring"),
					(error) => self2.emit("error", error),
				);
				const { sendCommand } = self2;
				self2.sendCommand = function (command) {
					if (Command_1.default.checkFlag("VALID_IN_MONITOR_MODE", command.name)) {
						return sendCommand.call(self2, command);
					}
					command.reject(new Error("Connection is in monitoring mode, can't process commands."));
					return command.promise;
				};
				self2.once("close", function () {
					delete self2.sendCommand;
				});
				return;
			}
			const finalSelect = self2.prevCondition ? self2.prevCondition.select : self2.condition.select;
			if (self2.options.readOnly) {
				debug2("set the connection to readonly mode");
				self2.readonly().catch(utils_1.noop);
			}
			if (self2.prevCondition) {
				const condition = self2.prevCondition;
				self2.prevCondition = null;
				if (condition.subscriber && self2.options.autoResubscribe) {
					if (self2.condition.select !== finalSelect) {
						debug2("connect to db [%d]", finalSelect);
						self2.select(finalSelect);
					}
					const subscribeChannels = condition.subscriber.channels("subscribe");
					if (subscribeChannels.length) {
						debug2("subscribe %d channels", subscribeChannels.length);
						self2.subscribe(subscribeChannels);
					}
					const psubscribeChannels = condition.subscriber.channels("psubscribe");
					if (psubscribeChannels.length) {
						debug2("psubscribe %d channels", psubscribeChannels.length);
						self2.psubscribe(psubscribeChannels);
					}
					const ssubscribeChannels = condition.subscriber.channels("ssubscribe");
					if (ssubscribeChannels.length) {
						debug2("ssubscribe %s", ssubscribeChannels.length);
						for (const channel of ssubscribeChannels) {
							self2.ssubscribe(channel);
						}
					}
				}
			}
			if (self2.prevCommandQueue) {
				if (self2.options.autoResendUnfulfilledCommands) {
					debug2("resend %d unfulfilled commands", self2.prevCommandQueue.length);
					while (self2.prevCommandQueue.length > 0) {
						const item = self2.prevCommandQueue.shift();
						if (item.select !== self2.condition.select && item.command.name !== "select") {
							self2.select(item.select);
						}
						self2.sendCommand(item.command, item.stream);
					}
				} else {
					self2.prevCommandQueue = null;
				}
			}
			if (self2.offlineQueue.length) {
				debug2("send %d commands in offline queue", self2.offlineQueue.length);
				const offlineQueue = self2.offlineQueue;
				self2.resetOfflineQueue();
				while (offlineQueue.length > 0) {
					const item = offlineQueue.shift();
					if (item.select !== self2.condition.select && item.command.name !== "select") {
						self2.select(item.select);
					}
					self2.sendCommand(item.command, item.stream);
				}
			}
			if (self2.condition.select !== finalSelect) {
				debug2("connect to db [%d]", finalSelect);
				self2.select(finalSelect);
			}
		};
	}
	exports.readyHandler = readyHandler;
});

// node_modules/ioredis/built/redis/RedisOptions.js
var require_RedisOptions = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.DEFAULT_REDIS_OPTIONS = undefined;
	exports.DEFAULT_REDIS_OPTIONS = {
		port: 6379,
		host: "localhost",
		family: 0,
		connectTimeout: 1e4,
		disconnectTimeout: 2000,
		retryStrategy: function (times) {
			return Math.min(times * 50, 2000);
		},
		keepAlive: 0,
		noDelay: true,
		connectionName: null,
		disableClientInfo: false,
		clientInfoTag: undefined,
		sentinels: null,
		name: null,
		role: "master",
		sentinelRetryStrategy: function (times) {
			return Math.min(times * 10, 1000);
		},
		sentinelReconnectStrategy: function () {
			return 60000;
		},
		natMap: null,
		enableTLSForSentinelMode: false,
		updateSentinels: true,
		failoverDetector: false,
		username: null,
		password: null,
		db: 0,
		enableOfflineQueue: true,
		enableReadyCheck: true,
		autoResubscribe: true,
		autoResendUnfulfilledCommands: true,
		lazyConnect: false,
		keyPrefix: "",
		reconnectOnError: null,
		readOnly: false,
		stringNumbers: false,
		maxRetriesPerRequest: 20,
		maxLoadingRetryTime: 1e4,
		enableAutoPipelining: false,
		autoPipeliningIgnoredCommands: [],
		sentinelMaxConnections: 10,
	};
});

// node_modules/ioredis/built/Redis.js
var require_Redis = __commonJS((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	var commands_1 = require_built();
	var events_1 = __require("events");
	var standard_as_callback_1 = require_built2();
	var cluster_1 = require_cluster();
	var Command_1 = require_Command();
	var connectors_1 = require_connectors();
	var SentinelConnector_1 = require_SentinelConnector();
	var eventHandler = require_event_handler();
	var RedisOptions_1 = require_RedisOptions();
	var ScanStream_1 = require_ScanStream();
	var transaction_1 = require_transaction();
	var utils_1 = require_utils2();
	var applyMixin_1 = require_applyMixin();
	var Commander_1 = require_Commander();
	var lodash_1 = require_lodash10();
	var Deque = require_denque();
	var debug2 = (0, utils_1.Debug)("redis");

	class Redis extends Commander_1.default {
		constructor(arg1, arg2, arg3) {
			super();
			this.status = "wait";
			this.isCluster = false;
			this.reconnectTimeout = null;
			this.connectionEpoch = 0;
			this.retryAttempts = 0;
			this.manuallyClosing = false;
			this._autoPipelines = new Map();
			this._runningAutoPipelines = new Set();
			this.parseOptions(arg1, arg2, arg3);
			events_1.EventEmitter.call(this);
			this.resetCommandQueue();
			this.resetOfflineQueue();
			if (this.options.Connector) {
				this.connector = new this.options.Connector(this.options);
			} else if (this.options.sentinels) {
				const sentinelConnector = new SentinelConnector_1.default(this.options);
				sentinelConnector.emitter = this;
				this.connector = sentinelConnector;
			} else {
				this.connector = new connectors_1.StandaloneConnector(this.options);
			}
			if (this.options.scripts) {
				Object.entries(this.options.scripts).forEach(([name, definition]) => {
					this.defineCommand(name, definition);
				});
			}
			if (this.options.lazyConnect) {
				this.setStatus("wait");
			} else {
				this.connect().catch(lodash_1.noop);
			}
		}
		static createClient(...args) {
			return new Redis(...args);
		}
		get autoPipelineQueueSize() {
			let queued = 0;
			for (const pipeline2 of this._autoPipelines.values()) {
				queued += pipeline2.length;
			}
			return queued;
		}
		connect(callback) {
			const promise = new Promise((resolve, reject) => {
				if (this.status === "connecting" || this.status === "connect" || this.status === "ready") {
					reject(new Error("Redis is already connecting/connected"));
					return;
				}
				this.connectionEpoch += 1;
				this.setStatus("connecting");
				const { options } = this;
				this.condition = {
					select: options.db,
					auth: options.username ? [options.username, options.password] : options.password,
					subscriber: false,
				};
				const _this = this;
				(0, standard_as_callback_1.default)(
					this.connector.connect(function (type, err) {
						_this.silentEmit(type, err);
					}),
					function (err, stream4) {
						if (err) {
							_this.flushQueue(err);
							_this.silentEmit("error", err);
							reject(err);
							_this.setStatus("end");
							return;
						}
						let CONNECT_EVENT = options.tls ? "secureConnect" : "connect";
						if ("sentinels" in options && options.sentinels && !options.enableTLSForSentinelMode) {
							CONNECT_EVENT = "connect";
						}
						_this.stream = stream4;
						if (options.noDelay) {
							stream4.setNoDelay(true);
						}
						if (typeof options.keepAlive === "number") {
							if (stream4.connecting) {
								stream4.once(CONNECT_EVENT, () => {
									stream4.setKeepAlive(true, options.keepAlive);
								});
							} else {
								stream4.setKeepAlive(true, options.keepAlive);
							}
						}
						if (stream4.connecting) {
							stream4.once(CONNECT_EVENT, eventHandler.connectHandler(_this));
							if (options.connectTimeout) {
								let connectTimeoutCleared = false;
								stream4.setTimeout(options.connectTimeout, function () {
									if (connectTimeoutCleared) {
										return;
									}
									stream4.setTimeout(0);
									stream4.destroy();
									const err2 = new Error("connect ETIMEDOUT");
									err2.errorno = "ETIMEDOUT";
									err2.code = "ETIMEDOUT";
									err2.syscall = "connect";
									eventHandler.errorHandler(_this)(err2);
								});
								stream4.once(CONNECT_EVENT, function () {
									connectTimeoutCleared = true;
									stream4.setTimeout(0);
								});
							}
						} else if (stream4.destroyed) {
							const firstError = _this.connector.firstError;
							if (firstError) {
								process.nextTick(() => {
									eventHandler.errorHandler(_this)(firstError);
								});
							}
							process.nextTick(eventHandler.closeHandler(_this));
						} else {
							process.nextTick(eventHandler.connectHandler(_this));
						}
						if (!stream4.destroyed) {
							stream4.once("error", eventHandler.errorHandler(_this));
							stream4.once("close", eventHandler.closeHandler(_this));
						}
						const connectionReadyHandler = function () {
							_this.removeListener("close", connectionCloseHandler);
							resolve();
						};
						var connectionCloseHandler = function () {
							_this.removeListener("ready", connectionReadyHandler);
							reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
						};
						_this.once("ready", connectionReadyHandler);
						_this.once("close", connectionCloseHandler);
					},
				);
			});
			return (0, standard_as_callback_1.default)(promise, callback);
		}
		disconnect(reconnect = false) {
			if (!reconnect) {
				this.manuallyClosing = true;
			}
			if (this.reconnectTimeout && !reconnect) {
				clearTimeout(this.reconnectTimeout);
				this.reconnectTimeout = null;
			}
			if (this.status === "wait") {
				eventHandler.closeHandler(this)();
			} else {
				this.connector.disconnect();
			}
		}
		end() {
			this.disconnect();
		}
		duplicate(override) {
			return new Redis({ ...this.options, ...override });
		}
		get mode() {
			var _a;
			return this.options.monitor
				? "monitor"
				: ((_a = this.condition) === null || _a === undefined ? undefined : _a.subscriber)
					? "subscriber"
					: "normal";
		}
		monitor(callback) {
			const monitorInstance = this.duplicate({
				monitor: true,
				lazyConnect: false,
			});
			return (0, standard_as_callback_1.default)(
				new Promise(function (resolve, reject) {
					monitorInstance.once("error", reject);
					monitorInstance.once("monitoring", function () {
						resolve(monitorInstance);
					});
				}),
				callback,
			);
		}
		sendCommand(command, stream4) {
			var _a, _b;
			if (this.status === "wait") {
				this.connect().catch(lodash_1.noop);
			}
			if (this.status === "end") {
				command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
				return command.promise;
			}
			if (
				((_a = this.condition) === null || _a === undefined ? undefined : _a.subscriber) &&
				!Command_1.default.checkFlag("VALID_IN_SUBSCRIBER_MODE", command.name)
			) {
				command.reject(
					new Error("Connection in subscriber mode, only subscriber commands may be used"),
				);
				return command.promise;
			}
			if (typeof this.options.commandTimeout === "number") {
				command.setTimeout(this.options.commandTimeout);
			}
			let writable =
				this.status === "ready" ||
				(!stream4 &&
					this.status === "connect" &&
					(0, commands_1.exists)(command.name) &&
					((0, commands_1.hasFlag)(command.name, "loading") ||
						Command_1.default.checkFlag("HANDSHAKE_COMMANDS", command.name)));
			if (!this.stream) {
				writable = false;
			} else if (!this.stream.writable) {
				writable = false;
			} else if (this.stream._writableState && this.stream._writableState.ended) {
				writable = false;
			}
			if (!writable) {
				if (!this.options.enableOfflineQueue) {
					command.reject(
						new Error("Stream isn't writeable and enableOfflineQueue options is false"),
					);
					return command.promise;
				}
				if (command.name === "quit" && this.offlineQueue.length === 0) {
					this.disconnect();
					command.resolve(Buffer.from("OK"));
					return command.promise;
				}
				if (debug2.enabled) {
					debug2(
						"queue command[%s]: %d -> %s(%o)",
						this._getDescription(),
						this.condition.select,
						command.name,
						command.args,
					);
				}
				this.offlineQueue.push({
					command,
					stream: stream4,
					select: this.condition.select,
				});
			} else {
				if (debug2.enabled) {
					debug2(
						"write command[%s]: %d -> %s(%o)",
						this._getDescription(),
						(_b = this.condition) === null || _b === undefined ? undefined : _b.select,
						command.name,
						command.args,
					);
				}
				if (stream4) {
					if ("isPipeline" in stream4 && stream4.isPipeline) {
						stream4.write(command.toWritable(stream4.destination.redis.stream));
					} else {
						stream4.write(command.toWritable(stream4));
					}
				} else {
					this.stream.write(command.toWritable(this.stream));
				}
				this.commandQueue.push({
					command,
					stream: stream4,
					select: this.condition.select,
				});
				if (Command_1.default.checkFlag("WILL_DISCONNECT", command.name)) {
					this.manuallyClosing = true;
				}
				if (this.options.socketTimeout !== undefined && this.socketTimeoutTimer === undefined) {
					this.setSocketTimeout();
				}
			}
			if (command.name === "select" && (0, utils_1.isInt)(command.args[0])) {
				const db = parseInt(command.args[0], 10);
				if (this.condition.select !== db) {
					this.condition.select = db;
					this.emit("select", db);
					debug2("switch to db [%d]", this.condition.select);
				}
			}
			return command.promise;
		}
		setSocketTimeout() {
			this.socketTimeoutTimer = setTimeout(() => {
				this.stream.destroy(
					new Error(
						`Socket timeout. Expecting data, but didn't receive any in ${this.options.socketTimeout}ms.`,
					),
				);
				this.socketTimeoutTimer = undefined;
			}, this.options.socketTimeout);
			this.stream.once("data", () => {
				clearTimeout(this.socketTimeoutTimer);
				this.socketTimeoutTimer = undefined;
				if (this.commandQueue.length === 0) return;
				this.setSocketTimeout();
			});
		}
		scanStream(options) {
			return this.createScanStream("scan", { options });
		}
		scanBufferStream(options) {
			return this.createScanStream("scanBuffer", { options });
		}
		sscanStream(key, options) {
			return this.createScanStream("sscan", { key, options });
		}
		sscanBufferStream(key, options) {
			return this.createScanStream("sscanBuffer", { key, options });
		}
		hscanStream(key, options) {
			return this.createScanStream("hscan", { key, options });
		}
		hscanBufferStream(key, options) {
			return this.createScanStream("hscanBuffer", { key, options });
		}
		zscanStream(key, options) {
			return this.createScanStream("zscan", { key, options });
		}
		zscanBufferStream(key, options) {
			return this.createScanStream("zscanBuffer", { key, options });
		}
		silentEmit(eventName, arg) {
			let error;
			if (eventName === "error") {
				error = arg;
				if (this.status === "end") {
					return;
				}
				if (this.manuallyClosing) {
					if (
						error instanceof Error &&
						(error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG ||
							error.syscall === "connect" ||
							error.syscall === "read")
					) {
						return;
					}
				}
			}
			if (this.listeners(eventName).length > 0) {
				return this.emit.apply(this, arguments);
			}
			if (error && error instanceof Error) {
				console.error("[ioredis] Unhandled error event:", error.stack);
			}
			return false;
		}
		recoverFromFatalError(_commandError, err, options) {
			this.flushQueue(err, options);
			this.silentEmit("error", err);
			this.disconnect(true);
		}
		handleReconnection(err, item) {
			var _a;
			let needReconnect = false;
			if (
				this.options.reconnectOnError &&
				!Command_1.default.checkFlag("IGNORE_RECONNECT_ON_ERROR", item.command.name)
			) {
				needReconnect = this.options.reconnectOnError(err);
			}
			switch (needReconnect) {
				case 1:
				case true:
					if (this.status !== "reconnecting") {
						this.disconnect(true);
					}
					item.command.reject(err);
					break;
				case 2:
					if (this.status !== "reconnecting") {
						this.disconnect(true);
					}
					if (
						((_a = this.condition) === null || _a === undefined ? undefined : _a.select) !==
							item.select &&
						item.command.name !== "select"
					) {
						this.select(item.select);
					}
					this.sendCommand(item.command);
					break;
				default:
					item.command.reject(err);
			}
		}
		_getDescription() {
			let description;
			if ("path" in this.options && this.options.path) {
				description = this.options.path;
			} else if (this.stream && this.stream.remoteAddress && this.stream.remotePort) {
				description = this.stream.remoteAddress + ":" + this.stream.remotePort;
			} else if ("host" in this.options && this.options.host) {
				description = this.options.host + ":" + this.options.port;
			} else {
				description = "";
			}
			if (this.options.connectionName) {
				description += ` (${this.options.connectionName})`;
			}
			return description;
		}
		resetCommandQueue() {
			this.commandQueue = new Deque();
		}
		resetOfflineQueue() {
			this.offlineQueue = new Deque();
		}
		parseOptions(...args) {
			const options = {};
			let isTls = false;
			for (let i = 0; i < args.length; ++i) {
				const arg = args[i];
				if (arg === null || typeof arg === "undefined") {
					continue;
				}
				if (typeof arg === "object") {
					(0, lodash_1.defaults)(options, arg);
				} else if (typeof arg === "string") {
					(0, lodash_1.defaults)(options, (0, utils_1.parseURL)(arg));
					if (arg.startsWith("rediss://")) {
						isTls = true;
					}
				} else if (typeof arg === "number") {
					options.port = arg;
				} else {
					throw new Error("Invalid argument " + arg);
				}
			}
			if (isTls) {
				(0, lodash_1.defaults)(options, { tls: true });
			}
			(0, lodash_1.defaults)(options, Redis.defaultOptions);
			if (typeof options.port === "string") {
				options.port = parseInt(options.port, 10);
			}
			if (typeof options.db === "string") {
				options.db = parseInt(options.db, 10);
			}
			this.options = (0, utils_1.resolveTLSProfile)(options);
		}
		setStatus(status2, arg) {
			if (debug2.enabled) {
				debug2("status[%s]: %s -> %s", this._getDescription(), this.status || "[empty]", status2);
			}
			this.status = status2;
			process.nextTick(this.emit.bind(this, status2, arg));
		}
		createScanStream(command, { key, options = {} }) {
			return new ScanStream_1.default({
				objectMode: true,
				key,
				redis: this,
				command,
				...options,
			});
		}
		flushQueue(error, options) {
			options = (0, lodash_1.defaults)({}, options, {
				offlineQueue: true,
				commandQueue: true,
			});
			let item;
			if (options.offlineQueue) {
				while ((item = this.offlineQueue.shift())) {
					item.command.reject(error);
				}
			}
			if (options.commandQueue) {
				if (this.commandQueue.length > 0) {
					if (this.stream) {
						this.stream.removeAllListeners("data");
					}
					while ((item = this.commandQueue.shift())) {
						item.command.reject(error);
					}
				}
			}
		}
		_readyCheck(callback) {
			const _this = this;
			this.info(function (err, res) {
				if (err) {
					if (err.message && err.message.includes("NOPERM")) {
						console.warn(
							`Skipping the ready check because INFO command fails: "${err.message}". You can disable ready check with "enableReadyCheck". More: https://github.com/luin/ioredis/wiki/Disable-ready-check.`,
						);
						return callback(null, {});
					}
					return callback(err);
				}
				if (typeof res !== "string") {
					return callback(null, res);
				}
				const info = {};
				const lines = res.split(`\r
`);
				for (let i = 0; i < lines.length; ++i) {
					const [fieldName, ...fieldValueParts] = lines[i].split(":");
					const fieldValue = fieldValueParts.join(":");
					if (fieldValue) {
						info[fieldName] = fieldValue;
					}
				}
				if (!info.loading || info.loading === "0") {
					callback(null, info);
				} else {
					const loadingEtaMs = (info.loading_eta_seconds || 1) * 1000;
					const retryTime =
						_this.options.maxLoadingRetryTime && _this.options.maxLoadingRetryTime < loadingEtaMs
							? _this.options.maxLoadingRetryTime
							: loadingEtaMs;
					debug2("Redis server still loading, trying again in " + retryTime + "ms");
					setTimeout(function () {
						_this._readyCheck(callback);
					}, retryTime);
				}
			}).catch(lodash_1.noop);
		}
	}
	Redis.Cluster = cluster_1.default;
	Redis.Command = Command_1.default;
	Redis.defaultOptions = RedisOptions_1.DEFAULT_REDIS_OPTIONS;
	(0, applyMixin_1.default)(Redis, events_1.EventEmitter);
	(0, transaction_1.addTransactionSupport)(Redis.prototype);
	exports.default = Redis;
});

// node_modules/ioredis/built/index.js
var require_built3 = __commonJS((exports, module) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.print =
		exports.ReplyError =
		exports.SentinelIterator =
		exports.SentinelConnector =
		exports.AbstractConnector =
		exports.Pipeline =
		exports.ScanStream =
		exports.Command =
		exports.Cluster =
		exports.Redis =
		exports.default =
			undefined;
	exports = module.exports = require_Redis().default;
	var Redis_1 = require_Redis();
	Object.defineProperty(exports, "default", {
		enumerable: true,
		get: function () {
			return Redis_1.default;
		},
	});
	var Redis_2 = require_Redis();
	Object.defineProperty(exports, "Redis", {
		enumerable: true,
		get: function () {
			return Redis_2.default;
		},
	});
	var cluster_1 = require_cluster();
	Object.defineProperty(exports, "Cluster", {
		enumerable: true,
		get: function () {
			return cluster_1.default;
		},
	});
	var Command_1 = require_Command();
	Object.defineProperty(exports, "Command", {
		enumerable: true,
		get: function () {
			return Command_1.default;
		},
	});
	var ScanStream_1 = require_ScanStream();
	Object.defineProperty(exports, "ScanStream", {
		enumerable: true,
		get: function () {
			return ScanStream_1.default;
		},
	});
	var Pipeline_1 = require_Pipeline();
	Object.defineProperty(exports, "Pipeline", {
		enumerable: true,
		get: function () {
			return Pipeline_1.default;
		},
	});
	var AbstractConnector_1 = require_AbstractConnector();
	Object.defineProperty(exports, "AbstractConnector", {
		enumerable: true,
		get: function () {
			return AbstractConnector_1.default;
		},
	});
	var SentinelConnector_1 = require_SentinelConnector();
	Object.defineProperty(exports, "SentinelConnector", {
		enumerable: true,
		get: function () {
			return SentinelConnector_1.default;
		},
	});
	Object.defineProperty(exports, "SentinelIterator", {
		enumerable: true,
		get: function () {
			return SentinelConnector_1.SentinelIterator;
		},
	});
	exports.ReplyError = require_redis_errors().ReplyError;
	Object.defineProperty(exports, "Promise", {
		get() {
			console.warn(
				"ioredis v5 does not support plugging third-party Promise library anymore. Native Promise will be used.",
			);
			return Promise;
		},
		set(_lib) {
			console.warn(
				"ioredis v5 does not support plugging third-party Promise library anymore. Native Promise will be used.",
			);
		},
	});
	function print(err, reply) {
		if (err) {
			console.log("Error: " + err);
		} else {
			console.log("Reply: " + reply);
		}
	}
	exports.print = print;
});

// node_modules/@sinclair/typebox/build/esm/type/guard/value.mjs
var exports_value = {};
__export(exports_value, {
	IsUndefined: () => IsUndefined,
	IsUint8Array: () => IsUint8Array,
	IsSymbol: () => IsSymbol,
	IsString: () => IsString,
	IsRegExp: () => IsRegExp,
	IsObject: () => IsObject,
	IsNumber: () => IsNumber,
	IsNull: () => IsNull,
	IsIterator: () => IsIterator,
	IsFunction: () => IsFunction,
	IsDate: () => IsDate,
	IsBoolean: () => IsBoolean,
	IsBigInt: () => IsBigInt,
	IsAsyncIterator: () => IsAsyncIterator,
	IsArray: () => IsArray,
	HasPropertyKey: () => HasPropertyKey,
});
function HasPropertyKey(value, key) {
	return key in value;
}
function IsAsyncIterator(value) {
	return (
		IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.asyncIterator in value
	);
}
function IsArray(value) {
	return Array.isArray(value);
}
function IsBigInt(value) {
	return typeof value === "bigint";
}
function IsBoolean(value) {
	return typeof value === "boolean";
}
function IsDate(value) {
	return value instanceof globalThis.Date;
}
function IsFunction(value) {
	return typeof value === "function";
}
function IsIterator(value) {
	return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.iterator in value;
}
function IsNull(value) {
	return value === null;
}
function IsNumber(value) {
	return typeof value === "number";
}
function IsObject(value) {
	return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
	return value instanceof globalThis.RegExp;
}
function IsString(value) {
	return typeof value === "string";
}
function IsSymbol(value) {
	return typeof value === "symbol";
}
function IsUint8Array(value) {
	return value instanceof globalThis.Uint8Array;
}
function IsUndefined(value) {
	return value === undefined;
}

// node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
function ArrayType(value) {
	return value.map((value2) => Visit(value2));
}
function DateType(value) {
	return new Date(value.getTime());
}
function Uint8ArrayType(value) {
	return new Uint8Array(value);
}
function RegExpType(value) {
	return new RegExp(value.source, value.flags);
}
function ObjectType(value) {
	const result = {};
	for (const key of Object.getOwnPropertyNames(value)) {
		result[key] = Visit(value[key]);
	}
	for (const key of Object.getOwnPropertySymbols(value)) {
		result[key] = Visit(value[key]);
	}
	return result;
}
function Visit(value) {
	return IsArray(value)
		? ArrayType(value)
		: IsDate(value)
			? DateType(value)
			: IsUint8Array(value)
				? Uint8ArrayType(value)
				: IsRegExp(value)
					? RegExpType(value)
					: IsObject(value)
						? ObjectType(value)
						: value;
}
function Clone(value) {
	return Visit(value);
}

// node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
function CloneType(schema, options) {
	return options === undefined ? Clone(schema) : Clone({ ...options, ...schema });
}

// node_modules/@sinclair/typebox/build/esm/value/guard/guard.mjs
function IsAsyncIterator2(value) {
	return IsObject2(value) && globalThis.Symbol.asyncIterator in value;
}
function IsIterator2(value) {
	return IsObject2(value) && globalThis.Symbol.iterator in value;
}
function IsStandardObject(value) {
	return (
		IsObject2(value) &&
		(globalThis.Object.getPrototypeOf(value) === Object.prototype ||
			globalThis.Object.getPrototypeOf(value) === null)
	);
}
function IsPromise(value) {
	return value instanceof globalThis.Promise;
}
function IsDate2(value) {
	return value instanceof Date && globalThis.Number.isFinite(value.getTime());
}
function IsMap(value) {
	return value instanceof globalThis.Map;
}
function IsSet(value) {
	return value instanceof globalThis.Set;
}
function IsTypedArray(value) {
	return globalThis.ArrayBuffer.isView(value);
}
function IsUint8Array2(value) {
	return value instanceof globalThis.Uint8Array;
}
function HasPropertyKey2(value, key) {
	return key in value;
}
function IsObject2(value) {
	return value !== null && typeof value === "object";
}
function IsArray2(value) {
	return globalThis.Array.isArray(value) && !globalThis.ArrayBuffer.isView(value);
}
function IsUndefined2(value) {
	return value === undefined;
}
function IsNull2(value) {
	return value === null;
}
function IsBoolean2(value) {
	return typeof value === "boolean";
}
function IsNumber2(value) {
	return typeof value === "number";
}
function IsInteger(value) {
	return globalThis.Number.isInteger(value);
}
function IsBigInt2(value) {
	return typeof value === "bigint";
}
function IsString2(value) {
	return typeof value === "string";
}
function IsFunction2(value) {
	return typeof value === "function";
}
function IsSymbol2(value) {
	return typeof value === "symbol";
}
function IsValueType(value) {
	return (
		IsBigInt2(value) ||
		IsBoolean2(value) ||
		IsNull2(value) ||
		IsNumber2(value) ||
		IsString2(value) ||
		IsSymbol2(value) ||
		IsUndefined2(value)
	);
}

// node_modules/@sinclair/typebox/build/esm/system/policy.mjs
var TypeSystemPolicy;
(function (TypeSystemPolicy2) {
	TypeSystemPolicy2.InstanceMode = "default";
	TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
	TypeSystemPolicy2.AllowArrayObject = false;
	TypeSystemPolicy2.AllowNaN = false;
	TypeSystemPolicy2.AllowNullVoid = false;
	function IsExactOptionalProperty(value, key) {
		return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
	}
	TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
	function IsObjectLike(value) {
		const isObject = IsObject2(value);
		return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !IsArray2(value);
	}
	TypeSystemPolicy2.IsObjectLike = IsObjectLike;
	function IsRecordLike(value) {
		return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
	}
	TypeSystemPolicy2.IsRecordLike = IsRecordLike;
	function IsNumberLike(value) {
		return TypeSystemPolicy2.AllowNaN ? IsNumber2(value) : Number.isFinite(value);
	}
	TypeSystemPolicy2.IsNumberLike = IsNumberLike;
	function IsVoidLike(value) {
		const isUndefined = IsUndefined2(value);
		return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
	}
	TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));

// node_modules/@sinclair/typebox/build/esm/type/create/immutable.mjs
function ImmutableArray(value) {
	return globalThis.Object.freeze(value).map((value2) => Immutable(value2));
}
function ImmutableDate(value) {
	return value;
}
function ImmutableUint8Array(value) {
	return value;
}
function ImmutableRegExp(value) {
	return value;
}
function ImmutableObject(value) {
	const result = {};
	for (const key of Object.getOwnPropertyNames(value)) {
		result[key] = Immutable(value[key]);
	}
	for (const key of Object.getOwnPropertySymbols(value)) {
		result[key] = Immutable(value[key]);
	}
	return globalThis.Object.freeze(result);
}
function Immutable(value) {
	return IsArray(value)
		? ImmutableArray(value)
		: IsDate(value)
			? ImmutableDate(value)
			: IsUint8Array(value)
				? ImmutableUint8Array(value)
				: IsRegExp(value)
					? ImmutableRegExp(value)
					: IsObject(value)
						? ImmutableObject(value)
						: value;
}

// node_modules/@sinclair/typebox/build/esm/type/create/type.mjs
function CreateType(schema, options) {
	const result = options !== undefined ? { ...options, ...schema } : schema;
	switch (TypeSystemPolicy.InstanceMode) {
		case "freeze":
			return Immutable(result);
		case "clone":
			return Clone(result);
		default:
			return result;
	}
}

// node_modules/@sinclair/typebox/build/esm/type/error/error.mjs
class TypeBoxError extends Error {
	constructor(message) {
		super(message);
	}
}

// node_modules/@sinclair/typebox/build/esm/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");

// node_modules/@sinclair/typebox/build/esm/type/guard/kind.mjs
function IsReadonly(value) {
	return IsObject(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional(value) {
	return IsObject(value) && value[OptionalKind] === "Optional";
}
function IsAny(value) {
	return IsKindOf(value, "Any");
}
function IsArgument(value) {
	return IsKindOf(value, "Argument");
}
function IsArray3(value) {
	return IsKindOf(value, "Array");
}
function IsAsyncIterator3(value) {
	return IsKindOf(value, "AsyncIterator");
}
function IsBigInt3(value) {
	return IsKindOf(value, "BigInt");
}
function IsBoolean3(value) {
	return IsKindOf(value, "Boolean");
}
function IsComputed(value) {
	return IsKindOf(value, "Computed");
}
function IsConstructor(value) {
	return IsKindOf(value, "Constructor");
}
function IsDate3(value) {
	return IsKindOf(value, "Date");
}
function IsFunction3(value) {
	return IsKindOf(value, "Function");
}
function IsInteger2(value) {
	return IsKindOf(value, "Integer");
}
function IsIntersect(value) {
	return IsKindOf(value, "Intersect");
}
function IsIterator3(value) {
	return IsKindOf(value, "Iterator");
}
function IsKindOf(value, kind) {
	return IsObject(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralValue(value) {
	return IsBoolean(value) || IsNumber(value) || IsString(value);
}
function IsLiteral(value) {
	return IsKindOf(value, "Literal");
}
function IsMappedKey(value) {
	return IsKindOf(value, "MappedKey");
}
function IsMappedResult(value) {
	return IsKindOf(value, "MappedResult");
}
function IsNever(value) {
	return IsKindOf(value, "Never");
}
function IsNot(value) {
	return IsKindOf(value, "Not");
}
function IsNull3(value) {
	return IsKindOf(value, "Null");
}
function IsNumber3(value) {
	return IsKindOf(value, "Number");
}
function IsObject3(value) {
	return IsKindOf(value, "Object");
}
function IsPromise2(value) {
	return IsKindOf(value, "Promise");
}
function IsRecord(value) {
	return IsKindOf(value, "Record");
}
function IsRef(value) {
	return IsKindOf(value, "Ref");
}
function IsRegExp2(value) {
	return IsKindOf(value, "RegExp");
}
function IsString3(value) {
	return IsKindOf(value, "String");
}
function IsSymbol3(value) {
	return IsKindOf(value, "Symbol");
}
function IsTemplateLiteral(value) {
	return IsKindOf(value, "TemplateLiteral");
}
function IsThis(value) {
	return IsKindOf(value, "This");
}
function IsTransform(value) {
	return IsObject(value) && TransformKind in value;
}
function IsTuple(value) {
	return IsKindOf(value, "Tuple");
}
function IsUndefined3(value) {
	return IsKindOf(value, "Undefined");
}
function IsUnion(value) {
	return IsKindOf(value, "Union");
}
function IsUint8Array3(value) {
	return IsKindOf(value, "Uint8Array");
}
function IsUnknown(value) {
	return IsKindOf(value, "Unknown");
}
function IsUnsafe(value) {
	return IsKindOf(value, "Unsafe");
}
function IsVoid(value) {
	return IsKindOf(value, "Void");
}
function IsKind(value) {
	return IsObject(value) && Kind in value && IsString(value[Kind]);
}
function IsSchema(value) {
	return (
		IsAny(value) ||
		IsArgument(value) ||
		IsArray3(value) ||
		IsBoolean3(value) ||
		IsBigInt3(value) ||
		IsAsyncIterator3(value) ||
		IsComputed(value) ||
		IsConstructor(value) ||
		IsDate3(value) ||
		IsFunction3(value) ||
		IsInteger2(value) ||
		IsIntersect(value) ||
		IsIterator3(value) ||
		IsLiteral(value) ||
		IsMappedKey(value) ||
		IsMappedResult(value) ||
		IsNever(value) ||
		IsNot(value) ||
		IsNull3(value) ||
		IsNumber3(value) ||
		IsObject3(value) ||
		IsPromise2(value) ||
		IsRecord(value) ||
		IsRef(value) ||
		IsRegExp2(value) ||
		IsString3(value) ||
		IsSymbol3(value) ||
		IsTemplateLiteral(value) ||
		IsThis(value) ||
		IsTuple(value) ||
		IsUndefined3(value) ||
		IsUnion(value) ||
		IsUint8Array3(value) ||
		IsUnknown(value) ||
		IsUnsafe(value) ||
		IsVoid(value) ||
		IsKind(value)
	);
}
// node_modules/@sinclair/typebox/build/esm/type/guard/type.mjs
var exports_type = {};
__export(exports_type, {
	TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError,
	IsVoid: () => IsVoid2,
	IsUnsafe: () => IsUnsafe2,
	IsUnknown: () => IsUnknown2,
	IsUnionLiteral: () => IsUnionLiteral,
	IsUnion: () => IsUnion2,
	IsUndefined: () => IsUndefined4,
	IsUint8Array: () => IsUint8Array4,
	IsTuple: () => IsTuple2,
	IsTransform: () => IsTransform2,
	IsThis: () => IsThis2,
	IsTemplateLiteral: () => IsTemplateLiteral2,
	IsSymbol: () => IsSymbol4,
	IsString: () => IsString4,
	IsSchema: () => IsSchema2,
	IsRegExp: () => IsRegExp3,
	IsRef: () => IsRef2,
	IsRecursive: () => IsRecursive,
	IsRecord: () => IsRecord2,
	IsReadonly: () => IsReadonly2,
	IsProperties: () => IsProperties,
	IsPromise: () => IsPromise3,
	IsOptional: () => IsOptional2,
	IsObject: () => IsObject4,
	IsNumber: () => IsNumber4,
	IsNull: () => IsNull4,
	IsNot: () => IsNot2,
	IsNever: () => IsNever2,
	IsMappedResult: () => IsMappedResult2,
	IsMappedKey: () => IsMappedKey2,
	IsLiteralValue: () => IsLiteralValue2,
	IsLiteralString: () => IsLiteralString,
	IsLiteralNumber: () => IsLiteralNumber,
	IsLiteralBoolean: () => IsLiteralBoolean,
	IsLiteral: () => IsLiteral2,
	IsKindOf: () => IsKindOf2,
	IsKind: () => IsKind2,
	IsIterator: () => IsIterator4,
	IsIntersect: () => IsIntersect2,
	IsInteger: () => IsInteger3,
	IsImport: () => IsImport,
	IsFunction: () => IsFunction4,
	IsDate: () => IsDate4,
	IsConstructor: () => IsConstructor2,
	IsComputed: () => IsComputed2,
	IsBoolean: () => IsBoolean4,
	IsBigInt: () => IsBigInt4,
	IsAsyncIterator: () => IsAsyncIterator4,
	IsArray: () => IsArray4,
	IsArgument: () => IsArgument2,
	IsAny: () => IsAny2,
});
class TypeGuardUnknownTypeError extends TypeBoxError {}
var KnownTypes = [
	"Argument",
	"Any",
	"Array",
	"AsyncIterator",
	"BigInt",
	"Boolean",
	"Computed",
	"Constructor",
	"Date",
	"Enum",
	"Function",
	"Integer",
	"Intersect",
	"Iterator",
	"Literal",
	"MappedKey",
	"MappedResult",
	"Not",
	"Null",
	"Number",
	"Object",
	"Promise",
	"Record",
	"Ref",
	"RegExp",
	"String",
	"Symbol",
	"TemplateLiteral",
	"This",
	"Tuple",
	"Undefined",
	"Union",
	"Uint8Array",
	"Unknown",
	"Void",
];
function IsPattern(value) {
	try {
		new RegExp(value);
		return true;
	} catch {
		return false;
	}
}
function IsControlCharacterFree(value) {
	if (!IsString(value)) return false;
	for (let i = 0; i < value.length; i++) {
		const code = value.charCodeAt(i);
		if ((code >= 7 && code <= 13) || code === 27 || code === 127) {
			return false;
		}
	}
	return true;
}
function IsAdditionalProperties(value) {
	return IsOptionalBoolean(value) || IsSchema2(value);
}
function IsOptionalBigInt(value) {
	return IsUndefined(value) || IsBigInt(value);
}
function IsOptionalNumber(value) {
	return IsUndefined(value) || IsNumber(value);
}
function IsOptionalBoolean(value) {
	return IsUndefined(value) || IsBoolean(value);
}
function IsOptionalString(value) {
	return IsUndefined(value) || IsString(value);
}
function IsOptionalPattern(value) {
	return (
		IsUndefined(value) || (IsString(value) && IsControlCharacterFree(value) && IsPattern(value))
	);
}
function IsOptionalFormat(value) {
	return IsUndefined(value) || (IsString(value) && IsControlCharacterFree(value));
}
function IsOptionalSchema(value) {
	return IsUndefined(value) || IsSchema2(value);
}
function IsReadonly2(value) {
	return IsObject(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional2(value) {
	return IsObject(value) && value[OptionalKind] === "Optional";
}
function IsAny2(value) {
	return IsKindOf2(value, "Any") && IsOptionalString(value.$id);
}
function IsArgument2(value) {
	return IsKindOf2(value, "Argument") && IsNumber(value.index);
}
function IsArray4(value) {
	return (
		IsKindOf2(value, "Array") &&
		value.type === "array" &&
		IsOptionalString(value.$id) &&
		IsSchema2(value.items) &&
		IsOptionalNumber(value.minItems) &&
		IsOptionalNumber(value.maxItems) &&
		IsOptionalBoolean(value.uniqueItems) &&
		IsOptionalSchema(value.contains) &&
		IsOptionalNumber(value.minContains) &&
		IsOptionalNumber(value.maxContains)
	);
}
function IsAsyncIterator4(value) {
	return (
		IsKindOf2(value, "AsyncIterator") &&
		value.type === "AsyncIterator" &&
		IsOptionalString(value.$id) &&
		IsSchema2(value.items)
	);
}
function IsBigInt4(value) {
	return (
		IsKindOf2(value, "BigInt") &&
		value.type === "bigint" &&
		IsOptionalString(value.$id) &&
		IsOptionalBigInt(value.exclusiveMaximum) &&
		IsOptionalBigInt(value.exclusiveMinimum) &&
		IsOptionalBigInt(value.maximum) &&
		IsOptionalBigInt(value.minimum) &&
		IsOptionalBigInt(value.multipleOf)
	);
}
function IsBoolean4(value) {
	return IsKindOf2(value, "Boolean") && value.type === "boolean" && IsOptionalString(value.$id);
}
function IsComputed2(value) {
	return (
		IsKindOf2(value, "Computed") &&
		IsString(value.target) &&
		IsArray(value.parameters) &&
		value.parameters.every((schema) => IsSchema2(schema))
	);
}
function IsConstructor2(value) {
	return (
		IsKindOf2(value, "Constructor") &&
		value.type === "Constructor" &&
		IsOptionalString(value.$id) &&
		IsArray(value.parameters) &&
		value.parameters.every((schema) => IsSchema2(schema)) &&
		IsSchema2(value.returns)
	);
}
function IsDate4(value) {
	return (
		IsKindOf2(value, "Date") &&
		value.type === "Date" &&
		IsOptionalString(value.$id) &&
		IsOptionalNumber(value.exclusiveMaximumTimestamp) &&
		IsOptionalNumber(value.exclusiveMinimumTimestamp) &&
		IsOptionalNumber(value.maximumTimestamp) &&
		IsOptionalNumber(value.minimumTimestamp) &&
		IsOptionalNumber(value.multipleOfTimestamp)
	);
}
function IsFunction4(value) {
	return (
		IsKindOf2(value, "Function") &&
		value.type === "Function" &&
		IsOptionalString(value.$id) &&
		IsArray(value.parameters) &&
		value.parameters.every((schema) => IsSchema2(schema)) &&
		IsSchema2(value.returns)
	);
}
function IsImport(value) {
	return (
		IsKindOf2(value, "Import") &&
		HasPropertyKey(value, "$defs") &&
		IsObject(value.$defs) &&
		IsProperties(value.$defs) &&
		HasPropertyKey(value, "$ref") &&
		IsString(value.$ref) &&
		value.$ref in value.$defs
	);
}
function IsInteger3(value) {
	return (
		IsKindOf2(value, "Integer") &&
		value.type === "integer" &&
		IsOptionalString(value.$id) &&
		IsOptionalNumber(value.exclusiveMaximum) &&
		IsOptionalNumber(value.exclusiveMinimum) &&
		IsOptionalNumber(value.maximum) &&
		IsOptionalNumber(value.minimum) &&
		IsOptionalNumber(value.multipleOf)
	);
}
function IsProperties(value) {
	return (
		IsObject(value) &&
		Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema2(schema))
	);
}
function IsIntersect2(value) {
	return (
		IsKindOf2(value, "Intersect") &&
		(IsString(value.type) && value.type !== "object" ? false : true) &&
		IsArray(value.allOf) &&
		value.allOf.every((schema) => IsSchema2(schema) && !IsTransform2(schema)) &&
		IsOptionalString(value.type) &&
		(IsOptionalBoolean(value.unevaluatedProperties) ||
			IsOptionalSchema(value.unevaluatedProperties)) &&
		IsOptionalString(value.$id)
	);
}
function IsIterator4(value) {
	return (
		IsKindOf2(value, "Iterator") &&
		value.type === "Iterator" &&
		IsOptionalString(value.$id) &&
		IsSchema2(value.items)
	);
}
function IsKindOf2(value, kind) {
	return IsObject(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralString(value) {
	return IsLiteral2(value) && IsString(value.const);
}
function IsLiteralNumber(value) {
	return IsLiteral2(value) && IsNumber(value.const);
}
function IsLiteralBoolean(value) {
	return IsLiteral2(value) && IsBoolean(value.const);
}
function IsLiteral2(value) {
	return IsKindOf2(value, "Literal") && IsOptionalString(value.$id) && IsLiteralValue2(value.const);
}
function IsLiteralValue2(value) {
	return IsBoolean(value) || IsNumber(value) || IsString(value);
}
function IsMappedKey2(value) {
	return (
		IsKindOf2(value, "MappedKey") &&
		IsArray(value.keys) &&
		value.keys.every((key) => IsNumber(key) || IsString(key))
	);
}
function IsMappedResult2(value) {
	return IsKindOf2(value, "MappedResult") && IsProperties(value.properties);
}
function IsNever2(value) {
	return (
		IsKindOf2(value, "Never") &&
		IsObject(value.not) &&
		Object.getOwnPropertyNames(value.not).length === 0
	);
}
function IsNot2(value) {
	return IsKindOf2(value, "Not") && IsSchema2(value.not);
}
function IsNull4(value) {
	return IsKindOf2(value, "Null") && value.type === "null" && IsOptionalString(value.$id);
}
function IsNumber4(value) {
	return (
		IsKindOf2(value, "Number") &&
		value.type === "number" &&
		IsOptionalString(value.$id) &&
		IsOptionalNumber(value.exclusiveMaximum) &&
		IsOptionalNumber(value.exclusiveMinimum) &&
		IsOptionalNumber(value.maximum) &&
		IsOptionalNumber(value.minimum) &&
		IsOptionalNumber(value.multipleOf)
	);
}
function IsObject4(value) {
	return (
		IsKindOf2(value, "Object") &&
		value.type === "object" &&
		IsOptionalString(value.$id) &&
		IsProperties(value.properties) &&
		IsAdditionalProperties(value.additionalProperties) &&
		IsOptionalNumber(value.minProperties) &&
		IsOptionalNumber(value.maxProperties)
	);
}
function IsPromise3(value) {
	return (
		IsKindOf2(value, "Promise") &&
		value.type === "Promise" &&
		IsOptionalString(value.$id) &&
		IsSchema2(value.item)
	);
}
function IsRecord2(value) {
	return (
		IsKindOf2(value, "Record") &&
		value.type === "object" &&
		IsOptionalString(value.$id) &&
		IsAdditionalProperties(value.additionalProperties) &&
		IsObject(value.patternProperties) &&
		((schema) => {
			const keys = Object.getOwnPropertyNames(schema.patternProperties);
			return (
				keys.length === 1 &&
				IsPattern(keys[0]) &&
				IsObject(schema.patternProperties) &&
				IsSchema2(schema.patternProperties[keys[0]])
			);
		})(value)
	);
}
function IsRecursive(value) {
	return IsObject(value) && Hint in value && value[Hint] === "Recursive";
}
function IsRef2(value) {
	return IsKindOf2(value, "Ref") && IsOptionalString(value.$id) && IsString(value.$ref);
}
function IsRegExp3(value) {
	return (
		IsKindOf2(value, "RegExp") &&
		IsOptionalString(value.$id) &&
		IsString(value.source) &&
		IsString(value.flags) &&
		IsOptionalNumber(value.maxLength) &&
		IsOptionalNumber(value.minLength)
	);
}
function IsString4(value) {
	return (
		IsKindOf2(value, "String") &&
		value.type === "string" &&
		IsOptionalString(value.$id) &&
		IsOptionalNumber(value.minLength) &&
		IsOptionalNumber(value.maxLength) &&
		IsOptionalPattern(value.pattern) &&
		IsOptionalFormat(value.format)
	);
}
function IsSymbol4(value) {
	return IsKindOf2(value, "Symbol") && value.type === "symbol" && IsOptionalString(value.$id);
}
function IsTemplateLiteral2(value) {
	return (
		IsKindOf2(value, "TemplateLiteral") &&
		value.type === "string" &&
		IsString(value.pattern) &&
		value.pattern[0] === "^" &&
		value.pattern[value.pattern.length - 1] === "$"
	);
}
function IsThis2(value) {
	return IsKindOf2(value, "This") && IsOptionalString(value.$id) && IsString(value.$ref);
}
function IsTransform2(value) {
	return IsObject(value) && TransformKind in value;
}
function IsTuple2(value) {
	return (
		IsKindOf2(value, "Tuple") &&
		value.type === "array" &&
		IsOptionalString(value.$id) &&
		IsNumber(value.minItems) &&
		IsNumber(value.maxItems) &&
		value.minItems === value.maxItems &&
		((IsUndefined(value.items) && IsUndefined(value.additionalItems) && value.minItems === 0) ||
			(IsArray(value.items) && value.items.every((schema) => IsSchema2(schema))))
	);
}
function IsUndefined4(value) {
	return IsKindOf2(value, "Undefined") && value.type === "undefined" && IsOptionalString(value.$id);
}
function IsUnionLiteral(value) {
	return (
		IsUnion2(value) &&
		value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema))
	);
}
function IsUnion2(value) {
	return (
		IsKindOf2(value, "Union") &&
		IsOptionalString(value.$id) &&
		IsObject(value) &&
		IsArray(value.anyOf) &&
		value.anyOf.every((schema) => IsSchema2(schema))
	);
}
function IsUint8Array4(value) {
	return (
		IsKindOf2(value, "Uint8Array") &&
		value.type === "Uint8Array" &&
		IsOptionalString(value.$id) &&
		IsOptionalNumber(value.minByteLength) &&
		IsOptionalNumber(value.maxByteLength)
	);
}
function IsUnknown2(value) {
	return IsKindOf2(value, "Unknown") && IsOptionalString(value.$id);
}
function IsUnsafe2(value) {
	return IsKindOf2(value, "Unsafe");
}
function IsVoid2(value) {
	return IsKindOf2(value, "Void") && value.type === "void" && IsOptionalString(value.$id);
}
function IsKind2(value) {
	return (
		IsObject(value) && Kind in value && IsString(value[Kind]) && !KnownTypes.includes(value[Kind])
	);
}
function IsSchema2(value) {
	return (
		IsObject(value) &&
		(IsAny2(value) ||
			IsArgument2(value) ||
			IsArray4(value) ||
			IsBoolean4(value) ||
			IsBigInt4(value) ||
			IsAsyncIterator4(value) ||
			IsComputed2(value) ||
			IsConstructor2(value) ||
			IsDate4(value) ||
			IsFunction4(value) ||
			IsInteger3(value) ||
			IsIntersect2(value) ||
			IsIterator4(value) ||
			IsLiteral2(value) ||
			IsMappedKey2(value) ||
			IsMappedResult2(value) ||
			IsNever2(value) ||
			IsNot2(value) ||
			IsNull4(value) ||
			IsNumber4(value) ||
			IsObject4(value) ||
			IsPromise3(value) ||
			IsRecord2(value) ||
			IsRef2(value) ||
			IsRegExp3(value) ||
			IsString4(value) ||
			IsSymbol4(value) ||
			IsTemplateLiteral2(value) ||
			IsThis2(value) ||
			IsTuple2(value) ||
			IsUndefined4(value) ||
			IsUnion2(value) ||
			IsUint8Array4(value) ||
			IsUnknown2(value) ||
			IsUnsafe2(value) ||
			IsVoid2(value) ||
			IsKind2(value))
	);
}
// node_modules/@sinclair/typebox/build/esm/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternNever = "(?!.*)";
var PatternBooleanExact = `^${PatternBoolean}$`;
var PatternNumberExact = `^${PatternNumber}$`;
var PatternStringExact = `^${PatternString}$`;
var PatternNeverExact = `^${PatternNever}$`;

// node_modules/@sinclair/typebox/build/esm/type/registry/format.mjs
var exports_format = {};
__export(exports_format, {
	Set: () => Set2,
	Has: () => Has,
	Get: () => Get,
	Entries: () => Entries,
	Delete: () => Delete,
	Clear: () => Clear,
});
var map = new Map();
function Entries() {
	return new Map(map);
}
function Clear() {
	return map.clear();
}
function Delete(format) {
	return map.delete(format);
}
function Has(format) {
	return map.has(format);
}
function Set2(format, func) {
	map.set(format, func);
}
function Get(format) {
	return map.get(format);
}
// node_modules/@sinclair/typebox/build/esm/type/registry/type.mjs
var exports_type2 = {};
__export(exports_type2, {
	Set: () => Set3,
	Has: () => Has2,
	Get: () => Get2,
	Entries: () => Entries2,
	Delete: () => Delete2,
	Clear: () => Clear2,
});
var map2 = new Map();
function Entries2() {
	return new Map(map2);
}
function Clear2() {
	return map2.clear();
}
function Delete2(kind) {
	return map2.delete(kind);
}
function Has2(kind) {
	return map2.has(kind);
}
function Set3(kind, func) {
	map2.set(kind, func);
}
function Get2(kind) {
	return map2.get(kind);
}
// node_modules/@sinclair/typebox/build/esm/type/sets/set.mjs
function SetIncludes(T, S) {
	return T.includes(S);
}
function SetDistinct(T) {
	return [...new Set(T)];
}
function SetIntersect(T, S) {
	return T.filter((L) => S.includes(L));
}
function SetIntersectManyResolve(T, Init) {
	return T.reduce((Acc, L) => {
		return SetIntersect(Acc, L);
	}, Init);
}
function SetIntersectMany(T) {
	return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
	const Acc = [];
	for (const L of T) Acc.push(...L);
	return Acc;
}

// node_modules/@sinclair/typebox/build/esm/type/any/any.mjs
function Any(options) {
	return CreateType({ [Kind]: "Any" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/array/array.mjs
function Array2(items, options) {
	return CreateType({ [Kind]: "Array", type: "array", items }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/argument/argument.mjs
function Argument(index) {
	return CreateType({ [Kind]: "Argument", index });
}

// node_modules/@sinclair/typebox/build/esm/type/async-iterator/async-iterator.mjs
function AsyncIterator(items, options) {
	return CreateType({ [Kind]: "AsyncIterator", type: "AsyncIterator", items }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/computed/computed.mjs
function Computed(target, parameters, options) {
	return CreateType({ [Kind]: "Computed", target, parameters }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/discard/discard.mjs
function DiscardKey(value, key) {
	const { [key]: _, ...rest } = value;
	return rest;
}
function Discard(value, keys) {
	return keys.reduce((acc, key) => DiscardKey(acc, key), value);
}

// node_modules/@sinclair/typebox/build/esm/type/never/never.mjs
function Never(options) {
	return CreateType({ [Kind]: "Never", not: {} }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped-result.mjs
function MappedResult(properties) {
	return CreateType({
		[Kind]: "MappedResult",
		properties,
	});
}

// node_modules/@sinclair/typebox/build/esm/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
	return CreateType({ [Kind]: "Constructor", type: "Constructor", parameters, returns }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/function/function.mjs
function Function2(parameters, returns, options) {
	return CreateType({ [Kind]: "Function", type: "Function", parameters, returns }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union-create.mjs
function UnionCreate(T, options) {
	return CreateType({ [Kind]: "Union", anyOf: T }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
function IsUnionOptional(types) {
	return types.some((type) => IsOptional(type));
}
function RemoveOptionalFromRest(types) {
	return types.map((left) => (IsOptional(left) ? RemoveOptionalFromType(left) : left));
}
function RemoveOptionalFromType(T) {
	return Discard(T, [OptionalKind]);
}
function ResolveUnion(types, options) {
	const isOptional = IsUnionOptional(types);
	return isOptional
		? Optional(UnionCreate(RemoveOptionalFromRest(types), options))
		: UnionCreate(RemoveOptionalFromRest(types), options);
}
function UnionEvaluated(T, options) {
	return T.length === 1
		? CreateType(T[0], options)
		: T.length === 0
			? Never(options)
			: ResolveUnion(T, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union.mjs
function Union(types, options) {
	return types.length === 0
		? Never(options)
		: types.length === 1
			? CreateType(types[0], options)
			: UnionCreate(types, options);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/parse.mjs
class TemplateLiteralParserError extends TypeBoxError {}
function Unescape(pattern) {
	return pattern
		.replace(/\\\$/g, "$")
		.replace(/\\\*/g, "*")
		.replace(/\\\^/g, "^")
		.replace(/\\\|/g, "|")
		.replace(/\\\(/g, "(")
		.replace(/\\\)/g, ")");
}
function IsNonEscaped(pattern, index, char) {
	return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen(pattern, index) {
	return IsNonEscaped(pattern, index, "(");
}
function IsCloseParen(pattern, index) {
	return IsNonEscaped(pattern, index, ")");
}
function IsSeparator(pattern, index) {
	return IsNonEscaped(pattern, index, "|");
}
function IsGroup(pattern) {
	if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1))) return false;
	let count = 0;
	for (let index = 0; index < pattern.length; index++) {
		if (IsOpenParen(pattern, index)) count += 1;
		if (IsCloseParen(pattern, index)) count -= 1;
		if (count === 0 && index !== pattern.length - 1) return false;
	}
	return true;
}
function InGroup(pattern) {
	return pattern.slice(1, pattern.length - 1);
}
function IsPrecedenceOr(pattern) {
	let count = 0;
	for (let index = 0; index < pattern.length; index++) {
		if (IsOpenParen(pattern, index)) count += 1;
		if (IsCloseParen(pattern, index)) count -= 1;
		if (IsSeparator(pattern, index) && count === 0) return true;
	}
	return false;
}
function IsPrecedenceAnd(pattern) {
	for (let index = 0; index < pattern.length; index++) {
		if (IsOpenParen(pattern, index)) return true;
	}
	return false;
}
function Or(pattern) {
	let [count, start] = [0, 0];
	const expressions = [];
	for (let index = 0; index < pattern.length; index++) {
		if (IsOpenParen(pattern, index)) count += 1;
		if (IsCloseParen(pattern, index)) count -= 1;
		if (IsSeparator(pattern, index) && count === 0) {
			const range2 = pattern.slice(start, index);
			if (range2.length > 0) expressions.push(TemplateLiteralParse(range2));
			start = index + 1;
		}
	}
	const range = pattern.slice(start);
	if (range.length > 0) expressions.push(TemplateLiteralParse(range));
	if (expressions.length === 0) return { type: "const", const: "" };
	if (expressions.length === 1) return expressions[0];
	return { type: "or", expr: expressions };
}
function And(pattern) {
	function Group(value, index) {
		if (!IsOpenParen(value, index))
			throw new TemplateLiteralParserError(
				"TemplateLiteralParser: Index must point to open parens",
			);
		let count = 0;
		for (let scan = index; scan < value.length; scan++) {
			if (IsOpenParen(value, scan)) count += 1;
			if (IsCloseParen(value, scan)) count -= 1;
			if (count === 0) return [index, scan];
		}
		throw new TemplateLiteralParserError(
			"TemplateLiteralParser: Unclosed group parens in expression",
		);
	}
	function Range(pattern2, index) {
		for (let scan = index; scan < pattern2.length; scan++) {
			if (IsOpenParen(pattern2, scan)) return [index, scan];
		}
		return [index, pattern2.length];
	}
	const expressions = [];
	for (let index = 0; index < pattern.length; index++) {
		if (IsOpenParen(pattern, index)) {
			const [start, end] = Group(pattern, index);
			const range = pattern.slice(start, end + 1);
			expressions.push(TemplateLiteralParse(range));
			index = end;
		} else {
			const [start, end] = Range(pattern, index);
			const range = pattern.slice(start, end);
			if (range.length > 0) expressions.push(TemplateLiteralParse(range));
			index = end - 1;
		}
	}
	return expressions.length === 0
		? { type: "const", const: "" }
		: expressions.length === 1
			? expressions[0]
			: { type: "and", expr: expressions };
}
function TemplateLiteralParse(pattern) {
	return IsGroup(pattern)
		? TemplateLiteralParse(InGroup(pattern))
		: IsPrecedenceOr(pattern)
			? Or(pattern)
			: IsPrecedenceAnd(pattern)
				? And(pattern)
				: { type: "const", const: Unescape(pattern) };
}
function TemplateLiteralParseExact(pattern) {
	return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
class TemplateLiteralFiniteError extends TypeBoxError {}
function IsNumberExpression(expression) {
	return (
		expression.type === "or" &&
		expression.expr.length === 2 &&
		expression.expr[0].type === "const" &&
		expression.expr[0].const === "0" &&
		expression.expr[1].type === "const" &&
		expression.expr[1].const === "[1-9][0-9]*"
	);
}
function IsBooleanExpression(expression) {
	return (
		expression.type === "or" &&
		expression.expr.length === 2 &&
		expression.expr[0].type === "const" &&
		expression.expr[0].const === "true" &&
		expression.expr[1].type === "const" &&
		expression.expr[1].const === "false"
	);
}
function IsStringExpression(expression) {
	return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite(expression) {
	return IsNumberExpression(expression) || IsStringExpression(expression)
		? false
		: IsBooleanExpression(expression)
			? true
			: expression.type === "and"
				? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr))
				: expression.type === "or"
					? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr))
					: expression.type === "const"
						? true
						: (() => {
								throw new TemplateLiteralFiniteError("Unknown expression type");
							})();
}
function IsTemplateLiteralFinite(schema) {
	const expression = TemplateLiteralParseExact(schema.pattern);
	return IsTemplateLiteralExpressionFinite(expression);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/generate.mjs
class TemplateLiteralGenerateError extends TypeBoxError {}
function* GenerateReduce(buffer) {
	if (buffer.length === 1) return yield* buffer[0];
	for (const left of buffer[0]) {
		for (const right of GenerateReduce(buffer.slice(1))) {
			yield `${left}${right}`;
		}
	}
}
function* GenerateAnd(expression) {
	return yield* GenerateReduce(
		expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]),
	);
}
function* GenerateOr(expression) {
	for (const expr of expression.expr) yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
	return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
	return expression.type === "and"
		? yield* GenerateAnd(expression)
		: expression.type === "or"
			? yield* GenerateOr(expression)
			: expression.type === "const"
				? yield* GenerateConst(expression)
				: (() => {
						throw new TemplateLiteralGenerateError("Unknown expression");
					})();
}
function TemplateLiteralGenerate(schema) {
	const expression = TemplateLiteralParseExact(schema.pattern);
	return IsTemplateLiteralExpressionFinite(expression)
		? [...TemplateLiteralExpressionGenerate(expression)]
		: [];
}

// node_modules/@sinclair/typebox/build/esm/type/literal/literal.mjs
function Literal(value, options) {
	return CreateType(
		{
			[Kind]: "Literal",
			const: value,
			type: typeof value,
		},
		options,
	);
}

// node_modules/@sinclair/typebox/build/esm/type/boolean/boolean.mjs
function Boolean2(options) {
	return CreateType({ [Kind]: "Boolean", type: "boolean" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/bigint/bigint.mjs
function BigInt2(options) {
	return CreateType({ [Kind]: "BigInt", type: "bigint" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/number/number.mjs
function Number2(options) {
	return CreateType({ [Kind]: "Number", type: "number" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/string/string.mjs
function String2(options) {
	return CreateType({ [Kind]: "String", type: "string" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
	const trim = syntax.trim().replace(/"|'/g, "");
	return trim === "boolean"
		? yield Boolean2()
		: trim === "number"
			? yield Number2()
			: trim === "bigint"
				? yield BigInt2()
				: trim === "string"
					? yield String2()
					: yield (() => {
							const literals = trim.split("|").map((literal) => Literal(literal.trim()));
							return literals.length === 0
								? Never()
								: literals.length === 1
									? literals[0]
									: UnionEvaluated(literals);
						})();
}
function* FromTerminal(syntax) {
	if (syntax[1] !== "{") {
		const L = Literal("$");
		const R = FromSyntax(syntax.slice(1));
		return yield* [L, ...R];
	}
	for (let i = 2; i < syntax.length; i++) {
		if (syntax[i] === "}") {
			const L = FromUnion(syntax.slice(2, i));
			const R = FromSyntax(syntax.slice(i + 1));
			return yield* [...L, ...R];
		}
	}
	yield Literal(syntax);
}
function* FromSyntax(syntax) {
	for (let i = 0; i < syntax.length; i++) {
		if (syntax[i] === "$") {
			const L = Literal(syntax.slice(0, i));
			const R = FromTerminal(syntax.slice(i));
			return yield* [L, ...R];
		}
	}
	yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
	return [...FromSyntax(syntax)];
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/pattern.mjs
class TemplateLiteralPatternError extends TypeBoxError {}
function Escape(value) {
	return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit2(schema, acc) {
	return IsTemplateLiteral(schema)
		? schema.pattern.slice(1, schema.pattern.length - 1)
		: IsUnion(schema)
			? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})`
			: IsNumber3(schema)
				? `${acc}${PatternNumber}`
				: IsInteger2(schema)
					? `${acc}${PatternNumber}`
					: IsBigInt3(schema)
						? `${acc}${PatternNumber}`
						: IsString3(schema)
							? `${acc}${PatternString}`
							: IsLiteral(schema)
								? `${acc}${Escape(schema.const.toString())}`
								: IsBoolean3(schema)
									? `${acc}${PatternBoolean}`
									: (() => {
											throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
										})();
}
function TemplateLiteralPattern(kinds) {
	return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
	const R = TemplateLiteralGenerate(schema);
	const L = R.map((S) => Literal(S));
	return UnionEvaluated(L);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/template-literal.mjs
function TemplateLiteral(unresolved, options) {
	const pattern = IsString(unresolved)
		? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved))
		: TemplateLiteralPattern(unresolved);
	return CreateType({ [Kind]: "TemplateLiteral", type: "string", pattern }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
function FromTemplateLiteral(templateLiteral) {
	const keys = TemplateLiteralGenerate(templateLiteral);
	return keys.map((key) => key.toString());
}
function FromUnion2(types) {
	const result = [];
	for (const type of types) result.push(...IndexPropertyKeys(type));
	return result;
}
function FromLiteral(literalValue) {
	return [literalValue.toString()];
}
function IndexPropertyKeys(type) {
	return [
		...new Set(
			IsTemplateLiteral(type)
				? FromTemplateLiteral(type)
				: IsUnion(type)
					? FromUnion2(type.anyOf)
					: IsLiteral(type)
						? FromLiteral(type.const)
						: IsNumber3(type)
							? ["[number]"]
							: IsInteger2(type)
								? ["[number]"]
								: [],
		),
	];
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-result.mjs
function FromProperties(type, properties, options) {
	const result = {};
	for (const K2 of Object.getOwnPropertyNames(properties)) {
		result[K2] = Index(type, IndexPropertyKeys(properties[K2]), options);
	}
	return result;
}
function FromMappedResult(type, mappedResult, options) {
	return FromProperties(type, mappedResult.properties, options);
}
function IndexFromMappedResult(type, mappedResult, options) {
	const properties = FromMappedResult(type, mappedResult, options);
	return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
function FromRest(types, key) {
	return types.map((type) => IndexFromPropertyKey(type, key));
}
function FromIntersectRest(types) {
	return types.filter((type) => !IsNever(type));
}
function FromIntersect(types, key) {
	return IntersectEvaluated(FromIntersectRest(FromRest(types, key)));
}
function FromUnionRest(types) {
	return types.some((L) => IsNever(L)) ? [] : types;
}
function FromUnion3(types, key) {
	return UnionEvaluated(FromUnionRest(FromRest(types, key)));
}
function FromTuple(types, key) {
	return key in types ? types[key] : key === "[number]" ? UnionEvaluated(types) : Never();
}
function FromArray(type, key) {
	return key === "[number]" ? type : Never();
}
function FromProperty(properties, propertyKey) {
	return propertyKey in properties ? properties[propertyKey] : Never();
}
function IndexFromPropertyKey(type, propertyKey) {
	return IsIntersect(type)
		? FromIntersect(type.allOf, propertyKey)
		: IsUnion(type)
			? FromUnion3(type.anyOf, propertyKey)
			: IsTuple(type)
				? FromTuple(type.items ?? [], propertyKey)
				: IsArray3(type)
					? FromArray(type.items, propertyKey)
					: IsObject3(type)
						? FromProperty(type.properties, propertyKey)
						: Never();
}
function IndexFromPropertyKeys(type, propertyKeys) {
	return propertyKeys.map((propertyKey) => IndexFromPropertyKey(type, propertyKey));
}
function FromSchema(type, propertyKeys) {
	return UnionEvaluated(IndexFromPropertyKeys(type, propertyKeys));
}
function Index(type, key, options) {
	if (IsRef(type) || IsRef(key)) {
		const error = "Index types using Ref parameters require both Type and Key to be of TSchema";
		if (!IsSchema(type) || !IsSchema(key)) throw new TypeBoxError(error);
		return Computed("Index", [type, key]);
	}
	if (IsMappedResult(key)) return IndexFromMappedResult(type, key, options);
	if (IsMappedKey(key)) return IndexFromMappedKey(type, key, options);
	return CreateType(
		IsSchema(key) ? FromSchema(type, IndexPropertyKeys(key)) : FromSchema(type, key),
		options,
	);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
function MappedIndexPropertyKey(type, key, options) {
	return { [key]: Index(type, [key], Clone(options)) };
}
function MappedIndexPropertyKeys(type, propertyKeys, options) {
	return propertyKeys.reduce((result, left) => {
		return { ...result, ...MappedIndexPropertyKey(type, left, options) };
	}, {});
}
function MappedIndexProperties(type, mappedKey, options) {
	return MappedIndexPropertyKeys(type, mappedKey.keys, options);
}
function IndexFromMappedKey(type, mappedKey, options) {
	const properties = MappedIndexProperties(type, mappedKey, options);
	return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/iterator/iterator.mjs
function Iterator(items, options) {
	return CreateType({ [Kind]: "Iterator", type: "Iterator", items }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/object/object.mjs
function RequiredKeys(properties) {
	const keys = [];
	for (let key in properties) {
		if (!IsOptional(properties[key])) keys.push(key);
	}
	return keys;
}
function _Object(properties, options) {
	const required = RequiredKeys(properties);
	const schematic =
		required.length > 0
			? { [Kind]: "Object", type: "object", properties, required }
			: { [Kind]: "Object", type: "object", properties };
	return CreateType(schematic, options);
}
var Object2 = _Object;

// node_modules/@sinclair/typebox/build/esm/type/promise/promise.mjs
function Promise2(item, options) {
	return CreateType({ [Kind]: "Promise", type: "Promise", item }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly.mjs
function RemoveReadonly(schema) {
	return CreateType(Discard(schema, [ReadonlyKind]));
}
function AddReadonly(schema) {
	return CreateType({ ...schema, [ReadonlyKind]: "Readonly" });
}
function ReadonlyWithFlag(schema, F) {
	return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
}
function Readonly(schema, enable) {
	const F = enable ?? true;
	return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
function FromProperties2(K, F) {
	const Acc = {};
	for (const K2 of globalThis.Object.getOwnPropertyNames(K)) Acc[K2] = Readonly(K[K2], F);
	return Acc;
}
function FromMappedResult2(R, F) {
	return FromProperties2(R.properties, F);
}
function ReadonlyFromMappedResult(R, F) {
	const P = FromMappedResult2(R, F);
	return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/tuple/tuple.mjs
function Tuple(types, options) {
	return CreateType(
		types.length > 0
			? {
					[Kind]: "Tuple",
					type: "array",
					items: types,
					additionalItems: false,
					minItems: types.length,
					maxItems: types.length,
				}
			: { [Kind]: "Tuple", type: "array", minItems: types.length, maxItems: types.length },
		options,
	);
}

// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
function FromMappedResult3(K, P) {
	return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
}
function MappedKeyToKnownMappedResultProperties(K) {
	return { [K]: Literal(K) };
}
function MappedKeyToUnknownMappedResultProperties(P) {
	const Acc = {};
	for (const L of P) Acc[L] = Literal(L);
	return Acc;
}
function MappedKeyToMappedResultProperties(K, P) {
	return SetIncludes(P, K)
		? MappedKeyToKnownMappedResultProperties(K)
		: MappedKeyToUnknownMappedResultProperties(P);
}
function FromMappedKey(K, P) {
	const R = MappedKeyToMappedResultProperties(K, P);
	return FromMappedResult3(K, R);
}
function FromRest2(K, T) {
	return T.map((L) => FromSchemaType(K, L));
}
function FromProperties3(K, T) {
	const Acc = {};
	for (const K2 of globalThis.Object.getOwnPropertyNames(T)) Acc[K2] = FromSchemaType(K, T[K2]);
	return Acc;
}
function FromSchemaType(K, T) {
	const options = { ...T };
	return IsOptional(T)
		? Optional(FromSchemaType(K, Discard(T, [OptionalKind])))
		: IsReadonly(T)
			? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind])))
			: IsMappedResult(T)
				? FromMappedResult3(K, T.properties)
				: IsMappedKey(T)
					? FromMappedKey(K, T.keys)
					: IsConstructor(T)
						? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns), options)
						: IsFunction3(T)
							? Function2(FromRest2(K, T.parameters), FromSchemaType(K, T.returns), options)
							: IsAsyncIterator3(T)
								? AsyncIterator(FromSchemaType(K, T.items), options)
								: IsIterator3(T)
									? Iterator(FromSchemaType(K, T.items), options)
									: IsIntersect(T)
										? Intersect(FromRest2(K, T.allOf), options)
										: IsUnion(T)
											? Union(FromRest2(K, T.anyOf), options)
											: IsTuple(T)
												? Tuple(FromRest2(K, T.items ?? []), options)
												: IsObject3(T)
													? Object2(FromProperties3(K, T.properties), options)
													: IsArray3(T)
														? Array2(FromSchemaType(K, T.items), options)
														: IsPromise2(T)
															? Promise2(FromSchemaType(K, T.item), options)
															: T;
}
function MappedFunctionReturnType(K, T) {
	const Acc = {};
	for (const L of K) Acc[L] = FromSchemaType(L, T);
	return Acc;
}
function Mapped(key, map3, options) {
	const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
	const RT = map3({ [Kind]: "MappedKey", keys: K });
	const R = MappedFunctionReturnType(K, RT);
	return Object2(R, options);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional.mjs
function RemoveOptional(schema) {
	return CreateType(Discard(schema, [OptionalKind]));
}
function AddOptional(schema) {
	return CreateType({ ...schema, [OptionalKind]: "Optional" });
}
function OptionalWithFlag(schema, F) {
	return F === false ? RemoveOptional(schema) : AddOptional(schema);
}
function Optional(schema, enable) {
	const F = enable ?? true;
	return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
function FromProperties4(P, F) {
	const Acc = {};
	for (const K2 of globalThis.Object.getOwnPropertyNames(P)) Acc[K2] = Optional(P[K2], F);
	return Acc;
}
function FromMappedResult4(R, F) {
	return FromProperties4(R.properties, F);
}
function OptionalFromMappedResult(R, F) {
	const P = FromMappedResult4(R, F);
	return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-create.mjs
function IntersectCreate(T, options = {}) {
	const allObjects = T.every((schema) => IsObject3(schema));
	const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties)
		? { unevaluatedProperties: options.unevaluatedProperties }
		: {};
	return CreateType(
		options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects
			? { ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: T }
			: { ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: T },
		options,
	);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
function IsIntersectOptional(types) {
	return types.every((left) => IsOptional(left));
}
function RemoveOptionalFromType2(type) {
	return Discard(type, [OptionalKind]);
}
function RemoveOptionalFromRest2(types) {
	return types.map((left) => (IsOptional(left) ? RemoveOptionalFromType2(left) : left));
}
function ResolveIntersect(types, options) {
	return IsIntersectOptional(types)
		? Optional(IntersectCreate(RemoveOptionalFromRest2(types), options))
		: IntersectCreate(RemoveOptionalFromRest2(types), options);
}
function IntersectEvaluated(types, options = {}) {
	if (types.length === 1) return CreateType(types[0], options);
	if (types.length === 0) return Never(options);
	if (types.some((schema) => IsTransform(schema)))
		throw new Error("Cannot intersect transform types");
	return ResolveIntersect(types, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect.mjs
function Intersect(types, options) {
	if (types.length === 1) return CreateType(types[0], options);
	if (types.length === 0) return Never(options);
	if (types.some((schema) => IsTransform(schema)))
		throw new Error("Cannot intersect transform types");
	return IntersectCreate(types, options);
}

// node_modules/@sinclair/typebox/build/esm/type/ref/ref.mjs
function Ref(...args) {
	const [$ref, options] = typeof args[0] === "string" ? [args[0], args[1]] : [args[0].$id, args[1]];
	if (typeof $ref !== "string") throw new TypeBoxError("Ref: $ref must be a string");
	return CreateType({ [Kind]: "Ref", $ref }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/awaited/awaited.mjs
function FromComputed(target, parameters) {
	return Computed("Awaited", [Computed(target, parameters)]);
}
function FromRef($ref) {
	return Computed("Awaited", [Ref($ref)]);
}
function FromIntersect2(types) {
	return Intersect(FromRest3(types));
}
function FromUnion4(types) {
	return Union(FromRest3(types));
}
function FromPromise(type) {
	return Awaited(type);
}
function FromRest3(types) {
	return types.map((type) => Awaited(type));
}
function Awaited(type, options) {
	return CreateType(
		IsComputed(type)
			? FromComputed(type.target, type.parameters)
			: IsIntersect(type)
				? FromIntersect2(type.allOf)
				: IsUnion(type)
					? FromUnion4(type.anyOf)
					: IsPromise2(type)
						? FromPromise(type.item)
						: IsRef(type)
							? FromRef(type.$ref)
							: type,
		options,
	);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs
function FromRest4(types) {
	const result = [];
	for (const L of types) result.push(KeyOfPropertyKeys(L));
	return result;
}
function FromIntersect3(types) {
	const propertyKeysArray = FromRest4(types);
	const propertyKeys = SetUnionMany(propertyKeysArray);
	return propertyKeys;
}
function FromUnion5(types) {
	const propertyKeysArray = FromRest4(types);
	const propertyKeys = SetIntersectMany(propertyKeysArray);
	return propertyKeys;
}
function FromTuple2(types) {
	return types.map((_, indexer) => indexer.toString());
}
function FromArray2(_) {
	return ["[number]"];
}
function FromProperties5(T) {
	return globalThis.Object.getOwnPropertyNames(T);
}
function FromPatternProperties(patternProperties) {
	if (!includePatternProperties) return [];
	const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
	return patternPropertyKeys.map((key) => {
		return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
	});
}
function KeyOfPropertyKeys(type) {
	return IsIntersect(type)
		? FromIntersect3(type.allOf)
		: IsUnion(type)
			? FromUnion5(type.anyOf)
			: IsTuple(type)
				? FromTuple2(type.items ?? [])
				: IsArray3(type)
					? FromArray2(type.items)
					: IsObject3(type)
						? FromProperties5(type.properties)
						: IsRecord(type)
							? FromPatternProperties(type.patternProperties)
							: [];
}
var includePatternProperties = false;
function KeyOfPattern(schema) {
	includePatternProperties = true;
	const keys = KeyOfPropertyKeys(schema);
	includePatternProperties = false;
	const pattern = keys.map((key) => `(${key})`);
	return `^(${pattern.join("|")})$`;
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
function FromComputed2(target, parameters) {
	return Computed("KeyOf", [Computed(target, parameters)]);
}
function FromRef2($ref) {
	return Computed("KeyOf", [Ref($ref)]);
}
function KeyOfFromType(type, options) {
	const propertyKeys = KeyOfPropertyKeys(type);
	const propertyKeyTypes = KeyOfPropertyKeysToRest(propertyKeys);
	const result = UnionEvaluated(propertyKeyTypes);
	return CreateType(result, options);
}
function KeyOfPropertyKeysToRest(propertyKeys) {
	return propertyKeys.map((L) => (L === "[number]" ? Number2() : Literal(L)));
}
function KeyOf(type, options) {
	return IsComputed(type)
		? FromComputed2(type.target, type.parameters)
		: IsRef(type)
			? FromRef2(type.$ref)
			: IsMappedResult(type)
				? KeyOfFromMappedResult(type, options)
				: KeyOfFromType(type, options);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
function FromProperties6(properties, options) {
	const result = {};
	for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
		result[K2] = KeyOf(properties[K2], Clone(options));
	return result;
}
function FromMappedResult5(mappedResult, options) {
	return FromProperties6(mappedResult.properties, options);
}
function KeyOfFromMappedResult(mappedResult, options) {
	const properties = FromMappedResult5(mappedResult, options);
	return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-entries.mjs
function KeyOfPropertyEntries(schema) {
	const keys = KeyOfPropertyKeys(schema);
	const schemas = IndexFromPropertyKeys(schema, keys);
	return keys.map((_, index) => [keys[index], schemas[index]]);
}

// node_modules/@sinclair/typebox/build/esm/type/composite/composite.mjs
function CompositeKeys(T) {
	const Acc = [];
	for (const L of T) Acc.push(...KeyOfPropertyKeys(L));
	return SetDistinct(Acc);
}
function FilterNever(T) {
	return T.filter((L) => !IsNever(L));
}
function CompositeProperty(T, K) {
	const Acc = [];
	for (const L of T) Acc.push(...IndexFromPropertyKeys(L, [K]));
	return FilterNever(Acc);
}
function CompositeProperties(T, K) {
	const Acc = {};
	for (const L of K) {
		Acc[L] = IntersectEvaluated(CompositeProperty(T, L));
	}
	return Acc;
}
function Composite(T, options) {
	const K = CompositeKeys(T);
	const P = CompositeProperties(T, K);
	const R = Object2(P, options);
	return R;
}

// node_modules/@sinclair/typebox/build/esm/type/date/date.mjs
function Date2(options) {
	return CreateType({ [Kind]: "Date", type: "Date" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/null/null.mjs
function Null(options) {
	return CreateType({ [Kind]: "Null", type: "null" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/symbol/symbol.mjs
function Symbol2(options) {
	return CreateType({ [Kind]: "Symbol", type: "symbol" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/undefined/undefined.mjs
function Undefined(options) {
	return CreateType({ [Kind]: "Undefined", type: "undefined" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/uint8array/uint8array.mjs
function Uint8Array2(options) {
	return CreateType({ [Kind]: "Uint8Array", type: "Uint8Array" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/unknown/unknown.mjs
function Unknown(options) {
	return CreateType({ [Kind]: "Unknown" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
function FromArray3(T) {
	return T.map((L) => FromValue(L, false));
}
function FromProperties7(value) {
	const Acc = {};
	for (const K of globalThis.Object.getOwnPropertyNames(value))
		Acc[K] = Readonly(FromValue(value[K], false));
	return Acc;
}
function ConditionalReadonly(T, root) {
	return root === true ? T : Readonly(T);
}
function FromValue(value, root) {
	return IsAsyncIterator(value)
		? ConditionalReadonly(Any(), root)
		: IsIterator(value)
			? ConditionalReadonly(Any(), root)
			: IsArray(value)
				? Readonly(Tuple(FromArray3(value)))
				: IsUint8Array(value)
					? Uint8Array2()
					: IsDate(value)
						? Date2()
						: IsObject(value)
							? ConditionalReadonly(Object2(FromProperties7(value)), root)
							: IsFunction(value)
								? ConditionalReadonly(Function2([], Unknown()), root)
								: IsUndefined(value)
									? Undefined()
									: IsNull(value)
										? Null()
										: IsSymbol(value)
											? Symbol2()
											: IsBigInt(value)
												? BigInt2()
												: IsNumber(value)
													? Literal(value)
													: IsBoolean(value)
														? Literal(value)
														: IsString(value)
															? Literal(value)
															: Object2({});
}
function Const(T, options) {
	return CreateType(FromValue(T, true), options);
}

// node_modules/@sinclair/typebox/build/esm/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options) {
	return IsConstructor(schema) ? Tuple(schema.parameters, options) : Never(options);
}

// node_modules/@sinclair/typebox/build/esm/type/enum/enum.mjs
function Enum(item, options) {
	if (IsUndefined(item)) throw new Error("Enum undefined or empty");
	const values1 = globalThis.Object.getOwnPropertyNames(item)
		.filter((key) => isNaN(key))
		.map((key) => item[key]);
	const values2 = [...new Set(values1)];
	const anyOf = values2.map((value) => Literal(value));
	return Union(anyOf, { ...options, [Hint]: "Enum" });
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs
class ExtendsResolverError extends TypeBoxError {}
var ExtendsResult;
(function (ExtendsResult2) {
	ExtendsResult2[(ExtendsResult2["Union"] = 0)] = "Union";
	ExtendsResult2[(ExtendsResult2["True"] = 1)] = "True";
	ExtendsResult2[(ExtendsResult2["False"] = 2)] = "False";
})(ExtendsResult || (ExtendsResult = {}));
function IntoBooleanResult(result) {
	return result === ExtendsResult.False ? result : ExtendsResult.True;
}
function Throw(message) {
	throw new ExtendsResolverError(message);
}
function IsStructuralRight(right) {
	return (
		exports_type.IsNever(right) ||
		exports_type.IsIntersect(right) ||
		exports_type.IsUnion(right) ||
		exports_type.IsUnknown(right) ||
		exports_type.IsAny(right)
	);
}
function StructuralRight(left, right) {
	return exports_type.IsNever(right)
		? FromNeverRight(left, right)
		: exports_type.IsIntersect(right)
			? FromIntersectRight(left, right)
			: exports_type.IsUnion(right)
				? FromUnionRight(left, right)
				: exports_type.IsUnknown(right)
					? FromUnknownRight(left, right)
					: exports_type.IsAny(right)
						? FromAnyRight(left, right)
						: Throw("StructuralRight");
}
function FromAnyRight(left, right) {
	return ExtendsResult.True;
}
function FromAny(left, right) {
	return exports_type.IsIntersect(right)
		? FromIntersectRight(left, right)
		: exports_type.IsUnion(right) &&
			  right.anyOf.some((schema) => exports_type.IsAny(schema) || exports_type.IsUnknown(schema))
			? ExtendsResult.True
			: exports_type.IsUnion(right)
				? ExtendsResult.Union
				: exports_type.IsUnknown(right)
					? ExtendsResult.True
					: exports_type.IsAny(right)
						? ExtendsResult.True
						: ExtendsResult.Union;
}
function FromArrayRight(left, right) {
	return exports_type.IsUnknown(left)
		? ExtendsResult.False
		: exports_type.IsAny(left)
			? ExtendsResult.Union
			: exports_type.IsNever(left)
				? ExtendsResult.True
				: ExtendsResult.False;
}
function FromArray4(left, right) {
	return exports_type.IsObject(right) && IsObjectArrayLike(right)
		? ExtendsResult.True
		: IsStructuralRight(right)
			? StructuralRight(left, right)
			: !exports_type.IsArray(right)
				? ExtendsResult.False
				: IntoBooleanResult(Visit3(left.items, right.items));
}
function FromAsyncIterator(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: !exports_type.IsAsyncIterator(right)
			? ExtendsResult.False
			: IntoBooleanResult(Visit3(left.items, right.items));
}
function FromBigInt(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right)
			? FromObjectRight(left, right)
			: exports_type.IsRecord(right)
				? FromRecordRight(left, right)
				: exports_type.IsBigInt(right)
					? ExtendsResult.True
					: ExtendsResult.False;
}
function FromBooleanRight(left, right) {
	return exports_type.IsLiteralBoolean(left)
		? ExtendsResult.True
		: exports_type.IsBoolean(left)
			? ExtendsResult.True
			: ExtendsResult.False;
}
function FromBoolean(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right)
			? FromObjectRight(left, right)
			: exports_type.IsRecord(right)
				? FromRecordRight(left, right)
				: exports_type.IsBoolean(right)
					? ExtendsResult.True
					: ExtendsResult.False;
}
function FromConstructor(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right)
			? FromObjectRight(left, right)
			: !exports_type.IsConstructor(right)
				? ExtendsResult.False
				: left.parameters.length > right.parameters.length
					? ExtendsResult.False
					: !left.parameters.every(
								(schema, index) =>
									IntoBooleanResult(Visit3(right.parameters[index], schema)) === ExtendsResult.True,
						  )
						? ExtendsResult.False
						: IntoBooleanResult(Visit3(left.returns, right.returns));
}
function FromDate(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right)
			? FromObjectRight(left, right)
			: exports_type.IsRecord(right)
				? FromRecordRight(left, right)
				: exports_type.IsDate(right)
					? ExtendsResult.True
					: ExtendsResult.False;
}
function FromFunction(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right)
			? FromObjectRight(left, right)
			: !exports_type.IsFunction(right)
				? ExtendsResult.False
				: left.parameters.length > right.parameters.length
					? ExtendsResult.False
					: !left.parameters.every(
								(schema, index) =>
									IntoBooleanResult(Visit3(right.parameters[index], schema)) === ExtendsResult.True,
						  )
						? ExtendsResult.False
						: IntoBooleanResult(Visit3(left.returns, right.returns));
}
function FromIntegerRight(left, right) {
	return exports_type.IsLiteral(left) && exports_value.IsNumber(left.const)
		? ExtendsResult.True
		: exports_type.IsNumber(left) || exports_type.IsInteger(left)
			? ExtendsResult.True
			: ExtendsResult.False;
}
function FromInteger(left, right) {
	return exports_type.IsInteger(right) || exports_type.IsNumber(right)
		? ExtendsResult.True
		: IsStructuralRight(right)
			? StructuralRight(left, right)
			: exports_type.IsObject(right)
				? FromObjectRight(left, right)
				: exports_type.IsRecord(right)
					? FromRecordRight(left, right)
					: ExtendsResult.False;
}
function FromIntersectRight(left, right) {
	return right.allOf.every((schema) => Visit3(left, schema) === ExtendsResult.True)
		? ExtendsResult.True
		: ExtendsResult.False;
}
function FromIntersect4(left, right) {
	return left.allOf.some((schema) => Visit3(schema, right) === ExtendsResult.True)
		? ExtendsResult.True
		: ExtendsResult.False;
}
function FromIterator(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: !exports_type.IsIterator(right)
			? ExtendsResult.False
			: IntoBooleanResult(Visit3(left.items, right.items));
}
function FromLiteral2(left, right) {
	return exports_type.IsLiteral(right) && right.const === left.const
		? ExtendsResult.True
		: IsStructuralRight(right)
			? StructuralRight(left, right)
			: exports_type.IsObject(right)
				? FromObjectRight(left, right)
				: exports_type.IsRecord(right)
					? FromRecordRight(left, right)
					: exports_type.IsString(right)
						? FromStringRight(left, right)
						: exports_type.IsNumber(right)
							? FromNumberRight(left, right)
							: exports_type.IsInteger(right)
								? FromIntegerRight(left, right)
								: exports_type.IsBoolean(right)
									? FromBooleanRight(left, right)
									: ExtendsResult.False;
}
function FromNeverRight(left, right) {
	return ExtendsResult.False;
}
function FromNever(left, right) {
	return ExtendsResult.True;
}
function UnwrapTNot(schema) {
	let [current, depth] = [schema, 0];
	while (true) {
		if (!exports_type.IsNot(current)) break;
		current = current.not;
		depth += 1;
	}
	return depth % 2 === 0 ? current : Unknown();
}
function FromNot(left, right) {
	return exports_type.IsNot(left)
		? Visit3(UnwrapTNot(left), right)
		: exports_type.IsNot(right)
			? Visit3(left, UnwrapTNot(right))
			: Throw("Invalid fallthrough for Not");
}
function FromNull(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right)
			? FromObjectRight(left, right)
			: exports_type.IsRecord(right)
				? FromRecordRight(left, right)
				: exports_type.IsNull(right)
					? ExtendsResult.True
					: ExtendsResult.False;
}
function FromNumberRight(left, right) {
	return exports_type.IsLiteralNumber(left)
		? ExtendsResult.True
		: exports_type.IsNumber(left) || exports_type.IsInteger(left)
			? ExtendsResult.True
			: ExtendsResult.False;
}
function FromNumber(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right)
			? FromObjectRight(left, right)
			: exports_type.IsRecord(right)
				? FromRecordRight(left, right)
				: exports_type.IsInteger(right) || exports_type.IsNumber(right)
					? ExtendsResult.True
					: ExtendsResult.False;
}
function IsObjectPropertyCount(schema, count) {
	return Object.getOwnPropertyNames(schema.properties).length === count;
}
function IsObjectStringLike(schema) {
	return IsObjectArrayLike(schema);
}
function IsObjectSymbolLike(schema) {
	return (
		IsObjectPropertyCount(schema, 0) ||
		(IsObjectPropertyCount(schema, 1) &&
			"description" in schema.properties &&
			exports_type.IsUnion(schema.properties.description) &&
			schema.properties.description.anyOf.length === 2 &&
			((exports_type.IsString(schema.properties.description.anyOf[0]) &&
				exports_type.IsUndefined(schema.properties.description.anyOf[1])) ||
				(exports_type.IsString(schema.properties.description.anyOf[1]) &&
					exports_type.IsUndefined(schema.properties.description.anyOf[0]))))
	);
}
function IsObjectNumberLike(schema) {
	return IsObjectPropertyCount(schema, 0);
}
function IsObjectBooleanLike(schema) {
	return IsObjectPropertyCount(schema, 0);
}
function IsObjectBigIntLike(schema) {
	return IsObjectPropertyCount(schema, 0);
}
function IsObjectDateLike(schema) {
	return IsObjectPropertyCount(schema, 0);
}
function IsObjectUint8ArrayLike(schema) {
	return IsObjectArrayLike(schema);
}
function IsObjectFunctionLike(schema) {
	const length = Number2();
	return (
		IsObjectPropertyCount(schema, 0) ||
		(IsObjectPropertyCount(schema, 1) &&
			"length" in schema.properties &&
			IntoBooleanResult(Visit3(schema.properties["length"], length)) === ExtendsResult.True)
	);
}
function IsObjectConstructorLike(schema) {
	return IsObjectPropertyCount(schema, 0);
}
function IsObjectArrayLike(schema) {
	const length = Number2();
	return (
		IsObjectPropertyCount(schema, 0) ||
		(IsObjectPropertyCount(schema, 1) &&
			"length" in schema.properties &&
			IntoBooleanResult(Visit3(schema.properties["length"], length)) === ExtendsResult.True)
	);
}
function IsObjectPromiseLike(schema) {
	const then = Function2([Any()], Any());
	return (
		IsObjectPropertyCount(schema, 0) ||
		(IsObjectPropertyCount(schema, 1) &&
			"then" in schema.properties &&
			IntoBooleanResult(Visit3(schema.properties["then"], then)) === ExtendsResult.True)
	);
}
function Property(left, right) {
	return Visit3(left, right) === ExtendsResult.False
		? ExtendsResult.False
		: exports_type.IsOptional(left) && !exports_type.IsOptional(right)
			? ExtendsResult.False
			: ExtendsResult.True;
}
function FromObjectRight(left, right) {
	return exports_type.IsUnknown(left)
		? ExtendsResult.False
		: exports_type.IsAny(left)
			? ExtendsResult.Union
			: exports_type.IsNever(left) ||
				  (exports_type.IsLiteralString(left) && IsObjectStringLike(right)) ||
				  (exports_type.IsLiteralNumber(left) && IsObjectNumberLike(right)) ||
				  (exports_type.IsLiteralBoolean(left) && IsObjectBooleanLike(right)) ||
				  (exports_type.IsSymbol(left) && IsObjectSymbolLike(right)) ||
				  (exports_type.IsBigInt(left) && IsObjectBigIntLike(right)) ||
				  (exports_type.IsString(left) && IsObjectStringLike(right)) ||
				  (exports_type.IsSymbol(left) && IsObjectSymbolLike(right)) ||
				  (exports_type.IsNumber(left) && IsObjectNumberLike(right)) ||
				  (exports_type.IsInteger(left) && IsObjectNumberLike(right)) ||
				  (exports_type.IsBoolean(left) && IsObjectBooleanLike(right)) ||
				  (exports_type.IsUint8Array(left) && IsObjectUint8ArrayLike(right)) ||
				  (exports_type.IsDate(left) && IsObjectDateLike(right)) ||
				  (exports_type.IsConstructor(left) && IsObjectConstructorLike(right)) ||
				  (exports_type.IsFunction(left) && IsObjectFunctionLike(right))
				? ExtendsResult.True
				: exports_type.IsRecord(left) && exports_type.IsString(RecordKey(left))
					? (() => {
							return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
						})()
					: exports_type.IsRecord(left) && exports_type.IsNumber(RecordKey(left))
						? (() => {
								return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
							})()
						: ExtendsResult.False;
}
function FromObject(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsRecord(right)
			? FromRecordRight(left, right)
			: !exports_type.IsObject(right)
				? ExtendsResult.False
				: (() => {
						for (const key of Object.getOwnPropertyNames(right.properties)) {
							if (!(key in left.properties) && !exports_type.IsOptional(right.properties[key])) {
								return ExtendsResult.False;
							}
							if (exports_type.IsOptional(right.properties[key])) {
								return ExtendsResult.True;
							}
							if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
								return ExtendsResult.False;
							}
						}
						return ExtendsResult.True;
					})();
}
function FromPromise2(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right) && IsObjectPromiseLike(right)
			? ExtendsResult.True
			: !exports_type.IsPromise(right)
				? ExtendsResult.False
				: IntoBooleanResult(Visit3(left.item, right.item));
}
function RecordKey(schema) {
	return PatternNumberExact in schema.patternProperties
		? Number2()
		: PatternStringExact in schema.patternProperties
			? String2()
			: Throw("Unknown record key pattern");
}
function RecordValue(schema) {
	return PatternNumberExact in schema.patternProperties
		? schema.patternProperties[PatternNumberExact]
		: PatternStringExact in schema.patternProperties
			? schema.patternProperties[PatternStringExact]
			: Throw("Unable to get record value schema");
}
function FromRecordRight(left, right) {
	const [Key, Value] = [RecordKey(right), RecordValue(right)];
	return exports_type.IsLiteralString(left) &&
		exports_type.IsNumber(Key) &&
		IntoBooleanResult(Visit3(left, Value)) === ExtendsResult.True
		? ExtendsResult.True
		: exports_type.IsUint8Array(left) && exports_type.IsNumber(Key)
			? Visit3(left, Value)
			: exports_type.IsString(left) && exports_type.IsNumber(Key)
				? Visit3(left, Value)
				: exports_type.IsArray(left) && exports_type.IsNumber(Key)
					? Visit3(left, Value)
					: exports_type.IsObject(left)
						? (() => {
								for (const key of Object.getOwnPropertyNames(left.properties)) {
									if (Property(Value, left.properties[key]) === ExtendsResult.False) {
										return ExtendsResult.False;
									}
								}
								return ExtendsResult.True;
							})()
						: ExtendsResult.False;
}
function FromRecord(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right)
			? FromObjectRight(left, right)
			: !exports_type.IsRecord(right)
				? ExtendsResult.False
				: Visit3(RecordValue(left), RecordValue(right));
}
function FromRegExp(left, right) {
	const L = exports_type.IsRegExp(left) ? String2() : left;
	const R = exports_type.IsRegExp(right) ? String2() : right;
	return Visit3(L, R);
}
function FromStringRight(left, right) {
	return exports_type.IsLiteral(left) && exports_value.IsString(left.const)
		? ExtendsResult.True
		: exports_type.IsString(left)
			? ExtendsResult.True
			: ExtendsResult.False;
}
function FromString(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right)
			? FromObjectRight(left, right)
			: exports_type.IsRecord(right)
				? FromRecordRight(left, right)
				: exports_type.IsString(right)
					? ExtendsResult.True
					: ExtendsResult.False;
}
function FromSymbol(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right)
			? FromObjectRight(left, right)
			: exports_type.IsRecord(right)
				? FromRecordRight(left, right)
				: exports_type.IsSymbol(right)
					? ExtendsResult.True
					: ExtendsResult.False;
}
function FromTemplateLiteral2(left, right) {
	return exports_type.IsTemplateLiteral(left)
		? Visit3(TemplateLiteralToUnion(left), right)
		: exports_type.IsTemplateLiteral(right)
			? Visit3(left, TemplateLiteralToUnion(right))
			: Throw("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple(left, right) {
	return (
		exports_type.IsArray(right) &&
		left.items !== undefined &&
		left.items.every((schema) => Visit3(schema, right.items) === ExtendsResult.True)
	);
}
function FromTupleRight(left, right) {
	return exports_type.IsNever(left)
		? ExtendsResult.True
		: exports_type.IsUnknown(left)
			? ExtendsResult.False
			: exports_type.IsAny(left)
				? ExtendsResult.Union
				: ExtendsResult.False;
}
function FromTuple3(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right) && IsObjectArrayLike(right)
			? ExtendsResult.True
			: exports_type.IsArray(right) && IsArrayOfTuple(left, right)
				? ExtendsResult.True
				: !exports_type.IsTuple(right)
					? ExtendsResult.False
					: (exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items)) ||
						  (!exports_value.IsUndefined(left.items) && exports_value.IsUndefined(right.items))
						? ExtendsResult.False
						: exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items)
							? ExtendsResult.True
							: left.items.every(
										(schema, index) => Visit3(schema, right.items[index]) === ExtendsResult.True,
								  )
								? ExtendsResult.True
								: ExtendsResult.False;
}
function FromUint8Array(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right)
			? FromObjectRight(left, right)
			: exports_type.IsRecord(right)
				? FromRecordRight(left, right)
				: exports_type.IsUint8Array(right)
					? ExtendsResult.True
					: ExtendsResult.False;
}
function FromUndefined(left, right) {
	return IsStructuralRight(right)
		? StructuralRight(left, right)
		: exports_type.IsObject(right)
			? FromObjectRight(left, right)
			: exports_type.IsRecord(right)
				? FromRecordRight(left, right)
				: exports_type.IsVoid(right)
					? FromVoidRight(left, right)
					: exports_type.IsUndefined(right)
						? ExtendsResult.True
						: ExtendsResult.False;
}
function FromUnionRight(left, right) {
	return right.anyOf.some((schema) => Visit3(left, schema) === ExtendsResult.True)
		? ExtendsResult.True
		: ExtendsResult.False;
}
function FromUnion6(left, right) {
	return left.anyOf.every((schema) => Visit3(schema, right) === ExtendsResult.True)
		? ExtendsResult.True
		: ExtendsResult.False;
}
function FromUnknownRight(left, right) {
	return ExtendsResult.True;
}
function FromUnknown(left, right) {
	return exports_type.IsNever(right)
		? FromNeverRight(left, right)
		: exports_type.IsIntersect(right)
			? FromIntersectRight(left, right)
			: exports_type.IsUnion(right)
				? FromUnionRight(left, right)
				: exports_type.IsAny(right)
					? FromAnyRight(left, right)
					: exports_type.IsString(right)
						? FromStringRight(left, right)
						: exports_type.IsNumber(right)
							? FromNumberRight(left, right)
							: exports_type.IsInteger(right)
								? FromIntegerRight(left, right)
								: exports_type.IsBoolean(right)
									? FromBooleanRight(left, right)
									: exports_type.IsArray(right)
										? FromArrayRight(left, right)
										: exports_type.IsTuple(right)
											? FromTupleRight(left, right)
											: exports_type.IsObject(right)
												? FromObjectRight(left, right)
												: exports_type.IsUnknown(right)
													? ExtendsResult.True
													: ExtendsResult.False;
}
function FromVoidRight(left, right) {
	return exports_type.IsUndefined(left)
		? ExtendsResult.True
		: exports_type.IsUndefined(left)
			? ExtendsResult.True
			: ExtendsResult.False;
}
function FromVoid(left, right) {
	return exports_type.IsIntersect(right)
		? FromIntersectRight(left, right)
		: exports_type.IsUnion(right)
			? FromUnionRight(left, right)
			: exports_type.IsUnknown(right)
				? FromUnknownRight(left, right)
				: exports_type.IsAny(right)
					? FromAnyRight(left, right)
					: exports_type.IsObject(right)
						? FromObjectRight(left, right)
						: exports_type.IsVoid(right)
							? ExtendsResult.True
							: ExtendsResult.False;
}
function Visit3(left, right) {
	return exports_type.IsTemplateLiteral(left) || exports_type.IsTemplateLiteral(right)
		? FromTemplateLiteral2(left, right)
		: exports_type.IsRegExp(left) || exports_type.IsRegExp(right)
			? FromRegExp(left, right)
			: exports_type.IsNot(left) || exports_type.IsNot(right)
				? FromNot(left, right)
				: exports_type.IsAny(left)
					? FromAny(left, right)
					: exports_type.IsArray(left)
						? FromArray4(left, right)
						: exports_type.IsBigInt(left)
							? FromBigInt(left, right)
							: exports_type.IsBoolean(left)
								? FromBoolean(left, right)
								: exports_type.IsAsyncIterator(left)
									? FromAsyncIterator(left, right)
									: exports_type.IsConstructor(left)
										? FromConstructor(left, right)
										: exports_type.IsDate(left)
											? FromDate(left, right)
											: exports_type.IsFunction(left)
												? FromFunction(left, right)
												: exports_type.IsInteger(left)
													? FromInteger(left, right)
													: exports_type.IsIntersect(left)
														? FromIntersect4(left, right)
														: exports_type.IsIterator(left)
															? FromIterator(left, right)
															: exports_type.IsLiteral(left)
																? FromLiteral2(left, right)
																: exports_type.IsNever(left)
																	? FromNever(left, right)
																	: exports_type.IsNull(left)
																		? FromNull(left, right)
																		: exports_type.IsNumber(left)
																			? FromNumber(left, right)
																			: exports_type.IsObject(left)
																				? FromObject(left, right)
																				: exports_type.IsRecord(left)
																					? FromRecord(left, right)
																					: exports_type.IsString(left)
																						? FromString(left, right)
																						: exports_type.IsSymbol(left)
																							? FromSymbol(left, right)
																							: exports_type.IsTuple(left)
																								? FromTuple3(left, right)
																								: exports_type.IsPromise(left)
																									? FromPromise2(left, right)
																									: exports_type.IsUint8Array(left)
																										? FromUint8Array(left, right)
																										: exports_type.IsUndefined(left)
																											? FromUndefined(left, right)
																											: exports_type.IsUnion(left)
																												? FromUnion6(left, right)
																												: exports_type.IsUnknown(left)
																													? FromUnknown(left, right)
																													: exports_type.IsVoid(left)
																														? FromVoid(left, right)
																														: Throw(
																																`Unknown left type operand '${left[Kind]}'`,
																															);
}
function ExtendsCheck(left, right) {
	return Visit3(left, right);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-result.mjs
function FromProperties8(P, Right, True, False, options) {
	const Acc = {};
	for (const K2 of globalThis.Object.getOwnPropertyNames(P))
		Acc[K2] = Extends(P[K2], Right, True, False, Clone(options));
	return Acc;
}
function FromMappedResult6(Left, Right, True, False, options) {
	return FromProperties8(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult(Left, Right, True, False, options) {
	const P = FromMappedResult6(Left, Right, True, False, options);
	return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
function ExtendsResolve(left, right, trueType, falseType) {
	const R = ExtendsCheck(left, right);
	return R === ExtendsResult.Union
		? Union([trueType, falseType])
		: R === ExtendsResult.True
			? trueType
			: falseType;
}
function Extends(L, R, T, F, options) {
	return IsMappedResult(L)
		? ExtendsFromMappedResult(L, R, T, F, options)
		: IsMappedKey(L)
			? CreateType(ExtendsFromMappedKey(L, R, T, F, options))
			: CreateType(ExtendsResolve(L, R, T, F), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
function FromPropertyKey(K, U, L, R, options) {
	return {
		[K]: Extends(Literal(K), U, L, R, Clone(options)),
	};
}
function FromPropertyKeys(K, U, L, R, options) {
	return K.reduce((Acc, LK) => {
		return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
	}, {});
}
function FromMappedKey2(K, U, L, R, options) {
	return FromPropertyKeys(K.keys, U, L, R, options);
}
function ExtendsFromMappedKey(T, U, L, R, options) {
	const P = FromMappedKey2(T, U, L, R, options);
	return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-undefined.mjs
function Intersect2(schema) {
	return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
}
function Union2(schema) {
	return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
}
function Not(schema) {
	return !ExtendsUndefinedCheck(schema.not);
}
function ExtendsUndefinedCheck(schema) {
	return schema[Kind] === "Intersect"
		? Intersect2(schema)
		: schema[Kind] === "Union"
			? Union2(schema)
			: schema[Kind] === "Not"
				? Not(schema)
				: schema[Kind] === "Undefined"
					? true
					: false;
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
	return Exclude(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
function ExcludeRest(L, R) {
	const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
	return excluded.length === 1 ? excluded[0] : Union(excluded);
}
function Exclude(L, R, options = {}) {
	if (IsTemplateLiteral(L)) return CreateType(ExcludeFromTemplateLiteral(L, R), options);
	if (IsMappedResult(L)) return CreateType(ExcludeFromMappedResult(L, R), options);
	return CreateType(
		IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L,
		options,
	);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
function FromProperties9(P, U) {
	const Acc = {};
	for (const K2 of globalThis.Object.getOwnPropertyNames(P)) Acc[K2] = Exclude(P[K2], U);
	return Acc;
}
function FromMappedResult7(R, T) {
	return FromProperties9(R.properties, T);
}
function ExcludeFromMappedResult(R, T) {
	const P = FromMappedResult7(R, T);
	return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
	return Extract(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
function ExtractRest(L, R) {
	const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
	return extracted.length === 1 ? extracted[0] : Union(extracted);
}
function Extract(L, R, options) {
	if (IsTemplateLiteral(L)) return CreateType(ExtractFromTemplateLiteral(L, R), options);
	if (IsMappedResult(L)) return CreateType(ExtractFromMappedResult(L, R), options);
	return CreateType(
		IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(),
		options,
	);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
function FromProperties10(P, T) {
	const Acc = {};
	for (const K2 of globalThis.Object.getOwnPropertyNames(P)) Acc[K2] = Extract(P[K2], T);
	return Acc;
}
function FromMappedResult8(R, T) {
	return FromProperties10(R.properties, T);
}
function ExtractFromMappedResult(R, T) {
	const P = FromMappedResult8(R, T);
	return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/instance-type/instance-type.mjs
function InstanceType(schema, options) {
	return IsConstructor(schema) ? CreateType(schema.returns, options) : Never(options);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
	return Readonly(Optional(schema));
}

// node_modules/@sinclair/typebox/build/esm/type/record/record.mjs
function RecordCreateFromPattern(pattern, T, options) {
	return CreateType(
		{ [Kind]: "Record", type: "object", patternProperties: { [pattern]: T } },
		options,
	);
}
function RecordCreateFromKeys(K, T, options) {
	const result = {};
	for (const K2 of K) result[K2] = T;
	return Object2(result, { ...options, [Hint]: "Record" });
}
function FromTemplateLiteralKey(K, T, options) {
	return IsTemplateLiteralFinite(K)
		? RecordCreateFromKeys(IndexPropertyKeys(K), T, options)
		: RecordCreateFromPattern(K.pattern, T, options);
}
function FromUnionKey(key, type, options) {
	return RecordCreateFromKeys(IndexPropertyKeys(Union(key)), type, options);
}
function FromLiteralKey(key, type, options) {
	return RecordCreateFromKeys([key.toString()], type, options);
}
function FromRegExpKey(key, type, options) {
	return RecordCreateFromPattern(key.source, type, options);
}
function FromStringKey(key, type, options) {
	const pattern = IsUndefined(key.pattern) ? PatternStringExact : key.pattern;
	return RecordCreateFromPattern(pattern, type, options);
}
function FromAnyKey(_, type, options) {
	return RecordCreateFromPattern(PatternStringExact, type, options);
}
function FromNeverKey(_key, type, options) {
	return RecordCreateFromPattern(PatternNeverExact, type, options);
}
function FromBooleanKey(_key, type, options) {
	return Object2({ true: type, false: type }, options);
}
function FromIntegerKey(_key, type, options) {
	return RecordCreateFromPattern(PatternNumberExact, type, options);
}
function FromNumberKey(_, type, options) {
	return RecordCreateFromPattern(PatternNumberExact, type, options);
}
function Record(key, type, options = {}) {
	return IsUnion(key)
		? FromUnionKey(key.anyOf, type, options)
		: IsTemplateLiteral(key)
			? FromTemplateLiteralKey(key, type, options)
			: IsLiteral(key)
				? FromLiteralKey(key.const, type, options)
				: IsBoolean3(key)
					? FromBooleanKey(key, type, options)
					: IsInteger2(key)
						? FromIntegerKey(key, type, options)
						: IsNumber3(key)
							? FromNumberKey(key, type, options)
							: IsRegExp2(key)
								? FromRegExpKey(key, type, options)
								: IsString3(key)
									? FromStringKey(key, type, options)
									: IsAny(key)
										? FromAnyKey(key, type, options)
										: IsNever(key)
											? FromNeverKey(key, type, options)
											: Never(options);
}
function RecordPattern(record) {
	return globalThis.Object.getOwnPropertyNames(record.patternProperties)[0];
}
function RecordKey2(type) {
	const pattern = RecordPattern(type);
	return pattern === PatternStringExact
		? String2()
		: pattern === PatternNumberExact
			? Number2()
			: String2({ pattern });
}
function RecordValue2(type) {
	return type.patternProperties[RecordPattern(type)];
}

// node_modules/@sinclair/typebox/build/esm/type/instantiate/instantiate.mjs
function FromConstructor2(args, type) {
	type.parameters = FromTypes(args, type.parameters);
	type.returns = FromType(args, type.returns);
	return type;
}
function FromFunction2(args, type) {
	type.parameters = FromTypes(args, type.parameters);
	type.returns = FromType(args, type.returns);
	return type;
}
function FromIntersect5(args, type) {
	type.allOf = FromTypes(args, type.allOf);
	return type;
}
function FromUnion7(args, type) {
	type.anyOf = FromTypes(args, type.anyOf);
	return type;
}
function FromTuple4(args, type) {
	if (IsUndefined(type.items)) return type;
	type.items = FromTypes(args, type.items);
	return type;
}
function FromArray5(args, type) {
	type.items = FromType(args, type.items);
	return type;
}
function FromAsyncIterator2(args, type) {
	type.items = FromType(args, type.items);
	return type;
}
function FromIterator2(args, type) {
	type.items = FromType(args, type.items);
	return type;
}
function FromPromise3(args, type) {
	type.item = FromType(args, type.item);
	return type;
}
function FromObject2(args, type) {
	const mappedProperties = FromProperties11(args, type.properties);
	return { ...type, ...Object2(mappedProperties) };
}
function FromRecord2(args, type) {
	const mappedKey = FromType(args, RecordKey2(type));
	const mappedValue = FromType(args, RecordValue2(type));
	const result = Record(mappedKey, mappedValue);
	return { ...type, ...result };
}
function FromArgument(args, argument) {
	return argument.index in args ? args[argument.index] : Unknown();
}
function FromProperty2(args, type) {
	const isReadonly = IsReadonly(type);
	const isOptional = IsOptional(type);
	const mapped = FromType(args, type);
	return isReadonly && isOptional
		? ReadonlyOptional(mapped)
		: isReadonly && !isOptional
			? Readonly(mapped)
			: !isReadonly && isOptional
				? Optional(mapped)
				: mapped;
}
function FromProperties11(args, properties) {
	return globalThis.Object.getOwnPropertyNames(properties).reduce((result, key) => {
		return { ...result, [key]: FromProperty2(args, properties[key]) };
	}, {});
}
function FromTypes(args, types) {
	return types.map((type) => FromType(args, type));
}
function FromType(args, type) {
	return IsConstructor(type)
		? FromConstructor2(args, type)
		: IsFunction3(type)
			? FromFunction2(args, type)
			: IsIntersect(type)
				? FromIntersect5(args, type)
				: IsUnion(type)
					? FromUnion7(args, type)
					: IsTuple(type)
						? FromTuple4(args, type)
						: IsArray3(type)
							? FromArray5(args, type)
							: IsAsyncIterator3(type)
								? FromAsyncIterator2(args, type)
								: IsIterator3(type)
									? FromIterator2(args, type)
									: IsPromise2(type)
										? FromPromise3(args, type)
										: IsObject3(type)
											? FromObject2(args, type)
											: IsRecord(type)
												? FromRecord2(args, type)
												: IsArgument(type)
													? FromArgument(args, type)
													: type;
}
function Instantiate(type, args) {
	return FromType(args, CloneType(type));
}

// node_modules/@sinclair/typebox/build/esm/type/integer/integer.mjs
function Integer(options) {
	return CreateType({ [Kind]: "Integer", type: "integer" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic-from-mapped-key.mjs
function MappedIntrinsicPropertyKey(K, M, options) {
	return {
		[K]: Intrinsic(Literal(K), M, Clone(options)),
	};
}
function MappedIntrinsicPropertyKeys(K, M, options) {
	const result = K.reduce((Acc, L) => {
		return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
	}, {});
	return result;
}
function MappedIntrinsicProperties(T, M, options) {
	return MappedIntrinsicPropertyKeys(T["keys"], M, options);
}
function IntrinsicFromMappedKey(T, M, options) {
	const P = MappedIntrinsicProperties(T, M, options);
	return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
function ApplyUncapitalize(value) {
	const [first, rest] = [value.slice(0, 1), value.slice(1)];
	return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize(value) {
	const [first, rest] = [value.slice(0, 1), value.slice(1)];
	return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase(value) {
	return value.toUpperCase();
}
function ApplyLowercase(value) {
	return value.toLowerCase();
}
function FromTemplateLiteral3(schema, mode, options) {
	const expression = TemplateLiteralParseExact(schema.pattern);
	const finite = IsTemplateLiteralExpressionFinite(expression);
	if (!finite) return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
	const strings = [...TemplateLiteralExpressionGenerate(expression)];
	const literals = strings.map((value) => Literal(value));
	const mapped = FromRest5(literals, mode);
	const union = Union(mapped);
	return TemplateLiteral([union], options);
}
function FromLiteralValue(value, mode) {
	return typeof value === "string"
		? mode === "Uncapitalize"
			? ApplyUncapitalize(value)
			: mode === "Capitalize"
				? ApplyCapitalize(value)
				: mode === "Uppercase"
					? ApplyUppercase(value)
					: mode === "Lowercase"
						? ApplyLowercase(value)
						: value
		: value.toString();
}
function FromRest5(T, M) {
	return T.map((L) => Intrinsic(L, M));
}
function Intrinsic(schema, mode, options = {}) {
	return IsMappedKey(schema)
		? IntrinsicFromMappedKey(schema, mode, options)
		: IsTemplateLiteral(schema)
			? FromTemplateLiteral3(schema, mode, options)
			: IsUnion(schema)
				? Union(FromRest5(schema.anyOf, mode), options)
				: IsLiteral(schema)
					? Literal(FromLiteralValue(schema.const, mode), options)
					: CreateType(schema, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
	return Intrinsic(T, "Capitalize", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
	return Intrinsic(T, "Lowercase", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
	return Intrinsic(T, "Uncapitalize", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
	return Intrinsic(T, "Uppercase", options);
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-result.mjs
function FromProperties12(properties, propertyKeys, options) {
	const result = {};
	for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
		result[K2] = Omit(properties[K2], propertyKeys, Clone(options));
	return result;
}
function FromMappedResult9(mappedResult, propertyKeys, options) {
	return FromProperties12(mappedResult.properties, propertyKeys, options);
}
function OmitFromMappedResult(mappedResult, propertyKeys, options) {
	const properties = FromMappedResult9(mappedResult, propertyKeys, options);
	return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
function FromIntersect6(types, propertyKeys) {
	return types.map((type) => OmitResolve(type, propertyKeys));
}
function FromUnion8(types, propertyKeys) {
	return types.map((type) => OmitResolve(type, propertyKeys));
}
function FromProperty3(properties, key) {
	const { [key]: _, ...R } = properties;
	return R;
}
function FromProperties13(properties, propertyKeys) {
	return propertyKeys.reduce((T, K2) => FromProperty3(T, K2), properties);
}
function FromObject3(properties, propertyKeys) {
	const options = Discard(properties, [TransformKind, "$id", "required", "properties"]);
	const omittedProperties = FromProperties13(properties["properties"], propertyKeys);
	return Object2(omittedProperties, options);
}
function UnionFromPropertyKeys(propertyKeys) {
	const result = propertyKeys.reduce(
		(result2, key) => (IsLiteralValue(key) ? [...result2, Literal(key)] : result2),
		[],
	);
	return Union(result);
}
function OmitResolve(properties, propertyKeys) {
	return IsIntersect(properties)
		? Intersect(FromIntersect6(properties.allOf, propertyKeys))
		: IsUnion(properties)
			? Union(FromUnion8(properties.anyOf, propertyKeys))
			: IsObject3(properties)
				? FromObject3(properties, propertyKeys)
				: Object2({});
}
function Omit(type, key, options) {
	const typeKey = IsArray(key) ? UnionFromPropertyKeys(key) : key;
	const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;
	const isTypeRef = IsRef(type);
	const isKeyRef = IsRef(key);
	return IsMappedResult(type)
		? OmitFromMappedResult(type, propertyKeys, options)
		: IsMappedKey(key)
			? OmitFromMappedKey(type, key, options)
			: isTypeRef && isKeyRef
				? Computed("Omit", [type, typeKey], options)
				: !isTypeRef && isKeyRef
					? Computed("Omit", [type, typeKey], options)
					: isTypeRef && !isKeyRef
						? Computed("Omit", [type, typeKey], options)
						: CreateType({ ...OmitResolve(type, propertyKeys), ...options });
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
function FromPropertyKey2(type, key, options) {
	return { [key]: Omit(type, [key], Clone(options)) };
}
function FromPropertyKeys2(type, propertyKeys, options) {
	return propertyKeys.reduce((Acc, LK) => {
		return { ...Acc, ...FromPropertyKey2(type, LK, options) };
	}, {});
}
function FromMappedKey3(type, mappedKey, options) {
	return FromPropertyKeys2(type, mappedKey.keys, options);
}
function OmitFromMappedKey(type, mappedKey, options) {
	const properties = FromMappedKey3(type, mappedKey, options);
	return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-result.mjs
function FromProperties14(properties, propertyKeys, options) {
	const result = {};
	for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
		result[K2] = Pick(properties[K2], propertyKeys, Clone(options));
	return result;
}
function FromMappedResult10(mappedResult, propertyKeys, options) {
	return FromProperties14(mappedResult.properties, propertyKeys, options);
}
function PickFromMappedResult(mappedResult, propertyKeys, options) {
	const properties = FromMappedResult10(mappedResult, propertyKeys, options);
	return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
function FromIntersect7(types, propertyKeys) {
	return types.map((type) => PickResolve(type, propertyKeys));
}
function FromUnion9(types, propertyKeys) {
	return types.map((type) => PickResolve(type, propertyKeys));
}
function FromProperties15(properties, propertyKeys) {
	const result = {};
	for (const K2 of propertyKeys) if (K2 in properties) result[K2] = properties[K2];
	return result;
}
function FromObject4(T, K) {
	const options = Discard(T, [TransformKind, "$id", "required", "properties"]);
	const properties = FromProperties15(T["properties"], K);
	return Object2(properties, options);
}
function UnionFromPropertyKeys2(propertyKeys) {
	const result = propertyKeys.reduce(
		(result2, key) => (IsLiteralValue(key) ? [...result2, Literal(key)] : result2),
		[],
	);
	return Union(result);
}
function PickResolve(properties, propertyKeys) {
	return IsIntersect(properties)
		? Intersect(FromIntersect7(properties.allOf, propertyKeys))
		: IsUnion(properties)
			? Union(FromUnion9(properties.anyOf, propertyKeys))
			: IsObject3(properties)
				? FromObject4(properties, propertyKeys)
				: Object2({});
}
function Pick(type, key, options) {
	const typeKey = IsArray(key) ? UnionFromPropertyKeys2(key) : key;
	const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;
	const isTypeRef = IsRef(type);
	const isKeyRef = IsRef(key);
	return IsMappedResult(type)
		? PickFromMappedResult(type, propertyKeys, options)
		: IsMappedKey(key)
			? PickFromMappedKey(type, key, options)
			: isTypeRef && isKeyRef
				? Computed("Pick", [type, typeKey], options)
				: !isTypeRef && isKeyRef
					? Computed("Pick", [type, typeKey], options)
					: isTypeRef && !isKeyRef
						? Computed("Pick", [type, typeKey], options)
						: CreateType({ ...PickResolve(type, propertyKeys), ...options });
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
function FromPropertyKey3(type, key, options) {
	return {
		[key]: Pick(type, [key], Clone(options)),
	};
}
function FromPropertyKeys3(type, propertyKeys, options) {
	return propertyKeys.reduce((result, leftKey) => {
		return { ...result, ...FromPropertyKey3(type, leftKey, options) };
	}, {});
}
function FromMappedKey4(type, mappedKey, options) {
	return FromPropertyKeys3(type, mappedKey.keys, options);
}
function PickFromMappedKey(type, mappedKey, options) {
	const properties = FromMappedKey4(type, mappedKey, options);
	return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/partial/partial.mjs
function FromComputed3(target, parameters) {
	return Computed("Partial", [Computed(target, parameters)]);
}
function FromRef3($ref) {
	return Computed("Partial", [Ref($ref)]);
}
function FromProperties16(properties) {
	const partialProperties = {};
	for (const K of globalThis.Object.getOwnPropertyNames(properties))
		partialProperties[K] = Optional(properties[K]);
	return partialProperties;
}
function FromObject5(type) {
	const options = Discard(type, [TransformKind, "$id", "required", "properties"]);
	const properties = FromProperties16(type["properties"]);
	return Object2(properties, options);
}
function FromRest6(types) {
	return types.map((type) => PartialResolve(type));
}
function PartialResolve(type) {
	return IsComputed(type)
		? FromComputed3(type.target, type.parameters)
		: IsRef(type)
			? FromRef3(type.$ref)
			: IsIntersect(type)
				? Intersect(FromRest6(type.allOf))
				: IsUnion(type)
					? Union(FromRest6(type.anyOf))
					: IsObject3(type)
						? FromObject5(type)
						: IsBigInt3(type)
							? type
							: IsBoolean3(type)
								? type
								: IsInteger2(type)
									? type
									: IsLiteral(type)
										? type
										: IsNull3(type)
											? type
											: IsNumber3(type)
												? type
												: IsString3(type)
													? type
													: IsSymbol3(type)
														? type
														: IsUndefined3(type)
															? type
															: Object2({});
}
function Partial(type, options) {
	if (IsMappedResult(type)) {
		return PartialFromMappedResult(type, options);
	} else {
		return CreateType({ ...PartialResolve(type), ...options });
	}
}

// node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
function FromProperties17(K, options) {
	const Acc = {};
	for (const K2 of globalThis.Object.getOwnPropertyNames(K))
		Acc[K2] = Partial(K[K2], Clone(options));
	return Acc;
}
function FromMappedResult11(R, options) {
	return FromProperties17(R.properties, options);
}
function PartialFromMappedResult(R, options) {
	const P = FromMappedResult11(R, options);
	return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/required/required.mjs
function FromComputed4(target, parameters) {
	return Computed("Required", [Computed(target, parameters)]);
}
function FromRef4($ref) {
	return Computed("Required", [Ref($ref)]);
}
function FromProperties18(properties) {
	const requiredProperties = {};
	for (const K of globalThis.Object.getOwnPropertyNames(properties))
		requiredProperties[K] = Discard(properties[K], [OptionalKind]);
	return requiredProperties;
}
function FromObject6(type) {
	const options = Discard(type, [TransformKind, "$id", "required", "properties"]);
	const properties = FromProperties18(type["properties"]);
	return Object2(properties, options);
}
function FromRest7(types) {
	return types.map((type) => RequiredResolve(type));
}
function RequiredResolve(type) {
	return IsComputed(type)
		? FromComputed4(type.target, type.parameters)
		: IsRef(type)
			? FromRef4(type.$ref)
			: IsIntersect(type)
				? Intersect(FromRest7(type.allOf))
				: IsUnion(type)
					? Union(FromRest7(type.anyOf))
					: IsObject3(type)
						? FromObject6(type)
						: IsBigInt3(type)
							? type
							: IsBoolean3(type)
								? type
								: IsInteger2(type)
									? type
									: IsLiteral(type)
										? type
										: IsNull3(type)
											? type
											: IsNumber3(type)
												? type
												: IsString3(type)
													? type
													: IsSymbol3(type)
														? type
														: IsUndefined3(type)
															? type
															: Object2({});
}
function Required(type, options) {
	if (IsMappedResult(type)) {
		return RequiredFromMappedResult(type, options);
	} else {
		return CreateType({ ...RequiredResolve(type), ...options });
	}
}

// node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
function FromProperties19(P, options) {
	const Acc = {};
	for (const K2 of globalThis.Object.getOwnPropertyNames(P)) Acc[K2] = Required(P[K2], options);
	return Acc;
}
function FromMappedResult12(R, options) {
	return FromProperties19(R.properties, options);
}
function RequiredFromMappedResult(R, options) {
	const P = FromMappedResult12(R, options);
	return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/module/compute.mjs
function DereferenceParameters(moduleProperties, types) {
	return types.map((type) => {
		return IsRef(type)
			? Dereference(moduleProperties, type.$ref)
			: FromType2(moduleProperties, type);
	});
}
function Dereference(moduleProperties, ref) {
	return ref in moduleProperties
		? IsRef(moduleProperties[ref])
			? Dereference(moduleProperties, moduleProperties[ref].$ref)
			: FromType2(moduleProperties, moduleProperties[ref])
		: Never();
}
function FromAwaited(parameters) {
	return Awaited(parameters[0]);
}
function FromIndex(parameters) {
	return Index(parameters[0], parameters[1]);
}
function FromKeyOf(parameters) {
	return KeyOf(parameters[0]);
}
function FromPartial(parameters) {
	return Partial(parameters[0]);
}
function FromOmit(parameters) {
	return Omit(parameters[0], parameters[1]);
}
function FromPick(parameters) {
	return Pick(parameters[0], parameters[1]);
}
function FromRequired(parameters) {
	return Required(parameters[0]);
}
function FromComputed5(moduleProperties, target, parameters) {
	const dereferenced = DereferenceParameters(moduleProperties, parameters);
	return target === "Awaited"
		? FromAwaited(dereferenced)
		: target === "Index"
			? FromIndex(dereferenced)
			: target === "KeyOf"
				? FromKeyOf(dereferenced)
				: target === "Partial"
					? FromPartial(dereferenced)
					: target === "Omit"
						? FromOmit(dereferenced)
						: target === "Pick"
							? FromPick(dereferenced)
							: target === "Required"
								? FromRequired(dereferenced)
								: Never();
}
function FromArray6(moduleProperties, type) {
	return Array2(FromType2(moduleProperties, type));
}
function FromAsyncIterator3(moduleProperties, type) {
	return AsyncIterator(FromType2(moduleProperties, type));
}
function FromConstructor3(moduleProperties, parameters, instanceType) {
	return Constructor(
		FromTypes2(moduleProperties, parameters),
		FromType2(moduleProperties, instanceType),
	);
}
function FromFunction3(moduleProperties, parameters, returnType) {
	return Function2(
		FromTypes2(moduleProperties, parameters),
		FromType2(moduleProperties, returnType),
	);
}
function FromIntersect8(moduleProperties, types) {
	return Intersect(FromTypes2(moduleProperties, types));
}
function FromIterator3(moduleProperties, type) {
	return Iterator(FromType2(moduleProperties, type));
}
function FromObject7(moduleProperties, properties) {
	return Object2(
		globalThis.Object.keys(properties).reduce((result, key) => {
			return { ...result, [key]: FromType2(moduleProperties, properties[key]) };
		}, {}),
	);
}
function FromRecord3(moduleProperties, type) {
	const [value, pattern] = [FromType2(moduleProperties, RecordValue2(type)), RecordPattern(type)];
	const result = CloneType(type);
	result.patternProperties[pattern] = value;
	return result;
}
function FromTransform(moduleProperties, transform) {
	return IsRef(transform)
		? {
				...Dereference(moduleProperties, transform.$ref),
				[TransformKind]: transform[TransformKind],
			}
		: transform;
}
function FromTuple5(moduleProperties, types) {
	return Tuple(FromTypes2(moduleProperties, types));
}
function FromUnion10(moduleProperties, types) {
	return Union(FromTypes2(moduleProperties, types));
}
function FromTypes2(moduleProperties, types) {
	return types.map((type) => FromType2(moduleProperties, type));
}
function FromType2(moduleProperties, type) {
	return IsOptional(type)
		? CreateType(FromType2(moduleProperties, Discard(type, [OptionalKind])), type)
		: IsReadonly(type)
			? CreateType(FromType2(moduleProperties, Discard(type, [ReadonlyKind])), type)
			: IsTransform(type)
				? CreateType(FromTransform(moduleProperties, type), type)
				: IsArray3(type)
					? CreateType(FromArray6(moduleProperties, type.items), type)
					: IsAsyncIterator3(type)
						? CreateType(FromAsyncIterator3(moduleProperties, type.items), type)
						: IsComputed(type)
							? CreateType(FromComputed5(moduleProperties, type.target, type.parameters))
							: IsConstructor(type)
								? CreateType(
										FromConstructor3(moduleProperties, type.parameters, type.returns),
										type,
									)
								: IsFunction3(type)
									? CreateType(FromFunction3(moduleProperties, type.parameters, type.returns), type)
									: IsIntersect(type)
										? CreateType(FromIntersect8(moduleProperties, type.allOf), type)
										: IsIterator3(type)
											? CreateType(FromIterator3(moduleProperties, type.items), type)
											: IsObject3(type)
												? CreateType(FromObject7(moduleProperties, type.properties), type)
												: IsRecord(type)
													? CreateType(FromRecord3(moduleProperties, type))
													: IsTuple(type)
														? CreateType(FromTuple5(moduleProperties, type.items || []), type)
														: IsUnion(type)
															? CreateType(FromUnion10(moduleProperties, type.anyOf), type)
															: type;
}
function ComputeType(moduleProperties, key) {
	return key in moduleProperties ? FromType2(moduleProperties, moduleProperties[key]) : Never();
}
function ComputeModuleProperties(moduleProperties) {
	return globalThis.Object.getOwnPropertyNames(moduleProperties).reduce((result, key) => {
		return { ...result, [key]: ComputeType(moduleProperties, key) };
	}, {});
}

// node_modules/@sinclair/typebox/build/esm/type/module/module.mjs
class TModule {
	constructor($defs) {
		const computed = ComputeModuleProperties($defs);
		const identified = this.WithIdentifiers(computed);
		this.$defs = identified;
	}
	Import(key, options) {
		const $defs = { ...this.$defs, [key]: CreateType(this.$defs[key], options) };
		return CreateType({ [Kind]: "Import", $defs, $ref: key });
	}
	WithIdentifiers($defs) {
		return globalThis.Object.getOwnPropertyNames($defs).reduce((result, key) => {
			return { ...result, [key]: { ...$defs[key], $id: key } };
		}, {});
	}
}
function Module(properties) {
	return new TModule(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/not/not.mjs
function Not2(type, options) {
	return CreateType({ [Kind]: "Not", not: type }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/parameters/parameters.mjs
function Parameters(schema, options) {
	return IsFunction3(schema) ? Tuple(schema.parameters, options) : Never();
}

// node_modules/@sinclair/typebox/build/esm/type/recursive/recursive.mjs
var Ordinal = 0;
function Recursive(callback, options = {}) {
	if (IsUndefined(options.$id)) options.$id = `T${Ordinal++}`;
	const thisType = CloneType(callback({ [Kind]: "This", $ref: `${options.$id}` }));
	thisType.$id = options.$id;
	return CreateType({ [Hint]: "Recursive", ...thisType }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/regexp/regexp.mjs
function RegExp2(unresolved, options) {
	const expr = IsString(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
	return CreateType(
		{ [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags },
		options,
	);
}

// node_modules/@sinclair/typebox/build/esm/type/rest/rest.mjs
function RestResolve(T) {
	return IsIntersect(T) ? T.allOf : IsUnion(T) ? T.anyOf : IsTuple(T) ? (T.items ?? []) : [];
}
function Rest(T) {
	return RestResolve(T);
}

// node_modules/@sinclair/typebox/build/esm/type/return-type/return-type.mjs
function ReturnType(schema, options) {
	return IsFunction3(schema) ? CreateType(schema.returns, options) : Never(options);
}

// node_modules/@sinclair/typebox/build/esm/type/transform/transform.mjs
class TransformDecodeBuilder {
	constructor(schema) {
		this.schema = schema;
	}
	Decode(decode) {
		return new TransformEncodeBuilder(this.schema, decode);
	}
}

class TransformEncodeBuilder {
	constructor(schema, decode) {
		this.schema = schema;
		this.decode = decode;
	}
	EncodeTransform(encode, schema) {
		const Encode = (value) => schema[TransformKind].Encode(encode(value));
		const Decode = (value) => this.decode(schema[TransformKind].Decode(value));
		const Codec = { Encode, Decode };
		return { ...schema, [TransformKind]: Codec };
	}
	EncodeSchema(encode, schema) {
		const Codec = { Decode: this.decode, Encode: encode };
		return { ...schema, [TransformKind]: Codec };
	}
	Encode(encode) {
		return IsTransform(this.schema)
			? this.EncodeTransform(encode, this.schema)
			: this.EncodeSchema(encode, this.schema);
	}
}
function Transform(schema) {
	return new TransformDecodeBuilder(schema);
}

// node_modules/@sinclair/typebox/build/esm/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
	return CreateType({ [Kind]: options[Kind] ?? "Unsafe" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/void/void.mjs
function Void(options) {
	return CreateType({ [Kind]: "Void", type: "void" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/type/type.mjs
var exports_type3 = {};
__export(exports_type3, {
	Void: () => Void,
	Uppercase: () => Uppercase,
	Unsafe: () => Unsafe,
	Unknown: () => Unknown,
	Union: () => Union,
	Undefined: () => Undefined,
	Uncapitalize: () => Uncapitalize,
	Uint8Array: () => Uint8Array2,
	Tuple: () => Tuple,
	Transform: () => Transform,
	TemplateLiteral: () => TemplateLiteral,
	Symbol: () => Symbol2,
	String: () => String2,
	ReturnType: () => ReturnType,
	Rest: () => Rest,
	Required: () => Required,
	RegExp: () => RegExp2,
	Ref: () => Ref,
	Recursive: () => Recursive,
	Record: () => Record,
	ReadonlyOptional: () => ReadonlyOptional,
	Readonly: () => Readonly,
	Promise: () => Promise2,
	Pick: () => Pick,
	Partial: () => Partial,
	Parameters: () => Parameters,
	Optional: () => Optional,
	Omit: () => Omit,
	Object: () => Object2,
	Number: () => Number2,
	Null: () => Null,
	Not: () => Not2,
	Never: () => Never,
	Module: () => Module,
	Mapped: () => Mapped,
	Lowercase: () => Lowercase,
	Literal: () => Literal,
	KeyOf: () => KeyOf,
	Iterator: () => Iterator,
	Intersect: () => Intersect,
	Integer: () => Integer,
	Instantiate: () => Instantiate,
	InstanceType: () => InstanceType,
	Index: () => Index,
	Function: () => Function2,
	Extract: () => Extract,
	Extends: () => Extends,
	Exclude: () => Exclude,
	Enum: () => Enum,
	Date: () => Date2,
	ConstructorParameters: () => ConstructorParameters,
	Constructor: () => Constructor,
	Const: () => Const,
	Composite: () => Composite,
	Capitalize: () => Capitalize,
	Boolean: () => Boolean2,
	BigInt: () => BigInt2,
	Awaited: () => Awaited,
	AsyncIterator: () => AsyncIterator,
	Array: () => Array2,
	Argument: () => Argument,
	Any: () => Any,
});

// node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
var Type = exports_type3;

// node_modules/@sinclair/typebox/build/esm/errors/function.mjs
function DefaultErrorFunction(error) {
	switch (error.errorType) {
		case ValueErrorType.ArrayContains:
			return "Expected array to contain at least one matching value";
		case ValueErrorType.ArrayMaxContains:
			return `Expected array to contain no more than ${error.schema.maxContains} matching values`;
		case ValueErrorType.ArrayMinContains:
			return `Expected array to contain at least ${error.schema.minContains} matching values`;
		case ValueErrorType.ArrayMaxItems:
			return `Expected array length to be less or equal to ${error.schema.maxItems}`;
		case ValueErrorType.ArrayMinItems:
			return `Expected array length to be greater or equal to ${error.schema.minItems}`;
		case ValueErrorType.ArrayUniqueItems:
			return "Expected array elements to be unique";
		case ValueErrorType.Array:
			return "Expected array";
		case ValueErrorType.AsyncIterator:
			return "Expected AsyncIterator";
		case ValueErrorType.BigIntExclusiveMaximum:
			return `Expected bigint to be less than ${error.schema.exclusiveMaximum}`;
		case ValueErrorType.BigIntExclusiveMinimum:
			return `Expected bigint to be greater than ${error.schema.exclusiveMinimum}`;
		case ValueErrorType.BigIntMaximum:
			return `Expected bigint to be less or equal to ${error.schema.maximum}`;
		case ValueErrorType.BigIntMinimum:
			return `Expected bigint to be greater or equal to ${error.schema.minimum}`;
		case ValueErrorType.BigIntMultipleOf:
			return `Expected bigint to be a multiple of ${error.schema.multipleOf}`;
		case ValueErrorType.BigInt:
			return "Expected bigint";
		case ValueErrorType.Boolean:
			return "Expected boolean";
		case ValueErrorType.DateExclusiveMinimumTimestamp:
			return `Expected Date timestamp to be greater than ${error.schema.exclusiveMinimumTimestamp}`;
		case ValueErrorType.DateExclusiveMaximumTimestamp:
			return `Expected Date timestamp to be less than ${error.schema.exclusiveMaximumTimestamp}`;
		case ValueErrorType.DateMinimumTimestamp:
			return `Expected Date timestamp to be greater or equal to ${error.schema.minimumTimestamp}`;
		case ValueErrorType.DateMaximumTimestamp:
			return `Expected Date timestamp to be less or equal to ${error.schema.maximumTimestamp}`;
		case ValueErrorType.DateMultipleOfTimestamp:
			return `Expected Date timestamp to be a multiple of ${error.schema.multipleOfTimestamp}`;
		case ValueErrorType.Date:
			return "Expected Date";
		case ValueErrorType.Function:
			return "Expected function";
		case ValueErrorType.IntegerExclusiveMaximum:
			return `Expected integer to be less than ${error.schema.exclusiveMaximum}`;
		case ValueErrorType.IntegerExclusiveMinimum:
			return `Expected integer to be greater than ${error.schema.exclusiveMinimum}`;
		case ValueErrorType.IntegerMaximum:
			return `Expected integer to be less or equal to ${error.schema.maximum}`;
		case ValueErrorType.IntegerMinimum:
			return `Expected integer to be greater or equal to ${error.schema.minimum}`;
		case ValueErrorType.IntegerMultipleOf:
			return `Expected integer to be a multiple of ${error.schema.multipleOf}`;
		case ValueErrorType.Integer:
			return "Expected integer";
		case ValueErrorType.IntersectUnevaluatedProperties:
			return "Unexpected property";
		case ValueErrorType.Intersect:
			return "Expected all values to match";
		case ValueErrorType.Iterator:
			return "Expected Iterator";
		case ValueErrorType.Literal:
			return `Expected ${typeof error.schema.const === "string" ? `'${error.schema.const}'` : error.schema.const}`;
		case ValueErrorType.Never:
			return "Never";
		case ValueErrorType.Not:
			return "Value should not match";
		case ValueErrorType.Null:
			return "Expected null";
		case ValueErrorType.NumberExclusiveMaximum:
			return `Expected number to be less than ${error.schema.exclusiveMaximum}`;
		case ValueErrorType.NumberExclusiveMinimum:
			return `Expected number to be greater than ${error.schema.exclusiveMinimum}`;
		case ValueErrorType.NumberMaximum:
			return `Expected number to be less or equal to ${error.schema.maximum}`;
		case ValueErrorType.NumberMinimum:
			return `Expected number to be greater or equal to ${error.schema.minimum}`;
		case ValueErrorType.NumberMultipleOf:
			return `Expected number to be a multiple of ${error.schema.multipleOf}`;
		case ValueErrorType.Number:
			return "Expected number";
		case ValueErrorType.Object:
			return "Expected object";
		case ValueErrorType.ObjectAdditionalProperties:
			return "Unexpected property";
		case ValueErrorType.ObjectMaxProperties:
			return `Expected object to have no more than ${error.schema.maxProperties} properties`;
		case ValueErrorType.ObjectMinProperties:
			return `Expected object to have at least ${error.schema.minProperties} properties`;
		case ValueErrorType.ObjectRequiredProperty:
			return "Expected required property";
		case ValueErrorType.Promise:
			return "Expected Promise";
		case ValueErrorType.RegExp:
			return "Expected string to match regular expression";
		case ValueErrorType.StringFormatUnknown:
			return `Unknown format '${error.schema.format}'`;
		case ValueErrorType.StringFormat:
			return `Expected string to match '${error.schema.format}' format`;
		case ValueErrorType.StringMaxLength:
			return `Expected string length less or equal to ${error.schema.maxLength}`;
		case ValueErrorType.StringMinLength:
			return `Expected string length greater or equal to ${error.schema.minLength}`;
		case ValueErrorType.StringPattern:
			return `Expected string to match '${error.schema.pattern}'`;
		case ValueErrorType.String:
			return "Expected string";
		case ValueErrorType.Symbol:
			return "Expected symbol";
		case ValueErrorType.TupleLength:
			return `Expected tuple to have ${error.schema.maxItems || 0} elements`;
		case ValueErrorType.Tuple:
			return "Expected tuple";
		case ValueErrorType.Uint8ArrayMaxByteLength:
			return `Expected byte length less or equal to ${error.schema.maxByteLength}`;
		case ValueErrorType.Uint8ArrayMinByteLength:
			return `Expected byte length greater or equal to ${error.schema.minByteLength}`;
		case ValueErrorType.Uint8Array:
			return "Expected Uint8Array";
		case ValueErrorType.Undefined:
			return "Expected undefined";
		case ValueErrorType.Union:
			return "Expected union value";
		case ValueErrorType.Void:
			return "Expected void";
		case ValueErrorType.Kind:
			return `Expected kind '${error.schema[Kind]}'`;
		default:
			return "Unknown error type";
	}
}
var errorFunction = DefaultErrorFunction;
function GetErrorFunction() {
	return errorFunction;
}

// node_modules/@sinclair/typebox/build/esm/value/deref/deref.mjs
class TypeDereferenceError extends TypeBoxError {
	constructor(schema) {
		super(`Unable to dereference schema with $id '${schema.$ref}'`);
		this.schema = schema;
	}
}
function Resolve(schema, references) {
	const target = references.find((target2) => target2.$id === schema.$ref);
	if (target === undefined) throw new TypeDereferenceError(schema);
	return Deref(target, references);
}
function Pushref(schema, references) {
	if (!IsString2(schema.$id) || references.some((target) => target.$id === schema.$id))
		return references;
	references.push(schema);
	return references;
}
function Deref(schema, references) {
	return schema[Kind] === "This" || schema[Kind] === "Ref" ? Resolve(schema, references) : schema;
}

// node_modules/@sinclair/typebox/build/esm/value/hash/hash.mjs
class ValueHashError extends TypeBoxError {
	constructor(value) {
		super("Unable to hash value");
		this.value = value;
	}
}
var ByteMarker;
(function (ByteMarker2) {
	ByteMarker2[(ByteMarker2["Undefined"] = 0)] = "Undefined";
	ByteMarker2[(ByteMarker2["Null"] = 1)] = "Null";
	ByteMarker2[(ByteMarker2["Boolean"] = 2)] = "Boolean";
	ByteMarker2[(ByteMarker2["Number"] = 3)] = "Number";
	ByteMarker2[(ByteMarker2["String"] = 4)] = "String";
	ByteMarker2[(ByteMarker2["Object"] = 5)] = "Object";
	ByteMarker2[(ByteMarker2["Array"] = 6)] = "Array";
	ByteMarker2[(ByteMarker2["Date"] = 7)] = "Date";
	ByteMarker2[(ByteMarker2["Uint8Array"] = 8)] = "Uint8Array";
	ByteMarker2[(ByteMarker2["Symbol"] = 9)] = "Symbol";
	ByteMarker2[(ByteMarker2["BigInt"] = 10)] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt("18446744073709551616")];
var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);
function* NumberToBytes(value) {
	const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
	for (let i = 0; i < byteCount; i++) {
		yield (value >> (8 * (byteCount - 1 - i))) & 255;
	}
}
function ArrayType2(value) {
	FNV1A64(ByteMarker.Array);
	for (const item of value) {
		Visit4(item);
	}
}
function BooleanType(value) {
	FNV1A64(ByteMarker.Boolean);
	FNV1A64(value ? 1 : 0);
}
function BigIntType(value) {
	FNV1A64(ByteMarker.BigInt);
	F64In.setBigInt64(0, value);
	for (const byte of F64Out) {
		FNV1A64(byte);
	}
}
function DateType2(value) {
	FNV1A64(ByteMarker.Date);
	Visit4(value.getTime());
}
function NullType(value) {
	FNV1A64(ByteMarker.Null);
}
function NumberType(value) {
	FNV1A64(ByteMarker.Number);
	F64In.setFloat64(0, value);
	for (const byte of F64Out) {
		FNV1A64(byte);
	}
}
function ObjectType2(value) {
	FNV1A64(ByteMarker.Object);
	for (const key of globalThis.Object.getOwnPropertyNames(value).sort()) {
		Visit4(key);
		Visit4(value[key]);
	}
}
function StringType(value) {
	FNV1A64(ByteMarker.String);
	for (let i = 0; i < value.length; i++) {
		for (const byte of NumberToBytes(value.charCodeAt(i))) {
			FNV1A64(byte);
		}
	}
}
function SymbolType(value) {
	FNV1A64(ByteMarker.Symbol);
	Visit4(value.description);
}
function Uint8ArrayType2(value) {
	FNV1A64(ByteMarker.Uint8Array);
	for (let i = 0; i < value.length; i++) {
		FNV1A64(value[i]);
	}
}
function UndefinedType(value) {
	return FNV1A64(ByteMarker.Undefined);
}
function Visit4(value) {
	if (IsArray2(value)) return ArrayType2(value);
	if (IsBoolean2(value)) return BooleanType(value);
	if (IsBigInt2(value)) return BigIntType(value);
	if (IsDate2(value)) return DateType2(value);
	if (IsNull2(value)) return NullType(value);
	if (IsNumber2(value)) return NumberType(value);
	if (IsObject2(value)) return ObjectType2(value);
	if (IsString2(value)) return StringType(value);
	if (IsSymbol2(value)) return SymbolType(value);
	if (IsUint8Array2(value)) return Uint8ArrayType2(value);
	if (IsUndefined2(value)) return UndefinedType(value);
	throw new ValueHashError(value);
}
function FNV1A64(byte) {
	Accumulator = Accumulator ^ Bytes[byte];
	Accumulator = (Accumulator * Prime) % Size;
}
function Hash(value) {
	Accumulator = BigInt("14695981039346656037");
	Visit4(value);
	return Accumulator;
}

// node_modules/@sinclair/typebox/build/esm/value/check/check.mjs
class ValueCheckUnknownTypeError extends TypeBoxError {
	constructor(schema) {
		super("Unknown type");
		this.schema = schema;
	}
}
function IsAnyOrUnknown(schema) {
	return schema[Kind] === "Any" || schema[Kind] === "Unknown";
}
function IsDefined(value) {
	return value !== undefined;
}
function FromAny2(schema, references, value) {
	return true;
}
function FromArgument2(schema, references, value) {
	return true;
}
function FromArray7(schema, references, value) {
	if (!IsArray2(value)) return false;
	if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
		return false;
	}
	if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
		return false;
	}
	if (!value.every((value2) => Visit5(schema.items, references, value2))) {
		return false;
	}
	if (
		schema.uniqueItems === true &&
		!(function () {
			const set2 = new Set();
			for (const element of value) {
				const hashed = Hash(element);
				if (set2.has(hashed)) {
					return false;
				} else {
					set2.add(hashed);
				}
			}
			return true;
		})()
	) {
		return false;
	}
	if (
		!(IsDefined(schema.contains) || IsNumber2(schema.minContains) || IsNumber2(schema.maxContains))
	) {
		return true;
	}
	const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
	const containsCount = value.reduce(
		(acc, value2) => (Visit5(containsSchema, references, value2) ? acc + 1 : acc),
		0,
	);
	if (containsCount === 0) {
		return false;
	}
	if (IsNumber2(schema.minContains) && containsCount < schema.minContains) {
		return false;
	}
	if (IsNumber2(schema.maxContains) && containsCount > schema.maxContains) {
		return false;
	}
	return true;
}
function FromAsyncIterator4(schema, references, value) {
	return IsAsyncIterator2(value);
}
function FromBigInt2(schema, references, value) {
	if (!IsBigInt2(value)) return false;
	if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
		return false;
	}
	if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
		return false;
	}
	if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
		return false;
	}
	if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
		return false;
	}
	if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
		return false;
	}
	return true;
}
function FromBoolean2(schema, references, value) {
	return IsBoolean2(value);
}
function FromConstructor4(schema, references, value) {
	return Visit5(schema.returns, references, value.prototype);
}
function FromDate2(schema, references, value) {
	if (!IsDate2(value)) return false;
	if (
		IsDefined(schema.exclusiveMaximumTimestamp) &&
		!(value.getTime() < schema.exclusiveMaximumTimestamp)
	) {
		return false;
	}
	if (
		IsDefined(schema.exclusiveMinimumTimestamp) &&
		!(value.getTime() > schema.exclusiveMinimumTimestamp)
	) {
		return false;
	}
	if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
		return false;
	}
	if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
		return false;
	}
	if (
		IsDefined(schema.multipleOfTimestamp) &&
		!(value.getTime() % schema.multipleOfTimestamp === 0)
	) {
		return false;
	}
	return true;
}
function FromFunction4(schema, references, value) {
	return IsFunction2(value);
}
function FromImport(schema, references, value) {
	const definitions = globalThis.Object.values(schema.$defs);
	const target = schema.$defs[schema.$ref];
	return Visit5(target, [...references, ...definitions], value);
}
function FromInteger2(schema, references, value) {
	if (!IsInteger(value)) {
		return false;
	}
	if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
		return false;
	}
	if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
		return false;
	}
	if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
		return false;
	}
	if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
		return false;
	}
	if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
		return false;
	}
	return true;
}
function FromIntersect9(schema, references, value) {
	const check1 = schema.allOf.every((schema2) => Visit5(schema2, references, value));
	if (schema.unevaluatedProperties === false) {
		const keyPattern = new RegExp(KeyOfPattern(schema));
		const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
		return check1 && check2;
	} else if (IsSchema(schema.unevaluatedProperties)) {
		const keyCheck = new RegExp(KeyOfPattern(schema));
		const check2 = Object.getOwnPropertyNames(value).every(
			(key) => keyCheck.test(key) || Visit5(schema.unevaluatedProperties, references, value[key]),
		);
		return check1 && check2;
	} else {
		return check1;
	}
}
function FromIterator4(schema, references, value) {
	return IsIterator2(value);
}
function FromLiteral3(schema, references, value) {
	return value === schema.const;
}
function FromNever2(schema, references, value) {
	return false;
}
function FromNot2(schema, references, value) {
	return !Visit5(schema.not, references, value);
}
function FromNull2(schema, references, value) {
	return IsNull2(value);
}
function FromNumber2(schema, references, value) {
	if (!TypeSystemPolicy.IsNumberLike(value)) return false;
	if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
		return false;
	}
	if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
		return false;
	}
	if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
		return false;
	}
	if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
		return false;
	}
	if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
		return false;
	}
	return true;
}
function FromObject8(schema, references, value) {
	if (!TypeSystemPolicy.IsObjectLike(value)) return false;
	if (
		IsDefined(schema.minProperties) &&
		!(Object.getOwnPropertyNames(value).length >= schema.minProperties)
	) {
		return false;
	}
	if (
		IsDefined(schema.maxProperties) &&
		!(Object.getOwnPropertyNames(value).length <= schema.maxProperties)
	) {
		return false;
	}
	const knownKeys = Object.getOwnPropertyNames(schema.properties);
	for (const knownKey of knownKeys) {
		const property = schema.properties[knownKey];
		if (schema.required && schema.required.includes(knownKey)) {
			if (!Visit5(property, references, value[knownKey])) {
				return false;
			}
			if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
				return false;
			}
		} else {
			if (
				TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) &&
				!Visit5(property, references, value[knownKey])
			) {
				return false;
			}
		}
	}
	if (schema.additionalProperties === false) {
		const valueKeys = Object.getOwnPropertyNames(value);
		if (
			schema.required &&
			schema.required.length === knownKeys.length &&
			valueKeys.length === knownKeys.length
		) {
			return true;
		} else {
			return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
		}
	} else if (typeof schema.additionalProperties === "object") {
		const valueKeys = Object.getOwnPropertyNames(value);
		return valueKeys.every(
			(key) =>
				knownKeys.includes(key) || Visit5(schema.additionalProperties, references, value[key]),
		);
	} else {
		return true;
	}
}
function FromPromise4(schema, references, value) {
	return IsPromise(value);
}
function FromRecord4(schema, references, value) {
	if (!TypeSystemPolicy.IsRecordLike(value)) {
		return false;
	}
	if (
		IsDefined(schema.minProperties) &&
		!(Object.getOwnPropertyNames(value).length >= schema.minProperties)
	) {
		return false;
	}
	if (
		IsDefined(schema.maxProperties) &&
		!(Object.getOwnPropertyNames(value).length <= schema.maxProperties)
	) {
		return false;
	}
	const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
	const regex = new RegExp(patternKey);
	const check1 = Object.entries(value).every(([key, value2]) => {
		return regex.test(key) ? Visit5(patternSchema, references, value2) : true;
	});
	const check2 =
		typeof schema.additionalProperties === "object"
			? Object.entries(value).every(([key, value2]) => {
					return !regex.test(key) ? Visit5(schema.additionalProperties, references, value2) : true;
				})
			: true;
	const check3 =
		schema.additionalProperties === false
			? Object.getOwnPropertyNames(value).every((key) => {
					return regex.test(key);
				})
			: true;
	return check1 && check2 && check3;
}
function FromRef5(schema, references, value) {
	return Visit5(Deref(schema, references), references, value);
}
function FromRegExp2(schema, references, value) {
	const regex = new RegExp(schema.source, schema.flags);
	if (IsDefined(schema.minLength)) {
		if (!(value.length >= schema.minLength)) return false;
	}
	if (IsDefined(schema.maxLength)) {
		if (!(value.length <= schema.maxLength)) return false;
	}
	return regex.test(value);
}
function FromString2(schema, references, value) {
	if (!IsString2(value)) {
		return false;
	}
	if (IsDefined(schema.minLength)) {
		if (!(value.length >= schema.minLength)) return false;
	}
	if (IsDefined(schema.maxLength)) {
		if (!(value.length <= schema.maxLength)) return false;
	}
	if (IsDefined(schema.pattern)) {
		const regex = new RegExp(schema.pattern);
		if (!regex.test(value)) return false;
	}
	if (IsDefined(schema.format)) {
		if (!exports_format.Has(schema.format)) return false;
		const func = exports_format.Get(schema.format);
		return func(value);
	}
	return true;
}
function FromSymbol2(schema, references, value) {
	return IsSymbol2(value);
}
function FromTemplateLiteral4(schema, references, value) {
	return IsString2(value) && new RegExp(schema.pattern).test(value);
}
function FromThis(schema, references, value) {
	return Visit5(Deref(schema, references), references, value);
}
function FromTuple6(schema, references, value) {
	if (!IsArray2(value)) {
		return false;
	}
	if (schema.items === undefined && !(value.length === 0)) {
		return false;
	}
	if (!(value.length === schema.maxItems)) {
		return false;
	}
	if (!schema.items) {
		return true;
	}
	for (let i = 0; i < schema.items.length; i++) {
		if (!Visit5(schema.items[i], references, value[i])) return false;
	}
	return true;
}
function FromUndefined2(schema, references, value) {
	return IsUndefined2(value);
}
function FromUnion11(schema, references, value) {
	return schema.anyOf.some((inner) => Visit5(inner, references, value));
}
function FromUint8Array2(schema, references, value) {
	if (!IsUint8Array2(value)) {
		return false;
	}
	if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
		return false;
	}
	if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
		return false;
	}
	return true;
}
function FromUnknown2(schema, references, value) {
	return true;
}
function FromVoid2(schema, references, value) {
	return TypeSystemPolicy.IsVoidLike(value);
}
function FromKind(schema, references, value) {
	if (!exports_type2.Has(schema[Kind])) return false;
	const func = exports_type2.Get(schema[Kind]);
	return func(schema, value);
}
function Visit5(schema, references, value) {
	const references_ = IsDefined(schema.$id) ? Pushref(schema, references) : references;
	const schema_ = schema;
	switch (schema_[Kind]) {
		case "Any":
			return FromAny2(schema_, references_, value);
		case "Argument":
			return FromArgument2(schema_, references_, value);
		case "Array":
			return FromArray7(schema_, references_, value);
		case "AsyncIterator":
			return FromAsyncIterator4(schema_, references_, value);
		case "BigInt":
			return FromBigInt2(schema_, references_, value);
		case "Boolean":
			return FromBoolean2(schema_, references_, value);
		case "Constructor":
			return FromConstructor4(schema_, references_, value);
		case "Date":
			return FromDate2(schema_, references_, value);
		case "Function":
			return FromFunction4(schema_, references_, value);
		case "Import":
			return FromImport(schema_, references_, value);
		case "Integer":
			return FromInteger2(schema_, references_, value);
		case "Intersect":
			return FromIntersect9(schema_, references_, value);
		case "Iterator":
			return FromIterator4(schema_, references_, value);
		case "Literal":
			return FromLiteral3(schema_, references_, value);
		case "Never":
			return FromNever2(schema_, references_, value);
		case "Not":
			return FromNot2(schema_, references_, value);
		case "Null":
			return FromNull2(schema_, references_, value);
		case "Number":
			return FromNumber2(schema_, references_, value);
		case "Object":
			return FromObject8(schema_, references_, value);
		case "Promise":
			return FromPromise4(schema_, references_, value);
		case "Record":
			return FromRecord4(schema_, references_, value);
		case "Ref":
			return FromRef5(schema_, references_, value);
		case "RegExp":
			return FromRegExp2(schema_, references_, value);
		case "String":
			return FromString2(schema_, references_, value);
		case "Symbol":
			return FromSymbol2(schema_, references_, value);
		case "TemplateLiteral":
			return FromTemplateLiteral4(schema_, references_, value);
		case "This":
			return FromThis(schema_, references_, value);
		case "Tuple":
			return FromTuple6(schema_, references_, value);
		case "Undefined":
			return FromUndefined2(schema_, references_, value);
		case "Union":
			return FromUnion11(schema_, references_, value);
		case "Uint8Array":
			return FromUint8Array2(schema_, references_, value);
		case "Unknown":
			return FromUnknown2(schema_, references_, value);
		case "Void":
			return FromVoid2(schema_, references_, value);
		default:
			if (!exports_type2.Has(schema_[Kind])) throw new ValueCheckUnknownTypeError(schema_);
			return FromKind(schema_, references_, value);
	}
}
function Check(...args) {
	return args.length === 3 ? Visit5(args[0], args[1], args[2]) : Visit5(args[0], [], args[1]);
}

// node_modules/@sinclair/typebox/build/esm/errors/errors.mjs
var ValueErrorType;
(function (ValueErrorType2) {
	ValueErrorType2[(ValueErrorType2["ArrayContains"] = 0)] = "ArrayContains";
	ValueErrorType2[(ValueErrorType2["ArrayMaxContains"] = 1)] = "ArrayMaxContains";
	ValueErrorType2[(ValueErrorType2["ArrayMaxItems"] = 2)] = "ArrayMaxItems";
	ValueErrorType2[(ValueErrorType2["ArrayMinContains"] = 3)] = "ArrayMinContains";
	ValueErrorType2[(ValueErrorType2["ArrayMinItems"] = 4)] = "ArrayMinItems";
	ValueErrorType2[(ValueErrorType2["ArrayUniqueItems"] = 5)] = "ArrayUniqueItems";
	ValueErrorType2[(ValueErrorType2["Array"] = 6)] = "Array";
	ValueErrorType2[(ValueErrorType2["AsyncIterator"] = 7)] = "AsyncIterator";
	ValueErrorType2[(ValueErrorType2["BigIntExclusiveMaximum"] = 8)] = "BigIntExclusiveMaximum";
	ValueErrorType2[(ValueErrorType2["BigIntExclusiveMinimum"] = 9)] = "BigIntExclusiveMinimum";
	ValueErrorType2[(ValueErrorType2["BigIntMaximum"] = 10)] = "BigIntMaximum";
	ValueErrorType2[(ValueErrorType2["BigIntMinimum"] = 11)] = "BigIntMinimum";
	ValueErrorType2[(ValueErrorType2["BigIntMultipleOf"] = 12)] = "BigIntMultipleOf";
	ValueErrorType2[(ValueErrorType2["BigInt"] = 13)] = "BigInt";
	ValueErrorType2[(ValueErrorType2["Boolean"] = 14)] = "Boolean";
	ValueErrorType2[(ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15)] =
		"DateExclusiveMaximumTimestamp";
	ValueErrorType2[(ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16)] =
		"DateExclusiveMinimumTimestamp";
	ValueErrorType2[(ValueErrorType2["DateMaximumTimestamp"] = 17)] = "DateMaximumTimestamp";
	ValueErrorType2[(ValueErrorType2["DateMinimumTimestamp"] = 18)] = "DateMinimumTimestamp";
	ValueErrorType2[(ValueErrorType2["DateMultipleOfTimestamp"] = 19)] = "DateMultipleOfTimestamp";
	ValueErrorType2[(ValueErrorType2["Date"] = 20)] = "Date";
	ValueErrorType2[(ValueErrorType2["Function"] = 21)] = "Function";
	ValueErrorType2[(ValueErrorType2["IntegerExclusiveMaximum"] = 22)] = "IntegerExclusiveMaximum";
	ValueErrorType2[(ValueErrorType2["IntegerExclusiveMinimum"] = 23)] = "IntegerExclusiveMinimum";
	ValueErrorType2[(ValueErrorType2["IntegerMaximum"] = 24)] = "IntegerMaximum";
	ValueErrorType2[(ValueErrorType2["IntegerMinimum"] = 25)] = "IntegerMinimum";
	ValueErrorType2[(ValueErrorType2["IntegerMultipleOf"] = 26)] = "IntegerMultipleOf";
	ValueErrorType2[(ValueErrorType2["Integer"] = 27)] = "Integer";
	ValueErrorType2[(ValueErrorType2["IntersectUnevaluatedProperties"] = 28)] =
		"IntersectUnevaluatedProperties";
	ValueErrorType2[(ValueErrorType2["Intersect"] = 29)] = "Intersect";
	ValueErrorType2[(ValueErrorType2["Iterator"] = 30)] = "Iterator";
	ValueErrorType2[(ValueErrorType2["Kind"] = 31)] = "Kind";
	ValueErrorType2[(ValueErrorType2["Literal"] = 32)] = "Literal";
	ValueErrorType2[(ValueErrorType2["Never"] = 33)] = "Never";
	ValueErrorType2[(ValueErrorType2["Not"] = 34)] = "Not";
	ValueErrorType2[(ValueErrorType2["Null"] = 35)] = "Null";
	ValueErrorType2[(ValueErrorType2["NumberExclusiveMaximum"] = 36)] = "NumberExclusiveMaximum";
	ValueErrorType2[(ValueErrorType2["NumberExclusiveMinimum"] = 37)] = "NumberExclusiveMinimum";
	ValueErrorType2[(ValueErrorType2["NumberMaximum"] = 38)] = "NumberMaximum";
	ValueErrorType2[(ValueErrorType2["NumberMinimum"] = 39)] = "NumberMinimum";
	ValueErrorType2[(ValueErrorType2["NumberMultipleOf"] = 40)] = "NumberMultipleOf";
	ValueErrorType2[(ValueErrorType2["Number"] = 41)] = "Number";
	ValueErrorType2[(ValueErrorType2["ObjectAdditionalProperties"] = 42)] =
		"ObjectAdditionalProperties";
	ValueErrorType2[(ValueErrorType2["ObjectMaxProperties"] = 43)] = "ObjectMaxProperties";
	ValueErrorType2[(ValueErrorType2["ObjectMinProperties"] = 44)] = "ObjectMinProperties";
	ValueErrorType2[(ValueErrorType2["ObjectRequiredProperty"] = 45)] = "ObjectRequiredProperty";
	ValueErrorType2[(ValueErrorType2["Object"] = 46)] = "Object";
	ValueErrorType2[(ValueErrorType2["Promise"] = 47)] = "Promise";
	ValueErrorType2[(ValueErrorType2["RegExp"] = 48)] = "RegExp";
	ValueErrorType2[(ValueErrorType2["StringFormatUnknown"] = 49)] = "StringFormatUnknown";
	ValueErrorType2[(ValueErrorType2["StringFormat"] = 50)] = "StringFormat";
	ValueErrorType2[(ValueErrorType2["StringMaxLength"] = 51)] = "StringMaxLength";
	ValueErrorType2[(ValueErrorType2["StringMinLength"] = 52)] = "StringMinLength";
	ValueErrorType2[(ValueErrorType2["StringPattern"] = 53)] = "StringPattern";
	ValueErrorType2[(ValueErrorType2["String"] = 54)] = "String";
	ValueErrorType2[(ValueErrorType2["Symbol"] = 55)] = "Symbol";
	ValueErrorType2[(ValueErrorType2["TupleLength"] = 56)] = "TupleLength";
	ValueErrorType2[(ValueErrorType2["Tuple"] = 57)] = "Tuple";
	ValueErrorType2[(ValueErrorType2["Uint8ArrayMaxByteLength"] = 58)] = "Uint8ArrayMaxByteLength";
	ValueErrorType2[(ValueErrorType2["Uint8ArrayMinByteLength"] = 59)] = "Uint8ArrayMinByteLength";
	ValueErrorType2[(ValueErrorType2["Uint8Array"] = 60)] = "Uint8Array";
	ValueErrorType2[(ValueErrorType2["Undefined"] = 61)] = "Undefined";
	ValueErrorType2[(ValueErrorType2["Union"] = 62)] = "Union";
	ValueErrorType2[(ValueErrorType2["Void"] = 63)] = "Void";
})(ValueErrorType || (ValueErrorType = {}));

class ValueErrorsUnknownTypeError extends TypeBoxError {
	constructor(schema) {
		super("Unknown type");
		this.schema = schema;
	}
}
function EscapeKey(key) {
	return key.replace(/~/g, "~0").replace(/\//g, "~1");
}
function IsDefined2(value) {
	return value !== undefined;
}

class ValueErrorIterator {
	constructor(iterator) {
		this.iterator = iterator;
	}
	[Symbol.iterator]() {
		return this.iterator;
	}
	First() {
		const next = this.iterator.next();
		return next.done ? undefined : next.value;
	}
}
function Create(errorType, schema, path, value, errors = []) {
	return {
		type: errorType,
		schema,
		path,
		value,
		message: GetErrorFunction()({ errorType, path, schema, value, errors }),
		errors,
	};
}
function* FromAny3(schema, references, path, value) {}
function* FromArgument3(schema, references, path, value) {}
function* FromArray8(schema, references, path, value) {
	if (!IsArray2(value)) {
		return yield Create(ValueErrorType.Array, schema, path, value);
	}
	if (IsDefined2(schema.minItems) && !(value.length >= schema.minItems)) {
		yield Create(ValueErrorType.ArrayMinItems, schema, path, value);
	}
	if (IsDefined2(schema.maxItems) && !(value.length <= schema.maxItems)) {
		yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);
	}
	for (let i = 0; i < value.length; i++) {
		yield* Visit6(schema.items, references, `${path}/${i}`, value[i]);
	}
	if (
		schema.uniqueItems === true &&
		!(function () {
			const set2 = new Set();
			for (const element of value) {
				const hashed = Hash(element);
				if (set2.has(hashed)) {
					return false;
				} else {
					set2.add(hashed);
				}
			}
			return true;
		})()
	) {
		yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);
	}
	if (
		!(
			IsDefined2(schema.contains) ||
			IsDefined2(schema.minContains) ||
			IsDefined2(schema.maxContains)
		)
	) {
		return;
	}
	const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
	const containsCount = value.reduce(
		(acc, value2, index) =>
			Visit6(containsSchema, references, `${path}${index}`, value2).next().done === true
				? acc + 1
				: acc,
		0,
	);
	if (containsCount === 0) {
		yield Create(ValueErrorType.ArrayContains, schema, path, value);
	}
	if (IsNumber2(schema.minContains) && containsCount < schema.minContains) {
		yield Create(ValueErrorType.ArrayMinContains, schema, path, value);
	}
	if (IsNumber2(schema.maxContains) && containsCount > schema.maxContains) {
		yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);
	}
}
function* FromAsyncIterator5(schema, references, path, value) {
	if (!IsAsyncIterator2(value)) yield Create(ValueErrorType.AsyncIterator, schema, path, value);
}
function* FromBigInt3(schema, references, path, value) {
	if (!IsBigInt2(value)) return yield Create(ValueErrorType.BigInt, schema, path, value);
	if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
		yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);
	}
	if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
		yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);
	}
	if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
		yield Create(ValueErrorType.BigIntMaximum, schema, path, value);
	}
	if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
		yield Create(ValueErrorType.BigIntMinimum, schema, path, value);
	}
	if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
		yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);
	}
}
function* FromBoolean3(schema, references, path, value) {
	if (!IsBoolean2(value)) yield Create(ValueErrorType.Boolean, schema, path, value);
}
function* FromConstructor5(schema, references, path, value) {
	yield* Visit6(schema.returns, references, path, value.prototype);
}
function* FromDate3(schema, references, path, value) {
	if (!IsDate2(value)) return yield Create(ValueErrorType.Date, schema, path, value);
	if (
		IsDefined2(schema.exclusiveMaximumTimestamp) &&
		!(value.getTime() < schema.exclusiveMaximumTimestamp)
	) {
		yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);
	}
	if (
		IsDefined2(schema.exclusiveMinimumTimestamp) &&
		!(value.getTime() > schema.exclusiveMinimumTimestamp)
	) {
		yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);
	}
	if (IsDefined2(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
		yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);
	}
	if (IsDefined2(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
		yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);
	}
	if (
		IsDefined2(schema.multipleOfTimestamp) &&
		!(value.getTime() % schema.multipleOfTimestamp === 0)
	) {
		yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);
	}
}
function* FromFunction5(schema, references, path, value) {
	if (!IsFunction2(value)) yield Create(ValueErrorType.Function, schema, path, value);
}
function* FromImport2(schema, references, path, value) {
	const definitions = globalThis.Object.values(schema.$defs);
	const target = schema.$defs[schema.$ref];
	yield* Visit6(target, [...references, ...definitions], path, value);
}
function* FromInteger3(schema, references, path, value) {
	if (!IsInteger(value)) return yield Create(ValueErrorType.Integer, schema, path, value);
	if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
		yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);
	}
	if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
		yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);
	}
	if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
		yield Create(ValueErrorType.IntegerMaximum, schema, path, value);
	}
	if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
		yield Create(ValueErrorType.IntegerMinimum, schema, path, value);
	}
	if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
		yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);
	}
}
function* FromIntersect10(schema, references, path, value) {
	let hasError = false;
	for (const inner of schema.allOf) {
		for (const error of Visit6(inner, references, path, value)) {
			hasError = true;
			yield error;
		}
	}
	if (hasError) {
		return yield Create(ValueErrorType.Intersect, schema, path, value);
	}
	if (schema.unevaluatedProperties === false) {
		const keyCheck = new RegExp(KeyOfPattern(schema));
		for (const valueKey of Object.getOwnPropertyNames(value)) {
			if (!keyCheck.test(valueKey)) {
				yield Create(
					ValueErrorType.IntersectUnevaluatedProperties,
					schema,
					`${path}/${valueKey}`,
					value,
				);
			}
		}
	}
	if (typeof schema.unevaluatedProperties === "object") {
		const keyCheck = new RegExp(KeyOfPattern(schema));
		for (const valueKey of Object.getOwnPropertyNames(value)) {
			if (!keyCheck.test(valueKey)) {
				const next = Visit6(
					schema.unevaluatedProperties,
					references,
					`${path}/${valueKey}`,
					value[valueKey],
				).next();
				if (!next.done) yield next.value;
			}
		}
	}
}
function* FromIterator5(schema, references, path, value) {
	if (!IsIterator2(value)) yield Create(ValueErrorType.Iterator, schema, path, value);
}
function* FromLiteral4(schema, references, path, value) {
	if (!(value === schema.const)) yield Create(ValueErrorType.Literal, schema, path, value);
}
function* FromNever3(schema, references, path, value) {
	yield Create(ValueErrorType.Never, schema, path, value);
}
function* FromNot3(schema, references, path, value) {
	if (Visit6(schema.not, references, path, value).next().done === true)
		yield Create(ValueErrorType.Not, schema, path, value);
}
function* FromNull3(schema, references, path, value) {
	if (!IsNull2(value)) yield Create(ValueErrorType.Null, schema, path, value);
}
function* FromNumber3(schema, references, path, value) {
	if (!TypeSystemPolicy.IsNumberLike(value))
		return yield Create(ValueErrorType.Number, schema, path, value);
	if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
		yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);
	}
	if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
		yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);
	}
	if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
		yield Create(ValueErrorType.NumberMaximum, schema, path, value);
	}
	if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
		yield Create(ValueErrorType.NumberMinimum, schema, path, value);
	}
	if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
		yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);
	}
}
function* FromObject9(schema, references, path, value) {
	if (!TypeSystemPolicy.IsObjectLike(value))
		return yield Create(ValueErrorType.Object, schema, path, value);
	if (
		IsDefined2(schema.minProperties) &&
		!(Object.getOwnPropertyNames(value).length >= schema.minProperties)
	) {
		yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
	}
	if (
		IsDefined2(schema.maxProperties) &&
		!(Object.getOwnPropertyNames(value).length <= schema.maxProperties)
	) {
		yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
	}
	const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
	const knownKeys = Object.getOwnPropertyNames(schema.properties);
	const unknownKeys = Object.getOwnPropertyNames(value);
	for (const requiredKey of requiredKeys) {
		if (unknownKeys.includes(requiredKey)) continue;
		yield Create(
			ValueErrorType.ObjectRequiredProperty,
			schema.properties[requiredKey],
			`${path}/${EscapeKey(requiredKey)}`,
			undefined,
		);
	}
	if (schema.additionalProperties === false) {
		for (const valueKey of unknownKeys) {
			if (!knownKeys.includes(valueKey)) {
				yield Create(
					ValueErrorType.ObjectAdditionalProperties,
					schema,
					`${path}/${EscapeKey(valueKey)}`,
					value[valueKey],
				);
			}
		}
	}
	if (typeof schema.additionalProperties === "object") {
		for (const valueKey of unknownKeys) {
			if (knownKeys.includes(valueKey)) continue;
			yield* Visit6(
				schema.additionalProperties,
				references,
				`${path}/${EscapeKey(valueKey)}`,
				value[valueKey],
			);
		}
	}
	for (const knownKey of knownKeys) {
		const property = schema.properties[knownKey];
		if (schema.required && schema.required.includes(knownKey)) {
			yield* Visit6(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
			if (ExtendsUndefinedCheck(schema) && !(knownKey in value)) {
				yield Create(
					ValueErrorType.ObjectRequiredProperty,
					property,
					`${path}/${EscapeKey(knownKey)}`,
					undefined,
				);
			}
		} else {
			if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
				yield* Visit6(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
			}
		}
	}
}
function* FromPromise5(schema, references, path, value) {
	if (!IsPromise(value)) yield Create(ValueErrorType.Promise, schema, path, value);
}
function* FromRecord5(schema, references, path, value) {
	if (!TypeSystemPolicy.IsRecordLike(value))
		return yield Create(ValueErrorType.Object, schema, path, value);
	if (
		IsDefined2(schema.minProperties) &&
		!(Object.getOwnPropertyNames(value).length >= schema.minProperties)
	) {
		yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
	}
	if (
		IsDefined2(schema.maxProperties) &&
		!(Object.getOwnPropertyNames(value).length <= schema.maxProperties)
	) {
		yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
	}
	const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
	const regex = new RegExp(patternKey);
	for (const [propertyKey, propertyValue] of Object.entries(value)) {
		if (regex.test(propertyKey))
			yield* Visit6(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
	}
	if (typeof schema.additionalProperties === "object") {
		for (const [propertyKey, propertyValue] of Object.entries(value)) {
			if (!regex.test(propertyKey))
				yield* Visit6(
					schema.additionalProperties,
					references,
					`${path}/${EscapeKey(propertyKey)}`,
					propertyValue,
				);
		}
	}
	if (schema.additionalProperties === false) {
		for (const [propertyKey, propertyValue] of Object.entries(value)) {
			if (regex.test(propertyKey)) continue;
			return yield Create(
				ValueErrorType.ObjectAdditionalProperties,
				schema,
				`${path}/${EscapeKey(propertyKey)}`,
				propertyValue,
			);
		}
	}
}
function* FromRef6(schema, references, path, value) {
	yield* Visit6(Deref(schema, references), references, path, value);
}
function* FromRegExp3(schema, references, path, value) {
	if (!IsString2(value)) return yield Create(ValueErrorType.String, schema, path, value);
	if (IsDefined2(schema.minLength) && !(value.length >= schema.minLength)) {
		yield Create(ValueErrorType.StringMinLength, schema, path, value);
	}
	if (IsDefined2(schema.maxLength) && !(value.length <= schema.maxLength)) {
		yield Create(ValueErrorType.StringMaxLength, schema, path, value);
	}
	const regex = new RegExp(schema.source, schema.flags);
	if (!regex.test(value)) {
		return yield Create(ValueErrorType.RegExp, schema, path, value);
	}
}
function* FromString3(schema, references, path, value) {
	if (!IsString2(value)) return yield Create(ValueErrorType.String, schema, path, value);
	if (IsDefined2(schema.minLength) && !(value.length >= schema.minLength)) {
		yield Create(ValueErrorType.StringMinLength, schema, path, value);
	}
	if (IsDefined2(schema.maxLength) && !(value.length <= schema.maxLength)) {
		yield Create(ValueErrorType.StringMaxLength, schema, path, value);
	}
	if (IsString2(schema.pattern)) {
		const regex = new RegExp(schema.pattern);
		if (!regex.test(value)) {
			yield Create(ValueErrorType.StringPattern, schema, path, value);
		}
	}
	if (IsString2(schema.format)) {
		if (!exports_format.Has(schema.format)) {
			yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);
		} else {
			const format = exports_format.Get(schema.format);
			if (!format(value)) {
				yield Create(ValueErrorType.StringFormat, schema, path, value);
			}
		}
	}
}
function* FromSymbol3(schema, references, path, value) {
	if (!IsSymbol2(value)) yield Create(ValueErrorType.Symbol, schema, path, value);
}
function* FromTemplateLiteral5(schema, references, path, value) {
	if (!IsString2(value)) return yield Create(ValueErrorType.String, schema, path, value);
	const regex = new RegExp(schema.pattern);
	if (!regex.test(value)) {
		yield Create(ValueErrorType.StringPattern, schema, path, value);
	}
}
function* FromThis2(schema, references, path, value) {
	yield* Visit6(Deref(schema, references), references, path, value);
}
function* FromTuple7(schema, references, path, value) {
	if (!IsArray2(value)) return yield Create(ValueErrorType.Tuple, schema, path, value);
	if (schema.items === undefined && !(value.length === 0)) {
		return yield Create(ValueErrorType.TupleLength, schema, path, value);
	}
	if (!(value.length === schema.maxItems)) {
		return yield Create(ValueErrorType.TupleLength, schema, path, value);
	}
	if (!schema.items) {
		return;
	}
	for (let i = 0; i < schema.items.length; i++) {
		yield* Visit6(schema.items[i], references, `${path}/${i}`, value[i]);
	}
}
function* FromUndefined3(schema, references, path, value) {
	if (!IsUndefined2(value)) yield Create(ValueErrorType.Undefined, schema, path, value);
}
function* FromUnion12(schema, references, path, value) {
	if (Check(schema, references, value)) return;
	const errors = schema.anyOf.map(
		(variant) => new ValueErrorIterator(Visit6(variant, references, path, value)),
	);
	yield Create(ValueErrorType.Union, schema, path, value, errors);
}
function* FromUint8Array3(schema, references, path, value) {
	if (!IsUint8Array2(value)) return yield Create(ValueErrorType.Uint8Array, schema, path, value);
	if (IsDefined2(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
		yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);
	}
	if (IsDefined2(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
		yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);
	}
}
function* FromUnknown3(schema, references, path, value) {}
function* FromVoid3(schema, references, path, value) {
	if (!TypeSystemPolicy.IsVoidLike(value)) yield Create(ValueErrorType.Void, schema, path, value);
}
function* FromKind2(schema, references, path, value) {
	const check = exports_type2.Get(schema[Kind]);
	if (!check(schema, value)) yield Create(ValueErrorType.Kind, schema, path, value);
}
function* Visit6(schema, references, path, value) {
	const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
	const schema_ = schema;
	switch (schema_[Kind]) {
		case "Any":
			return yield* FromAny3(schema_, references_, path, value);
		case "Argument":
			return yield* FromArgument3(schema_, references_, path, value);
		case "Array":
			return yield* FromArray8(schema_, references_, path, value);
		case "AsyncIterator":
			return yield* FromAsyncIterator5(schema_, references_, path, value);
		case "BigInt":
			return yield* FromBigInt3(schema_, references_, path, value);
		case "Boolean":
			return yield* FromBoolean3(schema_, references_, path, value);
		case "Constructor":
			return yield* FromConstructor5(schema_, references_, path, value);
		case "Date":
			return yield* FromDate3(schema_, references_, path, value);
		case "Function":
			return yield* FromFunction5(schema_, references_, path, value);
		case "Import":
			return yield* FromImport2(schema_, references_, path, value);
		case "Integer":
			return yield* FromInteger3(schema_, references_, path, value);
		case "Intersect":
			return yield* FromIntersect10(schema_, references_, path, value);
		case "Iterator":
			return yield* FromIterator5(schema_, references_, path, value);
		case "Literal":
			return yield* FromLiteral4(schema_, references_, path, value);
		case "Never":
			return yield* FromNever3(schema_, references_, path, value);
		case "Not":
			return yield* FromNot3(schema_, references_, path, value);
		case "Null":
			return yield* FromNull3(schema_, references_, path, value);
		case "Number":
			return yield* FromNumber3(schema_, references_, path, value);
		case "Object":
			return yield* FromObject9(schema_, references_, path, value);
		case "Promise":
			return yield* FromPromise5(schema_, references_, path, value);
		case "Record":
			return yield* FromRecord5(schema_, references_, path, value);
		case "Ref":
			return yield* FromRef6(schema_, references_, path, value);
		case "RegExp":
			return yield* FromRegExp3(schema_, references_, path, value);
		case "String":
			return yield* FromString3(schema_, references_, path, value);
		case "Symbol":
			return yield* FromSymbol3(schema_, references_, path, value);
		case "TemplateLiteral":
			return yield* FromTemplateLiteral5(schema_, references_, path, value);
		case "This":
			return yield* FromThis2(schema_, references_, path, value);
		case "Tuple":
			return yield* FromTuple7(schema_, references_, path, value);
		case "Undefined":
			return yield* FromUndefined3(schema_, references_, path, value);
		case "Union":
			return yield* FromUnion12(schema_, references_, path, value);
		case "Uint8Array":
			return yield* FromUint8Array3(schema_, references_, path, value);
		case "Unknown":
			return yield* FromUnknown3(schema_, references_, path, value);
		case "Void":
			return yield* FromVoid3(schema_, references_, path, value);
		default:
			if (!exports_type2.Has(schema_[Kind])) throw new ValueErrorsUnknownTypeError(schema);
			return yield* FromKind2(schema_, references_, path, value);
	}
}
function Errors(...args) {
	const iterator =
		args.length === 3 ? Visit6(args[0], args[1], "", args[2]) : Visit6(args[0], [], "", args[1]);
	return new ValueErrorIterator(iterator);
}
// node_modules/@sinclair/typebox/build/esm/value/assert/assert.mjs
var __classPrivateFieldSet = function (receiver, state, value, kind, f) {
	if (kind === "m") throw new TypeError("Private method is not writable");
	if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
		throw new TypeError("Cannot write private member to an object whose class did not declare it");
	return (
		kind === "a" ? f.call(receiver, value) : f ? (f.value = value) : state.set(receiver, value),
		value
	);
};
var __classPrivateFieldGet = function (receiver, state, kind, f) {
	if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
		throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AssertError_instances;
var _AssertError_iterator;
var _AssertError_Iterator;

class AssertError extends TypeBoxError {
	constructor(iterator) {
		const error = iterator.First();
		super(error === undefined ? "Invalid Value" : error.message);
		_AssertError_instances.add(this);
		_AssertError_iterator.set(this, undefined);
		__classPrivateFieldSet(this, _AssertError_iterator, iterator, "f");
		this.error = error;
	}
	Errors() {
		return new ValueErrorIterator(
			__classPrivateFieldGet(this, _AssertError_instances, "m", _AssertError_Iterator).call(this),
		);
	}
}
((_AssertError_iterator = new WeakMap()),
	(_AssertError_instances = new WeakSet()),
	(_AssertError_Iterator = function* _AssertError_Iterator2() {
		if (this.error) yield this.error;
		yield* __classPrivateFieldGet(this, _AssertError_iterator, "f");
	}));
function AssertValue(schema, references, value) {
	if (Check(schema, references, value)) return;
	throw new AssertError(Errors(schema, references, value));
}
function Assert(...args) {
	return args.length === 3
		? AssertValue(args[0], args[1], args[2])
		: AssertValue(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/clone/clone.mjs
function FromObject10(value) {
	const Acc = {};
	for (const key of Object.getOwnPropertyNames(value)) {
		Acc[key] = Clone2(value[key]);
	}
	for (const key of Object.getOwnPropertySymbols(value)) {
		Acc[key] = Clone2(value[key]);
	}
	return Acc;
}
function FromArray9(value) {
	return value.map((element) => Clone2(element));
}
function FromTypedArray(value) {
	return value.slice();
}
function FromMap(value) {
	return new Map(Clone2([...value.entries()]));
}
function FromSet(value) {
	return new Set(Clone2([...value.entries()]));
}
function FromDate4(value) {
	return new Date(value.toISOString());
}
function FromValue2(value) {
	return value;
}
function Clone2(value) {
	if (IsArray2(value)) return FromArray9(value);
	if (IsDate2(value)) return FromDate4(value);
	if (IsTypedArray(value)) return FromTypedArray(value);
	if (IsMap(value)) return FromMap(value);
	if (IsSet(value)) return FromSet(value);
	if (IsObject2(value)) return FromObject10(value);
	if (IsValueType(value)) return FromValue2(value);
	throw new Error("ValueClone: Unable to clone value");
}

// node_modules/@sinclair/typebox/build/esm/value/create/create.mjs
class ValueCreateError extends TypeBoxError {
	constructor(schema, message) {
		super(message);
		this.schema = schema;
	}
}
function FromDefault(value) {
	return IsFunction2(value) ? value() : Clone2(value);
}
function FromAny4(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else {
		return {};
	}
}
function FromArgument4(schema, references) {
	return {};
}
function FromArray10(schema, references) {
	if (schema.uniqueItems === true && !HasPropertyKey2(schema, "default")) {
		throw new ValueCreateError(
			schema,
			"Array with the uniqueItems constraint requires a default value",
		);
	} else if ("contains" in schema && !HasPropertyKey2(schema, "default")) {
		throw new ValueCreateError(
			schema,
			"Array with the contains constraint requires a default value",
		);
	} else if ("default" in schema) {
		return FromDefault(schema.default);
	} else if (schema.minItems !== undefined) {
		return Array.from({ length: schema.minItems }).map((item) => {
			return Visit7(schema.items, references);
		});
	} else {
		return [];
	}
}
function FromAsyncIterator6(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else {
		return (async function* () {})();
	}
}
function FromBigInt4(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else {
		return BigInt(0);
	}
}
function FromBoolean4(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else {
		return false;
	}
}
function FromConstructor6(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else {
		const value = Visit7(schema.returns, references);
		if (typeof value === "object" && !Array.isArray(value)) {
			return class {
				constructor() {
					for (const [key, val] of Object.entries(value)) {
						const self2 = this;
						self2[key] = val;
					}
				}
			};
		} else {
			return class {};
		}
	}
}
function FromDate5(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else if (schema.minimumTimestamp !== undefined) {
		return new Date(schema.minimumTimestamp);
	} else {
		return new Date();
	}
}
function FromFunction6(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else {
		return () => Visit7(schema.returns, references);
	}
}
function FromImport3(schema, references) {
	const definitions = globalThis.Object.values(schema.$defs);
	const target = schema.$defs[schema.$ref];
	return Visit7(target, [...references, ...definitions]);
}
function FromInteger4(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else if (schema.minimum !== undefined) {
		return schema.minimum;
	} else {
		return 0;
	}
}
function FromIntersect11(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else {
		const value = schema.allOf.reduce((acc, schema2) => {
			const next = Visit7(schema2, references);
			return typeof next === "object" ? { ...acc, ...next } : next;
		}, {});
		if (!Check(schema, references, value))
			throw new ValueCreateError(
				schema,
				"Intersect produced invalid value. Consider using a default value.",
			);
		return value;
	}
}
function FromIterator6(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else {
		return (function* () {})();
	}
}
function FromLiteral5(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else {
		return schema.const;
	}
}
function FromNever4(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else {
		throw new ValueCreateError(
			schema,
			"Never types cannot be created. Consider using a default value.",
		);
	}
}
function FromNot4(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else {
		throw new ValueCreateError(schema, "Not types must have a default value");
	}
}
function FromNull4(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else {
		return null;
	}
}
function FromNumber4(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else if (schema.minimum !== undefined) {
		return schema.minimum;
	} else {
		return 0;
	}
}
function FromObject11(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else {
		const required = new Set(schema.required);
		const Acc = {};
		for (const [key, subschema] of Object.entries(schema.properties)) {
			if (!required.has(key)) continue;
			Acc[key] = Visit7(subschema, references);
		}
		return Acc;
	}
}
function FromPromise6(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else {
		return Promise.resolve(Visit7(schema.item, references));
	}
}
function FromRecord6(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else {
		return {};
	}
}
function FromRef7(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else {
		return Visit7(Deref(schema, references), references);
	}
}
function FromRegExp4(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else {
		throw new ValueCreateError(
			schema,
			"RegExp types cannot be created. Consider using a default value.",
		);
	}
}
function FromString4(schema, references) {
	if (schema.pattern !== undefined) {
		if (!HasPropertyKey2(schema, "default")) {
			throw new ValueCreateError(schema, "String types with patterns must specify a default value");
		} else {
			return FromDefault(schema.default);
		}
	} else if (schema.format !== undefined) {
		if (!HasPropertyKey2(schema, "default")) {
			throw new ValueCreateError(schema, "String types with formats must specify a default value");
		} else {
			return FromDefault(schema.default);
		}
	} else {
		if (HasPropertyKey2(schema, "default")) {
			return FromDefault(schema.default);
		} else if (schema.minLength !== undefined) {
			return Array.from({ length: schema.minLength })
				.map(() => " ")
				.join("");
		} else {
			return "";
		}
	}
}
function FromSymbol4(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else if ("value" in schema) {
		return Symbol.for(schema.value);
	} else {
		return Symbol();
	}
}
function FromTemplateLiteral6(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	}
	if (!IsTemplateLiteralFinite(schema))
		throw new ValueCreateError(
			schema,
			"Can only create template literals that produce a finite variants. Consider using a default value.",
		);
	const generated = TemplateLiteralGenerate(schema);
	return generated[0];
}
function FromThis3(schema, references) {
	if (recursiveDepth++ > recursiveMaxDepth)
		throw new ValueCreateError(
			schema,
			"Cannot create recursive type as it appears possibly infinite. Consider using a default.",
		);
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else {
		return Visit7(Deref(schema, references), references);
	}
}
function FromTuple8(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	}
	if (schema.items === undefined) {
		return [];
	} else {
		return Array.from({ length: schema.minItems }).map((_, index) =>
			Visit7(schema.items[index], references),
		);
	}
}
function FromUndefined4(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else {
		return;
	}
}
function FromUnion13(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else if (schema.anyOf.length === 0) {
		throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
	} else {
		return Visit7(schema.anyOf[0], references);
	}
}
function FromUint8Array4(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else if (schema.minByteLength !== undefined) {
		return new Uint8Array(schema.minByteLength);
	} else {
		return new Uint8Array(0);
	}
}
function FromUnknown4(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else {
		return {};
	}
}
function FromVoid4(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else {
		return;
	}
}
function FromKind3(schema, references) {
	if (HasPropertyKey2(schema, "default")) {
		return FromDefault(schema.default);
	} else {
		throw new Error("User defined types must specify a default value");
	}
}
function Visit7(schema, references) {
	const references_ = Pushref(schema, references);
	const schema_ = schema;
	switch (schema_[Kind]) {
		case "Any":
			return FromAny4(schema_, references_);
		case "Argument":
			return FromArgument4(schema_, references_);
		case "Array":
			return FromArray10(schema_, references_);
		case "AsyncIterator":
			return FromAsyncIterator6(schema_, references_);
		case "BigInt":
			return FromBigInt4(schema_, references_);
		case "Boolean":
			return FromBoolean4(schema_, references_);
		case "Constructor":
			return FromConstructor6(schema_, references_);
		case "Date":
			return FromDate5(schema_, references_);
		case "Function":
			return FromFunction6(schema_, references_);
		case "Import":
			return FromImport3(schema_, references_);
		case "Integer":
			return FromInteger4(schema_, references_);
		case "Intersect":
			return FromIntersect11(schema_, references_);
		case "Iterator":
			return FromIterator6(schema_, references_);
		case "Literal":
			return FromLiteral5(schema_, references_);
		case "Never":
			return FromNever4(schema_, references_);
		case "Not":
			return FromNot4(schema_, references_);
		case "Null":
			return FromNull4(schema_, references_);
		case "Number":
			return FromNumber4(schema_, references_);
		case "Object":
			return FromObject11(schema_, references_);
		case "Promise":
			return FromPromise6(schema_, references_);
		case "Record":
			return FromRecord6(schema_, references_);
		case "Ref":
			return FromRef7(schema_, references_);
		case "RegExp":
			return FromRegExp4(schema_, references_);
		case "String":
			return FromString4(schema_, references_);
		case "Symbol":
			return FromSymbol4(schema_, references_);
		case "TemplateLiteral":
			return FromTemplateLiteral6(schema_, references_);
		case "This":
			return FromThis3(schema_, references_);
		case "Tuple":
			return FromTuple8(schema_, references_);
		case "Undefined":
			return FromUndefined4(schema_, references_);
		case "Union":
			return FromUnion13(schema_, references_);
		case "Uint8Array":
			return FromUint8Array4(schema_, references_);
		case "Unknown":
			return FromUnknown4(schema_, references_);
		case "Void":
			return FromVoid4(schema_, references_);
		default:
			if (!exports_type2.Has(schema_[Kind])) throw new ValueCreateError(schema_, "Unknown type");
			return FromKind3(schema_, references_);
	}
}
var recursiveMaxDepth = 512;
var recursiveDepth = 0;
function Create2(...args) {
	recursiveDepth = 0;
	return args.length === 2 ? Visit7(args[0], args[1]) : Visit7(args[0], []);
}

// node_modules/@sinclair/typebox/build/esm/value/cast/cast.mjs
class ValueCastError extends TypeBoxError {
	constructor(schema, message) {
		super(message);
		this.schema = schema;
	}
}
function ScoreUnion(schema, references, value) {
	if (schema[Kind] === "Object" && typeof value === "object" && !IsNull2(value)) {
		const object = schema;
		const keys = Object.getOwnPropertyNames(value);
		const entries = Object.entries(object.properties);
		return entries.reduce((acc, [key, schema2]) => {
			const literal = schema2[Kind] === "Literal" && schema2.const === value[key] ? 100 : 0;
			const checks = Check(schema2, references, value[key]) ? 10 : 0;
			const exists = keys.includes(key) ? 1 : 0;
			return acc + (literal + checks + exists);
		}, 0);
	} else if (schema[Kind] === "Union") {
		const schemas = schema.anyOf.map((schema2) => Deref(schema2, references));
		const scores = schemas.map((schema2) => ScoreUnion(schema2, references, value));
		return Math.max(...scores);
	} else {
		return Check(schema, references, value) ? 1 : 0;
	}
}
function SelectUnion(union, references, value) {
	const schemas = union.anyOf.map((schema) => Deref(schema, references));
	let [select, best] = [schemas[0], 0];
	for (const schema of schemas) {
		const score = ScoreUnion(schema, references, value);
		if (score > best) {
			select = schema;
			best = score;
		}
	}
	return select;
}
function CastUnion(union, references, value) {
	if ("default" in union) {
		return typeof value === "function" ? union.default : Clone2(union.default);
	} else {
		const schema = SelectUnion(union, references, value);
		return Cast(schema, references, value);
	}
}
function DefaultClone(schema, references, value) {
	return Check(schema, references, value) ? Clone2(value) : Create2(schema, references);
}
function Default(schema, references, value) {
	return Check(schema, references, value) ? value : Create2(schema, references);
}
function FromArray11(schema, references, value) {
	if (Check(schema, references, value)) return Clone2(value);
	const created = IsArray2(value) ? Clone2(value) : Create2(schema, references);
	const minimum =
		IsNumber2(schema.minItems) && created.length < schema.minItems
			? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)]
			: created;
	const maximum =
		IsNumber2(schema.maxItems) && minimum.length > schema.maxItems
			? minimum.slice(0, schema.maxItems)
			: minimum;
	const casted = maximum.map((value2) => Visit8(schema.items, references, value2));
	if (schema.uniqueItems !== true) return casted;
	const unique = [...new Set(casted)];
	if (!Check(schema, references, unique))
		throw new ValueCastError(
			schema,
			"Array cast produced invalid data due to uniqueItems constraint",
		);
	return unique;
}
function FromConstructor7(schema, references, value) {
	if (Check(schema, references, value)) return Create2(schema, references);
	const required = new Set(schema.returns.required || []);
	const result = function () {};
	for (const [key, property] of Object.entries(schema.returns.properties)) {
		if (!required.has(key) && value.prototype[key] === undefined) continue;
		result.prototype[key] = Visit8(property, references, value.prototype[key]);
	}
	return result;
}
function FromImport4(schema, references, value) {
	const definitions = globalThis.Object.values(schema.$defs);
	const target = schema.$defs[schema.$ref];
	return Visit8(target, [...references, ...definitions], value);
}
function IntersectAssign(correct, value) {
	if ((IsObject2(correct) && !IsObject2(value)) || (!IsObject2(correct) && IsObject2(value)))
		return correct;
	if (!IsObject2(correct) || !IsObject2(value)) return value;
	return globalThis.Object.getOwnPropertyNames(correct).reduce((result, key) => {
		const property = key in value ? IntersectAssign(correct[key], value[key]) : correct[key];
		return { ...result, [key]: property };
	}, {});
}
function FromIntersect12(schema, references, value) {
	if (Check(schema, references, value)) return value;
	const correct = Create2(schema, references);
	const assigned = IntersectAssign(correct, value);
	return Check(schema, references, assigned) ? assigned : correct;
}
function FromNever5(schema, references, value) {
	throw new ValueCastError(schema, "Never types cannot be cast");
}
function FromObject12(schema, references, value) {
	if (Check(schema, references, value)) return value;
	if (value === null || typeof value !== "object") return Create2(schema, references);
	const required = new Set(schema.required || []);
	const result = {};
	for (const [key, property] of Object.entries(schema.properties)) {
		if (!required.has(key) && value[key] === undefined) continue;
		result[key] = Visit8(property, references, value[key]);
	}
	if (typeof schema.additionalProperties === "object") {
		const propertyNames = Object.getOwnPropertyNames(schema.properties);
		for (const propertyName of Object.getOwnPropertyNames(value)) {
			if (propertyNames.includes(propertyName)) continue;
			result[propertyName] = Visit8(schema.additionalProperties, references, value[propertyName]);
		}
	}
	return result;
}
function FromRecord7(schema, references, value) {
	if (Check(schema, references, value)) return Clone2(value);
	if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
		return Create2(schema, references);
	const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
	const subschema = schema.patternProperties[subschemaPropertyName];
	const result = {};
	for (const [propKey, propValue] of Object.entries(value)) {
		result[propKey] = Visit8(subschema, references, propValue);
	}
	return result;
}
function FromRef8(schema, references, value) {
	return Visit8(Deref(schema, references), references, value);
}
function FromThis4(schema, references, value) {
	return Visit8(Deref(schema, references), references, value);
}
function FromTuple9(schema, references, value) {
	if (Check(schema, references, value)) return Clone2(value);
	if (!IsArray2(value)) return Create2(schema, references);
	if (schema.items === undefined) return [];
	return schema.items.map((schema2, index) => Visit8(schema2, references, value[index]));
}
function FromUnion14(schema, references, value) {
	return Check(schema, references, value) ? Clone2(value) : CastUnion(schema, references, value);
}
function Visit8(schema, references, value) {
	const references_ = IsString2(schema.$id) ? Pushref(schema, references) : references;
	const schema_ = schema;
	switch (schema[Kind]) {
		case "Array":
			return FromArray11(schema_, references_, value);
		case "Constructor":
			return FromConstructor7(schema_, references_, value);
		case "Import":
			return FromImport4(schema_, references_, value);
		case "Intersect":
			return FromIntersect12(schema_, references_, value);
		case "Never":
			return FromNever5(schema_, references_, value);
		case "Object":
			return FromObject12(schema_, references_, value);
		case "Record":
			return FromRecord7(schema_, references_, value);
		case "Ref":
			return FromRef8(schema_, references_, value);
		case "This":
			return FromThis4(schema_, references_, value);
		case "Tuple":
			return FromTuple9(schema_, references_, value);
		case "Union":
			return FromUnion14(schema_, references_, value);
		case "Date":
		case "Symbol":
		case "Uint8Array":
			return DefaultClone(schema, references, value);
		default:
			return Default(schema_, references_, value);
	}
}
function Cast(...args) {
	return args.length === 3 ? Visit8(args[0], args[1], args[2]) : Visit8(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/clean/clean.mjs
function IsCheckable(schema) {
	return IsKind(schema) && schema[Kind] !== "Unsafe";
}
function FromArray12(schema, references, value) {
	if (!IsArray2(value)) return value;
	return value.map((value2) => Visit9(schema.items, references, value2));
}
function FromImport5(schema, references, value) {
	const definitions = globalThis.Object.values(schema.$defs);
	const target = schema.$defs[schema.$ref];
	return Visit9(target, [...references, ...definitions], value);
}
function FromIntersect13(schema, references, value) {
	const unevaluatedProperties = schema.unevaluatedProperties;
	const intersections = schema.allOf.map((schema2) => Visit9(schema2, references, Clone2(value)));
	const composite = intersections.reduce(
		(acc, value2) => (IsObject2(value2) ? { ...acc, ...value2 } : value2),
		{},
	);
	if (!IsObject2(value) || !IsObject2(composite) || !IsKind(unevaluatedProperties))
		return composite;
	const knownkeys = KeyOfPropertyKeys(schema);
	for (const key of Object.getOwnPropertyNames(value)) {
		if (knownkeys.includes(key)) continue;
		if (Check(unevaluatedProperties, references, value[key])) {
			composite[key] = Visit9(unevaluatedProperties, references, value[key]);
		}
	}
	return composite;
}
function FromObject13(schema, references, value) {
	if (!IsObject2(value) || IsArray2(value)) return value;
	const additionalProperties = schema.additionalProperties;
	for (const key of Object.getOwnPropertyNames(value)) {
		if (HasPropertyKey2(schema.properties, key)) {
			value[key] = Visit9(schema.properties[key], references, value[key]);
			continue;
		}
		if (IsKind(additionalProperties) && Check(additionalProperties, references, value[key])) {
			value[key] = Visit9(additionalProperties, references, value[key]);
			continue;
		}
		delete value[key];
	}
	return value;
}
function FromRecord8(schema, references, value) {
	if (!IsObject2(value)) return value;
	const additionalProperties = schema.additionalProperties;
	const propertyKeys = Object.getOwnPropertyNames(value);
	const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
	const propertyKeyTest = new RegExp(propertyKey);
	for (const key of propertyKeys) {
		if (propertyKeyTest.test(key)) {
			value[key] = Visit9(propertySchema, references, value[key]);
			continue;
		}
		if (IsKind(additionalProperties) && Check(additionalProperties, references, value[key])) {
			value[key] = Visit9(additionalProperties, references, value[key]);
			continue;
		}
		delete value[key];
	}
	return value;
}
function FromRef9(schema, references, value) {
	return Visit9(Deref(schema, references), references, value);
}
function FromThis5(schema, references, value) {
	return Visit9(Deref(schema, references), references, value);
}
function FromTuple10(schema, references, value) {
	if (!IsArray2(value)) return value;
	if (IsUndefined2(schema.items)) return [];
	const length = Math.min(value.length, schema.items.length);
	for (let i = 0; i < length; i++) {
		value[i] = Visit9(schema.items[i], references, value[i]);
	}
	return value.length > length ? value.slice(0, length) : value;
}
function FromUnion15(schema, references, value) {
	for (const inner of schema.anyOf) {
		if (IsCheckable(inner) && Check(inner, references, value)) {
			return Visit9(inner, references, value);
		}
	}
	return value;
}
function Visit9(schema, references, value) {
	const references_ = IsString2(schema.$id) ? Pushref(schema, references) : references;
	const schema_ = schema;
	switch (schema_[Kind]) {
		case "Array":
			return FromArray12(schema_, references_, value);
		case "Import":
			return FromImport5(schema_, references_, value);
		case "Intersect":
			return FromIntersect13(schema_, references_, value);
		case "Object":
			return FromObject13(schema_, references_, value);
		case "Record":
			return FromRecord8(schema_, references_, value);
		case "Ref":
			return FromRef9(schema_, references_, value);
		case "This":
			return FromThis5(schema_, references_, value);
		case "Tuple":
			return FromTuple10(schema_, references_, value);
		case "Union":
			return FromUnion15(schema_, references_, value);
		default:
			return value;
	}
}
function Clean(...args) {
	return args.length === 3 ? Visit9(args[0], args[1], args[2]) : Visit9(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/convert/convert.mjs
function IsStringNumeric(value) {
	return IsString2(value) && !isNaN(value) && !isNaN(parseFloat(value));
}
function IsValueToString(value) {
	return IsBigInt2(value) || IsBoolean2(value) || IsNumber2(value);
}
function IsValueTrue(value) {
	return (
		value === true ||
		(IsNumber2(value) && value === 1) ||
		(IsBigInt2(value) && value === BigInt("1")) ||
		(IsString2(value) && (value.toLowerCase() === "true" || value === "1"))
	);
}
function IsValueFalse(value) {
	return (
		value === false ||
		(IsNumber2(value) && (value === 0 || Object.is(value, -0))) ||
		(IsBigInt2(value) && value === BigInt("0")) ||
		(IsString2(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0"))
	);
}
function IsTimeStringWithTimeZone(value) {
	return (
		IsString2(value) &&
		/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value)
	);
}
function IsTimeStringWithoutTimeZone(value) {
	return IsString2(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateTimeStringWithTimeZone(value) {
	return (
		IsString2(value) &&
		/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(
			value,
		)
	);
}
function IsDateTimeStringWithoutTimeZone(value) {
	return (
		IsString2(value) &&
		/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value)
	);
}
function IsDateString(value) {
	return IsString2(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
}
function TryConvertLiteralString(value, target) {
	const conversion = TryConvertString(value);
	return conversion === target ? conversion : value;
}
function TryConvertLiteralNumber(value, target) {
	const conversion = TryConvertNumber(value);
	return conversion === target ? conversion : value;
}
function TryConvertLiteralBoolean(value, target) {
	const conversion = TryConvertBoolean(value);
	return conversion === target ? conversion : value;
}
function TryConvertLiteral(schema, value) {
	return IsString2(schema.const)
		? TryConvertLiteralString(value, schema.const)
		: IsNumber2(schema.const)
			? TryConvertLiteralNumber(value, schema.const)
			: IsBoolean2(schema.const)
				? TryConvertLiteralBoolean(value, schema.const)
				: value;
}
function TryConvertBoolean(value) {
	return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;
}
function TryConvertBigInt(value) {
	const truncateInteger = (value2) => value2.split(".")[0];
	return IsStringNumeric(value)
		? BigInt(truncateInteger(value))
		: IsNumber2(value)
			? BigInt(Math.trunc(value))
			: IsValueFalse(value)
				? BigInt(0)
				: IsValueTrue(value)
					? BigInt(1)
					: value;
}
function TryConvertString(value) {
	return IsSymbol2(value) && value.description !== undefined
		? value.description.toString()
		: IsValueToString(value)
			? value.toString()
			: value;
}
function TryConvertNumber(value) {
	return IsStringNumeric(value)
		? parseFloat(value)
		: IsValueTrue(value)
			? 1
			: IsValueFalse(value)
				? 0
				: value;
}
function TryConvertInteger(value) {
	return IsStringNumeric(value)
		? parseInt(value)
		: IsNumber2(value)
			? Math.trunc(value)
			: IsValueTrue(value)
				? 1
				: IsValueFalse(value)
					? 0
					: value;
}
function TryConvertNull(value) {
	return IsString2(value) && value.toLowerCase() === "null" ? null : value;
}
function TryConvertUndefined(value) {
	return IsString2(value) && value === "undefined" ? undefined : value;
}
function TryConvertDate(value) {
	return IsDate2(value)
		? value
		: IsNumber2(value)
			? new Date(value)
			: IsValueTrue(value)
				? new Date(1)
				: IsValueFalse(value)
					? new Date(0)
					: IsStringNumeric(value)
						? new Date(parseInt(value))
						: IsTimeStringWithoutTimeZone(value)
							? new Date(`1970-01-01T${value}.000Z`)
							: IsTimeStringWithTimeZone(value)
								? new Date(`1970-01-01T${value}`)
								: IsDateTimeStringWithoutTimeZone(value)
									? new Date(`${value}.000Z`)
									: IsDateTimeStringWithTimeZone(value)
										? new Date(value)
										: IsDateString(value)
											? new Date(`${value}T00:00:00.000Z`)
											: value;
}
function Default2(value) {
	return value;
}
function FromArray13(schema, references, value) {
	const elements = IsArray2(value) ? value : [value];
	return elements.map((element) => Visit10(schema.items, references, element));
}
function FromBigInt5(schema, references, value) {
	return TryConvertBigInt(value);
}
function FromBoolean5(schema, references, value) {
	return TryConvertBoolean(value);
}
function FromDate6(schema, references, value) {
	return TryConvertDate(value);
}
function FromImport6(schema, references, value) {
	const definitions = globalThis.Object.values(schema.$defs);
	const target = schema.$defs[schema.$ref];
	return Visit10(target, [...references, ...definitions], value);
}
function FromInteger5(schema, references, value) {
	return TryConvertInteger(value);
}
function FromIntersect14(schema, references, value) {
	return schema.allOf.reduce((value2, schema2) => Visit10(schema2, references, value2), value);
}
function FromLiteral6(schema, references, value) {
	return TryConvertLiteral(schema, value);
}
function FromNull5(schema, references, value) {
	return TryConvertNull(value);
}
function FromNumber5(schema, references, value) {
	return TryConvertNumber(value);
}
function FromObject14(schema, references, value) {
	if (!IsObject2(value) || IsArray2(value)) return value;
	for (const propertyKey of Object.getOwnPropertyNames(schema.properties)) {
		if (!HasPropertyKey2(value, propertyKey)) continue;
		value[propertyKey] = Visit10(schema.properties[propertyKey], references, value[propertyKey]);
	}
	return value;
}
function FromRecord9(schema, references, value) {
	const isConvertable = IsObject2(value) && !IsArray2(value);
	if (!isConvertable) return value;
	const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
	const property = schema.patternProperties[propertyKey];
	for (const [propKey, propValue] of Object.entries(value)) {
		value[propKey] = Visit10(property, references, propValue);
	}
	return value;
}
function FromRef10(schema, references, value) {
	return Visit10(Deref(schema, references), references, value);
}
function FromString5(schema, references, value) {
	return TryConvertString(value);
}
function FromSymbol5(schema, references, value) {
	return IsString2(value) || IsNumber2(value) ? Symbol(value) : value;
}
function FromThis6(schema, references, value) {
	return Visit10(Deref(schema, references), references, value);
}
function FromTuple11(schema, references, value) {
	const isConvertable = IsArray2(value) && !IsUndefined2(schema.items);
	if (!isConvertable) return value;
	return value.map((value2, index) => {
		return index < schema.items.length ? Visit10(schema.items[index], references, value2) : value2;
	});
}
function FromUndefined5(schema, references, value) {
	return TryConvertUndefined(value);
}
function FromUnion16(schema, references, value) {
	for (const subschema of schema.anyOf) {
		if (Check(subschema, references, value)) {
			return value;
		}
	}
	for (const subschema of schema.anyOf) {
		const converted = Visit10(subschema, references, Clone2(value));
		if (!Check(subschema, references, converted)) continue;
		return converted;
	}
	return value;
}
function Visit10(schema, references, value) {
	const references_ = Pushref(schema, references);
	const schema_ = schema;
	switch (schema[Kind]) {
		case "Array":
			return FromArray13(schema_, references_, value);
		case "BigInt":
			return FromBigInt5(schema_, references_, value);
		case "Boolean":
			return FromBoolean5(schema_, references_, value);
		case "Date":
			return FromDate6(schema_, references_, value);
		case "Import":
			return FromImport6(schema_, references_, value);
		case "Integer":
			return FromInteger5(schema_, references_, value);
		case "Intersect":
			return FromIntersect14(schema_, references_, value);
		case "Literal":
			return FromLiteral6(schema_, references_, value);
		case "Null":
			return FromNull5(schema_, references_, value);
		case "Number":
			return FromNumber5(schema_, references_, value);
		case "Object":
			return FromObject14(schema_, references_, value);
		case "Record":
			return FromRecord9(schema_, references_, value);
		case "Ref":
			return FromRef10(schema_, references_, value);
		case "String":
			return FromString5(schema_, references_, value);
		case "Symbol":
			return FromSymbol5(schema_, references_, value);
		case "This":
			return FromThis6(schema_, references_, value);
		case "Tuple":
			return FromTuple11(schema_, references_, value);
		case "Undefined":
			return FromUndefined5(schema_, references_, value);
		case "Union":
			return FromUnion16(schema_, references_, value);
		default:
			return Default2(value);
	}
}
function Convert(...args) {
	return args.length === 3 ? Visit10(args[0], args[1], args[2]) : Visit10(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/transform/decode.mjs
class TransformDecodeCheckError extends TypeBoxError {
	constructor(schema, value, error) {
		super("Unable to decode value as it does not match the expected schema");
		this.schema = schema;
		this.value = value;
		this.error = error;
	}
}

class TransformDecodeError extends TypeBoxError {
	constructor(schema, path, value, error) {
		super(error instanceof Error ? error.message : "Unknown error");
		this.schema = schema;
		this.path = path;
		this.value = value;
		this.error = error;
	}
}
function Default3(schema, path, value) {
	try {
		return IsTransform(schema) ? schema[TransformKind].Decode(value) : value;
	} catch (error) {
		throw new TransformDecodeError(schema, path, value, error);
	}
}
function FromArray14(schema, references, path, value) {
	return IsArray2(value)
		? Default3(
				schema,
				path,
				value.map((value2, index) => Visit11(schema.items, references, `${path}/${index}`, value2)),
			)
		: Default3(schema, path, value);
}
function FromIntersect15(schema, references, path, value) {
	if (!IsObject2(value) || IsValueType(value)) return Default3(schema, path, value);
	const knownEntries = KeyOfPropertyEntries(schema);
	const knownKeys = knownEntries.map((entry) => entry[0]);
	const knownProperties = { ...value };
	for (const [knownKey, knownSchema] of knownEntries)
		if (knownKey in knownProperties) {
			knownProperties[knownKey] = Visit11(
				knownSchema,
				references,
				`${path}/${knownKey}`,
				knownProperties[knownKey],
			);
		}
	if (!IsTransform(schema.unevaluatedProperties)) {
		return Default3(schema, path, knownProperties);
	}
	const unknownKeys = Object.getOwnPropertyNames(knownProperties);
	const unevaluatedProperties = schema.unevaluatedProperties;
	const unknownProperties = { ...knownProperties };
	for (const key of unknownKeys)
		if (!knownKeys.includes(key)) {
			unknownProperties[key] = Default3(
				unevaluatedProperties,
				`${path}/${key}`,
				unknownProperties[key],
			);
		}
	return Default3(schema, path, unknownProperties);
}
function FromImport7(schema, references, path, value) {
	const additional = globalThis.Object.values(schema.$defs);
	const target = schema.$defs[schema.$ref];
	const result = Visit11(target, [...references, ...additional], path, value);
	return Default3(schema, path, result);
}
function FromNot5(schema, references, path, value) {
	return Default3(schema, path, Visit11(schema.not, references, path, value));
}
function FromObject15(schema, references, path, value) {
	if (!IsObject2(value)) return Default3(schema, path, value);
	const knownKeys = KeyOfPropertyKeys(schema);
	const knownProperties = { ...value };
	for (const key of knownKeys) {
		if (!HasPropertyKey2(knownProperties, key)) continue;
		if (
			IsUndefined2(knownProperties[key]) &&
			(!IsUndefined3(schema.properties[key]) ||
				TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key))
		)
			continue;
		knownProperties[key] = Visit11(
			schema.properties[key],
			references,
			`${path}/${key}`,
			knownProperties[key],
		);
	}
	if (!IsSchema(schema.additionalProperties)) {
		return Default3(schema, path, knownProperties);
	}
	const unknownKeys = Object.getOwnPropertyNames(knownProperties);
	const additionalProperties = schema.additionalProperties;
	const unknownProperties = { ...knownProperties };
	for (const key of unknownKeys)
		if (!knownKeys.includes(key)) {
			unknownProperties[key] = Default3(
				additionalProperties,
				`${path}/${key}`,
				unknownProperties[key],
			);
		}
	return Default3(schema, path, unknownProperties);
}
function FromRecord10(schema, references, path, value) {
	if (!IsObject2(value)) return Default3(schema, path, value);
	const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
	const knownKeys = new RegExp(pattern);
	const knownProperties = { ...value };
	for (const key of Object.getOwnPropertyNames(value))
		if (knownKeys.test(key)) {
			knownProperties[key] = Visit11(
				schema.patternProperties[pattern],
				references,
				`${path}/${key}`,
				knownProperties[key],
			);
		}
	if (!IsSchema(schema.additionalProperties)) {
		return Default3(schema, path, knownProperties);
	}
	const unknownKeys = Object.getOwnPropertyNames(knownProperties);
	const additionalProperties = schema.additionalProperties;
	const unknownProperties = { ...knownProperties };
	for (const key of unknownKeys)
		if (!knownKeys.test(key)) {
			unknownProperties[key] = Default3(
				additionalProperties,
				`${path}/${key}`,
				unknownProperties[key],
			);
		}
	return Default3(schema, path, unknownProperties);
}
function FromRef11(schema, references, path, value) {
	const target = Deref(schema, references);
	return Default3(schema, path, Visit11(target, references, path, value));
}
function FromThis7(schema, references, path, value) {
	const target = Deref(schema, references);
	return Default3(schema, path, Visit11(target, references, path, value));
}
function FromTuple12(schema, references, path, value) {
	return IsArray2(value) && IsArray2(schema.items)
		? Default3(
				schema,
				path,
				schema.items.map((schema2, index) =>
					Visit11(schema2, references, `${path}/${index}`, value[index]),
				),
			)
		: Default3(schema, path, value);
}
function FromUnion17(schema, references, path, value) {
	for (const subschema of schema.anyOf) {
		if (!Check(subschema, references, value)) continue;
		const decoded = Visit11(subschema, references, path, value);
		return Default3(schema, path, decoded);
	}
	return Default3(schema, path, value);
}
function Visit11(schema, references, path, value) {
	const references_ = Pushref(schema, references);
	const schema_ = schema;
	switch (schema[Kind]) {
		case "Array":
			return FromArray14(schema_, references_, path, value);
		case "Import":
			return FromImport7(schema_, references_, path, value);
		case "Intersect":
			return FromIntersect15(schema_, references_, path, value);
		case "Not":
			return FromNot5(schema_, references_, path, value);
		case "Object":
			return FromObject15(schema_, references_, path, value);
		case "Record":
			return FromRecord10(schema_, references_, path, value);
		case "Ref":
			return FromRef11(schema_, references_, path, value);
		case "Symbol":
			return Default3(schema_, path, value);
		case "This":
			return FromThis7(schema_, references_, path, value);
		case "Tuple":
			return FromTuple12(schema_, references_, path, value);
		case "Union":
			return FromUnion17(schema_, references_, path, value);
		default:
			return Default3(schema_, path, value);
	}
}
function TransformDecode(schema, references, value) {
	return Visit11(schema, references, "", value);
}

// node_modules/@sinclair/typebox/build/esm/value/transform/encode.mjs
class TransformEncodeCheckError extends TypeBoxError {
	constructor(schema, value, error) {
		super("The encoded value does not match the expected schema");
		this.schema = schema;
		this.value = value;
		this.error = error;
	}
}

class TransformEncodeError extends TypeBoxError {
	constructor(schema, path, value, error) {
		super(`${error instanceof Error ? error.message : "Unknown error"}`);
		this.schema = schema;
		this.path = path;
		this.value = value;
		this.error = error;
	}
}
function Default4(schema, path, value) {
	try {
		return IsTransform(schema) ? schema[TransformKind].Encode(value) : value;
	} catch (error) {
		throw new TransformEncodeError(schema, path, value, error);
	}
}
function FromArray15(schema, references, path, value) {
	const defaulted = Default4(schema, path, value);
	return IsArray2(defaulted)
		? defaulted.map((value2, index) =>
				Visit12(schema.items, references, `${path}/${index}`, value2),
			)
		: defaulted;
}
function FromImport8(schema, references, path, value) {
	const additional = globalThis.Object.values(schema.$defs);
	const target = schema.$defs[schema.$ref];
	const result = Default4(schema, path, value);
	return Visit12(target, [...references, ...additional], path, result);
}
function FromIntersect16(schema, references, path, value) {
	const defaulted = Default4(schema, path, value);
	if (!IsObject2(value) || IsValueType(value)) return defaulted;
	const knownEntries = KeyOfPropertyEntries(schema);
	const knownKeys = knownEntries.map((entry) => entry[0]);
	const knownProperties = { ...defaulted };
	for (const [knownKey, knownSchema] of knownEntries)
		if (knownKey in knownProperties) {
			knownProperties[knownKey] = Visit12(
				knownSchema,
				references,
				`${path}/${knownKey}`,
				knownProperties[knownKey],
			);
		}
	if (!IsTransform(schema.unevaluatedProperties)) {
		return knownProperties;
	}
	const unknownKeys = Object.getOwnPropertyNames(knownProperties);
	const unevaluatedProperties = schema.unevaluatedProperties;
	const properties = { ...knownProperties };
	for (const key of unknownKeys)
		if (!knownKeys.includes(key)) {
			properties[key] = Default4(unevaluatedProperties, `${path}/${key}`, properties[key]);
		}
	return properties;
}
function FromNot6(schema, references, path, value) {
	return Default4(schema.not, path, Default4(schema, path, value));
}
function FromObject16(schema, references, path, value) {
	const defaulted = Default4(schema, path, value);
	if (!IsObject2(defaulted)) return defaulted;
	const knownKeys = KeyOfPropertyKeys(schema);
	const knownProperties = { ...defaulted };
	for (const key of knownKeys) {
		if (!HasPropertyKey2(knownProperties, key)) continue;
		if (
			IsUndefined2(knownProperties[key]) &&
			(!IsUndefined3(schema.properties[key]) ||
				TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key))
		)
			continue;
		knownProperties[key] = Visit12(
			schema.properties[key],
			references,
			`${path}/${key}`,
			knownProperties[key],
		);
	}
	if (!IsSchema(schema.additionalProperties)) {
		return knownProperties;
	}
	const unknownKeys = Object.getOwnPropertyNames(knownProperties);
	const additionalProperties = schema.additionalProperties;
	const properties = { ...knownProperties };
	for (const key of unknownKeys)
		if (!knownKeys.includes(key)) {
			properties[key] = Default4(additionalProperties, `${path}/${key}`, properties[key]);
		}
	return properties;
}
function FromRecord11(schema, references, path, value) {
	const defaulted = Default4(schema, path, value);
	if (!IsObject2(value)) return defaulted;
	const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
	const knownKeys = new RegExp(pattern);
	const knownProperties = { ...defaulted };
	for (const key of Object.getOwnPropertyNames(value))
		if (knownKeys.test(key)) {
			knownProperties[key] = Visit12(
				schema.patternProperties[pattern],
				references,
				`${path}/${key}`,
				knownProperties[key],
			);
		}
	if (!IsSchema(schema.additionalProperties)) {
		return knownProperties;
	}
	const unknownKeys = Object.getOwnPropertyNames(knownProperties);
	const additionalProperties = schema.additionalProperties;
	const properties = { ...knownProperties };
	for (const key of unknownKeys)
		if (!knownKeys.test(key)) {
			properties[key] = Default4(additionalProperties, `${path}/${key}`, properties[key]);
		}
	return properties;
}
function FromRef12(schema, references, path, value) {
	const target = Deref(schema, references);
	const resolved = Visit12(target, references, path, value);
	return Default4(schema, path, resolved);
}
function FromThis8(schema, references, path, value) {
	const target = Deref(schema, references);
	const resolved = Visit12(target, references, path, value);
	return Default4(schema, path, resolved);
}
function FromTuple13(schema, references, path, value) {
	const value1 = Default4(schema, path, value);
	return IsArray2(schema.items)
		? schema.items.map((schema2, index) =>
				Visit12(schema2, references, `${path}/${index}`, value1[index]),
			)
		: [];
}
function FromUnion18(schema, references, path, value) {
	for (const subschema of schema.anyOf) {
		if (!Check(subschema, references, value)) continue;
		const value1 = Visit12(subschema, references, path, value);
		return Default4(schema, path, value1);
	}
	for (const subschema of schema.anyOf) {
		const value1 = Visit12(subschema, references, path, value);
		if (!Check(schema, references, value1)) continue;
		return Default4(schema, path, value1);
	}
	return Default4(schema, path, value);
}
function Visit12(schema, references, path, value) {
	const references_ = Pushref(schema, references);
	const schema_ = schema;
	switch (schema[Kind]) {
		case "Array":
			return FromArray15(schema_, references_, path, value);
		case "Import":
			return FromImport8(schema_, references_, path, value);
		case "Intersect":
			return FromIntersect16(schema_, references_, path, value);
		case "Not":
			return FromNot6(schema_, references_, path, value);
		case "Object":
			return FromObject16(schema_, references_, path, value);
		case "Record":
			return FromRecord11(schema_, references_, path, value);
		case "Ref":
			return FromRef12(schema_, references_, path, value);
		case "This":
			return FromThis8(schema_, references_, path, value);
		case "Tuple":
			return FromTuple13(schema_, references_, path, value);
		case "Union":
			return FromUnion18(schema_, references_, path, value);
		default:
			return Default4(schema_, path, value);
	}
}
function TransformEncode(schema, references, value) {
	return Visit12(schema, references, "", value);
}

// node_modules/@sinclair/typebox/build/esm/value/transform/has.mjs
function FromArray16(schema, references) {
	return IsTransform(schema) || Visit13(schema.items, references);
}
function FromAsyncIterator7(schema, references) {
	return IsTransform(schema) || Visit13(schema.items, references);
}
function FromConstructor8(schema, references) {
	return (
		IsTransform(schema) ||
		Visit13(schema.returns, references) ||
		schema.parameters.some((schema2) => Visit13(schema2, references))
	);
}
function FromFunction7(schema, references) {
	return (
		IsTransform(schema) ||
		Visit13(schema.returns, references) ||
		schema.parameters.some((schema2) => Visit13(schema2, references))
	);
}
function FromIntersect17(schema, references) {
	return (
		IsTransform(schema) ||
		IsTransform(schema.unevaluatedProperties) ||
		schema.allOf.some((schema2) => Visit13(schema2, references))
	);
}
function FromImport9(schema, references) {
	const additional = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce(
		(result, key) => [...result, schema.$defs[key]],
		[],
	);
	const target = schema.$defs[schema.$ref];
	return IsTransform(schema) || Visit13(target, [...additional, ...references]);
}
function FromIterator7(schema, references) {
	return IsTransform(schema) || Visit13(schema.items, references);
}
function FromNot7(schema, references) {
	return IsTransform(schema) || Visit13(schema.not, references);
}
function FromObject17(schema, references) {
	return (
		IsTransform(schema) ||
		Object.values(schema.properties).some((schema2) => Visit13(schema2, references)) ||
		(IsSchema(schema.additionalProperties) && Visit13(schema.additionalProperties, references))
	);
}
function FromPromise7(schema, references) {
	return IsTransform(schema) || Visit13(schema.item, references);
}
function FromRecord12(schema, references) {
	const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
	const property = schema.patternProperties[pattern];
	return (
		IsTransform(schema) ||
		Visit13(property, references) ||
		(IsSchema(schema.additionalProperties) && IsTransform(schema.additionalProperties))
	);
}
function FromRef13(schema, references) {
	if (IsTransform(schema)) return true;
	return Visit13(Deref(schema, references), references);
}
function FromThis9(schema, references) {
	if (IsTransform(schema)) return true;
	return Visit13(Deref(schema, references), references);
}
function FromTuple14(schema, references) {
	return (
		IsTransform(schema) ||
		(!IsUndefined2(schema.items) && schema.items.some((schema2) => Visit13(schema2, references)))
	);
}
function FromUnion19(schema, references) {
	return IsTransform(schema) || schema.anyOf.some((schema2) => Visit13(schema2, references));
}
function Visit13(schema, references) {
	const references_ = Pushref(schema, references);
	const schema_ = schema;
	if (schema.$id && visited.has(schema.$id)) return false;
	if (schema.$id) visited.add(schema.$id);
	switch (schema[Kind]) {
		case "Array":
			return FromArray16(schema_, references_);
		case "AsyncIterator":
			return FromAsyncIterator7(schema_, references_);
		case "Constructor":
			return FromConstructor8(schema_, references_);
		case "Function":
			return FromFunction7(schema_, references_);
		case "Import":
			return FromImport9(schema_, references_);
		case "Intersect":
			return FromIntersect17(schema_, references_);
		case "Iterator":
			return FromIterator7(schema_, references_);
		case "Not":
			return FromNot7(schema_, references_);
		case "Object":
			return FromObject17(schema_, references_);
		case "Promise":
			return FromPromise7(schema_, references_);
		case "Record":
			return FromRecord12(schema_, references_);
		case "Ref":
			return FromRef13(schema_, references_);
		case "This":
			return FromThis9(schema_, references_);
		case "Tuple":
			return FromTuple14(schema_, references_);
		case "Union":
			return FromUnion19(schema_, references_);
		default:
			return IsTransform(schema);
	}
}
var visited = new Set();
function HasTransform(schema, references) {
	visited.clear();
	return Visit13(schema, references);
}

// node_modules/@sinclair/typebox/build/esm/value/decode/decode.mjs
function Decode(...args) {
	const [schema, references, value] =
		args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
	if (!Check(schema, references, value))
		throw new TransformDecodeCheckError(schema, value, Errors(schema, references, value).First());
	return HasTransform(schema, references) ? TransformDecode(schema, references, value) : value;
}
// node_modules/@sinclair/typebox/build/esm/value/default/default.mjs
function ValueOrDefault(schema, value) {
	const defaultValue = HasPropertyKey2(schema, "default") ? schema.default : undefined;
	const clone = IsFunction2(defaultValue) ? defaultValue() : Clone2(defaultValue);
	return IsUndefined2(value)
		? clone
		: IsObject2(value) && IsObject2(clone)
			? Object.assign(clone, value)
			: value;
}
function HasDefaultProperty(schema) {
	return IsKind(schema) && "default" in schema;
}
function FromArray17(schema, references, value) {
	if (IsArray2(value)) {
		for (let i = 0; i < value.length; i++) {
			value[i] = Visit14(schema.items, references, value[i]);
		}
		return value;
	}
	const defaulted = ValueOrDefault(schema, value);
	if (!IsArray2(defaulted)) return defaulted;
	for (let i = 0; i < defaulted.length; i++) {
		defaulted[i] = Visit14(schema.items, references, defaulted[i]);
	}
	return defaulted;
}
function FromDate7(schema, references, value) {
	return IsDate2(value) ? value : ValueOrDefault(schema, value);
}
function FromImport10(schema, references, value) {
	const definitions = globalThis.Object.values(schema.$defs);
	const target = schema.$defs[schema.$ref];
	return Visit14(target, [...references, ...definitions], value);
}
function FromIntersect18(schema, references, value) {
	const defaulted = ValueOrDefault(schema, value);
	return schema.allOf.reduce((acc, schema2) => {
		const next = Visit14(schema2, references, defaulted);
		return IsObject2(next) ? { ...acc, ...next } : next;
	}, {});
}
function FromObject18(schema, references, value) {
	const defaulted = ValueOrDefault(schema, value);
	if (!IsObject2(defaulted)) return defaulted;
	const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
	for (const key of knownPropertyKeys) {
		const propertyValue = Visit14(schema.properties[key], references, defaulted[key]);
		if (IsUndefined2(propertyValue)) continue;
		defaulted[key] = Visit14(schema.properties[key], references, defaulted[key]);
	}
	if (!HasDefaultProperty(schema.additionalProperties)) return defaulted;
	for (const key of Object.getOwnPropertyNames(defaulted)) {
		if (knownPropertyKeys.includes(key)) continue;
		defaulted[key] = Visit14(schema.additionalProperties, references, defaulted[key]);
	}
	return defaulted;
}
function FromRecord13(schema, references, value) {
	const defaulted = ValueOrDefault(schema, value);
	if (!IsObject2(defaulted)) return defaulted;
	const additionalPropertiesSchema = schema.additionalProperties;
	const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
	const knownPropertyKey = new RegExp(propertyKeyPattern);
	for (const key of Object.getOwnPropertyNames(defaulted)) {
		if (!(knownPropertyKey.test(key) && HasDefaultProperty(propertySchema))) continue;
		defaulted[key] = Visit14(propertySchema, references, defaulted[key]);
	}
	if (!HasDefaultProperty(additionalPropertiesSchema)) return defaulted;
	for (const key of Object.getOwnPropertyNames(defaulted)) {
		if (knownPropertyKey.test(key)) continue;
		defaulted[key] = Visit14(additionalPropertiesSchema, references, defaulted[key]);
	}
	return defaulted;
}
function FromRef14(schema, references, value) {
	return Visit14(Deref(schema, references), references, ValueOrDefault(schema, value));
}
function FromThis10(schema, references, value) {
	return Visit14(Deref(schema, references), references, value);
}
function FromTuple15(schema, references, value) {
	const defaulted = ValueOrDefault(schema, value);
	if (!IsArray2(defaulted) || IsUndefined2(schema.items)) return defaulted;
	const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
	for (let i = 0; i < max; i++) {
		if (i < items.length) defaulted[i] = Visit14(items[i], references, defaulted[i]);
	}
	return defaulted;
}
function FromUnion20(schema, references, value) {
	const defaulted = ValueOrDefault(schema, value);
	for (const inner of schema.anyOf) {
		const result = Visit14(inner, references, Clone2(defaulted));
		if (Check(inner, references, result)) {
			return result;
		}
	}
	return defaulted;
}
function Visit14(schema, references, value) {
	const references_ = Pushref(schema, references);
	const schema_ = schema;
	switch (schema_[Kind]) {
		case "Array":
			return FromArray17(schema_, references_, value);
		case "Date":
			return FromDate7(schema_, references_, value);
		case "Import":
			return FromImport10(schema_, references_, value);
		case "Intersect":
			return FromIntersect18(schema_, references_, value);
		case "Object":
			return FromObject18(schema_, references_, value);
		case "Record":
			return FromRecord13(schema_, references_, value);
		case "Ref":
			return FromRef14(schema_, references_, value);
		case "This":
			return FromThis10(schema_, references_, value);
		case "Tuple":
			return FromTuple15(schema_, references_, value);
		case "Union":
			return FromUnion20(schema_, references_, value);
		default:
			return ValueOrDefault(schema_, value);
	}
}
function Default5(...args) {
	return args.length === 3 ? Visit14(args[0], args[1], args[2]) : Visit14(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/pointer/pointer.mjs
var exports_pointer = {};
__export(exports_pointer, {
	ValuePointerRootSetError: () => ValuePointerRootSetError,
	ValuePointerRootDeleteError: () => ValuePointerRootDeleteError,
	Set: () => Set4,
	Has: () => Has3,
	Get: () => Get3,
	Format: () => Format,
	Delete: () => Delete3,
});
class ValuePointerRootSetError extends TypeBoxError {
	constructor(value, path, update) {
		super("Cannot set root value");
		this.value = value;
		this.path = path;
		this.update = update;
	}
}

class ValuePointerRootDeleteError extends TypeBoxError {
	constructor(value, path) {
		super("Cannot delete root value");
		this.value = value;
		this.path = path;
	}
}
function Escape2(component) {
	return component.indexOf("~") === -1
		? component
		: component.replace(/~1/g, "/").replace(/~0/g, "~");
}
function* Format(pointer) {
	if (pointer === "") return;
	let [start, end] = [0, 0];
	for (let i = 0; i < pointer.length; i++) {
		const char = pointer.charAt(i);
		if (char === "/") {
			if (i === 0) {
				start = i + 1;
			} else {
				end = i;
				yield Escape2(pointer.slice(start, end));
				start = i + 1;
			}
		} else {
			end = i;
		}
	}
	yield Escape2(pointer.slice(start));
}
function Set4(value, pointer, update) {
	if (pointer === "") throw new ValuePointerRootSetError(value, pointer, update);
	let [owner, next, key] = [null, value, ""];
	for (const component of Format(pointer)) {
		if (next[component] === undefined) next[component] = {};
		owner = next;
		next = next[component];
		key = component;
	}
	owner[key] = update;
}
function Delete3(value, pointer) {
	if (pointer === "") throw new ValuePointerRootDeleteError(value, pointer);
	let [owner, next, key] = [null, value, ""];
	for (const component of Format(pointer)) {
		if (next[component] === undefined || next[component] === null) return;
		owner = next;
		next = next[component];
		key = component;
	}
	if (Array.isArray(owner)) {
		const index = parseInt(key);
		owner.splice(index, 1);
	} else {
		delete owner[key];
	}
}
function Has3(value, pointer) {
	if (pointer === "") return true;
	let [owner, next, key] = [null, value, ""];
	for (const component of Format(pointer)) {
		if (next[component] === undefined) return false;
		owner = next;
		next = next[component];
		key = component;
	}
	return Object.getOwnPropertyNames(owner).includes(key);
}
function Get3(value, pointer) {
	if (pointer === "") return value;
	let current = value;
	for (const component of Format(pointer)) {
		if (current[component] === undefined) return;
		current = current[component];
	}
	return current;
}
// node_modules/@sinclair/typebox/build/esm/value/equal/equal.mjs
function ObjectType3(left, right) {
	if (!IsObject2(right)) return false;
	const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
	const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
	if (leftKeys.length !== rightKeys.length) return false;
	return leftKeys.every((key) => Equal(left[key], right[key]));
}
function DateType3(left, right) {
	return IsDate2(right) && left.getTime() === right.getTime();
}
function ArrayType3(left, right) {
	if (!IsArray2(right) || left.length !== right.length) return false;
	return left.every((value, index) => Equal(value, right[index]));
}
function TypedArrayType(left, right) {
	if (
		!IsTypedArray(right) ||
		left.length !== right.length ||
		Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name
	)
		return false;
	return left.every((value, index) => Equal(value, right[index]));
}
function ValueType(left, right) {
	return left === right;
}
function Equal(left, right) {
	if (IsDate2(left)) return DateType3(left, right);
	if (IsTypedArray(left)) return TypedArrayType(left, right);
	if (IsArray2(left)) return ArrayType3(left, right);
	if (IsObject2(left)) return ObjectType3(left, right);
	if (IsValueType(left)) return ValueType(left, right);
	throw new Error("ValueEquals: Unable to compare value");
}

// node_modules/@sinclair/typebox/build/esm/value/delta/delta.mjs
var Insert = Object2({
	type: Literal("insert"),
	path: String2(),
	value: Unknown(),
});
var Update = Object2({
	type: Literal("update"),
	path: String2(),
	value: Unknown(),
});
var Delete4 = Object2({
	type: Literal("delete"),
	path: String2(),
});
var Edit = Union([Insert, Update, Delete4]);

class ValueDiffError extends TypeBoxError {
	constructor(value, message) {
		super(message);
		this.value = value;
	}
}
function CreateUpdate(path, value) {
	return { type: "update", path, value };
}
function CreateInsert(path, value) {
	return { type: "insert", path, value };
}
function CreateDelete(path) {
	return { type: "delete", path };
}
function AssertDiffable(value) {
	if (globalThis.Object.getOwnPropertySymbols(value).length > 0)
		throw new ValueDiffError(value, "Cannot diff objects with symbols");
}
function* ObjectType4(path, current, next) {
	AssertDiffable(current);
	AssertDiffable(next);
	if (!IsStandardObject(next)) return yield CreateUpdate(path, next);
	const currentKeys = globalThis.Object.getOwnPropertyNames(current);
	const nextKeys = globalThis.Object.getOwnPropertyNames(next);
	for (const key of nextKeys) {
		if (HasPropertyKey2(current, key)) continue;
		yield CreateInsert(`${path}/${key}`, next[key]);
	}
	for (const key of currentKeys) {
		if (!HasPropertyKey2(next, key)) continue;
		if (Equal(current, next)) continue;
		yield* Visit15(`${path}/${key}`, current[key], next[key]);
	}
	for (const key of currentKeys) {
		if (HasPropertyKey2(next, key)) continue;
		yield CreateDelete(`${path}/${key}`);
	}
}
function* ArrayType4(path, current, next) {
	if (!IsArray2(next)) return yield CreateUpdate(path, next);
	for (let i = 0; i < Math.min(current.length, next.length); i++) {
		yield* Visit15(`${path}/${i}`, current[i], next[i]);
	}
	for (let i = 0; i < next.length; i++) {
		if (i < current.length) continue;
		yield CreateInsert(`${path}/${i}`, next[i]);
	}
	for (let i = current.length - 1; i >= 0; i--) {
		if (i < next.length) continue;
		yield CreateDelete(`${path}/${i}`);
	}
}
function* TypedArrayType2(path, current, next) {
	if (
		!IsTypedArray(next) ||
		current.length !== next.length ||
		globalThis.Object.getPrototypeOf(current).constructor.name !==
			globalThis.Object.getPrototypeOf(next).constructor.name
	)
		return yield CreateUpdate(path, next);
	for (let i = 0; i < Math.min(current.length, next.length); i++) {
		yield* Visit15(`${path}/${i}`, current[i], next[i]);
	}
}
function* ValueType2(path, current, next) {
	if (current === next) return;
	yield CreateUpdate(path, next);
}
function* Visit15(path, current, next) {
	if (IsStandardObject(current)) return yield* ObjectType4(path, current, next);
	if (IsArray2(current)) return yield* ArrayType4(path, current, next);
	if (IsTypedArray(current)) return yield* TypedArrayType2(path, current, next);
	if (IsValueType(current)) return yield* ValueType2(path, current, next);
	throw new ValueDiffError(current, "Unable to diff value");
}
function Diff(current, next) {
	return [...Visit15("", current, next)];
}
function IsRootUpdate(edits) {
	return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
}
function IsIdentity(edits) {
	return edits.length === 0;
}
function Patch(current, edits) {
	if (IsRootUpdate(edits)) {
		return Clone2(edits[0].value);
	}
	if (IsIdentity(edits)) {
		return Clone2(current);
	}
	const clone = Clone2(current);
	for (const edit of edits) {
		switch (edit.type) {
			case "insert": {
				exports_pointer.Set(clone, edit.path, edit.value);
				break;
			}
			case "update": {
				exports_pointer.Set(clone, edit.path, edit.value);
				break;
			}
			case "delete": {
				exports_pointer.Delete(clone, edit.path);
				break;
			}
		}
	}
	return clone;
}
// node_modules/@sinclair/typebox/build/esm/value/encode/encode.mjs
function Encode(...args) {
	const [schema, references, value] =
		args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
	const encoded = HasTransform(schema, references)
		? TransformEncode(schema, references, value)
		: value;
	if (!Check(schema, references, encoded))
		throw new TransformEncodeCheckError(
			schema,
			encoded,
			Errors(schema, references, encoded).First(),
		);
	return encoded;
}
// node_modules/@sinclair/typebox/build/esm/value/mutate/mutate.mjs
function IsStandardObject2(value) {
	return IsObject2(value) && !IsArray2(value);
}

class ValueMutateError extends TypeBoxError {
	constructor(message) {
		super(message);
	}
}
function ObjectType5(root, path, current, next) {
	if (!IsStandardObject2(current)) {
		exports_pointer.Set(root, path, Clone2(next));
	} else {
		const currentKeys = Object.getOwnPropertyNames(current);
		const nextKeys = Object.getOwnPropertyNames(next);
		for (const currentKey of currentKeys) {
			if (!nextKeys.includes(currentKey)) {
				delete current[currentKey];
			}
		}
		for (const nextKey of nextKeys) {
			if (!currentKeys.includes(nextKey)) {
				current[nextKey] = null;
			}
		}
		for (const nextKey of nextKeys) {
			Visit16(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
		}
	}
}
function ArrayType5(root, path, current, next) {
	if (!IsArray2(current)) {
		exports_pointer.Set(root, path, Clone2(next));
	} else {
		for (let index = 0; index < next.length; index++) {
			Visit16(root, `${path}/${index}`, current[index], next[index]);
		}
		current.splice(next.length);
	}
}
function TypedArrayType3(root, path, current, next) {
	if (IsTypedArray(current) && current.length === next.length) {
		for (let i = 0; i < current.length; i++) {
			current[i] = next[i];
		}
	} else {
		exports_pointer.Set(root, path, Clone2(next));
	}
}
function ValueType3(root, path, current, next) {
	if (current === next) return;
	exports_pointer.Set(root, path, next);
}
function Visit16(root, path, current, next) {
	if (IsArray2(next)) return ArrayType5(root, path, current, next);
	if (IsTypedArray(next)) return TypedArrayType3(root, path, current, next);
	if (IsStandardObject2(next)) return ObjectType5(root, path, current, next);
	if (IsValueType(next)) return ValueType3(root, path, current, next);
}
function IsNonMutableValue(value) {
	return IsTypedArray(value) || IsValueType(value);
}
function IsMismatchedValue(current, next) {
	return (
		(IsStandardObject2(current) && IsArray2(next)) || (IsArray2(current) && IsStandardObject2(next))
	);
}
function Mutate(current, next) {
	if (IsNonMutableValue(current) || IsNonMutableValue(next))
		throw new ValueMutateError("Only object and array types can be mutated at the root level");
	if (IsMismatchedValue(current, next))
		throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
	Visit16(current, "", current, next);
}
// node_modules/@sinclair/typebox/build/esm/value/parse/parse.mjs
class ParseError extends TypeBoxError {
	constructor(message) {
		super(message);
	}
}
var ParseRegistry;
(function (ParseRegistry2) {
	const registry = new Map([
		[
			"Assert",
			(type, references, value) => {
				Assert(type, references, value);
				return value;
			},
		],
		["Cast", (type, references, value) => Cast(type, references, value)],
		["Clean", (type, references, value) => Clean(type, references, value)],
		["Clone", (_type, _references, value) => Clone2(value)],
		["Convert", (type, references, value) => Convert(type, references, value)],
		[
			"Decode",
			(type, references, value) =>
				HasTransform(type, references) ? TransformDecode(type, references, value) : value,
		],
		["Default", (type, references, value) => Default5(type, references, value)],
		[
			"Encode",
			(type, references, value) =>
				HasTransform(type, references) ? TransformEncode(type, references, value) : value,
		],
	]);
	function Delete5(key) {
		registry.delete(key);
	}
	ParseRegistry2.Delete = Delete5;
	function Set5(key, callback) {
		registry.set(key, callback);
	}
	ParseRegistry2.Set = Set5;
	function Get4(key) {
		return registry.get(key);
	}
	ParseRegistry2.Get = Get4;
})(ParseRegistry || (ParseRegistry = {}));
var ParseDefault = ["Clone", "Clean", "Default", "Convert", "Assert", "Decode"];
function ParseValue(operations, type, references, value) {
	return operations.reduce((value2, operationKey) => {
		const operation = ParseRegistry.Get(operationKey);
		if (IsUndefined2(operation))
			throw new ParseError(`Unable to find Parse operation '${operationKey}'`);
		return operation(type, references, value2);
	}, value);
}
function Parse(...args) {
	const [operations, schema, references, value] =
		args.length === 4
			? [args[0], args[1], args[2], args[3]]
			: args.length === 3
				? IsArray2(args[0])
					? [args[0], args[1], [], args[2]]
					: [ParseDefault, args[0], args[1], args[2]]
				: args.length === 2
					? [ParseDefault, args[0], [], args[1]]
					: (() => {
							throw new ParseError("Invalid Arguments");
						})();
	return ParseValue(operations, schema, references, value);
}
// node_modules/@sinclair/typebox/build/esm/value/value/value.mjs
var exports_value2 = {};
__export(exports_value2, {
	ValueErrorIterator: () => ValueErrorIterator,
	Patch: () => Patch,
	Parse: () => Parse,
	Mutate: () => Mutate,
	Hash: () => Hash,
	Errors: () => Errors,
	Equal: () => Equal,
	Encode: () => Encode,
	Edit: () => Edit,
	Diff: () => Diff,
	Default: () => Default5,
	Decode: () => Decode,
	Create: () => Create2,
	Convert: () => Convert,
	Clone: () => Clone2,
	Clean: () => Clean,
	Check: () => Check,
	Cast: () => Cast,
	Assert: () => Assert,
});
// node_modules/@sinclair/typebox/build/esm/compiler/compiler.mjs
class TypeCheck {
	constructor(schema, references, checkFunc, code) {
		this.schema = schema;
		this.references = references;
		this.checkFunc = checkFunc;
		this.code = code;
		this.hasTransform = HasTransform(schema, references);
	}
	Code() {
		return this.code;
	}
	Schema() {
		return this.schema;
	}
	References() {
		return this.references;
	}
	Errors(value) {
		return Errors(this.schema, this.references, value);
	}
	Check(value) {
		return this.checkFunc(value);
	}
	Decode(value) {
		if (!this.checkFunc(value))
			throw new TransformDecodeCheckError(this.schema, value, this.Errors(value).First());
		return this.hasTransform ? TransformDecode(this.schema, this.references, value) : value;
	}
	Encode(value) {
		const encoded = this.hasTransform
			? TransformEncode(this.schema, this.references, value)
			: value;
		if (!this.checkFunc(encoded))
			throw new TransformEncodeCheckError(this.schema, value, this.Errors(value).First());
		return encoded;
	}
}
var Character;
(function (Character2) {
	function DollarSign(code) {
		return code === 36;
	}
	Character2.DollarSign = DollarSign;
	function IsUnderscore(code) {
		return code === 95;
	}
	Character2.IsUnderscore = IsUnderscore;
	function IsAlpha(code) {
		return (code >= 65 && code <= 90) || (code >= 97 && code <= 122);
	}
	Character2.IsAlpha = IsAlpha;
	function IsNumeric(code) {
		return code >= 48 && code <= 57;
	}
	Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function (MemberExpression2) {
	function IsFirstCharacterNumeric(value) {
		if (value.length === 0) return false;
		return Character.IsNumeric(value.charCodeAt(0));
	}
	function IsAccessor(value) {
		if (IsFirstCharacterNumeric(value)) return false;
		for (let i = 0; i < value.length; i++) {
			const code = value.charCodeAt(i);
			const check2 =
				Character.IsAlpha(code) ||
				Character.IsNumeric(code) ||
				Character.DollarSign(code) ||
				Character.IsUnderscore(code);
			if (!check2) return false;
		}
		return true;
	}
	function EscapeHyphen(key) {
		return key.replace(/'/g, "\\'");
	}
	function Encode2(object, key) {
		return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;
	}
	MemberExpression2.Encode = Encode2;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function (Identifier2) {
	function Encode2($id) {
		const buffer = [];
		for (let i = 0; i < $id.length; i++) {
			const code = $id.charCodeAt(i);
			if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
				buffer.push($id.charAt(i));
			} else {
				buffer.push(`_${code}_`);
			}
		}
		return buffer.join("").replace(/__/g, "_");
	}
	Identifier2.Encode = Encode2;
})(Identifier || (Identifier = {}));
var LiteralString;
(function (LiteralString2) {
	function Escape3(content) {
		return content.replace(/'/g, "\\'");
	}
	LiteralString2.Escape = Escape3;
})(LiteralString || (LiteralString = {}));

class TypeCompilerUnknownTypeError extends TypeBoxError {
	constructor(schema) {
		super("Unknown type");
		this.schema = schema;
	}
}

class TypeCompilerTypeGuardError extends TypeBoxError {
	constructor(schema) {
		super("Preflight validation check failed to guard for the given schema");
		this.schema = schema;
	}
}
var Policy;
(function (Policy2) {
	function IsExactOptionalProperty(value, key, expression) {
		return TypeSystemPolicy.ExactOptionalPropertyTypes
			? `('${key}' in ${value} ? ${expression} : true)`
			: `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;
	}
	Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
	function IsObjectLike(value) {
		return !TypeSystemPolicy.AllowArrayObject
			? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))`
			: `(typeof ${value} === 'object' && ${value} !== null)`;
	}
	Policy2.IsObjectLike = IsObjectLike;
	function IsRecordLike(value) {
		return !TypeSystemPolicy.AllowArrayObject
			? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`
			: `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;
	}
	Policy2.IsRecordLike = IsRecordLike;
	function IsNumberLike(value) {
		return TypeSystemPolicy.AllowNaN ? `typeof ${value} === 'number'` : `Number.isFinite(${value})`;
	}
	Policy2.IsNumberLike = IsNumberLike;
	function IsVoidLike(value) {
		return TypeSystemPolicy.AllowNullVoid
			? `(${value} === undefined || ${value} === null)`
			: `${value} === undefined`;
	}
	Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function (TypeCompiler2) {
	function IsAnyOrUnknown2(schema) {
		return schema[Kind] === "Any" || schema[Kind] === "Unknown";
	}
	function* FromAny5(schema, references, value) {
		yield "true";
	}
	function* FromArgument5(schema, references, value) {
		yield "true";
	}
	function* FromArray18(schema, references, value) {
		yield `Array.isArray(${value})`;
		const [parameter, accumulator] = [
			CreateParameter("value", "any"),
			CreateParameter("acc", "number"),
		];
		if (IsNumber2(schema.maxItems)) yield `${value}.length <= ${schema.maxItems}`;
		if (IsNumber2(schema.minItems)) yield `${value}.length >= ${schema.minItems}`;
		const elementExpression = CreateExpression(schema.items, references, "value");
		yield `${value}.every((${parameter}) => ${elementExpression})`;
		if (
			IsSchema2(schema.contains) ||
			IsNumber2(schema.minContains) ||
			IsNumber2(schema.maxContains)
		) {
			const containsSchema = IsSchema2(schema.contains) ? schema.contains : Never();
			const checkExpression = CreateExpression(containsSchema, references, "value");
			const checkMinContains = IsNumber2(schema.minContains)
				? [`(count >= ${schema.minContains})`]
				: [];
			const checkMaxContains = IsNumber2(schema.maxContains)
				? [`(count <= ${schema.maxContains})`]
				: [];
			const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
			const check2 = ["(count > 0)", ...checkMinContains, ...checkMaxContains].join(" && ");
			yield `((${parameter}) => { ${checkCount}; return ${check2}})(${value})`;
		}
		if (schema.uniqueItems === true) {
			const check2 =
				"const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true";
			const block = `const set = new Set(); for(const element of value) { ${check2} }`;
			yield `((${parameter}) => { ${block} )(${value})`;
		}
	}
	function* FromAsyncIterator8(schema, references, value) {
		yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;
	}
	function* FromBigInt6(schema, references, value) {
		yield `(typeof ${value} === 'bigint')`;
		if (IsBigInt2(schema.exclusiveMaximum)) yield `${value} < BigInt(${schema.exclusiveMaximum})`;
		if (IsBigInt2(schema.exclusiveMinimum)) yield `${value} > BigInt(${schema.exclusiveMinimum})`;
		if (IsBigInt2(schema.maximum)) yield `${value} <= BigInt(${schema.maximum})`;
		if (IsBigInt2(schema.minimum)) yield `${value} >= BigInt(${schema.minimum})`;
		if (IsBigInt2(schema.multipleOf)) yield `(${value} % BigInt(${schema.multipleOf})) === 0`;
	}
	function* FromBoolean6(schema, references, value) {
		yield `(typeof ${value} === 'boolean')`;
	}
	function* FromConstructor9(schema, references, value) {
		yield* Visit17(schema.returns, references, `${value}.prototype`);
	}
	function* FromDate8(schema, references, value) {
		yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;
		if (IsNumber2(schema.exclusiveMaximumTimestamp))
			yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
		if (IsNumber2(schema.exclusiveMinimumTimestamp))
			yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
		if (IsNumber2(schema.maximumTimestamp))
			yield `${value}.getTime() <= ${schema.maximumTimestamp}`;
		if (IsNumber2(schema.minimumTimestamp))
			yield `${value}.getTime() >= ${schema.minimumTimestamp}`;
		if (IsNumber2(schema.multipleOfTimestamp))
			yield `(${value}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
	}
	function* FromFunction8(schema, references, value) {
		yield `(typeof ${value} === 'function')`;
	}
	function* FromImport11(schema, references, value) {
		const members = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => {
			return [...result, schema.$defs[key]];
		}, []);
		yield* Visit17(Ref(schema.$ref), [...references, ...members], value);
	}
	function* FromInteger6(schema, references, value) {
		yield `Number.isInteger(${value})`;
		if (IsNumber2(schema.exclusiveMaximum)) yield `${value} < ${schema.exclusiveMaximum}`;
		if (IsNumber2(schema.exclusiveMinimum)) yield `${value} > ${schema.exclusiveMinimum}`;
		if (IsNumber2(schema.maximum)) yield `${value} <= ${schema.maximum}`;
		if (IsNumber2(schema.minimum)) yield `${value} >= ${schema.minimum}`;
		if (IsNumber2(schema.multipleOf)) yield `(${value} % ${schema.multipleOf}) === 0`;
	}
	function* FromIntersect19(schema, references, value) {
		const check1 = schema.allOf
			.map((schema2) => CreateExpression(schema2, references, value))
			.join(" && ");
		if (schema.unevaluatedProperties === false) {
			const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
			const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;
			yield `(${check1} && ${check2})`;
		} else if (IsSchema2(schema.unevaluatedProperties)) {
			const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
			const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;
			yield `(${check1} && ${check2})`;
		} else {
			yield `(${check1})`;
		}
	}
	function* FromIterator8(schema, references, value) {
		yield `(typeof value === 'object' && Symbol.iterator in ${value})`;
	}
	function* FromLiteral7(schema, references, value) {
		if (typeof schema.const === "number" || typeof schema.const === "boolean") {
			yield `(${value} === ${schema.const})`;
		} else {
			yield `(${value} === '${LiteralString.Escape(schema.const)}')`;
		}
	}
	function* FromNever6(schema, references, value) {
		yield "false";
	}
	function* FromNot8(schema, references, value) {
		const expression = CreateExpression(schema.not, references, value);
		yield `(!${expression})`;
	}
	function* FromNull6(schema, references, value) {
		yield `(${value} === null)`;
	}
	function* FromNumber6(schema, references, value) {
		yield Policy.IsNumberLike(value);
		if (IsNumber2(schema.exclusiveMaximum)) yield `${value} < ${schema.exclusiveMaximum}`;
		if (IsNumber2(schema.exclusiveMinimum)) yield `${value} > ${schema.exclusiveMinimum}`;
		if (IsNumber2(schema.maximum)) yield `${value} <= ${schema.maximum}`;
		if (IsNumber2(schema.minimum)) yield `${value} >= ${schema.minimum}`;
		if (IsNumber2(schema.multipleOf)) yield `(${value} % ${schema.multipleOf}) === 0`;
	}
	function* FromObject19(schema, references, value) {
		yield Policy.IsObjectLike(value);
		if (IsNumber2(schema.minProperties))
			yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
		if (IsNumber2(schema.maxProperties))
			yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
		const knownKeys = Object.getOwnPropertyNames(schema.properties);
		for (const knownKey of knownKeys) {
			const memberExpression = MemberExpression.Encode(value, knownKey);
			const property = schema.properties[knownKey];
			if (schema.required && schema.required.includes(knownKey)) {
				yield* Visit17(property, references, memberExpression);
				if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
					yield `('${knownKey}' in ${value})`;
			} else {
				const expression = CreateExpression(property, references, memberExpression);
				yield Policy.IsExactOptionalProperty(value, knownKey, expression);
			}
		}
		if (schema.additionalProperties === false) {
			if (schema.required && schema.required.length === knownKeys.length) {
				yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;
			} else {
				const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
				yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;
			}
		}
		if (typeof schema.additionalProperties === "object") {
			const expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`);
			const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
			yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;
		}
	}
	function* FromPromise8(schema, references, value) {
		yield `${value} instanceof Promise`;
	}
	function* FromRecord14(schema, references, value) {
		yield Policy.IsRecordLike(value);
		if (IsNumber2(schema.minProperties))
			yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
		if (IsNumber2(schema.maxProperties))
			yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
		const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
		const variable = CreateVariable(`${new RegExp(patternKey)}`);
		const check1 = CreateExpression(patternSchema, references, "value");
		const check2 = IsSchema2(schema.additionalProperties)
			? CreateExpression(schema.additionalProperties, references, value)
			: schema.additionalProperties === false
				? "false"
				: "true";
		const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
		yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;
	}
	function* FromRef15(schema, references, value) {
		const target = Deref(schema, references);
		if (state.functions.has(schema.$ref))
			return yield `${CreateFunctionName(schema.$ref)}(${value})`;
		yield* Visit17(target, references, value);
	}
	function* FromRegExp5(schema, references, value) {
		const variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);
		yield `(typeof ${value} === 'string')`;
		if (IsNumber2(schema.maxLength)) yield `${value}.length <= ${schema.maxLength}`;
		if (IsNumber2(schema.minLength)) yield `${value}.length >= ${schema.minLength}`;
		yield `${variable}.test(${value})`;
	}
	function* FromString6(schema, references, value) {
		yield `(typeof ${value} === 'string')`;
		if (IsNumber2(schema.maxLength)) yield `${value}.length <= ${schema.maxLength}`;
		if (IsNumber2(schema.minLength)) yield `${value}.length >= ${schema.minLength}`;
		if (schema.pattern !== undefined) {
			const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
			yield `${variable}.test(${value})`;
		}
		if (schema.format !== undefined) {
			yield `format('${schema.format}', ${value})`;
		}
	}
	function* FromSymbol6(schema, references, value) {
		yield `(typeof ${value} === 'symbol')`;
	}
	function* FromTemplateLiteral7(schema, references, value) {
		yield `(typeof ${value} === 'string')`;
		const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
		yield `${variable}.test(${value})`;
	}
	function* FromThis11(schema, references, value) {
		yield `${CreateFunctionName(schema.$ref)}(${value})`;
	}
	function* FromTuple16(schema, references, value) {
		yield `Array.isArray(${value})`;
		if (schema.items === undefined) return yield `${value}.length === 0`;
		yield `(${value}.length === ${schema.maxItems})`;
		for (let i = 0; i < schema.items.length; i++) {
			const expression = CreateExpression(schema.items[i], references, `${value}[${i}]`);
			yield `${expression}`;
		}
	}
	function* FromUndefined6(schema, references, value) {
		yield `${value} === undefined`;
	}
	function* FromUnion21(schema, references, value) {
		const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value));
		yield `(${expressions.join(" || ")})`;
	}
	function* FromUint8Array5(schema, references, value) {
		yield `${value} instanceof Uint8Array`;
		if (IsNumber2(schema.maxByteLength)) yield `(${value}.length <= ${schema.maxByteLength})`;
		if (IsNumber2(schema.minByteLength)) yield `(${value}.length >= ${schema.minByteLength})`;
	}
	function* FromUnknown5(schema, references, value) {
		yield "true";
	}
	function* FromVoid5(schema, references, value) {
		yield Policy.IsVoidLike(value);
	}
	function* FromKind4(schema, references, value) {
		const instance = state.instances.size;
		state.instances.set(instance, schema);
		yield `kind('${schema[Kind]}', ${instance}, ${value})`;
	}
	function* Visit17(schema, references, value, useHoisting = true) {
		const references_ = IsString2(schema.$id) ? [...references, schema] : references;
		const schema_ = schema;
		if (useHoisting && IsString2(schema.$id)) {
			const functionName = CreateFunctionName(schema.$id);
			if (state.functions.has(functionName)) {
				return yield `${functionName}(${value})`;
			} else {
				state.functions.set(functionName, "<deferred>");
				const functionCode = CreateFunction(functionName, schema, references, "value", false);
				state.functions.set(functionName, functionCode);
				return yield `${functionName}(${value})`;
			}
		}
		switch (schema_[Kind]) {
			case "Any":
				return yield* FromAny5(schema_, references_, value);
			case "Argument":
				return yield* FromArgument5(schema_, references_, value);
			case "Array":
				return yield* FromArray18(schema_, references_, value);
			case "AsyncIterator":
				return yield* FromAsyncIterator8(schema_, references_, value);
			case "BigInt":
				return yield* FromBigInt6(schema_, references_, value);
			case "Boolean":
				return yield* FromBoolean6(schema_, references_, value);
			case "Constructor":
				return yield* FromConstructor9(schema_, references_, value);
			case "Date":
				return yield* FromDate8(schema_, references_, value);
			case "Function":
				return yield* FromFunction8(schema_, references_, value);
			case "Import":
				return yield* FromImport11(schema_, references_, value);
			case "Integer":
				return yield* FromInteger6(schema_, references_, value);
			case "Intersect":
				return yield* FromIntersect19(schema_, references_, value);
			case "Iterator":
				return yield* FromIterator8(schema_, references_, value);
			case "Literal":
				return yield* FromLiteral7(schema_, references_, value);
			case "Never":
				return yield* FromNever6(schema_, references_, value);
			case "Not":
				return yield* FromNot8(schema_, references_, value);
			case "Null":
				return yield* FromNull6(schema_, references_, value);
			case "Number":
				return yield* FromNumber6(schema_, references_, value);
			case "Object":
				return yield* FromObject19(schema_, references_, value);
			case "Promise":
				return yield* FromPromise8(schema_, references_, value);
			case "Record":
				return yield* FromRecord14(schema_, references_, value);
			case "Ref":
				return yield* FromRef15(schema_, references_, value);
			case "RegExp":
				return yield* FromRegExp5(schema_, references_, value);
			case "String":
				return yield* FromString6(schema_, references_, value);
			case "Symbol":
				return yield* FromSymbol6(schema_, references_, value);
			case "TemplateLiteral":
				return yield* FromTemplateLiteral7(schema_, references_, value);
			case "This":
				return yield* FromThis11(schema_, references_, value);
			case "Tuple":
				return yield* FromTuple16(schema_, references_, value);
			case "Undefined":
				return yield* FromUndefined6(schema_, references_, value);
			case "Union":
				return yield* FromUnion21(schema_, references_, value);
			case "Uint8Array":
				return yield* FromUint8Array5(schema_, references_, value);
			case "Unknown":
				return yield* FromUnknown5(schema_, references_, value);
			case "Void":
				return yield* FromVoid5(schema_, references_, value);
			default:
				if (!exports_type2.Has(schema_[Kind])) throw new TypeCompilerUnknownTypeError(schema);
				return yield* FromKind4(schema_, references_, value);
		}
	}
	const state = {
		language: "javascript",
		functions: new Map(),
		variables: new Map(),
		instances: new Map(),
	};
	function CreateExpression(schema, references, value, useHoisting = true) {
		return `(${[...Visit17(schema, references, value, useHoisting)].join(" && ")})`;
	}
	function CreateFunctionName($id) {
		return `check_${Identifier.Encode($id)}`;
	}
	function CreateVariable(expression) {
		const variableName = `local_${state.variables.size}`;
		state.variables.set(variableName, `const ${variableName} = ${expression}`);
		return variableName;
	}
	function CreateFunction(name, schema, references, value, useHoisting = true) {
		const [newline, pad] = [
			`
`,
			(length) => "".padStart(length, " "),
		];
		const parameter = CreateParameter("value", "any");
		const returns = CreateReturns("boolean");
		const expression = [...Visit17(schema, references, value, useHoisting)]
			.map((expression2) => `${pad(4)}${expression2}`)
			.join(` &&${newline}`);
		return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})
}`;
	}
	function CreateParameter(name, type) {
		const annotation = state.language === "typescript" ? `: ${type}` : "";
		return `${name}${annotation}`;
	}
	function CreateReturns(type) {
		return state.language === "typescript" ? `: ${type}` : "";
	}
	function Build(schema, references, options) {
		const functionCode = CreateFunction("check", schema, references, "value");
		const parameter = CreateParameter("value", "any");
		const returns = CreateReturns("boolean");
		const functions = [...state.functions.values()];
		const variables = [...state.variables.values()];
		const checkFunction = IsString2(schema.$id)
			? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema.$id)}(value)
}`
			: `return ${functionCode}`;
		return [...variables, ...functions, checkFunction].join(`
`);
	}
	function Code(...args) {
		const defaults = { language: "javascript" };
		const [schema, references, options] =
			args.length === 2 && IsArray2(args[1])
				? [args[0], args[1], defaults]
				: args.length === 2 && !IsArray2(args[1])
					? [args[0], [], args[1]]
					: args.length === 3
						? [args[0], args[1], args[2]]
						: args.length === 1
							? [args[0], [], defaults]
							: [null, [], defaults];
		state.language = options.language;
		state.variables.clear();
		state.functions.clear();
		state.instances.clear();
		if (!IsSchema2(schema)) throw new TypeCompilerTypeGuardError(schema);
		for (const schema2 of references)
			if (!IsSchema2(schema2)) throw new TypeCompilerTypeGuardError(schema2);
		return Build(schema, references, options);
	}
	TypeCompiler2.Code = Code;
	function Compile(schema, references = []) {
		const generatedCode = Code(schema, references, { language: "javascript" });
		const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
		const instances = new Map(state.instances);
		function typeRegistryFunction(kind, instance, value) {
			if (!exports_type2.Has(kind) || !instances.has(instance)) return false;
			const checkFunc = exports_type2.Get(kind);
			const schema2 = instances.get(instance);
			return checkFunc(schema2, value);
		}
		function formatRegistryFunction(format, value) {
			if (!exports_format.Has(format)) return false;
			const checkFunc = exports_format.Get(format);
			return checkFunc(value);
		}
		function hashFunction(value) {
			return Hash(value);
		}
		const checkFunction = compiledFunction(
			typeRegistryFunction,
			formatRegistryFunction,
			hashFunction,
		);
		return new TypeCheck(schema, references, checkFunction, generatedCode);
	}
	TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));

// node_modules/elysia/dist/bun/index.js
var __create2 = Object.create;
var {
	getPrototypeOf: __getProtoOf2,
	defineProperty: __defProp2,
	getOwnPropertyNames: __getOwnPropNames2,
} = Object;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __toESM2 = (mod, isNodeMode, target) => {
	target = mod != null ? __create2(__getProtoOf2(mod)) : {};
	let to =
		isNodeMode || !mod || !mod.__esModule
			? __defProp2(target, "default", { value: mod, enumerable: true })
			: target;
	for (let key of __getOwnPropNames2(mod))
		if (!__hasOwnProp2.call(to, key))
			__defProp2(to, key, { get: () => mod[key], enumerable: true });
	return to;
};
var __commonJS2 = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var require_fast_decode_uri_component = __commonJS2((exports, module) => {
	var UTF8_ACCEPT = 12,
		UTF8_REJECT = 0,
		UTF8_DATA = [
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
			2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
			3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
			5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4,
			4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60,
			72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24,
			24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127,
			63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7,
		];
	function decodeURIComponent2(uri) {
		var percentPosition = uri.indexOf("%");
		if (percentPosition === -1) return uri;
		var length = uri.length,
			decoded = "",
			last = 0,
			codepoint = 0,
			startOfOctets = percentPosition,
			state = UTF8_ACCEPT;
		while (percentPosition > -1 && percentPosition < length) {
			var high = hexCodeToInt(uri[percentPosition + 1], 4),
				low = hexCodeToInt(uri[percentPosition + 2], 0),
				byte = high | low,
				type = UTF8_DATA[byte];
			if (
				((state = UTF8_DATA[256 + state + type]),
				(codepoint = (codepoint << 6) | (byte & UTF8_DATA[364 + type])),
				state === UTF8_ACCEPT)
			)
				((decoded += uri.slice(last, startOfOctets)),
					(decoded +=
						codepoint <= 65535
							? String.fromCharCode(codepoint)
							: String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023))),
					(codepoint = 0),
					(last = percentPosition + 3),
					(percentPosition = startOfOctets = uri.indexOf("%", last)));
			else if (state === UTF8_REJECT) return null;
			else {
				if (
					((percentPosition += 3),
					percentPosition < length && uri.charCodeAt(percentPosition) === 37)
				)
					continue;
				return null;
			}
		}
		return decoded + uri.slice(last);
	}
	var HEX = {
		0: 0,
		1: 1,
		2: 2,
		3: 3,
		4: 4,
		5: 5,
		6: 6,
		7: 7,
		8: 8,
		9: 9,
		a: 10,
		A: 10,
		b: 11,
		B: 11,
		c: 12,
		C: 12,
		d: 13,
		D: 13,
		e: 14,
		E: 14,
		f: 15,
		F: 15,
	};
	function hexCodeToInt(c, shift) {
		var i = HEX[c];
		return i === undefined ? 255 : i << shift;
	}
	module.exports = decodeURIComponent2;
});
var require_dist = __commonJS2((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.parse = parse2;
	exports.serialize = serialize;
	var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/,
		cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/,
		domainValueRegExp =
			/^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i,
		pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/,
		__toString = Object.prototype.toString,
		NullObject = (() => {
			let C = function () {};
			return ((C.prototype = Object.create(null)), C);
		})();
	function parse2(str, options) {
		let obj = new NullObject(),
			len = str.length;
		if (len < 2) return obj;
		let dec = options?.decode || decode2,
			index = 0;
		do {
			let eqIdx = str.indexOf("=", index);
			if (eqIdx === -1) break;
			let colonIdx = str.indexOf(";", index),
				endIdx = colonIdx === -1 ? len : colonIdx;
			if (eqIdx > endIdx) {
				index = str.lastIndexOf(";", eqIdx - 1) + 1;
				continue;
			}
			let keyStartIdx = startIndex(str, index, eqIdx),
				keyEndIdx = endIndex(str, eqIdx, keyStartIdx),
				key = str.slice(keyStartIdx, keyEndIdx);
			if (obj[key] === undefined) {
				let valStartIdx = startIndex(str, eqIdx + 1, endIdx),
					valEndIdx = endIndex(str, endIdx, valStartIdx),
					value = dec(str.slice(valStartIdx, valEndIdx));
				obj[key] = value;
			}
			index = endIdx + 1;
		} while (index < len);
		return obj;
	}
	function startIndex(str, index, max) {
		do {
			let code = str.charCodeAt(index);
			if (code !== 32 && code !== 9) return index;
		} while (++index < max);
		return max;
	}
	function endIndex(str, index, min) {
		while (index > min) {
			let code = str.charCodeAt(--index);
			if (code !== 32 && code !== 9) return index + 1;
		}
		return min;
	}
	function serialize(name, val, options) {
		let enc = options?.encode || encodeURIComponent;
		if (!cookieNameRegExp.test(name)) throw TypeError(`argument name is invalid: ${name}`);
		let value = enc(val);
		if (!cookieValueRegExp.test(value)) throw TypeError(`argument val is invalid: ${val}`);
		let str = name + "=" + value;
		if (!options) return str;
		if (options.maxAge !== undefined) {
			if (!Number.isInteger(options.maxAge))
				throw TypeError(`option maxAge is invalid: ${options.maxAge}`);
			str += "; Max-Age=" + options.maxAge;
		}
		if (options.domain) {
			if (!domainValueRegExp.test(options.domain))
				throw TypeError(`option domain is invalid: ${options.domain}`);
			str += "; Domain=" + options.domain;
		}
		if (options.path) {
			if (!pathValueRegExp.test(options.path))
				throw TypeError(`option path is invalid: ${options.path}`);
			str += "; Path=" + options.path;
		}
		if (options.expires) {
			if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf()))
				throw TypeError(`option expires is invalid: ${options.expires}`);
			str += "; Expires=" + options.expires.toUTCString();
		}
		if (options.httpOnly) str += "; HttpOnly";
		if (options.secure) str += "; Secure";
		if (options.partitioned) str += "; Partitioned";
		if (options.priority)
			switch (typeof options.priority === "string" ? options.priority.toLowerCase() : undefined) {
				case "low":
					str += "; Priority=Low";
					break;
				case "medium":
					str += "; Priority=Medium";
					break;
				case "high":
					str += "; Priority=High";
					break;
				default:
					throw TypeError(`option priority is invalid: ${options.priority}`);
			}
		if (options.sameSite)
			switch (
				typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite
			) {
				case true:
				case "strict":
					str += "; SameSite=Strict";
					break;
				case "lax":
					str += "; SameSite=Lax";
					break;
				case "none":
					str += "; SameSite=None";
					break;
				default:
					throw TypeError(`option sameSite is invalid: ${options.sameSite}`);
			}
		return str;
	}
	function decode2(str) {
		if (str.indexOf("%") === -1) return str;
		try {
			return decodeURIComponent(str);
		} catch (e) {
			return str;
		}
	}
	function isDate(val) {
		return __toString.call(val) === "[object Date]";
	}
});
var Y = (v, b) => {
	let A = b?.length ? {} : null;
	if (A) for (let Q of b) A[Q.part.charCodeAt(0)] = Q;
	return { part: v, store: null, inert: A, params: null, wildcardStore: null };
};
var k = (v, b) => ({ ...v, part: b });
var T = (v) => ({ name: v, store: null, inert: null });

class _ {
	config;
	root = {};
	history = [];
	deferred = [];
	constructor(v = {}) {
		if (((this.config = v), v.lazy)) this.find = this.lazyFind;
		if (v.onParam && !Array.isArray(v.onParam)) this.config.onParam = [this.config.onParam];
	}
	static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g, optionalParams: /(\/:\w+\?)/g };
	lazyFind = (v, b) => {
		if (!this.config.lazy) return this.find;
		return (this.build(), this.find(v, b));
	};
	build() {
		if (!this.config.lazy) return;
		for (let [v, b, A] of this.deferred) this.add(v, b, A, { lazy: false, ignoreHistory: true });
		((this.deferred = []),
			(this.find = (v, b) => {
				let A = this.root[v];
				if (!A) return null;
				return $(b, b.length, A, 0, this.config.onParam);
			}));
	}
	add(
		v,
		b,
		A,
		{ ignoreError: Q = false, ignoreHistory: O = false, lazy: V = this.config.lazy } = {},
	) {
		if (V) return ((this.find = this.lazyFind), this.deferred.push([v, b, A]), A);
		if (typeof b !== "string") throw TypeError("Route path must be a string");
		if (b === "") b = "/";
		else if (b[0] !== "/") b = `/${b}`;
		let X = b[b.length - 1] === "*",
			J = b.match(_.regex.optionalParams);
		if (J) {
			let F = b.replaceAll("?", "");
			this.add(v, F, A, { ignoreError: Q, ignoreHistory: O, lazy: V });
			for (let B = 0; B < J.length; B++) {
				let D = b.replace(J[B], "");
				this.add(v, D, A, { ignoreError: true, ignoreHistory: O, lazy: V });
			}
			return A;
		}
		if (J) b = b.replaceAll("?", "");
		if (this.history.find(([F, B, D]) => F === v && B === b)) return A;
		if (X || (J && b.charCodeAt(b.length - 1) === 63)) b = b.slice(0, -1);
		if (!O) this.history.push([v, b, A]);
		let K = b.split(_.regex.static),
			G = b.match(_.regex.params) || [];
		if (K[K.length - 1] === "") K.pop();
		let q;
		if (!this.root[v]) q = this.root[v] = Y("/");
		else q = this.root[v];
		let U = 0;
		for (let F = 0; F < K.length; ++F) {
			let B = K[F];
			if (F > 0) {
				let D = G[U++].slice(1);
				if (q.params === null) q.params = T(D);
				else if (q.params.name !== D)
					if (Q) return A;
					else
						throw Error(
							`Cannot create route "${b}" with parameter "${D}" because a route already exists with a different parameter name ("${q.params.name}") in the same location`,
						);
				let S = q.params;
				if (S.inert === null) {
					q = S.inert = Y(B);
					continue;
				}
				q = S.inert;
			}
			for (let D = 0; ; ) {
				if (D === B.length) {
					if (D < q.part.length) {
						let S = k(q, q.part.slice(D));
						Object.assign(q, Y(B, [S]));
					}
					break;
				}
				if (D === q.part.length) {
					if (q.inert === null) q.inert = {};
					let S = q.inert[B.charCodeAt(D)];
					if (S) {
						((q = S), (B = B.slice(D)), (D = 0));
						continue;
					}
					let Z = Y(B.slice(D));
					((q.inert[B.charCodeAt(D)] = Z), (q = Z));
					break;
				}
				if (B[D] !== q.part[D]) {
					let S = k(q, q.part.slice(D)),
						Z = Y(B.slice(D));
					(Object.assign(q, Y(q.part.slice(0, D), [S, Z])), (q = Z));
					break;
				}
				++D;
			}
		}
		if (U < G.length) {
			let B = G[U].slice(1);
			if (q.params === null) q.params = T(B);
			else if (q.params.name !== B)
				if (Q) return A;
				else
					throw Error(
						`Cannot create route "${b}" with parameter "${B}" because a route already exists with a different parameter name ("${q.params.name}") in the same location`,
					);
			if (q.params.store === null) q.params.store = A;
			return q.params.store;
		}
		if (X) {
			if (q.wildcardStore === null) q.wildcardStore = A;
			return q.wildcardStore;
		}
		if (q.store === null) q.store = A;
		return q.store;
	}
	find(v, b) {
		let A = this.root[v];
		if (!A) return null;
		return $(b, b.length, A, 0, this.config.onParam);
	}
}
var $ = (v, b, A, Q, O) => {
	let V = A.part,
		X = V.length,
		J = Q + X;
	if (X > 1) {
		if (J > b) return null;
		if (X < 15) {
			for (let K = 1, G = Q + 1; K < X; ++K, ++G)
				if (V.charCodeAt(K) !== v.charCodeAt(G)) return null;
		} else if (v.slice(Q, J) !== V) return null;
	}
	if (J === b) {
		if (A.store !== null) return { store: A.store, params: {} };
		if (A.wildcardStore !== null) return { store: A.wildcardStore, params: { "*": "" } };
		return null;
	}
	if (A.inert !== null) {
		let K = A.inert[v.charCodeAt(J)];
		if (K !== undefined) {
			let G = $(v, b, K, J, O);
			if (G !== null) return G;
		}
	}
	if (A.params !== null) {
		let { store: K, name: G, inert: q } = A.params,
			U = v.indexOf("/", J);
		if (U !== J) {
			if (U === -1 || U >= b) {
				if (K !== null) {
					let F = {};
					if (((F[G] = v.substring(J, b)), O))
						for (let B = 0; B < O.length; B++) {
							let D = O[B](F[G], G);
							if (D !== undefined) F[G] = D;
						}
					return { store: K, params: F };
				}
			} else if (q !== null) {
				let F = $(v, b, q, U, O);
				if (F !== null) {
					if (((F.params[G] = v.substring(J, U)), O))
						for (let B = 0; B < O.length; B++) {
							let D = O[B](F.params[G], G);
							if (D !== undefined) F.params[G] = D;
						}
					return F;
				}
			}
		}
	}
	if (A.wildcardStore !== null)
		return { store: A.wildcardStore, params: { "*": v.substring(J, b) } };
	return null;
};
var import_fast_decode_uri_component4 = __toESM2(require_fast_decode_uri_component(), 1);
var isBun = typeof Bun < "u";
var mime = {
	aac: "audio/aac",
	abw: "application/x-abiword",
	ai: "application/postscript",
	arc: "application/octet-stream",
	avi: "video/x-msvideo",
	azw: "application/vnd.amazon.ebook",
	bin: "application/octet-stream",
	bz: "application/x-bzip",
	bz2: "application/x-bzip2",
	csh: "application/x-csh",
	css: "text/css",
	csv: "text/csv",
	doc: "application/msword",
	dll: "application/octet-stream",
	eot: "application/vnd.ms-fontobject",
	epub: "application/epub+zip",
	gif: "image/gif",
	htm: "text/html",
	html: "text/html",
	ico: "image/x-icon",
	ics: "text/calendar",
	jar: "application/java-archive",
	jpeg: "image/jpeg",
	jpg: "image/jpeg",
	js: "application/javascript",
	json: "application/json",
	mid: "audio/midi",
	midi: "audio/midi",
	mp2: "audio/mpeg",
	mp3: "audio/mpeg",
	mp4: "video/mp4",
	mpa: "video/mpeg",
	mpe: "video/mpeg",
	mpeg: "video/mpeg",
	mpkg: "application/vnd.apple.installer+xml",
	odp: "application/vnd.oasis.opendocument.presentation",
	ods: "application/vnd.oasis.opendocument.spreadsheet",
	odt: "application/vnd.oasis.opendocument.text",
	oga: "audio/ogg",
	ogv: "video/ogg",
	ogx: "application/ogg",
	otf: "font/otf",
	png: "image/png",
	pdf: "application/pdf",
	ppt: "application/vnd.ms-powerpoint",
	rar: "application/x-rar-compressed",
	rtf: "application/rtf",
	sh: "application/x-sh",
	svg: "image/svg+xml",
	swf: "application/x-shockwave-flash",
	tar: "application/x-tar",
	tif: "image/tiff",
	tiff: "image/tiff",
	ts: "application/typescript",
	ttf: "font/ttf",
	txt: "text/plain",
	vsd: "application/vnd.visio",
	wav: "audio/x-wav",
	weba: "audio/webm",
	webm: "video/webm",
	webp: "image/webp",
	woff: "font/woff",
	woff2: "font/woff2",
	xhtml: "application/xhtml+xml",
	xls: "application/vnd.ms-excel",
	xlsx: "application/vnd.ms-excel",
	xlsx_OLD: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
	xml: "application/xml",
	xul: "application/vnd.mozilla.xul+xml",
	zip: "application/zip",
	"3gp": "video/3gpp",
	"3gp_DOES_NOT_CONTAIN_VIDEO": "audio/3gpp",
	"3gp2": "video/3gpp2",
	"3gp2_DOES_NOT_CONTAIN_VIDEO": "audio/3gpp2",
	"7z": "application/x-7z-compressed",
};
var getFileExtension = (path) => {
	let index = path.lastIndexOf(".");
	if (index === -1) return "";
	return path.slice(index + 1);
};
var createReadStream;
var stat;

class ElysiaFile {
	path;
	value;
	stats;
	constructor(path) {
		this.path = path;
		if (isBun) this.value = Bun.file(path);
		else {
			if (!createReadStream || !stat) {
				if (typeof window < "u") {
					console.warn("Browser environment does not support file");
					return;
				}
				let warnMissing = (name) =>
					console.warn(
						Error(
							`[elysia] \`file\` require \`fs${name ? "." + name : ""}\` ${name?.includes(".") ? "module " : ""}which is not available in this environment`,
						),
					);
				if (typeof process > "u" || typeof process.getBuiltinModule !== "function") {
					warnMissing();
					return;
				}
				let fs = process.getBuiltinModule("fs");
				if (!fs) {
					warnMissing();
					return;
				}
				if (typeof fs.createReadStream !== "function") {
					warnMissing();
					return;
				}
				if (typeof fs.promises?.stat !== "function") {
					warnMissing();
					return;
				}
				((createReadStream = fs.createReadStream), (stat = fs.promises.stat));
			}
			((this.value = (() => createReadStream(path))()), (this.stats = stat(path)));
		}
	}
	get type() {
		return mime[getFileExtension(this.path)] || "application/octet-stream";
	}
	get length() {
		if (isBun) return this.value.size;
		return this.stats?.then((x) => x.size) ?? 0;
	}
}
var hasHeaderShorthand = "toJSON" in new Headers();
var replaceUrlPath = (url, pathname) => {
	let urlObject = new URL(url);
	return ((urlObject.pathname = pathname), urlObject.toString());
};
var isClass = (v) =>
	(typeof v === "function" && /^\s*class\s+/.test(v.toString())) ||
	(v.toString && v.toString().startsWith("[object ") && v.toString() !== "[object Object]") ||
	isNotEmpty(Object.getPrototypeOf(v));
var isObject = (item) => item && typeof item === "object" && !Array.isArray(item);
var mergeDeep = (target, source, options) => {
	let skipKeys = options?.skipKeys,
		override = options?.override ?? true,
		mergeArray = options?.mergeArray ?? false;
	if (!isObject(target) || !isObject(source)) return target;
	for (let [key, value] of Object.entries(source)) {
		if (skipKeys?.includes(key)) continue;
		if (mergeArray && Array.isArray(value)) {
			target[key] = Array.isArray(target[key]) ? [...target[key], ...value] : (target[key] = value);
			continue;
		}
		if (!isObject(value) || !(key in target) || isClass(value)) {
			if ((override || !(key in target)) && !Object.isFrozen(target))
				try {
					target[key] = value;
				} catch {}
			continue;
		}
		if (!Object.isFrozen(target[key]))
			try {
				target[key] = mergeDeep(target[key], value, { skipKeys, override, mergeArray });
			} catch {}
	}
	return target;
};
var mergeCookie = (a, b) => {
	let v = mergeDeep(Object.assign({}, a), b, { skipKeys: ["properties"], mergeArray: false });
	if (v.properties) delete v.properties;
	return v;
};
var mergeObjectArray = (a, b) => {
	if (!b) return a;
	let array = [],
		checksums = [];
	if (a) {
		if (!Array.isArray(a)) a = [a];
		for (let item of a) if ((array.push(item), item.checksum)) checksums.push(item.checksum);
	}
	if (b) {
		if (!Array.isArray(b)) b = [b];
		for (let item of b) if (!checksums.includes(item.checksum)) array.push(item);
	}
	return array;
};
var primitiveHooks = [
	"start",
	"request",
	"parse",
	"transform",
	"resolve",
	"beforeHandle",
	"afterHandle",
	"mapResponse",
	"afterResponse",
	"trace",
	"error",
	"stop",
	"body",
	"headers",
	"params",
	"query",
	"response",
	"type",
	"detail",
];
var primitiveHookMap = primitiveHooks.reduce((acc, x) => ((acc[x] = true), acc), {});
var isRecordNumber = (x) => typeof x === "object" && Object.keys(x).every((x2) => !isNaN(+x2));
var mergeResponse = (a, b) => {
	if (isRecordNumber(a) && isRecordNumber(b)) return Object.assign({}, a, b);
	else if (a && !isRecordNumber(a) && isRecordNumber(b)) return Object.assign({ 200: a }, b);
	return b ?? a;
};
var mergeSchemaValidator = (a, b) => {
	if (!a && !b)
		return {
			body: undefined,
			headers: undefined,
			params: undefined,
			query: undefined,
			cookie: undefined,
			response: undefined,
		};
	return {
		body: b?.body ?? a?.body,
		headers: b?.headers ?? a?.headers,
		params: b?.params ?? a?.params,
		query: b?.query ?? a?.query,
		cookie: b?.cookie ?? a?.cookie,
		response: mergeResponse(a?.response, b?.response),
	};
};
var mergeHook = (a, b) => {
	if (!b) return a ?? {};
	if (!a) return b ?? {};
	if (!Object.values(b).find((x) => x !== undefined && x !== null)) return { ...a };
	let hook = {
		...a,
		...b,
		body: b.body ?? a.body,
		headers: b.headers ?? a.headers,
		params: b.params ?? a.params,
		query: b.query ?? a.query,
		cookie: b.cookie ?? a.cookie,
		response: mergeResponse(a.response, b.response),
		type: a.type || b.type,
		detail: mergeDeep(b.detail ?? {}, a.detail ?? {}),
		parse: mergeObjectArray(a.parse, b.parse),
		transform: mergeObjectArray(a.transform, b.transform),
		beforeHandle: mergeObjectArray(
			mergeObjectArray(fnToContainer(a.resolve, "resolve"), a.beforeHandle),
			mergeObjectArray(fnToContainer(b.resolve, "resolve"), b.beforeHandle),
		),
		afterHandle: mergeObjectArray(a.afterHandle, b.afterHandle),
		mapResponse: mergeObjectArray(a.mapResponse, b.mapResponse),
		afterResponse: mergeObjectArray(a.afterResponse, b.afterResponse),
		trace: mergeObjectArray(a.trace, b.trace),
		error: mergeObjectArray(a.error, b.error),
		standaloneSchema:
			a.standaloneSchema || b.standaloneSchema
				? a.standaloneSchema && !b.standaloneSchema
					? a.standaloneSchema
					: b.standaloneSchema && !a.standaloneSchema
						? b.standaloneSchema
						: [...(a.standaloneSchema ?? []), ...(b.standaloneSchema ?? [])]
				: undefined,
	};
	if (hook.resolve) delete hook.resolve;
	return hook;
};
var lifeCycleToArray = (a) => {
	if (a.parse && !Array.isArray(a.parse)) a.parse = [a.parse];
	if (a.transform && !Array.isArray(a.transform)) a.transform = [a.transform];
	if (a.afterHandle && !Array.isArray(a.afterHandle)) a.afterHandle = [a.afterHandle];
	if (a.mapResponse && !Array.isArray(a.mapResponse)) a.mapResponse = [a.mapResponse];
	if (a.afterResponse && !Array.isArray(a.afterResponse)) a.afterResponse = [a.afterResponse];
	if (a.trace && !Array.isArray(a.trace)) a.trace = [a.trace];
	if (a.error && !Array.isArray(a.error)) a.error = [a.error];
	let beforeHandle = [];
	if (a.resolve)
		((beforeHandle = fnToContainer(Array.isArray(a.resolve) ? a.resolve : [a.resolve], "resolve")),
			delete a.resolve);
	if (a.beforeHandle)
		if (beforeHandle.length)
			beforeHandle = beforeHandle.concat(
				Array.isArray(a.beforeHandle) ? a.beforeHandle : [a.beforeHandle],
			);
		else beforeHandle = Array.isArray(a.beforeHandle) ? a.beforeHandle : [a.beforeHandle];
	if (beforeHandle.length) a.beforeHandle = beforeHandle;
	return a;
};
var isBun2 = typeof Bun < "u";
var hasBunHash = isBun2 && typeof Bun.hash === "function";
var checksum = (s) => {
	let h = 9;
	for (let i = 0; i < s.length; ) h = Math.imul(h ^ s.charCodeAt(i++), 387420489);
	return (h = h ^ (h >>> 9));
};
var injectChecksum = (checksum2, x) => {
	if (!x) return;
	if (!Array.isArray(x)) {
		let fn = x;
		if (checksum2 && !fn.checksum) fn.checksum = checksum2;
		if (fn.scope === "scoped") fn.scope = "local";
		return fn;
	}
	let fns = [...x];
	for (let fn of fns) {
		if (checksum2 && !fn.checksum) fn.checksum = checksum2;
		if (fn.scope === "scoped") fn.scope = "local";
	}
	return fns;
};
var mergeLifeCycle = (a, b, checksum2) => {
	return {
		start: mergeObjectArray(a.start, injectChecksum(checksum2, b?.start)),
		request: mergeObjectArray(a.request, injectChecksum(checksum2, b?.request)),
		parse: mergeObjectArray(a.parse, injectChecksum(checksum2, b?.parse)),
		transform: mergeObjectArray(a.transform, injectChecksum(checksum2, b?.transform)),
		beforeHandle: mergeObjectArray(
			mergeObjectArray(fnToContainer(a.resolve, "resolve"), a.beforeHandle),
			injectChecksum(
				checksum2,
				mergeObjectArray(fnToContainer(b?.resolve, "resolve"), b?.beforeHandle),
			),
		),
		afterHandle: mergeObjectArray(a.afterHandle, injectChecksum(checksum2, b?.afterHandle)),
		mapResponse: mergeObjectArray(a.mapResponse, injectChecksum(checksum2, b?.mapResponse)),
		afterResponse: mergeObjectArray(a.afterResponse, injectChecksum(checksum2, b?.afterResponse)),
		trace: mergeObjectArray(a.trace, injectChecksum(checksum2, b?.trace)),
		error: mergeObjectArray(a.error, injectChecksum(checksum2, b?.error)),
		stop: mergeObjectArray(a.stop, injectChecksum(checksum2, b?.stop)),
	};
};
var asHookType = (fn, inject, { skipIfHasType = false }) => {
	if (!fn) return fn;
	if (!Array.isArray(fn)) {
		if (skipIfHasType) fn.scope ??= inject;
		else fn.scope = inject;
		return fn;
	}
	for (let x of fn)
		if (skipIfHasType) x.scope ??= inject;
		else x.scope = inject;
	return fn;
};
var filterGlobal = (fn) => {
	if (!fn) return fn;
	if (!Array.isArray(fn))
		switch (fn.scope) {
			case "global":
			case "scoped":
				return { ...fn };
			default:
				return { fn };
		}
	let array = [];
	for (let x of fn)
		switch (x.scope) {
			case "global":
			case "scoped":
				array.push({ ...x });
				break;
		}
	return array;
};
var filterGlobalHook = (hook) => {
	return {
		...hook,
		type: hook?.type,
		detail: hook?.detail,
		parse: filterGlobal(hook?.parse),
		transform: filterGlobal(hook?.transform),
		beforeHandle: filterGlobal(hook?.beforeHandle),
		afterHandle: filterGlobal(hook?.afterHandle),
		mapResponse: filterGlobal(hook?.mapResponse),
		afterResponse: filterGlobal(hook?.afterResponse),
		error: filterGlobal(hook?.error),
		trace: filterGlobal(hook?.trace),
	};
};
var StatusMap = {
	Continue: 100,
	"Switching Protocols": 101,
	Processing: 102,
	"Early Hints": 103,
	OK: 200,
	Created: 201,
	Accepted: 202,
	"Non-Authoritative Information": 203,
	"No Content": 204,
	"Reset Content": 205,
	"Partial Content": 206,
	"Multi-Status": 207,
	"Already Reported": 208,
	"Multiple Choices": 300,
	"Moved Permanently": 301,
	Found: 302,
	"See Other": 303,
	"Not Modified": 304,
	"Temporary Redirect": 307,
	"Permanent Redirect": 308,
	"Bad Request": 400,
	Unauthorized: 401,
	"Payment Required": 402,
	Forbidden: 403,
	"Not Found": 404,
	"Method Not Allowed": 405,
	"Not Acceptable": 406,
	"Proxy Authentication Required": 407,
	"Request Timeout": 408,
	Conflict: 409,
	Gone: 410,
	"Length Required": 411,
	"Precondition Failed": 412,
	"Payload Too Large": 413,
	"URI Too Long": 414,
	"Unsupported Media Type": 415,
	"Range Not Satisfiable": 416,
	"Expectation Failed": 417,
	"I'm a teapot": 418,
	"Enhance Your Calm": 420,
	"Misdirected Request": 421,
	"Unprocessable Content": 422,
	Locked: 423,
	"Failed Dependency": 424,
	"Too Early": 425,
	"Upgrade Required": 426,
	"Precondition Required": 428,
	"Too Many Requests": 429,
	"Request Header Fields Too Large": 431,
	"Unavailable For Legal Reasons": 451,
	"Internal Server Error": 500,
	"Not Implemented": 501,
	"Bad Gateway": 502,
	"Service Unavailable": 503,
	"Gateway Timeout": 504,
	"HTTP Version Not Supported": 505,
	"Variant Also Negotiates": 506,
	"Insufficient Storage": 507,
	"Loop Detected": 508,
	"Not Extended": 510,
	"Network Authentication Required": 511,
};
var InvertedStatusMap = Object.fromEntries(Object.entries(StatusMap).map(([k2, v]) => [v, k2]));
function removeTrailingEquals(digest) {
	let trimmedDigest = digest;
	while (trimmedDigest.endsWith("=")) trimmedDigest = trimmedDigest.slice(0, -1);
	return trimmedDigest;
}
var encoder = new TextEncoder();
var signCookie = async (val, secret) => {
	if (typeof val === "object") val = JSON.stringify(val);
	else if (typeof val !== "string") val = val + "";
	if (secret === null) throw TypeError("Secret key must be provided.");
	let secretKey = await crypto.subtle.importKey(
			"raw",
			encoder.encode(secret),
			{ name: "HMAC", hash: "SHA-256" },
			false,
			["sign"],
		),
		hmacBuffer = await crypto.subtle.sign("HMAC", secretKey, encoder.encode(val));
	return val + "." + removeTrailingEquals(Buffer.from(hmacBuffer).toString("base64"));
};
var unsignCookie = async (input, secret) => {
	if (typeof input !== "string") throw TypeError("Signed cookie string must be provided.");
	if (secret === null) throw TypeError("Secret key must be provided.");
	let tentativeValue = input.slice(0, input.lastIndexOf("."));
	return (await signCookie(tentativeValue, secret)) === input ? tentativeValue : false;
};
var insertStandaloneValidator = (hook, name, value) => {
	if (!hook.standaloneValidator?.length || !Array.isArray(hook.standaloneValidator)) {
		hook.standaloneValidator = [{ [name]: value }];
		return;
	}
	let last = hook.standaloneValidator[hook.standaloneValidator.length - 1];
	if (name in last) hook.standaloneValidator.push({ [name]: value });
	else last[name] = value;
};
var parseNumericString = (message) => {
	if (typeof message === "number") return message;
	if (message.length < 16) {
		if (message.trim().length === 0) return null;
		let length = Number(message);
		if (Number.isNaN(length)) return null;
		return length;
	}
	if (message.length === 16) {
		if (message.trim().length === 0) return null;
		let number = Number(message);
		if (Number.isNaN(number) || number.toString() !== message) return null;
		return number;
	}
	return null;
};
var isNumericString = (message) => parseNumericString(message) !== null;

class PromiseGroup {
	onError;
	onFinally;
	root = null;
	promises = [];
	constructor(onError = console.error, onFinally = () => {}) {
		this.onError = onError;
		this.onFinally = onFinally;
	}
	get size() {
		return this.promises.length;
	}
	add(promise) {
		if ((this.promises.push(promise), (this.root ||= this.drain()), this.promises.length === 1))
			this.then(this.onFinally);
		return promise;
	}
	async drain() {
		while (this.promises.length > 0) {
			try {
				await this.promises[0];
			} catch (error) {
				this.onError(error);
			}
			this.promises.shift();
		}
		this.root = null;
	}
	then(onfulfilled, onrejected) {
		return (this.root ?? Promise.resolve()).then(onfulfilled, onrejected);
	}
}
var fnToContainer = (fn, subType) => {
	if (!fn) return fn;
	if (!Array.isArray(fn)) {
		if (typeof fn === "function" || typeof fn === "string")
			return subType ? { fn, subType } : { fn };
		else if ("fn" in fn) return fn;
	}
	let fns = [];
	for (let x of fn)
		if (typeof x === "function" || typeof x === "string")
			fns.push(subType ? { fn: x, subType } : { fn: x });
		else if ("fn" in x) fns.push(x);
	return fns;
};
var localHookToLifeCycleStore = (a) => {
	if (a.start) a.start = fnToContainer(a.start);
	if (a.request) a.request = fnToContainer(a.request);
	if (a.parse) a.parse = fnToContainer(a.parse);
	if (a.transform) a.transform = fnToContainer(a.transform);
	if (a.beforeHandle) a.beforeHandle = fnToContainer(a.beforeHandle);
	if (a.afterHandle) a.afterHandle = fnToContainer(a.afterHandle);
	if (a.mapResponse) a.mapResponse = fnToContainer(a.mapResponse);
	if (a.afterResponse) a.afterResponse = fnToContainer(a.afterResponse);
	if (a.trace) a.trace = fnToContainer(a.trace);
	if (a.error) a.error = fnToContainer(a.error);
	if (a.stop) a.stop = fnToContainer(a.stop);
	return a;
};
var lifeCycleToFn = (a) => {
	let lifecycle = Object.create(null);
	if (a.start?.map) lifecycle.start = a.start.map((x) => x.fn);
	if (a.request?.map) lifecycle.request = a.request.map((x) => x.fn);
	if (a.parse?.map) lifecycle.parse = a.parse.map((x) => x.fn);
	if (a.transform?.map) lifecycle.transform = a.transform.map((x) => x.fn);
	if (a.beforeHandle?.map) lifecycle.beforeHandle = a.beforeHandle.map((x) => x.fn);
	if (a.afterHandle?.map) lifecycle.afterHandle = a.afterHandle.map((x) => x.fn);
	if (a.mapResponse?.map) lifecycle.mapResponse = a.mapResponse.map((x) => x.fn);
	if (a.afterResponse?.map) lifecycle.afterResponse = a.afterResponse.map((x) => x.fn);
	if (a.error?.map) lifecycle.error = a.error.map((x) => x.fn);
	if (a.stop?.map) lifecycle.stop = a.stop.map((x) => x.fn);
	if (a.trace?.map) lifecycle.trace = a.trace.map((x) => x.fn);
	else lifecycle.trace = [];
	return lifecycle;
};
var cloneInference = (inference) => ({
	body: inference.body,
	cookie: inference.cookie,
	headers: inference.headers,
	query: inference.query,
	set: inference.set,
	server: inference.server,
	path: inference.path,
	route: inference.route,
	url: inference.url,
});
var redirect = (url, status = 302) => Response.redirect(url, status);
var ELYSIA_FORM_DATA = Symbol("ElysiaFormData");
var ELYSIA_REQUEST_ID = Symbol("ElysiaRequestId");
var form = (items) => {
	let formData = new FormData();
	if (((formData[ELYSIA_FORM_DATA] = {}), items))
		for (let [key, value] of Object.entries(items)) {
			if (Array.isArray(value)) {
				formData[ELYSIA_FORM_DATA][key] = [];
				for (let v of value) {
					if (value instanceof File) formData.append(key, value, value.name);
					else if (value instanceof ElysiaFile)
						formData.append(key, value.value, value.value?.name);
					else formData.append(key, value);
					formData[ELYSIA_FORM_DATA][key].push(value);
				}
				continue;
			}
			if (value instanceof File) formData.append(key, value, value.name);
			else if (value instanceof ElysiaFile) formData.append(key, value.value, value.value?.name);
			else formData.append(key, value);
			formData[ELYSIA_FORM_DATA][key] = value;
		}
	return formData;
};
var randomId =
	typeof crypto > "u"
		? () => {
				let result = "",
					characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
					charactersLength = characters.length;
				for (let i = 0; i < 16; i++)
					result += characters.charAt(Math.floor(Math.random() * charactersLength));
				return result;
			}
		: () => {
				let uuid = crypto.randomUUID();
				return uuid.slice(0, 8) + uuid.slice(24, 32);
			};
var deduplicateChecksum = (array) => {
	if (!array.length) return [];
	let hashes = [];
	for (let i = 0; i < array.length; i++) {
		let item = array[i];
		if (item.checksum) {
			if (hashes.includes(item.checksum)) (array.splice(i, 1), i--);
			hashes.push(item.checksum);
		}
	}
	return array;
};
var promoteEvent = (events, as = "scoped") => {
	if (!events) return;
	if (as === "scoped") {
		for (let event of events)
			if ("scope" in event && event.scope === "local") event.scope = "scoped";
		return;
	}
	for (let event of events) if ("scope" in event) event.scope = "global";
};
var getLoosePath = (path) => {
	if (path.charCodeAt(path.length - 1) === 47) return path.slice(0, path.length - 1);
	return path + "/";
};
var isNotEmpty = (obj) => {
	if (!obj) return false;
	for (let _2 in obj) return true;
	return false;
};
var encodePath = (path, { dynamic = false } = {}) => {
	let encoded = encodeURIComponent(path).replace(/%2F/g, "/");
	if (dynamic) encoded = encoded.replace(/%3A/g, ":").replace(/%3F/g, "?");
	return encoded;
};
var supportPerMethodInlineHandler = (() => {
	if (typeof Bun > "u") return true;
	if (Bun.semver?.satisfies?.(Bun.version, ">=1.2.14")) return true;
	return false;
})();
async function getResponseLength(response) {
	if (response.bodyUsed || !response.body) return 0;
	let length = 0,
		reader = response.body.getReader();
	while (true) {
		let { done, value } = await reader.read();
		if (done) break;
		length += value.byteLength;
	}
	return length;
}
var emptySchema = {
	headers: true,
	cookie: true,
	query: true,
	params: true,
	body: true,
	response: true,
};
var env = typeof Bun < "u" ? Bun.env : typeof process < "u" ? process?.env : undefined;
var ERROR_CODE = Symbol("ElysiaErrorCode");
var isProduction = (env?.NODE_ENV ?? env?.ENV) === "production";
var emptyHttpStatus = {
	101: undefined,
	204: undefined,
	205: undefined,
	304: undefined,
	307: undefined,
	308: undefined,
};

class ElysiaCustomStatusResponse {
	code;
	response;
	constructor(code, response) {
		let res = response ?? (code in InvertedStatusMap ? InvertedStatusMap[code] : code);
		if (((this.code = StatusMap[code] ?? code), code in emptyHttpStatus)) this.response = undefined;
		else this.response = res;
	}
}
var status = (code, response) => new ElysiaCustomStatusResponse(code, response);
class NotFoundError extends Error {
	code = "NOT_FOUND";
	status = 404;
	constructor(message) {
		super(message ?? "NOT_FOUND");
	}
}

class ParseError2 extends Error {
	code = "PARSE";
	status = 400;
	constructor(cause) {
		super("Bad Request", { cause });
	}
}

class InvalidCookieSignature extends Error {
	key;
	code = "INVALID_COOKIE_SIGNATURE";
	status = 400;
	constructor(key, message) {
		super(message ?? `"${key}" has invalid cookie signature`);
		this.key = key;
	}
}
var mapValueError = (error) => {
	if (!error) return { summary: undefined };
	let { message, path, value, type } = error;
	if (Array.isArray(path)) path = path[0];
	let property = typeof path === "string" ? path.slice(1).replaceAll("/", ".") : "unknown",
		isRoot = path === "";
	switch (type) {
		case 42:
			return {
				...error,
				summary: isRoot
					? "Value should not be provided"
					: `Property '${property}' should not be provided`,
			};
		case 45:
			return {
				...error,
				summary: isRoot ? "Value is missing" : `Property '${property}' is missing`,
			};
		case 50:
			let quoteIndex = message.indexOf("'"),
				format = message.slice(quoteIndex + 1, message.indexOf("'", quoteIndex + 1));
			return {
				...error,
				summary: isRoot ? "Value should be an email" : `Property '${property}' should be ${format}`,
			};
		case 54:
			return {
				...error,
				summary: `${message.slice(0, 9).trim()} property '${property}' to be ${message.slice(8).trim()} but found: ${value}`,
			};
		case 62:
			let union = error.schema.anyOf.map((x) => `'${x?.format ?? x.type}'`).join(", ");
			return {
				...error,
				summary: isRoot
					? `Value should be one of ${union}`
					: `Property '${property}' should be one of: ${union}`,
			};
		default:
			return { summary: message, ...error };
	}
};

class InvalidFileType extends Error {
	property;
	expected;
	message;
	code = "INVALID_FILE_TYPE";
	status = 422;
	constructor(property, expected, message = `"${property}" has invalid file type`) {
		super(message);
		this.property = property;
		this.expected = expected;
		this.message = message;
		Object.setPrototypeOf(this, InvalidFileType.prototype);
	}
	toResponse(headers) {
		if (isProduction)
			return new Response(JSON.stringify({ type: "validation", on: "body" }), {
				status: 422,
				headers: { ...headers, "content-type": "application/json" },
			});
		return new Response(
			JSON.stringify({
				type: "validation",
				on: "body",
				summary: "Invalid file type",
				message: this.message,
				property: this.property,
				expected: this.expected,
			}),
			{ status: 422, headers: { ...headers, "content-type": "application/json" } },
		);
	}
}

class ValidationError extends Error {
	type;
	validator;
	value;
	allowUnsafeValidationDetails;
	code = "VALIDATION";
	status = 422;
	valueError;
	get messageValue() {
		return this.valueError;
	}
	expected;
	customError;
	constructor(type, validator, value, allowUnsafeValidationDetails = false, errors) {
		let message = "",
			error,
			expected,
			customError;
		if (
			validator?.provider === "standard" ||
			"~standard" in validator ||
			(validator.schema && "~standard" in validator.schema)
		) {
			let standard = ("~standard" in validator ? validator : validator.schema)["~standard"];
			if (((error = (errors ?? standard.validate(value).issues)?.[0]), isProduction))
				message = JSON.stringify({ type: "validation", on: type, found: value });
			else
				message = JSON.stringify(
					{
						type: "validation",
						on: type,
						property: error.path?.[0] || "root",
						message: error?.message,
						summary: error?.problem,
						expected,
						found: value,
						errors,
					},
					null,
					2,
				);
			customError = error?.message;
		} else {
			if (value && typeof value === "object" && value instanceof ElysiaCustomStatusResponse)
				value = value.response;
			error =
				errors?.First() ??
				("Errors" in validator
					? validator.Errors(value).First()
					: exports_value2.Errors(validator, value).First());
			let accessor = error?.path || "root",
				schema = validator?.schema ?? validator;
			if (!isProduction && !allowUnsafeValidationDetails)
				try {
					expected = exports_value2.Create(schema);
				} catch (error2) {
					expected = {
						type: "Could not create expected value",
						message: error2?.message,
						error: error2,
					};
				}
			if (
				((customError =
					error?.schema?.message || error?.schema?.error !== undefined
						? typeof error.schema.error === "function"
							? error.schema.error(
									isProduction && !allowUnsafeValidationDetails
										? { type: "validation", on: type, found: value }
										: {
												type: "validation",
												on: type,
												value,
												property: accessor,
												message: error?.message,
												summary: mapValueError(error).summary,
												found: value,
												expected,
												errors:
													"Errors" in validator
														? [...validator.Errors(value)].map(mapValueError)
														: [...exports_value2.Errors(validator, value)].map(mapValueError),
											},
									validator,
								)
							: error.schema.error
						: undefined),
				customError !== undefined)
			)
				message = typeof customError === "object" ? JSON.stringify(customError) : customError + "";
			else if (isProduction && !allowUnsafeValidationDetails)
				message = JSON.stringify({ type: "validation", on: type, found: value });
			else
				message = JSON.stringify(
					{
						type: "validation",
						on: type,
						property: accessor,
						message: error?.message,
						summary: mapValueError(error).summary,
						expected,
						found: value,
						errors:
							"Errors" in validator
								? [...validator.Errors(value)].map(mapValueError)
								: [...exports_value2.Errors(validator, value)].map(mapValueError),
					},
					null,
					2,
				);
		}
		super(message);
		this.type = type;
		this.validator = validator;
		this.value = value;
		this.allowUnsafeValidationDetails = allowUnsafeValidationDetails;
		((this.valueError = error),
			(this.expected = expected),
			(this.customError = customError),
			Object.setPrototypeOf(this, ValidationError.prototype));
	}
	get all() {
		if (
			this.validator?.provider === "standard" ||
			"~standard" in this.validator ||
			("schema" in this.validator && this.validator.schema && "~standard" in this.validator.schema)
		)
			return (
				("~standard" in this.validator ? this.validator : this.validator.schema)["~standard"]
					.validate(this.value)
					.issues?.map((issue) => ({
						summary: issue.message,
						path: issue.path?.join(".") || "root",
						message: issue.message,
						value: this.value,
					})) || []
			);
		return "Errors" in this.validator
			? [...this.validator.Errors(this.value)].map(mapValueError)
			: [...exports_value2.Errors(this.validator, this.value)].map(mapValueError);
	}
	static simplifyModel(validator) {
		let model = "schema" in validator ? validator.schema : validator;
		try {
			return exports_value2.Create(model);
		} catch {
			return model;
		}
	}
	get model() {
		if ("~standard" in this.validator) return this.validator;
		return ValidationError.simplifyModel(this.validator);
	}
	toResponse(headers) {
		return new Response(this.message, {
			status: 400,
			headers: { ...headers, "content-type": "application/json" },
		});
	}
	detail(message, allowUnsafeValidatorDetails = this.allowUnsafeValidationDetails) {
		if (!this.customError) return this.message;
		let value = this.value,
			expected = this.expected,
			errors = this.all;
		return isProduction && !allowUnsafeValidatorDetails
			? { type: "validation", on: this.type, found: value, message }
			: {
					type: "validation",
					on: this.type,
					property: this.valueError?.path || "root",
					message,
					summary: mapValueError(this.valueError).summary,
					found: value,
					expected,
					errors,
				};
	}
}
var tryParse = (v, schema) => {
	try {
		return JSON.parse(v);
	} catch {
		throw new ValidationError("property", schema, v);
	}
};
function createType(kind, func) {
	if (!exports_type2.Has(kind)) exports_type2.Set(kind, func);
	return (options = {}) => Unsafe({ ...options, [Kind]: kind });
}
var compile = (schema) => {
	try {
		let compiler = TypeCompiler.Compile(schema);
		return (
			(compiler.Create = () => exports_value2.Create(schema)),
			(compiler.Error = (v) => new ValidationError("property", schema, v, compiler.Errors(v))),
			compiler
		);
	} catch {
		return {
			Check: (v) => exports_value2.Check(schema, v),
			CheckThrow: (v) => {
				if (!exports_value2.Check(schema, v))
					throw new ValidationError("property", schema, v, exports_value2.Errors(schema, v));
			},
			Decode: (v) => exports_value2.Decode(schema, v),
			Create: () => exports_value2.Create(schema),
			Error: (v) => new ValidationError("property", schema, v, exports_value2.Errors(schema, v)),
		};
	}
};
var parseFileUnit = (size) => {
	if (typeof size === "string")
		switch (size.slice(-1)) {
			case "k":
				return +size.slice(0, size.length - 1) * 1024;
			case "m":
				return +size.slice(0, size.length - 1) * 1048576;
			default:
				return +size;
		}
	return size;
};
var checkFileExtension = (type, extension) => {
	if (type.startsWith(extension)) return true;
	return (
		extension.charCodeAt(extension.length - 1) === 42 &&
		extension.charCodeAt(extension.length - 2) === 47 &&
		type.startsWith(extension.slice(0, -1))
	);
};
var _fileTypeFromBlobWarn = false;
var warnIfFileTypeIsNotInstalled = () => {
	if (!_fileTypeFromBlobWarn)
		(console.warn(
			"[Elysia] Attempt to validate file type without 'file-type'. This may lead to security risks. We recommend installing 'file-type' to properly validate file extension.",
		),
			(_fileTypeFromBlobWarn = true));
};
var loadFileType = async () =>
	Promise.resolve()
		.then(() => (init_file_type(), exports_file_type))
		.then((x) => {
			return ((_fileTypeFromBlob = x.fileTypeFromBlob), _fileTypeFromBlob);
		})
		.catch(warnIfFileTypeIsNotInstalled);
var _fileTypeFromBlob;
var fileTypeFromBlob2 = (file2) => {
	if (_fileTypeFromBlob) return _fileTypeFromBlob(file2);
	return loadFileType().then((mod) => {
		if (mod) return mod(file2);
	});
};
var fileType = async (file2, extension, name = file2?.name ?? "") => {
	if (Array.isArray(file2))
		return (await Promise.all(file2.map((f) => fileType(f, extension, name))), true);
	if (!file2) return false;
	let result = await fileTypeFromBlob2(file2);
	if (!result) throw new InvalidFileType(name, extension);
	if (typeof extension === "string") {
		if (!checkFileExtension(result.mime, extension)) throw new InvalidFileType(name, extension);
	}
	for (let i = 0; i < extension.length; i++)
		if (checkFileExtension(result.mime, extension[i])) return true;
	throw new InvalidFileType(name, extension);
};
var validateFile = (options, value) => {
	if (value instanceof ElysiaFile) return true;
	if (!(value instanceof Blob)) return false;
	if (options.minSize && value.size < parseFileUnit(options.minSize)) return false;
	if (options.maxSize && value.size > parseFileUnit(options.maxSize)) return false;
	if (options.extension) {
		if (typeof options.extension === "string")
			return checkFileExtension(value.type, options.extension);
		for (let i = 0; i < options.extension.length; i++)
			if (checkFileExtension(value.type, options.extension[i])) return true;
		return false;
	}
	return true;
};
var fullFormats = {
	date,
	time: getTime(true),
	"date-time": getDateTime(true),
	"iso-time": getTime(false),
	"iso-date-time": getDateTime(false),
	duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
	uri,
	"uri-reference":
		/^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
	"uri-template":
		/^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
	url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
	email:
		/^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
	hostname:
		/^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
	ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
	ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
	regex,
	uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
	"json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
	"json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
	"relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
	byte,
	int32: { type: "number", validate: validateInt32 },
	int64: { type: "number", validate: validateInt64 },
	float: { type: "number", validate: validateNumber },
	double: { type: "number", validate: validateNumber },
	password: true,
	binary: true,
};
function isLeapYear(year) {
	return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function date(str) {
	let matches = DATE.exec(str);
	if (!matches) return false;
	let year = +matches[1],
		month = +matches[2],
		day = +matches[3];
	return (
		month >= 1 &&
		month <= 12 &&
		day >= 1 &&
		day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month])
	);
}
var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
function getTime(strictTimeZone) {
	return function (str) {
		let matches = TIME.exec(str);
		if (!matches) return false;
		let hr = +matches[1],
			min = +matches[2],
			sec = +matches[3],
			tz = matches[4],
			tzSign = matches[5] === "-" ? -1 : 1,
			tzH = +(matches[6] || 0),
			tzM = +(matches[7] || 0);
		if (tzH > 23 || tzM > 59 || (strictTimeZone && !tz)) return false;
		if (hr <= 23 && min <= 59 && sec < 60) return true;
		let utcMin = min - tzM * tzSign,
			utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
		return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
	};
}
var parseDateTimeEmptySpace = (str) => {
	if (str.charCodeAt(str.length - 6) === 32) return str.slice(0, -6) + "+" + str.slice(-5);
	return str;
};
var DATE_TIME_SEPARATOR = /t|\s/i;
function getDateTime(strictTimeZone) {
	let time = getTime(strictTimeZone);
	return function (str) {
		let dateTime = str.split(DATE_TIME_SEPARATOR);
		return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);
	};
}
var NOT_URI_FRAGMENT = /\/|:/;
var URI =
	/^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function uri(str) {
	return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}
var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
function byte(str) {
	return ((BYTE.lastIndex = 0), BYTE.test(str));
}
var MIN_INT32 = -2147483648;
var MAX_INT32 = 2147483647;
function validateInt32(value) {
	return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
}
function validateInt64(value) {
	return Number.isInteger(value);
}
function validateNumber() {
	return true;
}
var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
	if (Z_ANCHOR.test(str)) return false;
	try {
		return (new RegExp(str), true);
	} catch (e) {
		return false;
	}
}
var isISO8601 =
	/(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
var isFormalDate =
	/(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{2}\s\d{4}\s\d{2}:\d{2}:\d{2}\sGMT(?:\+|-)\d{4}\s\([^)]+\)/;
var isShortenDate =
	/^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:19|20)\d{2})|(?:(?:19|20)\d{2}[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\s[AP]M)?)?$/;
var _validateDate = fullFormats.date;
var _validateDateTime = fullFormats["date-time"];
if (!exports_format.Has("date"))
	exports_format.Set("date", (value) => {
		let temp = parseDateTimeEmptySpace(value).replace(/"/g, "");
		if (
			isISO8601.test(temp) ||
			isFormalDate.test(temp) ||
			isShortenDate.test(temp) ||
			_validateDate(temp)
		) {
			let date2 = new Date(temp);
			if (!Number.isNaN(date2.getTime())) return true;
		}
		return false;
	});
if (!exports_format.Has("date-time"))
	exports_format.Set("date-time", (value) => {
		let temp = value.replace(/"/g, "");
		if (
			isISO8601.test(temp) ||
			isFormalDate.test(temp) ||
			isShortenDate.test(temp) ||
			_validateDateTime(temp)
		) {
			let date2 = new Date(temp);
			if (!Number.isNaN(date2.getTime())) return true;
		}
		return false;
	});
Object.entries(fullFormats).forEach((formatEntry) => {
	let [formatName, formatValue] = formatEntry;
	if (!exports_format.Has(formatName)) {
		if (formatValue instanceof RegExp)
			exports_format.Set(formatName, (value) => formatValue.test(value));
		else if (typeof formatValue === "function") exports_format.Set(formatName, formatValue);
	}
});
if (!exports_format.Has("numeric"))
	exports_format.Set("numeric", (value) => !!value && !isNaN(+value));
if (!exports_format.Has("integer"))
	exports_format.Set("integer", (value) => !!value && Number.isInteger(+value));
if (!exports_format.Has("boolean"))
	exports_format.Set("boolean", (value) => value === "true" || value === "false");
if (!exports_format.Has("ObjectString"))
	exports_format.Set("ObjectString", (value) => {
		let start = value.charCodeAt(0);
		if (start === 9 || start === 10 || start === 32) start = value.trimStart().charCodeAt(0);
		if (start !== 123 && start !== 91) return false;
		try {
			return (JSON.parse(value), true);
		} catch {
			return false;
		}
	});
if (!exports_format.Has("ArrayString"))
	exports_format.Set("ArrayString", (value) => {
		let start = value.charCodeAt(0);
		if (start === 9 || start === 10 || start === 32) start = value.trimStart().charCodeAt(0);
		if (start !== 123 && start !== 91) return false;
		try {
			return (JSON.parse(value), true);
		} catch {
			return false;
		}
	});
var t = Object.assign({}, Type);
createType(
	"UnionEnum",
	(schema, value) =>
		(typeof value === "number" || typeof value === "string" || value === null) &&
		schema.enum.includes(value),
);
createType("ArrayBuffer", (schema, value) => value instanceof ArrayBuffer);
var internalFiles = createType("Files", (options, value) => {
	if (options.minItems && options.minItems > 1 && !Array.isArray(value)) return false;
	if (!Array.isArray(value)) return validateFile(options, value);
	if (options.minItems && value.length < options.minItems) return false;
	if (options.maxItems && value.length > options.maxItems) return false;
	for (let i = 0; i < value.length; i++) if (!validateFile(options, value[i])) return false;
	return true;
});
var internalFormData = createType("ElysiaForm", ({ compiler, ...schema }, value) => {
	if (!(value instanceof FormData)) return false;
	if (compiler) {
		if (!(ELYSIA_FORM_DATA in value)) throw new ValidationError("property", schema, value);
		if (!compiler.Check(value[ELYSIA_FORM_DATA])) throw compiler.Error(value[ELYSIA_FORM_DATA]);
	}
	return true;
});
var ElysiaType = {
	String: (property) => Type.String(property),
	Numeric: (property) => {
		let schema = Type.Number(property),
			compiler = compile(schema);
		return t
			.Transform(
				t.Union([t.String({ format: "numeric", default: 0 }), t.Number(property)], property),
			)
			.Decode((value) => {
				let number = +value;
				if (isNaN(number)) return value;
				if (property && !compiler.Check(number)) throw compiler.Error(number);
				return number;
			})
			.Encode((value) => value);
	},
	NumericEnum(item, property) {
		let schema = Type.Enum(item, property),
			compiler = compile(schema);
		return t
			.Transform(t.Union([t.String({ format: "numeric" }), t.Number()], property))
			.Decode((value) => {
				let number = +value;
				if (isNaN(number)) throw compiler.Error(number);
				if (!compiler.Check(number)) throw compiler.Error(number);
				return number;
			})
			.Encode((value) => value);
	},
	Integer: (property) => {
		let schema = Type.Integer(property),
			compiler = compile(schema);
		return t
			.Transform(
				t.Union([t.String({ format: "integer", default: 0 }), Type.Integer(property)], property),
			)
			.Decode((value) => {
				let number = +value;
				if (!compiler.Check(number)) throw compiler.Error(number);
				return number;
			})
			.Encode((value) => value);
	},
	Date: (property) => {
		let schema = Type.Date(property),
			compiler = compile(schema),
			_default = property?.default ? new Date(property.default) : undefined;
		return t
			.Transform(
				t.Union(
					[
						Type.Date(property),
						t.String({ format: "date-time", default: _default?.toISOString() }),
						t.String({ format: "date", default: _default?.toISOString() }),
						t.Number({ default: _default?.getTime() }),
					],
					property,
				),
			)
			.Decode((value) => {
				if (typeof value === "number") {
					let date3 = new Date(value);
					if (!compiler.Check(date3)) throw compiler.Error(date3);
					return date3;
				}
				if (value instanceof Date) return value;
				let date2 = new Date(parseDateTimeEmptySpace(value));
				if (!date2 || isNaN(date2.getTime())) throw new ValidationError("property", schema, date2);
				if (!compiler.Check(date2)) throw compiler.Error(date2);
				return date2;
			})
			.Encode((value) => {
				if (value instanceof Date) return value.toISOString();
				if (typeof value === "string") {
					if (isNaN(new Date(parseDateTimeEmptySpace(value)).getTime()))
						throw new ValidationError("property", schema, value);
					return value;
				}
				if (!compiler.Check(value)) throw compiler.Error(value);
				return value;
			});
	},
	BooleanString: (property) => {
		let schema = Type.Boolean(property),
			compiler = compile(schema);
		return t
			.Transform(
				t.Union([t.Boolean(property), t.String({ format: "boolean", default: false })], property),
			)
			.Decode((value) => {
				if (typeof value === "string") return value === "true";
				if (value !== undefined && !compiler.Check(value)) throw compiler.Error(value);
				return value;
			})
			.Encode((value) => value);
	},
	ObjectString: (properties, options) => {
		let schema = t.Object(properties, options),
			compiler = compile(schema);
		return t
			.Transform(
				t.Union([t.String({ format: "ObjectString", default: "{}" }), schema], {
					elysiaMeta: "ObjectString",
				}),
			)
			.Decode((value) => {
				if (typeof value === "string") {
					if (value.charCodeAt(0) !== 123) throw new ValidationError("property", schema, value);
					if (!compiler.Check((value = tryParse(value, schema)))) throw compiler.Error(value);
					return compiler.Decode(value);
				}
				return value;
			})
			.Encode((value) => {
				let original;
				if (typeof value === "string") value = tryParse((original = value), schema);
				if (!compiler.Check(value)) throw compiler.Error(value);
				return original ?? JSON.stringify(value);
			});
	},
	ArrayString: (children = t.String(), options) => {
		let schema = t.Array(children, options),
			compiler = compile(schema),
			decode2 = (value, isProperty = false) => {
				if (value.charCodeAt(0) === 91) {
					if (!compiler.Check((value = tryParse(value, schema)))) throw compiler.Error(value);
					return compiler.Decode(value);
				}
				if (isProperty) return value;
				throw new ValidationError("property", schema, value);
			};
		return t
			.Transform(t.Union([t.String({ format: "ArrayString", default: options?.default }), schema]))
			.Decode((value) => {
				if (Array.isArray(value)) {
					let values = [];
					for (let i = 0; i < value.length; i++) {
						let v = value[i];
						if (typeof v === "string") {
							let t2 = decode2(v, true);
							if (Array.isArray(t2)) values = values.concat(t2);
							else values.push(t2);
							continue;
						}
						values.push(v);
					}
					return values;
				}
				if (typeof value === "string") return decode2(value);
				return value;
			})
			.Encode((value) => {
				let original;
				if (typeof value === "string") value = tryParse((original = value), schema);
				if (!compiler.Check(value)) throw new ValidationError("property", schema, value);
				return original ?? JSON.stringify(value);
			});
	},
	ArrayQuery: (children = t.String(), options) => {
		let schema = t.Array(children, options),
			compiler = compile(schema),
			decode2 = (value) => {
				if (value.indexOf(",") !== -1) return compiler.Decode(value.split(","));
				return [value];
			};
		return t
			.Transform(
				t.Union([t.String({ default: options?.default }), schema], { elysiaMeta: "ArrayQuery" }),
			)
			.Decode((value) => {
				if (Array.isArray(value)) {
					let values = [];
					for (let i = 0; i < value.length; i++) {
						let v = value[i];
						if (typeof v === "string") {
							let t2 = decode2(v);
							if (Array.isArray(t2)) values = values.concat(t2);
							else values.push(t2);
							continue;
						}
						values.push(v);
					}
					return values;
				}
				if (typeof value === "string") return decode2(value);
				return value;
			})
			.Encode((value) => {
				let original;
				if (typeof value === "string") value = tryParse((original = value), schema);
				if (!compiler.Check(value)) throw new ValidationError("property", schema, value);
				return original ?? JSON.stringify(value);
			});
	},
	File: createType("File", validateFile),
	Files: (options = {}) =>
		t
			.Transform(internalFiles(options))
			.Decode((value) => {
				if (Array.isArray(value)) return value;
				return [value];
			})
			.Encode((value) => value),
	Nullable: (schema, options) => t.Union([schema, t.Null()], { ...options, nullable: true }),
	MaybeEmpty: (schema, options) => t.Union([schema, t.Null(), t.Undefined()], options),
	Cookie: (
		properties,
		{
			domain,
			expires,
			httpOnly,
			maxAge,
			path,
			priority,
			sameSite,
			secure,
			secrets,
			sign,
			...options
		} = {},
	) => {
		let v = t.Object(properties, options);
		return (
			(v.config = {
				domain,
				expires,
				httpOnly,
				maxAge,
				path,
				priority,
				sameSite,
				secure,
				secrets,
				sign,
			}),
			v
		);
	},
	UnionEnum: (values, options = {}) => {
		let type = values.every((value) => typeof value === "string")
			? { type: "string" }
			: values.every((value) => typeof value === "number")
				? { type: "number" }
				: values.every((value) => value === null)
					? { type: "null" }
					: {};
		if (values.some((x) => typeof x === "object" && x !== null))
			throw Error("This type does not support objects or arrays");
		return { default: values[0], ...options, [Kind]: "UnionEnum", ...type, enum: values };
	},
	NoValidate: (v, enabled = true) => {
		return ((v.noValidate = enabled), v);
	},
	Form: (v, options = {}) => {
		let schema = t.Object(v, { default: form({}), ...options }),
			compiler = compile(schema);
		return t.Union([schema, internalFormData({ compiler })]);
	},
	ArrayBuffer(options = {}) {
		return { default: [1, 2, 3], ...options, [Kind]: "ArrayBuffer" };
	},
	Uint8Array: (options) => {
		let schema = Type.Uint8Array(options),
			compiler = compile(schema);
		return t
			.Transform(t.Union([t.ArrayBuffer(), Type.Uint8Array(options)]))
			.Decode((value) => {
				if (value instanceof ArrayBuffer) {
					if (!compiler.Check((value = new Uint8Array(value)))) throw compiler.Error(value);
					return value;
				}
				return value;
			})
			.Encode((value) => value);
	},
};
t.BooleanString = ElysiaType.BooleanString;
t.ObjectString = ElysiaType.ObjectString;
t.ArrayString = ElysiaType.ArrayString;
t.ArrayQuery = ElysiaType.ArrayQuery;
t.Numeric = ElysiaType.Numeric;
t.NumericEnum = ElysiaType.NumericEnum;
t.Integer = ElysiaType.Integer;
t.File = (arg) => {
	if (arg?.type) loadFileType();
	return ElysiaType.File({
		default: "File",
		...arg,
		extension: arg?.type,
		type: "string",
		format: "binary",
	});
};
t.Files = (arg) => {
	if (arg?.type) loadFileType();
	return ElysiaType.Files({
		...arg,
		elysiaMeta: "Files",
		default: "Files",
		extension: arg?.type,
		type: "array",
		items: { ...arg, default: "Files", type: "string", format: "binary" },
	});
};
t.Nullable = ElysiaType.Nullable;
t.MaybeEmpty = ElysiaType.MaybeEmpty;
t.Cookie = ElysiaType.Cookie;
t.Date = ElysiaType.Date;
t.UnionEnum = ElysiaType.UnionEnum;
t.NoValidate = ElysiaType.NoValidate;
t.Form = ElysiaType.Form;
t.ArrayBuffer = ElysiaType.ArrayBuffer;
t.Uint8Array = ElysiaType.Uint8Array;
var import_cookie = __toESM2(require_dist(), 1);
var import_fast_decode_uri_component = __toESM2(require_fast_decode_uri_component(), 1);

class Cookie {
	name;
	jar;
	initial;
	constructor(name, jar, initial = {}) {
		this.name = name;
		this.jar = jar;
		this.initial = initial;
	}
	get cookie() {
		return this.jar[this.name] ?? this.initial;
	}
	set cookie(jar) {
		if (!(this.name in this.jar)) this.jar[this.name] = this.initial;
		this.jar[this.name] = jar;
	}
	get setCookie() {
		if (!(this.name in this.jar)) this.jar[this.name] = this.initial;
		return this.jar[this.name];
	}
	set setCookie(jar) {
		this.cookie = jar;
	}
	get value() {
		return this.cookie.value;
	}
	set value(value) {
		this.setCookie.value = value;
	}
	get expires() {
		return this.cookie.expires;
	}
	set expires(expires) {
		this.setCookie.expires = expires;
	}
	get maxAge() {
		return this.cookie.maxAge;
	}
	set maxAge(maxAge) {
		this.setCookie.maxAge = maxAge;
	}
	get domain() {
		return this.cookie.domain;
	}
	set domain(domain) {
		this.setCookie.domain = domain;
	}
	get path() {
		return this.cookie.path;
	}
	set path(path) {
		this.setCookie.path = path;
	}
	get secure() {
		return this.cookie.secure;
	}
	set secure(secure) {
		this.setCookie.secure = secure;
	}
	get httpOnly() {
		return this.cookie.httpOnly;
	}
	set httpOnly(httpOnly) {
		this.setCookie.httpOnly = httpOnly;
	}
	get sameSite() {
		return this.cookie.sameSite;
	}
	set sameSite(sameSite) {
		this.setCookie.sameSite = sameSite;
	}
	get priority() {
		return this.cookie.priority;
	}
	set priority(priority) {
		this.setCookie.priority = priority;
	}
	get partitioned() {
		return this.cookie.partitioned;
	}
	set partitioned(partitioned) {
		this.setCookie.partitioned = partitioned;
	}
	get secrets() {
		return this.cookie.secrets;
	}
	set secrets(secrets) {
		this.setCookie.secrets = secrets;
	}
	update(config) {
		return (
			(this.setCookie = Object.assign(
				this.cookie,
				typeof config === "function" ? config(this.cookie) : config,
			)),
			this
		);
	}
	set(config) {
		return (
			(this.setCookie = Object.assign(
				{ ...this.initial, value: this.value },
				typeof config === "function" ? config(this.cookie) : config,
			)),
			this
		);
	}
	remove() {
		if (this.value === undefined) return;
		return (this.set({ expires: new Date(0), maxAge: 0, value: "" }), this);
	}
	toString() {
		return typeof this.value === "object"
			? JSON.stringify(this.value)
			: (this.value?.toString() ?? "");
	}
}
var createCookieJar = (set2, store, initial) => {
	if (!set2.cookie) set2.cookie = {};
	return new Proxy(store, {
		get(_2, key) {
			if (key in store)
				return new Cookie(key, set2.cookie, Object.assign({}, initial ?? {}, store[key]));
			return new Cookie(key, set2.cookie, Object.assign({}, initial));
		},
	});
};
var parseCookie = async (set2, cookieString, { secrets, sign, ...initial } = {}) => {
	if (!cookieString) return createCookieJar(set2, {}, initial);
	let isStringKey = typeof secrets === "string";
	if (sign && sign !== true && !Array.isArray(sign)) sign = [sign];
	let jar = {},
		cookies = import_cookie.parse(cookieString);
	for (let [name, v] of Object.entries(cookies)) {
		if (v === undefined) continue;
		let value = import_fast_decode_uri_component.default(v);
		if (value) {
			let starts = value.charCodeAt(0),
				ends = value.charCodeAt(value.length - 1);
			if ((starts === 123 && ends === 125) || (starts === 91 && ends === 93))
				try {
					value = JSON.parse(value);
				} catch {}
		}
		if (sign === true || sign?.includes(name)) {
			if (!secrets) throw Error("No secret is provided to cookie plugin");
			if (isStringKey) {
				let temp = await unsignCookie(value, secrets);
				if (temp === false) throw new InvalidCookieSignature(name);
				value = temp;
			} else {
				let decoded = true;
				for (let i = 0; i < secrets.length; i++) {
					let temp = await unsignCookie(value, secrets[i]);
					if (temp !== false) {
						((decoded = true), (value = temp));
						break;
					}
				}
				if (!decoded) throw new InvalidCookieSignature(name);
			}
		}
		jar[name] = { value };
	}
	return createCookieJar(set2, jar, initial);
};
var serializeCookie = (cookies) => {
	if (!cookies || !isNotEmpty(cookies)) return;
	let set2 = [];
	for (let [key, property] of Object.entries(cookies)) {
		if (!key || !property) continue;
		let value = property.value;
		if (value === undefined || value === null) continue;
		set2.push(
			import_cookie.serialize(
				key,
				typeof value === "object" ? JSON.stringify(value) : value + "",
				property,
			),
		);
	}
	if (set2.length === 0) return;
	if (set2.length === 1) return set2[0];
	return set2;
};
var env2 = isBun ? Bun.env : typeof process < "u" && process?.env ? process.env : {};
var handleFile = (response, set2) => {
	if (!isBun && response instanceof Promise) return response.then((res) => handleFile(res, set2));
	let size = response.size,
		immutable =
			set2 &&
			(set2.status === 206 || set2.status === 304 || set2.status === 412 || set2.status === 416),
		defaultHeader = immutable
			? {}
			: {
					"accept-ranges": "bytes",
					"content-range": size ? `bytes 0-${size - 1}/${size}` : undefined,
				};
	if (!set2 && !size) return new Response(response);
	if (!set2) return new Response(response, { headers: defaultHeader });
	if (set2.headers instanceof Headers) {
		for (let key of Object.keys(defaultHeader))
			if (key in set2.headers) set2.headers.append(key, defaultHeader[key]);
		if (immutable) (set2.headers.delete("content-length"), set2.headers.delete("accept-ranges"));
		return new Response(response, set2);
	}
	if (isNotEmpty(set2.headers))
		return new Response(response, {
			status: set2.status,
			headers: Object.assign(defaultHeader, set2.headers),
		});
	return new Response(response, { status: set2.status, headers: defaultHeader });
};
var parseSetCookies = (headers, setCookie) => {
	if (!headers) return headers;
	headers.delete("set-cookie");
	for (let i = 0; i < setCookie.length; i++) {
		let index = setCookie[i].indexOf("=");
		headers.append(
			"set-cookie",
			`${setCookie[i].slice(0, index)}=${setCookie[i].slice(index + 1) || ""}`,
		);
	}
	return headers;
};
var responseToSetHeaders = (response, set2) => {
	if (set2?.headers) {
		if (response) {
			if (hasHeaderShorthand) Object.assign(set2.headers, response.headers.toJSON());
			else
				for (let [key, value] of response.headers.entries())
					if (key in set2.headers) set2.headers[key] = value;
		}
		if (set2.status === 200) set2.status = response.status;
		if (set2.headers["content-encoding"]) delete set2.headers["content-encoding"];
		return set2;
	}
	if (!response) return { headers: {}, status: set2?.status ?? 200 };
	if (hasHeaderShorthand) {
		if (
			((set2 = { headers: response.headers.toJSON(), status: set2?.status ?? 200 }),
			set2.headers["content-encoding"])
		)
			delete set2.headers["content-encoding"];
		return set2;
	}
	set2 = { headers: {}, status: set2?.status ?? 200 };
	for (let [key, value] of response.headers.entries()) {
		if (key === "content-encoding") continue;
		if (key in set2.headers) set2.headers[key] = value;
	}
	return set2;
};
var allowRapidStream = env2.ELYSIA_RAPID_STREAM === "true";
var createStreamHandler =
	({ mapResponse, mapCompactResponse }) =>
	async (generator, set2, request) => {
		let init = generator.next?.();
		if (set2) handleSet(set2);
		if (init instanceof Promise) init = await init;
		if (init?.value instanceof ReadableStream) generator = init.value;
		else if (init && (typeof init?.done > "u" || init?.done)) {
			if (set2) return mapResponse(init.value, set2, request);
			return mapCompactResponse(init.value, request);
		}
		let isSSE =
				init?.value?.sse ??
				generator?.sse ??
				set2?.headers["content-type"]?.startsWith("text/event-stream"),
			format = isSSE
				? (data) => `data: ${data}

`
				: (data) => data,
			contentType = isSSE
				? "text/event-stream"
				: init?.value && typeof init?.value === "object"
					? "application/json"
					: "text/plain";
		if (set2?.headers) {
			if (!set2.headers["transfer-encoding"]) set2.headers["transfer-encoding"] = "chunked";
			if (!set2.headers["content-type"]) set2.headers["content-type"] = contentType;
			if (!set2.headers["cache-control"]) set2.headers["cache-control"] = "no-cache";
		} else
			set2 = {
				status: 200,
				headers: {
					"content-type": contentType,
					"transfer-encoding": "chunked",
					"cache-control": "no-cache",
					connection: "keep-alive",
				},
			};
		let isBrowser = request?.headers.has("Origin");
		return new Response(
			new ReadableStream({
				async start(controller) {
					let end = false;
					if (
						(request?.signal?.addEventListener("abort", () => {
							end = true;
							try {
								controller.close();
							} catch {}
						}),
						!init || init.value instanceof ReadableStream)
					);
					else if (init.value !== undefined && init.value !== null)
						if (init.value.toSSE) controller.enqueue(init.value.toSSE());
						else if (typeof init.value === "object")
							try {
								controller.enqueue(format(JSON.stringify(init.value)));
							} catch {
								controller.enqueue(format(init.value.toString()));
							}
						else controller.enqueue(format(init.value.toString()));
					try {
						for await (let chunk of generator) {
							if (end) break;
							if (chunk === undefined || chunk === null) continue;
							if (chunk.toSSE) controller.enqueue(chunk.toSSE());
							else {
								if (typeof chunk === "object")
									try {
										controller.enqueue(format(JSON.stringify(chunk)));
									} catch {
										controller.enqueue(format(chunk.toString()));
									}
								else controller.enqueue(format(chunk.toString()));
								if (!allowRapidStream && isBrowser && !isSSE)
									await new Promise((resolve) => setTimeout(() => resolve(), 0));
							}
						}
					} catch (error) {
						console.warn(error);
					}
					try {
						controller.close();
					} catch {}
				},
			}),
			set2,
		);
	};
async function* streamResponse(response) {
	let body = response.body;
	if (!body) return;
	let reader = body.getReader(),
		decoder = new TextDecoder();
	try {
		while (true) {
			let { done, value } = await reader.read();
			if (done) break;
			if (typeof value === "string") yield value;
			else yield decoder.decode(value);
		}
	} finally {
		reader.releaseLock();
	}
}
var handleSet = (set2) => {
	if (typeof set2.status === "string") set2.status = StatusMap[set2.status];
	if (set2.cookie && isNotEmpty(set2.cookie)) {
		let cookie = serializeCookie(set2.cookie);
		if (cookie) set2.headers["set-cookie"] = cookie;
	}
	if (set2.headers["set-cookie"] && Array.isArray(set2.headers["set-cookie"]))
		set2.headers = parseSetCookies(new Headers(set2.headers), set2.headers["set-cookie"]);
};
var createResponseHandler = (handler) => {
	let handleStream = createStreamHandler(handler);
	return (response, set2, request) => {
		let isCookieSet = false;
		if (set2.headers instanceof Headers)
			for (let key of set2.headers.keys())
				if (key === "set-cookie") {
					if (isCookieSet) continue;
					isCookieSet = true;
					for (let cookie of set2.headers.getSetCookie())
						response.headers.append("set-cookie", cookie);
				} else response.headers.append(key, set2.headers?.get(key) ?? "");
		else for (let key in set2.headers) response.headers.append(key, set2.headers[key]);
		let status2 = set2.status ?? 200;
		if (
			response.status !== status2 &&
			status2 !== 200 &&
			(response.status <= 300 || response.status > 400)
		) {
			let newResponse = new Response(response.body, {
				headers: response.headers,
				status: set2.status,
			});
			if (
				!newResponse.headers.has("content-length") &&
				newResponse.headers.get("transfer-encoding") === "chunked"
			)
				return handleStream(
					streamResponse(newResponse),
					responseToSetHeaders(newResponse, set2),
					request,
				);
			return newResponse;
		}
		if (
			!response.headers.has("content-length") &&
			response.headers.get("transfer-encoding") === "chunked"
		)
			return handleStream(streamResponse(response), responseToSetHeaders(response, set2), request);
		return response;
	};
};
async function tee(source, branches = 2) {
	let buffer = [],
		done = false,
		waiting = [];
	(async () => {
		for await (let value of source)
			(buffer.push(value), waiting.forEach((w) => w.resolve()), (waiting = []));
		((done = true), waiting.forEach((w) => w.resolve()));
	})();
	async function* makeIterator() {
		let i = 0;
		while (true)
			if (i < buffer.length) yield buffer[i++];
			else if (done) return;
			else await new Promise((resolve) => waiting.push({ resolve }));
	}
	return Array.from({ length: branches }, makeIterator);
}
var handleElysiaFile = (file2, set2 = { headers: {} }) => {
	let path = file2.path,
		contentType = mime[path.slice(path.lastIndexOf(".") + 1)];
	if (contentType) set2.headers["content-type"] = contentType;
	if (
		file2.stats &&
		set2.status !== 206 &&
		set2.status !== 304 &&
		set2.status !== 412 &&
		set2.status !== 416
	)
		return file2.stats.then((stat2) => {
			let size = stat2.size;
			if (size !== undefined)
				((set2.headers["content-range"] = `bytes 0-${size - 1}/${size}`),
					(set2.headers["content-length"] = size));
			return handleFile(file2.value, set2);
		});
	return handleFile(file2.value, set2);
};
var mapResponse = (response, set2, request) => {
	if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie)
		switch ((handleSet(set2), response?.constructor?.name)) {
			case "String":
				return ((set2.headers["content-type"] = "text/plain"), new Response(response, set2));
			case "Array":
			case "Object":
				return (
					(set2.headers["content-type"] = "application/json"),
					new Response(JSON.stringify(response), set2)
				);
			case "ElysiaFile":
				return handleElysiaFile(response, set2);
			case "File":
				return handleFile(response, set2);
			case "Blob":
				return handleFile(response, set2);
			case "ElysiaCustomStatusResponse":
				return ((set2.status = response.code), mapResponse(response.response, set2, request));
			case undefined:
				if (!response) return new Response("", set2);
				return new Response(JSON.stringify(response), set2);
			case "Response":
				return handleResponse(response, set2, request);
			case "Error":
				return errorToResponse(response, set2);
			case "Promise":
				return response.then((x) => mapResponse(x, set2, request));
			case "Function":
				return mapResponse(response(), set2, request);
			case "Number":
			case "Boolean":
				return new Response(response.toString(), set2);
			case "Cookie":
				if (response instanceof Cookie) return new Response(response.value, set2);
				return new Response(response?.toString(), set2);
			case "FormData":
				return new Response(response, set2);
			default:
				if (response instanceof Response) return handleResponse(response, set2, request);
				if (response instanceof Promise) return response.then((x) => mapResponse(x, set2));
				if (response instanceof Error) return errorToResponse(response, set2);
				if (response instanceof ElysiaCustomStatusResponse)
					return ((set2.status = response.code), mapResponse(response.response, set2, request));
				if (typeof response?.next === "function" || response instanceof ReadableStream)
					return handleStream(response, set2, request);
				if (typeof response?.then === "function") return response.then((x) => mapResponse(x, set2));
				if (typeof response?.toResponse === "function")
					return mapResponse(response.toResponse(), set2);
				if ("charCodeAt" in response) {
					let code = response.charCodeAt(0);
					if (code === 123 || code === 91) {
						if (!set2.headers["Content-Type"]) set2.headers["Content-Type"] = "application/json";
						return new Response(JSON.stringify(response), set2);
					}
				}
				return new Response(response, set2);
		}
	if (typeof response?.next === "function" || response instanceof ReadableStream)
		return handleStream(response, set2, request);
	return mapCompactResponse(response, request);
};
var mapEarlyResponse = (response, set2, request) => {
	if (response === undefined || response === null) return;
	if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie)
		switch ((handleSet(set2), response?.constructor?.name)) {
			case "String":
				return ((set2.headers["content-type"] = "text/plain"), new Response(response, set2));
			case "Array":
			case "Object":
				return (
					(set2.headers["content-type"] = "application/json"),
					new Response(JSON.stringify(response), set2)
				);
			case "ElysiaFile":
				return handleElysiaFile(response, set2);
			case "File":
				return handleFile(response, set2);
			case "Blob":
				return handleFile(response, set2);
			case "ElysiaCustomStatusResponse":
				return ((set2.status = response.code), mapEarlyResponse(response.response, set2, request));
			case undefined:
				if (!response) return;
				return new Response(JSON.stringify(response), set2);
			case "Response":
				return handleResponse(response, set2, request);
			case "Promise":
				return response.then((x) => mapEarlyResponse(x, set2));
			case "Error":
				return errorToResponse(response, set2);
			case "Function":
				return mapEarlyResponse(response(), set2);
			case "Number":
			case "Boolean":
				return new Response(response.toString(), set2);
			case "FormData":
				return new Response(response);
			case "Cookie":
				if (response instanceof Cookie) return new Response(response.value, set2);
				return new Response(response?.toString(), set2);
			default:
				if (response instanceof Response) return handleResponse(response, set2, request);
				if (response instanceof Promise) return response.then((x) => mapEarlyResponse(x, set2));
				if (response instanceof Error) return errorToResponse(response, set2);
				if (response instanceof ElysiaCustomStatusResponse)
					return (
						(set2.status = response.code),
						mapEarlyResponse(response.response, set2, request)
					);
				if (typeof response?.next === "function" || response instanceof ReadableStream)
					return handleStream(response, set2, request);
				if (typeof response?.then === "function")
					return response.then((x) => mapEarlyResponse(x, set2));
				if (typeof response?.toResponse === "function")
					return mapEarlyResponse(response.toResponse(), set2);
				if ("charCodeAt" in response) {
					let code = response.charCodeAt(0);
					if (code === 123 || code === 91) {
						if (!set2.headers["Content-Type"]) set2.headers["Content-Type"] = "application/json";
						return new Response(JSON.stringify(response), set2);
					}
				}
				return new Response(response, set2);
		}
	else
		switch (response?.constructor?.name) {
			case "String":
				return ((set2.headers["content-type"] = "text/plain"), new Response(response));
			case "Array":
			case "Object":
				return (
					(set2.headers["content-type"] = "application/json"),
					new Response(JSON.stringify(response), set2)
				);
			case "ElysiaFile":
				return handleElysiaFile(response, set2);
			case "File":
				return handleFile(response, set2);
			case "Blob":
				return handleFile(response, set2);
			case "ElysiaCustomStatusResponse":
				return ((set2.status = response.code), mapEarlyResponse(response.response, set2, request));
			case undefined:
				if (!response) return new Response("");
				return new Response(JSON.stringify(response), {
					headers: { "content-type": "application/json" },
				});
			case "Response":
				return response;
			case "Promise":
				return response.then((x) => {
					let r = mapEarlyResponse(x, set2);
					if (r !== undefined) return r;
				});
			case "Error":
				return errorToResponse(response, set2);
			case "Function":
				return mapCompactResponse(response(), request);
			case "Number":
			case "Boolean":
				return new Response(response.toString());
			case "Cookie":
				if (response instanceof Cookie) return new Response(response.value, set2);
				return new Response(response?.toString(), set2);
			case "FormData":
				return new Response(response);
			default:
				if (response instanceof Response) return response;
				if (response instanceof Promise) return response.then((x) => mapEarlyResponse(x, set2));
				if (response instanceof Error) return errorToResponse(response, set2);
				if (response instanceof ElysiaCustomStatusResponse)
					return (
						(set2.status = response.code),
						mapEarlyResponse(response.response, set2, request)
					);
				if (typeof response?.next === "function" || response instanceof ReadableStream)
					return handleStream(response, set2, request);
				if (typeof response?.then === "function")
					return response.then((x) => mapEarlyResponse(x, set2));
				if (typeof response?.toResponse === "function")
					return mapEarlyResponse(response.toResponse(), set2);
				if ("charCodeAt" in response) {
					let code = response.charCodeAt(0);
					if (code === 123 || code === 91) {
						if (!set2.headers["Content-Type"]) set2.headers["Content-Type"] = "application/json";
						return new Response(JSON.stringify(response), set2);
					}
				}
				return new Response(response);
		}
};
var mapCompactResponse = (response, request) => {
	switch (response?.constructor?.name) {
		case "String":
			return new Response(response, { headers: { "Content-Type": "text/plain" } });
		case "Object":
		case "Array":
			return new Response(JSON.stringify(response), {
				headers: { "Content-Type": "application/json" },
			});
		case "ElysiaFile":
			return handleElysiaFile(response);
		case "File":
			return handleFile(response);
		case "Blob":
			return handleFile(response);
		case "ElysiaCustomStatusResponse":
			return mapResponse(response.response, { status: response.code, headers: {} });
		case undefined:
			if (!response) return new Response("");
			return new Response(JSON.stringify(response), {
				headers: { "content-type": "application/json" },
			});
		case "Response":
			return response;
		case "Error":
			return errorToResponse(response);
		case "Promise":
			return response.then((x) => mapCompactResponse(x, request));
		case "Function":
			return mapCompactResponse(response(), request);
		case "Number":
		case "Boolean":
			return new Response(response.toString());
		case "FormData":
			return new Response(response);
		default:
			if (response instanceof Response) return response;
			if (response instanceof Promise) return response.then((x) => mapCompactResponse(x, request));
			if (response instanceof Error) return errorToResponse(response);
			if (response instanceof ElysiaCustomStatusResponse)
				return mapResponse(response.response, { status: response.code, headers: {} });
			if (typeof response?.next === "function" || response instanceof ReadableStream)
				return handleStream(response, undefined, request);
			if (typeof response?.then === "function") return response.then((x) => mapResponse(x, set));
			if (typeof response?.toResponse === "function")
				return mapCompactResponse(response.toResponse());
			if ("charCodeAt" in response) {
				let code = response.charCodeAt(0);
				if (code === 123 || code === 91)
					return new Response(JSON.stringify(response), {
						headers: { "Content-Type": "application/json" },
					});
			}
			return new Response(response);
	}
};
var errorToResponse = (error, set2) => {
	if (typeof error?.toResponse === "function") {
		let raw = error.toResponse(),
			targetSet = set2 ?? { headers: {}, status: 200, redirect: "" },
			apply = (resolved) => {
				if (resolved instanceof Response) targetSet.status = resolved.status;
				return mapResponse(resolved, targetSet);
			};
		return typeof raw?.then === "function" ? raw.then(apply) : apply(raw);
	}
	return new Response(
		JSON.stringify({ name: error?.name, message: error?.message, cause: error?.cause }),
		{ status: set2?.status !== 200 ? (set2?.status ?? 500) : 500, headers: set2?.headers },
	);
};
var createStaticHandler = (handle, hooks, setHeaders = {}) => {
	if (typeof handle === "function") return;
	let response = mapResponse(handle, { headers: setHeaders });
	if (
		!hooks.parse?.length &&
		!hooks.transform?.length &&
		!hooks.beforeHandle?.length &&
		!hooks.afterHandle?.length
	)
		return () => response.clone();
};
var handleResponse = createResponseHandler({ mapResponse, mapCompactResponse });
var handleStream = createStreamHandler({ mapResponse, mapCompactResponse });
var WebStandardAdapter = {
	name: "web-standard",
	isWebStandard: true,
	handler: { mapResponse, mapEarlyResponse, mapCompactResponse, createStaticHandler },
	composeHandler: {
		mapResponseContext: "c.request",
		preferWebstandardHeaders: true,
		headers: `c.headers={}
for(const [k,v] of c.request.headers.entries())c.headers[k]=v
`,
		parser: {
			json(isOptional) {
				if (isOptional)
					return `try{c.body=await c.request.json()}catch{}
`;
				return `c.body=await c.request.json()
`;
			},
			text() {
				return `c.body=await c.request.text()
`;
			},
			urlencoded() {
				return `c.body=parseQuery(await c.request.text())
`;
			},
			arrayBuffer() {
				return `c.body=await c.request.arrayBuffer()
`;
			},
			formData(isOptional) {
				let fnLiteral = `
c.body={}
`;
				if (isOptional) fnLiteral += "let form;try{form=await c.request.formData()}catch{}";
				else
					fnLiteral += `const form=await c.request.formData()
`;
				return (
					fnLiteral +
					`for(const key of form.keys()){if(c.body[key]) continue
const value=form.getAll(key)
if(value.length===1)c.body[key]=value[0]
else c.body[key]=value}`
				);
			},
		},
	},
	async stop(app, closeActiveConnections) {
		if (!app.server) throw Error("Elysia isn't running. Call `app.listen` to start the server.");
		if (app.server) {
			if (
				(await app.server.stop(closeActiveConnections), (app.server = null), app.event.stop?.length)
			)
				for (let i = 0; i < app.event.stop.length; i++) app.event.stop[i].fn(app);
		}
	},
	composeGeneralHandler: {
		parameters: "r",
		createContext(app) {
			let decoratorsLiteral = "",
				fnLiteral = "",
				defaultHeaders = app.setHeaders;
			for (let key of Object.keys(app.decorator))
				decoratorsLiteral += `,'${key}':decorator['${key}']`;
			let standardHostname = app.config.handler?.standardHostname ?? true,
				hasTrace = !!app.event.trace?.length;
			if (
				((fnLiteral += `const u=r.url,s=u.indexOf('/',${standardHostname ? 11 : 7}),qi=u.indexOf('?',s+1),p=u.substring(s,qi===-1?undefined:qi)
`),
				hasTrace)
			)
				fnLiteral += `const id=randomId()
`;
			if (
				((fnLiteral += "const c={request:r,store,qi,path:p,url:u,redirect,status,set:{headers:"),
				(fnLiteral += Object.keys(defaultHeaders ?? {}).length
					? "Object.assign({},app.setHeaders)"
					: "Object.create(null)"),
				(fnLiteral += ",status:200}"),
				app.inference.server)
			)
				fnLiteral += ",get server(){return app.getServer()}";
			if (hasTrace) fnLiteral += ",[ELYSIA_REQUEST_ID]:id";
			return (
				(fnLiteral += decoratorsLiteral),
				(fnLiteral += `}
`),
				fnLiteral
			);
		},
		error404(hasEventHook, hasErrorHook, afterHandle = "") {
			let findDynamicRoute =
				"if(route===null){" +
				afterHandle +
				(hasErrorHook ? "" : "c.set.status=404") +
				`
return `;
			if (hasErrorHook) findDynamicRoute += `app.handleError(c,notFound,false,${this.parameters})`;
			else
				findDynamicRoute += hasEventHook
					? "c.response=c.responseValue=new Response(error404Message,{status:c.set.status===200?404:c.set.status,headers:c.set.headers})"
					: "c.response=c.responseValue=error404.clone()";
			return (
				(findDynamicRoute += "}"),
				{
					declare: hasErrorHook
						? ""
						: `const error404Message=notFound.message.toString()
const error404=new Response(error404Message,{status:404})
`,
					code: findDynamicRoute,
				}
			);
		},
	},
	composeError: {
		mapResponseContext: "",
		validationError:
			"return new Response(error.message,{headers:Object.assign({'content-type':'application/json'},set.headers),status:set.status})",
		unknownError:
			"return new Response(error.message,{headers:set.headers,status:error.status??set.status??500})",
	},
	listen() {
		return () => {
			throw Error(
				"WebStandard does not support listen, you might want to export default Elysia.fetch instead",
			);
		};
	},
};
function isCloudflareWorker() {
	try {
		if (typeof caches < "u" && typeof caches.default < "u") return true;
		if (typeof WebSocketPair < "u") return true;
	} catch {
		return false;
	}
	return false;
}
var CloudflareAdapter = {
	...WebStandardAdapter,
	name: "cloudflare-worker",
	composeGeneralHandler: {
		...WebStandardAdapter.composeGeneralHandler,
		error404(hasEventHook, hasErrorHook, afterHandle) {
			let { code } = WebStandardAdapter.composeGeneralHandler.error404(
				hasEventHook,
				hasErrorHook,
				afterHandle,
			);
			return {
				code,
				declare: hasErrorHook
					? ""
					: `const error404Message=notFound.message.toString()
const error404={clone:()=>new Response(error404Message,{status:404})}
`,
			};
		},
	},
	beforeCompile(app) {
		for (let route of app.routes) route.compile();
	},
	listen(app) {
		return (options, callback) => {
			(console.warn(
				"Cloudflare Worker does not support listen method. Please export default Elysia instance instead.",
			),
				app.compile());
		};
	},
};
var separateFunction = (code) => {
	if (code.startsWith("async")) code = code.slice(5);
	code = code.trimStart();
	let index = -1;
	if (code.charCodeAt(0) === 40) {
		if (((index = code.indexOf("=>", code.indexOf(")"))), index !== -1)) {
			let bracketEndIndex = index;
			while (bracketEndIndex > 0) if (code.charCodeAt(--bracketEndIndex) === 41) break;
			let body = code.slice(index + 2);
			if (body.charCodeAt(0) === 32) body = body.trimStart();
			return [code.slice(1, bracketEndIndex), body, { isArrowReturn: body.charCodeAt(0) !== 123 }];
		}
	}
	if (/^(\w+)=>/g.test(code)) {
		if (((index = code.indexOf("=>")), index !== -1)) {
			let body = code.slice(index + 2);
			if (body.charCodeAt(0) === 32) body = body.trimStart();
			return [code.slice(0, index), body, { isArrowReturn: body.charCodeAt(0) !== 123 }];
		}
	}
	if (code.startsWith("function")) {
		index = code.indexOf("(");
		let end = code.indexOf(")");
		return [code.slice(index + 1, end), code.slice(end + 2), { isArrowReturn: false }];
	}
	let start = code.indexOf("(");
	if (start !== -1) {
		let sep = code.indexOf(
				`
`,
				2,
			),
			parameter = code.slice(0, sep),
			end = parameter.lastIndexOf(")") + 1,
			body = code.slice(sep + 1);
		return [parameter.slice(start, end), "{" + body, { isArrowReturn: false }];
	}
	let x = code.split(
		`
`,
		2,
	);
	return [x[0], x[1], { isArrowReturn: false }];
};
var bracketPairRange = (parameter) => {
	let start = parameter.indexOf("{");
	if (start === -1) return [-1, 0];
	let end = start + 1,
		deep = 1;
	for (; end < parameter.length; end++) {
		let char = parameter.charCodeAt(end);
		if (char === 123) deep++;
		else if (char === 125) deep--;
		if (deep === 0) break;
	}
	if (deep !== 0) return [0, parameter.length];
	return [start, end + 1];
};
var bracketPairRangeReverse = (parameter) => {
	let end = parameter.lastIndexOf("}");
	if (end === -1) return [-1, 0];
	let start = end - 1,
		deep = 1;
	for (; start >= 0; start--) {
		let char = parameter.charCodeAt(start);
		if (char === 125) deep++;
		else if (char === 123) deep--;
		if (deep === 0) break;
	}
	if (deep !== 0) return [-1, 0];
	return [start, end + 1];
};
var removeColonAlias = (parameter) => {
	while (true) {
		let start = parameter.indexOf(":");
		if (start === -1) break;
		let end = parameter.indexOf(",", start);
		if (end === -1) end = parameter.indexOf("}", start) - 1;
		if (end === -2) end = parameter.length;
		parameter = parameter.slice(0, start) + parameter.slice(end);
	}
	return parameter;
};
var retrieveRootParamters = (parameter) => {
	let hasParenthesis = false;
	if (parameter.charCodeAt(0) === 40) parameter = parameter.slice(1, -1);
	if (parameter.charCodeAt(0) === 123)
		((hasParenthesis = true), (parameter = parameter.slice(1, -1)));
	parameter = parameter.replace(/( |\t|\n)/g, "").trim();
	let parameters = [];
	while (true) {
		let [start, end] = bracketPairRange(parameter);
		if (start === -1) break;
		if ((parameters.push(parameter.slice(0, start - 1)), parameter.charCodeAt(end) === 44)) end++;
		parameter = parameter.slice(end);
	}
	if (((parameter = removeColonAlias(parameter)), parameter))
		parameters = parameters.concat(parameter.split(","));
	let parameterMap = Object.create(null);
	for (let p of parameters) {
		if (p.indexOf(",") === -1) {
			parameterMap[p] = true;
			continue;
		}
		for (let q of p.split(",")) parameterMap[q.trim()] = true;
	}
	return { hasParenthesis, parameters: parameterMap };
};
var findParameterReference = (parameter, inference) => {
	let { parameters, hasParenthesis } = retrieveRootParamters(parameter);
	if (parameters.query) inference.query = true;
	if (parameters.headers) inference.headers = true;
	if (parameters.body) inference.body = true;
	if (parameters.cookie) inference.cookie = true;
	if (parameters.set) inference.set = true;
	if (parameters.server) inference.server = true;
	if (parameters.route) inference.route = true;
	if (parameters.url) inference.url = true;
	if (parameters.path) inference.path = true;
	if (hasParenthesis) return `{ ${Object.keys(parameters).join(", ")} }`;
	return Object.keys(parameters).join(", ");
};
var findEndIndex = (type, content, index) => {
	let regex2 = new RegExp(`${type.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}[\\n\\t,; ]`);
	if (index !== undefined) regex2.lastIndex = index;
	let match = regex2.exec(content);
	return match ? match.index : -1;
};
var findAlias = (type, body, depth = 0) => {
	if (depth > 5) return [];
	let aliases = [],
		content = body;
	while (true) {
		let index = findEndIndex(" = " + type, content);
		if (index === -1) index = findEndIndex("=" + type, content);
		if (index === -1) {
			let lastIndex = content.indexOf(" = " + type);
			if (lastIndex === -1) lastIndex = content.indexOf("=" + type);
			if (lastIndex + 3 + type.length !== content.length) break;
			index = lastIndex;
		}
		let part = content.slice(0, index),
			lastPart = part.lastIndexOf(" "),
			variable = part.slice(lastPart !== -1 ? lastPart + 1 : -1);
		if (variable === "}") {
			let [start, end] = bracketPairRangeReverse(part);
			(aliases.push(removeColonAlias(content.slice(start, end))),
				(content = content.slice(index + 3 + type.length)));
			continue;
		}
		while (variable.charCodeAt(0) === 44) variable = variable.slice(1);
		while (variable.charCodeAt(0) === 9) variable = variable.slice(1);
		if (!variable.includes("(")) aliases.push(variable);
		content = content.slice(index + 3 + type.length);
	}
	for (let alias of aliases) {
		if (alias.charCodeAt(0) === 123) continue;
		let deepAlias = findAlias(alias, body);
		if (deepAlias.length > 0) aliases.push(...deepAlias);
	}
	return aliases;
};
var extractMainParameter = (parameter) => {
	if (!parameter) return;
	if (parameter.charCodeAt(0) !== 123) return parameter;
	if (((parameter = parameter.slice(2, -2)), !parameter.includes(","))) {
		if (parameter.indexOf("...") !== -1) return parameter.slice(parameter.indexOf("...") + 3);
		return;
	}
	let spreadIndex = parameter.indexOf("...");
	if (spreadIndex === -1) return;
	return parameter.slice(spreadIndex + 3).trimEnd();
};
var inferBodyReference = (code, aliases, inference) => {
	let access = (type, alias) =>
		new RegExp(`${alias}\\.(${type})|${alias}\\["${type}"\\]|${alias}\\['${type}'\\]`).test(code);
	for (let alias of aliases) {
		if (!alias) continue;
		if (alias.charCodeAt(0) === 123) {
			let parameters = retrieveRootParamters(alias).parameters;
			if (parameters.query) inference.query = true;
			if (parameters.headers) inference.headers = true;
			if (parameters.body) inference.body = true;
			if (parameters.cookie) inference.cookie = true;
			if (parameters.set) inference.set = true;
			if (parameters.server) inference.server = true;
			if (parameters.url) inference.url = true;
			if (parameters.route) inference.route = true;
			if (parameters.path) inference.path = true;
			continue;
		}
		if (
			!inference.query &&
			(access("query", alias) ||
				code.includes("return " + alias) ||
				code.includes("return " + alias + ".query"))
		)
			inference.query = true;
		if (!inference.headers && access("headers", alias)) inference.headers = true;
		if (!inference.body && access("body", alias)) inference.body = true;
		if (!inference.cookie && access("cookie", alias)) inference.cookie = true;
		if (!inference.set && access("set", alias)) inference.set = true;
		if (!inference.server && access("server", alias)) inference.server = true;
		if (!inference.route && access("route", alias)) inference.route = true;
		if (!inference.url && access("url", alias)) inference.url = true;
		if (!inference.path && access("path", alias)) inference.path = true;
		if (
			inference.query &&
			inference.headers &&
			inference.body &&
			inference.cookie &&
			inference.set &&
			inference.server &&
			inference.route &&
			inference.url &&
			inference.path
		)
			break;
	}
	return aliases;
};
var isContextPassToFunction = (context, body, inference) => {
	try {
		let captureFunction = new RegExp(`\\w\\((.*?)?${context}`, "gs");
		captureFunction.test(body);
		let nextChar = body.charCodeAt(captureFunction.lastIndex);
		if (nextChar === 41 || nextChar === 44)
			return (
				(inference.query = true),
				(inference.headers = true),
				(inference.body = true),
				(inference.cookie = true),
				(inference.set = true),
				(inference.server = true),
				(inference.url = true),
				(inference.route = true),
				(inference.path = true),
				true
			);
		return false;
	} catch (error) {
		return (
			console.log(
				"[Sucrose] warning: unexpected isContextPassToFunction error, you may continue development as usual but please report the following to maintainers:",
			),
			console.log("--- body ---"),
			console.log(body),
			console.log("--- context ---"),
			console.log(context),
			true
		);
	}
};
var pendingGC;
var caches2 = {};
var clearSucroseCache = (delay) => {
	if (delay === null || isCloudflareWorker()) return;
	if (delay === undefined) delay = 295000;
	if (pendingGC) clearTimeout(pendingGC);
	pendingGC = setTimeout(() => {
		if (((caches2 = {}), (pendingGC = undefined), isBun)) Bun.gc(false);
	}, delay);
};
var mergeInference = (a, b) => {
	return {
		body: a.body || b.body,
		cookie: a.cookie || b.cookie,
		headers: a.headers || b.headers,
		query: a.query || b.query,
		set: a.set || b.set,
		server: a.server || b.server,
		url: a.url || b.url,
		route: a.route || b.route,
		path: a.path || b.path,
	};
};
var sucrose = (
	lifeCycle,
	inference = {
		query: false,
		headers: false,
		body: false,
		cookie: false,
		set: false,
		server: false,
		url: false,
		route: false,
		path: false,
	},
	settings = {},
) => {
	let events = [];
	if (lifeCycle.request?.length) events.push(...lifeCycle.request);
	if (lifeCycle.beforeHandle?.length) events.push(...lifeCycle.beforeHandle);
	if (lifeCycle.parse?.length) events.push(...lifeCycle.parse);
	if (lifeCycle.error?.length) events.push(...lifeCycle.error);
	if (lifeCycle.transform?.length) events.push(...lifeCycle.transform);
	if (lifeCycle.afterHandle?.length) events.push(...lifeCycle.afterHandle);
	if (lifeCycle.mapResponse?.length) events.push(...lifeCycle.mapResponse);
	if (lifeCycle.afterResponse?.length) events.push(...lifeCycle.afterResponse);
	if (lifeCycle.handler && typeof lifeCycle.handler === "function") events.push(lifeCycle.handler);
	for (let i = 0; i < events.length; i++) {
		let e = events[i];
		if (!e) continue;
		let event = typeof e === "object" ? e.fn : e;
		if (typeof event !== "function") continue;
		let content = event.toString(),
			key = checksum(content),
			cachedInference = caches2[key];
		if (cachedInference) {
			inference = mergeInference(inference, cachedInference);
			continue;
		}
		clearSucroseCache(settings.gcTime);
		let fnInference = {
				query: false,
				headers: false,
				body: false,
				cookie: false,
				set: false,
				server: false,
				url: false,
				route: false,
				path: false,
			},
			[parameter, body] = separateFunction(content),
			rootParameters = findParameterReference(parameter, fnInference),
			mainParameter = extractMainParameter(rootParameters);
		if (mainParameter) {
			let aliases = findAlias(mainParameter, body.slice(1, -1));
			aliases.splice(0, -1, mainParameter);
			let code = body;
			if (code.charCodeAt(0) === 123 && code.charCodeAt(body.length - 1) === 125)
				code = code.slice(1, -1);
			if (!isContextPassToFunction(mainParameter, code, fnInference))
				inferBodyReference(code, aliases, fnInference);
			if (!fnInference.query && code.includes("return " + mainParameter + ".query"))
				fnInference.query = true;
		}
		if (!caches2[key]) caches2[key] = fnInference;
		if (
			((inference = mergeInference(inference, fnInference)),
			inference.query &&
				inference.headers &&
				inference.body &&
				inference.cookie &&
				inference.set &&
				inference.server &&
				inference.url &&
				inference.route &&
				inference.path)
		)
			break;
	}
	return inference;
};
var mapResponse2 = (response, set2, request) => {
	if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie)
		switch ((handleSet(set2), response?.constructor?.name)) {
			case "String":
				return new Response(response, set2);
			case "Array":
			case "Object":
				return (
					(set2.headers["content-type"] = "application/json"),
					new Response(JSON.stringify(response), set2)
				);
			case "ElysiaFile":
				return handleFile(response.value, set2);
			case "File":
				return handleFile(response, set2);
			case "Blob":
				return handleFile(response, set2);
			case "ElysiaCustomStatusResponse":
				return ((set2.status = response.code), mapResponse2(response.response, set2, request));
			case undefined:
				if (!response) return new Response("", set2);
				return new Response(JSON.stringify(response), set2);
			case "Response":
				return handleResponse2(response, set2, request);
			case "Error":
				return errorToResponse2(response, set2);
			case "Promise":
				return response.then((x) => mapResponse2(x, set2, request));
			case "Function":
				return mapResponse2(response(), set2, request);
			case "Number":
			case "Boolean":
				return new Response(response.toString(), set2);
			case "Cookie":
				if (response instanceof Cookie) return new Response(response.value, set2);
				return new Response(response?.toString(), set2);
			case "FormData":
				return new Response(response, set2);
			default:
				if (response instanceof Response) return handleResponse2(response, set2, request);
				if (response instanceof Promise) return response.then((x) => mapResponse2(x, set2));
				if (response instanceof Error) return errorToResponse2(response, set2);
				if (response instanceof ElysiaCustomStatusResponse)
					return ((set2.status = response.code), mapResponse2(response.response, set2, request));
				if (typeof response?.next === "function" || response instanceof ReadableStream)
					return handleStream2(response, set2, request);
				if (typeof response?.then === "function")
					return response.then((x) => mapResponse2(x, set2));
				if (typeof response?.toResponse === "function")
					return mapResponse2(response.toResponse(), set2);
				if ("charCodeAt" in response) {
					let code = response.charCodeAt(0);
					if (code === 123 || code === 91) {
						if (!set2.headers["Content-Type"]) set2.headers["Content-Type"] = "application/json";
						return new Response(JSON.stringify(response), set2);
					}
				}
				return new Response(response, set2);
		}
	if (typeof response?.next === "function" || response instanceof ReadableStream)
		return handleStream2(response, set2, request);
	return mapCompactResponse2(response, request);
};
var mapEarlyResponse2 = (response, set2, request) => {
	if (response === undefined || response === null) return;
	if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.cookie)
		switch ((handleSet(set2), response?.constructor?.name)) {
			case "String":
				return new Response(response, set2);
			case "Array":
			case "Object":
				return (
					(set2.headers["content-type"] = "application/json"),
					new Response(JSON.stringify(response), set2)
				);
			case "ElysiaFile":
				return handleFile(response.value, set2);
			case "File":
				return handleFile(response, set2);
			case "Blob":
				return handleFile(response, set2);
			case "ElysiaCustomStatusResponse":
				return ((set2.status = response.code), mapEarlyResponse2(response.response, set2, request));
			case undefined:
				if (!response) return;
				return new Response(JSON.stringify(response), set2);
			case "Response":
				return handleResponse2(response, set2, request);
			case "Promise":
				return response.then((x) => mapEarlyResponse2(x, set2));
			case "Error":
				return errorToResponse2(response, set2);
			case "Function":
				return mapEarlyResponse2(response(), set2);
			case "Number":
			case "Boolean":
				return new Response(response.toString(), set2);
			case "FormData":
				return new Response(response);
			case "Cookie":
				if (response instanceof Cookie) return new Response(response.value, set2);
				return new Response(response?.toString(), set2);
			default:
				if (response instanceof Response) return handleResponse2(response, set2, request);
				if (response instanceof Promise) return response.then((x) => mapEarlyResponse2(x, set2));
				if (response instanceof Error) return errorToResponse2(response, set2);
				if (response instanceof ElysiaCustomStatusResponse)
					return (
						(set2.status = response.code),
						mapEarlyResponse2(response.response, set2, request)
					);
				if (typeof response?.next === "function" || response instanceof ReadableStream)
					return handleStream2(response, set2, request);
				if (typeof response?.then === "function")
					return response.then((x) => mapEarlyResponse2(x, set2));
				if (typeof response?.toResponse === "function")
					return mapEarlyResponse2(response.toResponse(), set2);
				if ("charCodeAt" in response) {
					let code = response.charCodeAt(0);
					if (code === 123 || code === 91) {
						if (!set2.headers["Content-Type"]) set2.headers["Content-Type"] = "application/json";
						return new Response(JSON.stringify(response), set2);
					}
				}
				return new Response(response, set2);
		}
	else
		switch (response?.constructor?.name) {
			case "String":
				return new Response(response);
			case "Array":
			case "Object":
				return (
					(set2.headers["content-type"] = "application/json"),
					new Response(JSON.stringify(response), set2)
				);
			case "ElysiaFile":
				return handleFile(response.value, set2);
			case "File":
				return handleFile(response, set2);
			case "Blob":
				return handleFile(response, set2);
			case "ElysiaCustomStatusResponse":
				return ((set2.status = response.code), mapEarlyResponse2(response.response, set2, request));
			case undefined:
				if (!response) return new Response("");
				return new Response(JSON.stringify(response), {
					headers: { "content-type": "application/json" },
				});
			case "Response":
				return response;
			case "Promise":
				return response.then((x) => {
					let r = mapEarlyResponse2(x, set2);
					if (r !== undefined) return r;
				});
			case "Error":
				return errorToResponse2(response, set2);
			case "Function":
				return mapCompactResponse2(response(), request);
			case "Number":
			case "Boolean":
				return new Response(response.toString());
			case "Cookie":
				if (response instanceof Cookie) return new Response(response.value, set2);
				return new Response(response?.toString(), set2);
			case "FormData":
				return new Response(response);
			default:
				if (response instanceof Response) return response;
				if (response instanceof Promise) return response.then((x) => mapEarlyResponse2(x, set2));
				if (response instanceof Error) return errorToResponse2(response, set2);
				if (response instanceof ElysiaCustomStatusResponse)
					return (
						(set2.status = response.code),
						mapEarlyResponse2(response.response, set2, request)
					);
				if (typeof response?.next === "function" || response instanceof ReadableStream)
					return handleStream2(response, set2, request);
				if (typeof response?.then === "function")
					return response.then((x) => mapEarlyResponse2(x, set2));
				if (typeof response?.toResponse === "function")
					return mapEarlyResponse2(response.toResponse(), set2);
				if ("charCodeAt" in response) {
					let code = response.charCodeAt(0);
					if (code === 123 || code === 91) {
						if (!set2.headers["Content-Type"]) set2.headers["Content-Type"] = "application/json";
						return new Response(JSON.stringify(response), set2);
					}
				}
				return new Response(response);
		}
};
var mapCompactResponse2 = (response, request) => {
	switch (response?.constructor?.name) {
		case "String":
			return new Response(response);
		case "Object":
		case "Array":
			return new Response(JSON.stringify(response), {
				headers: { "Content-Type": "application/json" },
			});
		case "ElysiaFile":
			return handleFile(response.value);
		case "File":
			return handleFile(response);
		case "Blob":
			return handleFile(response);
		case "ElysiaCustomStatusResponse":
			return mapResponse2(response.response, { status: response.code, headers: {} });
		case undefined:
			if (!response) return new Response("");
			return new Response(JSON.stringify(response), {
				headers: { "content-type": "application/json" },
			});
		case "Response":
			return response;
		case "Error":
			return errorToResponse2(response);
		case "Promise":
			return response.then((x) => mapCompactResponse2(x, request));
		case "Function":
			return mapCompactResponse2(response(), request);
		case "Number":
		case "Boolean":
			return new Response(response.toString());
		case "FormData":
			return new Response(response);
		default:
			if (response instanceof Response) return response;
			if (response instanceof Promise) return response.then((x) => mapCompactResponse2(x, request));
			if (response instanceof Error) return errorToResponse2(response);
			if (response instanceof ElysiaCustomStatusResponse)
				return mapResponse2(response.response, { status: response.code, headers: {} });
			if (typeof response?.next === "function" || response instanceof ReadableStream)
				return handleStream2(response, undefined, request);
			if (typeof response?.then === "function") return response.then((x) => mapResponse2(x, set));
			if (typeof response?.toResponse === "function")
				return mapCompactResponse2(response.toResponse());
			if ("charCodeAt" in response) {
				let code = response.charCodeAt(0);
				if (code === 123 || code === 91)
					return new Response(JSON.stringify(response), {
						headers: { "Content-Type": "application/json" },
					});
			}
			return new Response(response);
	}
};
var errorToResponse2 = (error, set2) => {
	if (typeof error?.toResponse === "function") {
		let raw = error.toResponse(),
			targetSet = set2 ?? { headers: {}, status: 200, redirect: "" },
			apply = (resolved) => {
				if (resolved instanceof Response) targetSet.status = resolved.status;
				return mapResponse2(resolved, targetSet);
			};
		return typeof raw?.then === "function" ? raw.then(apply) : apply(raw);
	}
	return new Response(
		JSON.stringify({ name: error?.name, message: error?.message, cause: error?.cause }),
		{ status: set2?.status !== 200 ? (set2?.status ?? 500) : 500, headers: set2?.headers },
	);
};
var createStaticHandler2 = (handle, hooks, setHeaders = {}) => {
	if (typeof handle === "function") return;
	let response = mapResponse2(handle, { headers: setHeaders });
	if (
		!hooks.parse?.length &&
		!hooks.transform?.length &&
		!hooks.beforeHandle?.length &&
		!hooks.afterHandle?.length
	)
		return () => response.clone();
};
var handleResponse2 = createResponseHandler({
	mapResponse: mapResponse2,
	mapCompactResponse: mapCompactResponse2,
});
var handleStream2 = createStreamHandler({
	mapResponse: mapResponse2,
	mapCompactResponse: mapCompactResponse2,
});
var import_fast_decode_uri_component3 = __toESM2(require_fast_decode_uri_component(), 1);
var import_fast_decode_uri_component2 = __toESM2(require_fast_decode_uri_component(), 1);
var KEY_HAS_PLUS = 1;
var KEY_NEEDS_DECODE = 2;
var VALUE_HAS_PLUS = 4;
var VALUE_NEEDS_DECODE = 8;
function parseQueryFromURL(input, startIndex = 0, array, object) {
	let result = Object.create(null),
		flags = 0,
		inputLength = input.length,
		startingIndex = startIndex - 1,
		equalityIndex = startingIndex;
	for (let i = 0; i < inputLength; i++)
		switch (input.charCodeAt(i)) {
			case 38:
				(processKeyValuePair(input, i), (startingIndex = i), (equalityIndex = i), (flags = 0));
				break;
			case 61:
				if (equalityIndex <= startingIndex) equalityIndex = i;
				else flags |= VALUE_NEEDS_DECODE;
				break;
			case 43:
				if (equalityIndex > startingIndex) flags |= VALUE_HAS_PLUS;
				else flags |= KEY_HAS_PLUS;
				break;
			case 37:
				if (equalityIndex > startingIndex) flags |= VALUE_NEEDS_DECODE;
				else flags |= KEY_NEEDS_DECODE;
				break;
		}
	if (startingIndex < inputLength) processKeyValuePair(input, inputLength);
	return result;
	function processKeyValuePair(input2, endIndex) {
		let hasBothKeyValuePair = equalityIndex > startingIndex,
			effectiveEqualityIndex = hasBothKeyValuePair ? equalityIndex : endIndex,
			keySlice = input2.slice(startingIndex + 1, effectiveEqualityIndex);
		if (!hasBothKeyValuePair && keySlice.length === 0) return;
		let finalKey = keySlice;
		if (flags & KEY_HAS_PLUS) finalKey = finalKey.replace(/\+/g, " ");
		if (flags & KEY_NEEDS_DECODE)
			finalKey = import_fast_decode_uri_component2.default(finalKey) || finalKey;
		let finalValue = "";
		if (hasBothKeyValuePair) {
			let valueSlice = input2.slice(equalityIndex + 1, endIndex);
			if (flags & VALUE_HAS_PLUS) valueSlice = valueSlice.replace(/\+/g, " ");
			if (flags & VALUE_NEEDS_DECODE)
				valueSlice = import_fast_decode_uri_component2.default(valueSlice) || valueSlice;
			finalValue = valueSlice;
		}
		let currentValue = result[finalKey];
		if (array?.[finalKey])
			if (finalValue.charCodeAt(0) === 91) {
				if (object?.[finalKey]) finalValue = JSON.parse(finalValue);
				else finalValue = finalValue.slice(1, -1).split(",");
				if (currentValue === undefined) result[finalKey] = finalValue;
				else if (Array.isArray(currentValue)) currentValue.push(...finalValue);
				else ((result[finalKey] = finalValue), result[finalKey].unshift(currentValue));
			} else if (currentValue === undefined) result[finalKey] = finalValue;
			else if (Array.isArray(currentValue)) currentValue.push(finalValue);
			else result[finalKey] = [currentValue, finalValue];
		else result[finalKey] = finalValue;
	}
}
function parseQueryStandardSchema(input, startIndex = 0) {
	let result = Object.create(null),
		flags = 0,
		inputLength = input.length,
		startingIndex = startIndex - 1,
		equalityIndex = startingIndex;
	for (let i = 0; i < inputLength; i++)
		switch (input.charCodeAt(i)) {
			case 38:
				(processKeyValuePair(input, i), (startingIndex = i), (equalityIndex = i), (flags = 0));
				break;
			case 61:
				if (equalityIndex <= startingIndex) equalityIndex = i;
				else flags |= VALUE_NEEDS_DECODE;
				break;
			case 43:
				if (equalityIndex > startingIndex) flags |= VALUE_HAS_PLUS;
				else flags |= KEY_HAS_PLUS;
				break;
			case 37:
				if (equalityIndex > startingIndex) flags |= VALUE_NEEDS_DECODE;
				else flags |= KEY_NEEDS_DECODE;
				break;
		}
	if (startingIndex < inputLength) processKeyValuePair(input, inputLength);
	return result;
	function processKeyValuePair(input2, endIndex) {
		let hasBothKeyValuePair = equalityIndex > startingIndex,
			effectiveEqualityIndex = hasBothKeyValuePair ? equalityIndex : endIndex,
			keySlice = input2.slice(startingIndex + 1, effectiveEqualityIndex);
		if (!hasBothKeyValuePair && keySlice.length === 0) return;
		let finalKey = keySlice;
		if (flags & KEY_HAS_PLUS) finalKey = finalKey.replace(/\+/g, " ");
		if (flags & KEY_NEEDS_DECODE)
			finalKey = import_fast_decode_uri_component2.default(finalKey) || finalKey;
		let finalValue = "";
		if (hasBothKeyValuePair) {
			let valueSlice = input2.slice(equalityIndex + 1, endIndex);
			if (flags & VALUE_HAS_PLUS) valueSlice = valueSlice.replace(/\+/g, " ");
			if (flags & VALUE_NEEDS_DECODE)
				valueSlice = import_fast_decode_uri_component2.default(valueSlice) || valueSlice;
			finalValue = valueSlice;
		}
		let currentValue = result[finalKey];
		if (finalValue.charCodeAt(0) === 91 && finalValue.charCodeAt(finalValue.length - 1) === 93) {
			try {
				finalValue = JSON.parse(finalValue);
			} catch {}
			if (currentValue === undefined) result[finalKey] = finalValue;
			else if (Array.isArray(currentValue)) currentValue.push(finalValue);
			else result[finalKey] = [currentValue, finalValue];
		} else if (
			finalValue.charCodeAt(0) === 123 &&
			finalValue.charCodeAt(finalValue.length - 1) === 125
		) {
			try {
				finalValue = JSON.parse(finalValue);
			} catch {}
			if (currentValue === undefined) result[finalKey] = finalValue;
			else if (Array.isArray(currentValue)) currentValue.push(finalValue);
			else result[finalKey] = [currentValue, finalValue];
		} else {
			if (finalValue.includes(",")) finalValue = finalValue.split(",");
			if (currentValue === undefined) result[finalKey] = finalValue;
			else if (Array.isArray(currentValue)) currentValue.push(finalValue);
			else result[finalKey] = [currentValue, finalValue];
		}
	}
}
function parseQuery(input) {
	let result = Object.create(null),
		flags = 0,
		inputLength = input.length,
		startingIndex = -1,
		equalityIndex = -1;
	for (let i = 0; i < inputLength; i++)
		switch (input.charCodeAt(i)) {
			case 38:
				(processKeyValuePair(input, i), (startingIndex = i), (equalityIndex = i), (flags = 0));
				break;
			case 61:
				if (equalityIndex <= startingIndex) equalityIndex = i;
				else flags |= VALUE_NEEDS_DECODE;
				break;
			case 43:
				if (equalityIndex > startingIndex) flags |= VALUE_HAS_PLUS;
				else flags |= KEY_HAS_PLUS;
				break;
			case 37:
				if (equalityIndex > startingIndex) flags |= VALUE_NEEDS_DECODE;
				else flags |= KEY_NEEDS_DECODE;
				break;
		}
	if (startingIndex < inputLength) processKeyValuePair(input, inputLength);
	return result;
	function processKeyValuePair(input2, endIndex) {
		let hasBothKeyValuePair = equalityIndex > startingIndex,
			effectiveEqualityIndex = hasBothKeyValuePair ? equalityIndex : endIndex,
			keySlice = input2.slice(startingIndex + 1, effectiveEqualityIndex);
		if (!hasBothKeyValuePair && keySlice.length === 0) return;
		let finalKey = keySlice;
		if (flags & KEY_HAS_PLUS) finalKey = finalKey.replace(/\+/g, " ");
		if (flags & KEY_NEEDS_DECODE)
			finalKey = import_fast_decode_uri_component2.default(finalKey) || finalKey;
		let finalValue = "";
		if (hasBothKeyValuePair) {
			let valueSlice = input2.slice(equalityIndex + 1, endIndex);
			if (flags & VALUE_HAS_PLUS) valueSlice = valueSlice.replace(/\+/g, " ");
			if (flags & VALUE_NEEDS_DECODE)
				valueSlice = import_fast_decode_uri_component2.default(valueSlice) || valueSlice;
			finalValue = valueSlice;
		}
		let currentValue = result[finalKey];
		if (currentValue === undefined) result[finalKey] = finalValue;
		else if (Array.isArray(currentValue)) currentValue.push(finalValue);
		else result[finalKey] = [currentValue, finalValue];
	}
}
var ELYSIA_TRACE = Symbol("ElysiaTrace");
var createProcess = () => {
	let { promise, resolve } = Promise.withResolvers(),
		{ promise: end, resolve: resolveEnd } = Promise.withResolvers(),
		{ promise: error, resolve: resolveError } = Promise.withResolvers(),
		callbacks = [],
		callbacksEnd = [];
	return [
		(callback) => {
			if (callback) callbacks.push(callback);
			return promise;
		},
		(process2) => {
			let processes = [],
				resolvers = [],
				groupError = null;
			for (let i = 0; i < (process2.total ?? 0); i++) {
				let { promise: promise2, resolve: resolve2 } = Promise.withResolvers(),
					{ promise: end2, resolve: resolveEnd2 } = Promise.withResolvers(),
					{ promise: error2, resolve: resolveError2 } = Promise.withResolvers(),
					callbacks2 = [],
					callbacksEnd2 = [];
				(processes.push((callback) => {
					if (callback) callbacks2.push(callback);
					return promise2;
				}),
					resolvers.push((process3) => {
						let result2 = {
							...process3,
							end: end2,
							error: error2,
							index: i,
							onStop(callback) {
								if (callback) callbacksEnd2.push(callback);
								return end2;
							},
						};
						resolve2(result2);
						for (let i2 = 0; i2 < callbacks2.length; i2++) callbacks2[i2](result2);
						return (error3 = null) => {
							let end3 = performance.now();
							if (error3) groupError = error3;
							let detail = {
								end: end3,
								error: error3,
								get elapsed() {
									return end3 - process3.begin;
								},
							};
							for (let i2 = 0; i2 < callbacksEnd2.length; i2++) callbacksEnd2[i2](detail);
							(resolveEnd2(end3), resolveError2(error3));
						};
					}));
			}
			let result = {
				...process2,
				end,
				error,
				onEvent(callback) {
					for (let i = 0; i < processes.length; i++) processes[i](callback);
				},
				onStop(callback) {
					if (callback) callbacksEnd.push(callback);
					return end;
				},
			};
			resolve(result);
			for (let i = 0; i < callbacks.length; i++) callbacks[i](result);
			return {
				resolveChild: resolvers,
				resolve(error2 = null) {
					let end2 = performance.now();
					if (!error2 && groupError) error2 = groupError;
					let detail = {
						end: end2,
						error: error2,
						get elapsed() {
							return end2 - process2.begin;
						},
					};
					for (let i = 0; i < callbacksEnd.length; i++) callbacksEnd[i](detail);
					(resolveEnd(end2), resolveError(error2));
				},
			};
		},
	];
};
var createTracer = (traceListener) => {
	return (context) => {
		let [onRequest, resolveRequest] = createProcess(),
			[onParse, resolveParse] = createProcess(),
			[onTransform, resolveTransform] = createProcess(),
			[onBeforeHandle, resolveBeforeHandle] = createProcess(),
			[onHandle, resolveHandle] = createProcess(),
			[onAfterHandle, resolveAfterHandle] = createProcess(),
			[onError, resolveError] = createProcess(),
			[onMapResponse, resolveMapResponse] = createProcess(),
			[onAfterResponse, resolveAfterResponse] = createProcess();
		return (
			traceListener({
				id: context[ELYSIA_REQUEST_ID],
				context,
				set: context.set,
				onRequest,
				onParse,
				onTransform,
				onBeforeHandle,
				onHandle,
				onAfterHandle,
				onMapResponse,
				onAfterResponse,
				onError,
				time: Date.now(),
				store: context.store,
			}),
			{
				request: resolveRequest,
				parse: resolveParse,
				transform: resolveTransform,
				beforeHandle: resolveBeforeHandle,
				handle: resolveHandle,
				afterHandle: resolveAfterHandle,
				error: resolveError,
				mapResponse: resolveMapResponse,
				afterResponse: resolveAfterResponse,
			}
		);
	};
};
var Kind3 = Symbol.for("TypeBox.Kind");
var Hint2 = Symbol.for("TypeBox.Hint");
var isSpecialProperty = (name) => /(\ |-|\t|\n|\.|\[|\]|\{|\})/.test(name) || !isNaN(+name[0]);
var joinProperty = (v1, v2, isOptional = false) => {
	if (typeof v2 === "number") return `${v1}[${v2}]`;
	if (isSpecialProperty(v2)) return `${v1}${isOptional ? "?." : ""}["${v2}"]`;
	return `${v1}${isOptional ? "?" : ""}.${v2}`;
};
var encodeProperty = (v) => (isSpecialProperty(v) ? `"${v}"` : v);
var sanitize = (key, sanitize2 = 0, schema) => {
	if (schema.type !== "string" || schema.const || schema.trusted) return key;
	let hof = "";
	for (let i = sanitize2 - 1; i >= 0; i--) hof += `d.h${i}(`;
	return hof + key + ")".repeat(sanitize2);
};
var mergeObjectIntersection = (schema) => {
	if (
		!schema.allOf ||
		(Kind3 in schema && (schema[Kind3] !== "Intersect" || schema.type !== "object"))
	)
		return schema;
	let { allOf, ...newSchema } = schema;
	if (((newSchema.properties = {}), Kind3 in newSchema)) newSchema[Kind3] = "Object";
	for (let type of allOf) {
		if (type.type !== "object") continue;
		let { properties, required, type: _2, [Kind3]: __, ...rest } = type;
		if (required)
			newSchema.required = newSchema.required ? newSchema.required.concat(required) : required;
		Object.assign(newSchema, rest);
		for (let property in type.properties)
			newSchema.properties[property] = mergeObjectIntersection(type.properties[property]);
	}
	return newSchema;
};
var handleRecord = (schema, property, instruction) => {
	let child =
		schema.patternProperties["^(.*)$"] ??
		schema.patternProperties[Object.keys(schema.patternProperties)[0]];
	if (!child) return property;
	let i = instruction.array;
	instruction.array++;
	let v = `(()=>{const ar${i}s=Object.keys(${property}),ar${i}v={};for(let i=0;i<ar${i}s.length;i++){const ar${i}p=${property}[ar${i}s[i]];ar${i}v[ar${i}s[i]]=${mirror(child, `ar${i}p`, instruction)}`,
		optionals = instruction.optionalsInArray[i + 1];
	if (optionals)
		for (let oi = 0; oi < optionals.length; oi++) {
			let target = `ar${i}v[ar${i}s[i]]${optionals[oi]}`;
			v += `;if(${target}===undefined)delete ${target}`;
		}
	return ((v += `}return ar${i}v})()`), v);
};
var handleTuple = (schema, property, instruction) => {
	let i = instruction.array;
	instruction.array++;
	let isRoot = property === "v" && !instruction.unions.length,
		v = "";
	if (!isRoot) v = "(()=>{";
	v += `const ar${i}v=[`;
	for (let i2 = 0; i2 < schema.length; i2++) {
		if (i2 !== 0) v += ",";
		v += mirror(schema[i2], joinProperty(property, i2, instruction.parentIsOptional), instruction);
	}
	if (((v += "];"), !isRoot)) v += `return ar${i}v})()`;
	return v;
};
function deepClone(source, weak = new WeakMap()) {
	if (source === null || typeof source !== "object" || typeof source === "function") return source;
	if (weak.has(source)) return weak.get(source);
	if (Array.isArray(source)) {
		let copy = Array(source.length);
		weak.set(source, copy);
		for (let i = 0; i < source.length; i++) copy[i] = deepClone(source[i], weak);
		return copy;
	}
	if (typeof source === "object") {
		let keys = Object.keys(source).concat(Object.getOwnPropertySymbols(source)),
			cloned = {};
		for (let key of keys) cloned[key] = deepClone(source[key], weak);
		return cloned;
	}
	return source;
}
var handleUnion = (schemas, property, instruction) => {
	if (instruction.TypeCompiler === undefined) {
		if (!instruction.typeCompilerWanred)
			(console.warn(Error("[exact-mirror] TypeBox's TypeCompiler is required to use Union")),
				(instruction.typeCompilerWanred = true));
		return property;
	}
	instruction.unionKeys[property] = 1;
	let ui = instruction.unions.length,
		typeChecks = (instruction.unions[ui] = []),
		v = `(()=>{
`,
		unwrapRef = (type) => {
			if (!(Kind3 in type) || !type.$ref) return type;
			if (type[Kind3] === "This") return deepClone(instruction.definitions[type.$ref]);
			else if (type[Kind3] === "Ref")
				if (!instruction.modules)
					console.warn(
						Error("[exact-mirror] modules is required when using nested cyclic reference"),
					);
				else return instruction.modules.Import(type.$ref);
			return type;
		};
	for (let i = 0; i < schemas.length; i++) {
		let type = unwrapRef(schemas[i]);
		if (Array.isArray(type.anyOf))
			for (let i2 = 0; i2 < type.anyOf.length; i2++) type.anyOf[i2] = unwrapRef(type.anyOf[i2]);
		else if (type.items)
			if (Array.isArray(type.items))
				for (let i2 = 0; i2 < type.items.length; i2++) type.items[i2] = unwrapRef(type.items[i2]);
			else type.items = unwrapRef(type.items);
		(typeChecks.push(TypeCompiler.Compile(type)),
			(v += `if(d.unions[${ui}][${i}].Check(${property})){return ${mirror(type, property, { ...instruction, recursion: instruction.recursion + 1, parentIsOptional: true })}}
`));
	}
	return ((v += `return ${instruction.removeUnknownUnionType ? "undefined" : property}})()`), v);
};
var mirror = (schema, property, instruction) => {
	if (!schema) return "";
	let isRoot = property === "v" && !instruction.unions.length;
	if (Kind3 in schema && schema[Kind3] === "Import" && schema.$ref in schema.$defs)
		return mirror(schema.$defs[schema.$ref], property, {
			...instruction,
			definitions: Object.assign(instruction.definitions, schema.$defs),
		});
	if (isRoot && schema.type !== "object" && schema.type !== "array" && !schema.anyOf)
		return `return ${sanitize("v", instruction.sanitize?.length, schema)}`;
	if (instruction.recursion >= instruction.recursionLimit) return property;
	let v = "";
	if (schema.$id && Hint2 in schema) instruction.definitions[schema.$id] = schema;
	switch (schema.type) {
		case "object":
			if (schema[Kind3] === "Record") {
				v = handleRecord(schema, property, instruction);
				break;
			}
			if (((schema = mergeObjectIntersection(schema)), (v += "{"), schema.additionalProperties))
				v += `...${property},`;
			let keys = Object.keys(schema.properties);
			for (let i2 = 0; i2 < keys.length; i2++) {
				let key = keys[i2],
					isOptional =
						!schema.required ||
						(schema.required && !schema.required.includes(key)) ||
						Array.isArray(schema.properties[key].anyOf),
					name = joinProperty(property, key, instruction.parentIsOptional);
				if (isOptional) {
					let index = instruction.array;
					if (property.startsWith("ar")) {
						let dotIndex = name.indexOf("."),
							refName;
						if (dotIndex >= 0) refName = name.slice(dotIndex);
						else refName = name.slice(property.length);
						if (refName.startsWith("?."))
							if (refName.charAt(2) === "[") refName = refName.slice(2);
							else refName = refName.slice(1);
						let array = instruction.optionalsInArray;
						if (array[index]) array[index].push(refName);
						else array[index] = [refName];
					} else instruction.optionals.push(name);
				}
				let child = schema.properties[key];
				if (i2 !== 0) v += ",";
				v += `${encodeProperty(key)}:${isOptional ? `${name}===undefined?undefined:` : ""}${mirror(child, name, { ...instruction, recursion: instruction.recursion + 1, parentIsOptional: isOptional })}`;
			}
			v += "}";
			break;
		case "array":
			if (schema.items.type !== "object" && schema.items.type !== "array")
				if (Array.isArray(schema.items)) {
					v = handleTuple(schema.items, property, instruction);
					break;
				} else if (isRoot) return "return v";
				else if (
					Kind3 in schema.items &&
					schema.items.$ref &&
					(schema.items[Kind3] === "Ref" || schema.items[Kind3] === "This")
				)
					v = mirror(deepClone(instruction.definitions[schema.items.$ref]), property, {
						...instruction,
						parentIsOptional: true,
						recursion: instruction.recursion + 1,
					});
				else {
					v = property;
					break;
				}
			let i = instruction.array;
			instruction.array++;
			let reference = property;
			if (isRoot) v = `const ar${i}v=new Array(${property}.length);`;
			else
				((reference = `ar${i}s`),
					(v = `((${reference})=>{const ar${i}v=new Array(${reference}.length);`));
			v += `for(let i=0;i<${reference}.length;i++){const ar${i}p=${reference}[i];ar${i}v[i]=${mirror(schema.items, `ar${i}p`, instruction)}`;
			let optionals = instruction.optionalsInArray[i + 1];
			if (optionals)
				for (let oi = 0; oi < optionals.length; oi++) {
					let target = `ar${i}v[i]${optionals[oi]}`;
					v += `;if(${target}===undefined)delete ${target}`;
				}
			if (((v += "}"), !isRoot)) v += `return ar${i}v})(${property})`;
			break;
		default:
			if (schema.$ref && schema.$ref in instruction.definitions)
				return mirror(instruction.definitions[schema.$ref], property, instruction);
			if (Array.isArray(schema.anyOf)) {
				v = handleUnion(schema.anyOf, property, instruction);
				break;
			}
			v = sanitize(property, instruction.sanitize?.length, schema);
			break;
	}
	if (!isRoot) return v;
	if (schema.type === "array") v = `${v}const x=ar0v;`;
	else
		v = `const x=${v}
`;
	for (let i = 0; i < instruction.optionals.length; i++) {
		let key = instruction.optionals[i],
			prop = key.slice(1);
		if (((v += `if(${key}===undefined`), instruction.unionKeys[key])) v += `||x${prop}===undefined`;
		let shouldQuestion = prop.charCodeAt(0) !== 63 && schema.type !== "array";
		v += `)delete x${shouldQuestion ? (prop.charCodeAt(0) === 91 ? "?." : "?") : ""}${prop}
`;
	}
	return `${v}return x`;
};
var createMirror = (
	schema,
	{
		TypeCompiler: TypeCompiler22,
		modules,
		definitions,
		sanitize: sanitize2,
		recursionLimit = 8,
		removeUnknownUnionType = false,
	} = {},
) => {
	let unions = [];
	if (typeof sanitize2 === "function") sanitize2 = [sanitize2];
	let f = mirror(schema, "v", {
		optionals: [],
		optionalsInArray: [],
		array: 0,
		parentIsOptional: false,
		unions,
		unionKeys: {},
		TypeCompiler: TypeCompiler22,
		modules,
		definitions: definitions ?? modules?.$defs ?? {},
		sanitize: sanitize2,
		recursion: 0,
		recursionLimit,
		removeUnknownUnionType,
	});
	if (!unions.length && !sanitize2?.length) return Function("v", f);
	let hof;
	if (sanitize2?.length) {
		hof = {};
		for (let i = 0; i < sanitize2.length; i++) hof[`h${i}`] = sanitize2[i];
	}
	return Function("d", `return function mirror(v){${f}}`)({ unions, ...hof });
};
var isOptional = (schema) => {
	if (!schema) return false;
	if (schema?.[Kind] === "Import" && schema.References) return schema.References().some(isOptional);
	if (schema.schema) schema = schema.schema;
	return !!schema && OptionalKind in schema;
};
var hasAdditionalProperties = (_schema) => {
	if (!_schema) return false;
	let schema = _schema?.schema ?? _schema;
	if (schema[Kind] === "Import" && _schema.References)
		return _schema.References().some(hasAdditionalProperties);
	if (schema.anyOf) return schema.anyOf.some(hasAdditionalProperties);
	if (schema.someOf) return schema.someOf.some(hasAdditionalProperties);
	if (schema.allOf) return schema.allOf.some(hasAdditionalProperties);
	if (schema.not) return schema.not.some(hasAdditionalProperties);
	if (schema.type === "object") {
		let properties = schema.properties;
		if ("additionalProperties" in schema) return schema.additionalProperties;
		if ("patternProperties" in schema) return false;
		for (let key of Object.keys(properties)) {
			let property = properties[key];
			if (property.type === "object") {
				if (hasAdditionalProperties(property)) return true;
			} else if (property.anyOf) {
				for (let i = 0; i < property.anyOf.length; i++)
					if (hasAdditionalProperties(property.anyOf[i])) return true;
			}
			return property.additionalProperties;
		}
		return false;
	}
	if (schema.type === "array" && schema.items && !Array.isArray(schema.items))
		return hasAdditionalProperties(schema.items);
	return false;
};
var hasType = (type, schema) => {
	if (!schema) return false;
	if (Kind in schema && schema[Kind] === type) return true;
	if (schema.type === "object") {
		let properties = schema.properties;
		if (!properties) return false;
		for (let key of Object.keys(properties)) {
			let property = properties[key];
			if (property.type === "object") {
				if (hasType(type, property)) return true;
			} else if (property.anyOf) {
				for (let i = 0; i < property.anyOf.length; i++)
					if (hasType(type, property.anyOf[i])) return true;
			}
			if (Kind in property && property[Kind] === type) return true;
		}
		return false;
	}
	return !!schema.properties && Kind in schema.properties && schema.properties[Kind] === type;
};
var hasElysiaMeta = (meta, _schema) => {
	if (!_schema) return false;
	let schema = _schema?.schema ?? _schema;
	if (schema.elysiaMeta === meta) return true;
	if (schema[Kind] === "Import" && _schema.References)
		return _schema.References().some((schema2) => hasElysiaMeta(meta, schema2));
	if (schema.anyOf) return schema.anyOf.some((schema2) => hasElysiaMeta(meta, schema2));
	if (schema.someOf) return schema.someOf.some((schema2) => hasElysiaMeta(meta, schema2));
	if (schema.allOf) return schema.allOf.some((schema2) => hasElysiaMeta(meta, schema2));
	if (schema.not) return schema.not.some((schema2) => hasElysiaMeta(meta, schema2));
	if (schema.type === "object") {
		let properties = schema.properties;
		for (let key of Object.keys(properties)) {
			let property = properties[key];
			if (property.type === "object") {
				if (hasElysiaMeta(meta, property)) return true;
			} else if (property.anyOf) {
				for (let i = 0; i < property.anyOf.length; i++)
					if (hasElysiaMeta(meta, property.anyOf[i])) return true;
			}
			return schema.elysiaMeta === meta;
		}
		return false;
	}
	if (schema.type === "array" && schema.items && !Array.isArray(schema.items))
		return hasElysiaMeta(meta, schema.items);
	return false;
};
var hasProperty = (expectedProperty, _schema) => {
	if (!_schema) return;
	let schema = _schema.schema ?? _schema;
	if (schema[Kind] === "Import" && _schema.References)
		return _schema.References().some((schema2) => hasProperty(expectedProperty, schema2));
	if (schema.type === "object") {
		let properties = schema.properties;
		if (!properties) return false;
		for (let key of Object.keys(properties)) {
			let property = properties[key];
			if (expectedProperty in property) return true;
			if (property.type === "object") {
				if (hasProperty(expectedProperty, property)) return true;
			} else if (property.anyOf) {
				for (let i = 0; i < property.anyOf.length; i++)
					if (hasProperty(expectedProperty, property.anyOf[i])) return true;
			}
		}
		return false;
	}
	return expectedProperty in schema;
};
var hasRef = (schema) => {
	if (!schema) return false;
	if (schema.oneOf) {
		for (let i = 0; i < schema.oneOf.length; i++) if (hasRef(schema.oneOf[i])) return true;
	}
	if (schema.anyOf) {
		for (let i = 0; i < schema.anyOf.length; i++) if (hasRef(schema.anyOf[i])) return true;
	}
	if (schema.oneOf) {
		for (let i = 0; i < schema.oneOf.length; i++) if (hasRef(schema.oneOf[i])) return true;
	}
	if (schema.allOf) {
		for (let i = 0; i < schema.allOf.length; i++) if (hasRef(schema.allOf[i])) return true;
	}
	if (schema.not && hasRef(schema.not)) return true;
	if (schema.type === "object" && schema.properties) {
		let properties = schema.properties;
		for (let key of Object.keys(properties)) {
			let property = properties[key];
			if (hasRef(property)) return true;
			if (property.type === "array" && property.items && hasRef(property.items)) return true;
		}
	}
	if (schema.type === "array" && schema.items && hasRef(schema.items)) return true;
	return schema[Kind] === "Ref" && "$ref" in schema;
};
var hasTransform = (schema) => {
	if (!schema) return false;
	if (
		schema.$ref &&
		schema.$defs &&
		schema.$ref in schema.$defs &&
		hasTransform(schema.$defs[schema.$ref])
	)
		return true;
	if (schema.oneOf) {
		for (let i = 0; i < schema.oneOf.length; i++) if (hasTransform(schema.oneOf[i])) return true;
	}
	if (schema.anyOf) {
		for (let i = 0; i < schema.anyOf.length; i++) if (hasTransform(schema.anyOf[i])) return true;
	}
	if (schema.allOf) {
		for (let i = 0; i < schema.allOf.length; i++) if (hasTransform(schema.allOf[i])) return true;
	}
	if (schema.not && hasTransform(schema.not)) return true;
	if (schema.type === "object" && schema.properties) {
		let properties = schema.properties;
		for (let key of Object.keys(properties)) {
			let property = properties[key];
			if (hasTransform(property)) return true;
			if (property.type === "array" && property.items && hasTransform(property.items)) return true;
		}
	}
	if (schema.type === "array" && schema.items && hasTransform(schema.items)) return true;
	return TransformKind in schema;
};
var replaceSchemaType = (schema, options, _config = {}) => {
	let config = _config;
	if (((config.root = true), !Array.isArray(options)))
		return ((options.original = schema), _replaceSchemaType(schema, options, config));
	for (let option of options)
		((option.original = schema), (schema = _replaceSchemaType(schema, option, config)));
	return schema;
};
var _replaceSchemaType = (schema, options, config) => {
	if (!schema) return schema;
	let root = config.root;
	if (options.onlyFirst && schema.type === options.onlyFirst) return options.to(schema) ?? schema;
	if (options.untilObjectFound && !root && schema.type === "object") return schema;
	let fromSymbol = options.from[Kind];
	if (schema.oneOf) {
		for (let i = 0; i < schema.oneOf.length; i++)
			schema.oneOf[i] = _replaceSchemaType(schema.oneOf[i], options, config);
		return schema;
	}
	if (schema.anyOf) {
		for (let i = 0; i < schema.anyOf.length; i++)
			schema.anyOf[i] = _replaceSchemaType(schema.anyOf[i], options, config);
		return schema;
	}
	if (schema.allOf) {
		for (let i = 0; i < schema.allOf.length; i++)
			schema.allOf[i] = _replaceSchemaType(schema.allOf[i], options, config);
		return schema;
	}
	if (schema.not) return _replaceSchemaType(schema.not, options, config);
	let isRoot = root && !!options.excludeRoot;
	if (schema[Kind] === fromSymbol) {
		let { anyOf, oneOf, allOf, not, properties: properties2, items, ...rest } = schema,
			to = options.to(rest);
		if (!to) return schema;
		let transform2,
			composeProperties = (schema2) => {
				let v = _composeProperties(schema2);
				if (v.$id) delete v.$id;
				return v;
			},
			_composeProperties = (v) => {
				if (properties2 && v.type === "object") {
					let newProperties = {};
					for (let [key, value2] of Object.entries(properties2))
						newProperties[key] = _replaceSchemaType(value2, options, { ...config, root: false });
					return { ...rest, ...v, properties: newProperties };
				}
				if (items && v.type === "array")
					return {
						...rest,
						...v,
						items: _replaceSchemaType(items, options, { ...config, root: false }),
					};
				let value = { ...rest, ...v };
				if (
					(delete value.required,
					properties2 && v.type === "string" && v.format === "ObjectString" && v.default === "{}")
				)
					((transform2 = t.ObjectString(properties2, rest)), (value.properties = properties2));
				else if (items && v.type === "string" && v.format === "ArrayString" && v.default === "[]")
					((transform2 = t.ArrayString(items, rest)), (value.items = items));
				return value;
			};
		if (isRoot) {
			if (properties2) {
				let newProperties = {};
				for (let [key, value] of Object.entries(properties2))
					newProperties[key] = _replaceSchemaType(value, options, { ...config, root: false });
				return { ...rest, properties: newProperties };
			} else if (items?.map)
				return {
					...rest,
					items: items.map((v) => _replaceSchemaType(v, options, { ...config, root: false })),
				};
			return rest;
		}
		if (to.anyOf)
			for (let i = 0; i < to.anyOf.length; i++) to.anyOf[i] = composeProperties(to.anyOf[i]);
		else if (to.oneOf)
			for (let i = 0; i < to.oneOf.length; i++) to.oneOf[i] = composeProperties(to.oneOf[i]);
		else if (to.allOf)
			for (let i = 0; i < to.allOf.length; i++) to.allOf[i] = composeProperties(to.allOf[i]);
		else if (to.not) to.not = composeProperties(to.not);
		if (transform2) to[TransformKind] = transform2[TransformKind];
		if (to.anyOf || to.oneOf || to.allOf || to.not) return to;
		if (properties2) {
			let newProperties = {};
			for (let [key, value] of Object.entries(properties2))
				newProperties[key] = _replaceSchemaType(value, options, { ...config, root: false });
			return { ...rest, ...to, properties: newProperties };
		} else if (items?.map)
			return {
				...rest,
				...to,
				items: items.map((v) => _replaceSchemaType(v, options, { ...config, root: false })),
			};
		return { ...rest, ...to };
	}
	let properties = schema?.properties;
	if (properties && root && options.rootOnly !== true)
		for (let [key, value] of Object.entries(properties))
			switch (value[Kind]) {
				case fromSymbol:
					let { anyOf, oneOf, allOf, not, type, ...rest } = value,
						to = options.to(rest);
					if (!to) return schema;
					if (to.anyOf)
						for (let i = 0; i < to.anyOf.length; i++) to.anyOf[i] = { ...rest, ...to.anyOf[i] };
					else if (to.oneOf)
						for (let i = 0; i < to.oneOf.length; i++) to.oneOf[i] = { ...rest, ...to.oneOf[i] };
					else if (to.allOf)
						for (let i = 0; i < to.allOf.length; i++) to.allOf[i] = { ...rest, ...to.allOf[i] };
					else if (to.not) to.not = { ...rest, ...to.not };
					properties[key] = {
						...rest,
						..._replaceSchemaType(rest, options, { ...config, root: false }),
					};
					break;
				case "Object":
				case "Union":
					properties[key] = _replaceSchemaType(value, options, { ...config, root: false });
					break;
				default:
					if (Array.isArray(value.items))
						for (let i = 0; i < value.items.length; i++)
							value.items[i] = _replaceSchemaType(value.items[i], options, {
								...config,
								root: false,
							});
					else if (value.anyOf || value.oneOf || value.allOf || value.not)
						properties[key] = _replaceSchemaType(value, options, { ...config, root: false });
					else if (value.type === "array")
						value.items = _replaceSchemaType(value.items, options, { ...config, root: false });
					break;
			}
	if (schema.type === "array" && schema.items)
		if (Array.isArray(schema.items))
			schema.items = schema.items.map((item) =>
				_replaceSchemaType(item, options, { ...config, root: false }),
			);
		else schema.items = _replaceSchemaType(schema.items, options, { ...config, root: false });
	return schema;
};
var createCleaner = (schema) => (value) => {
	if (typeof value === "object")
		try {
			return exports_value2.Clean(schema, value);
		} catch {}
	return value;
};
var getSchemaValidator = (
	s,
	{
		models = {},
		dynamic = false,
		modules,
		normalize = false,
		additionalProperties = false,
		forceAdditionalProperties = false,
		coerce = false,
		additionalCoerce = [],
		validators,
		sanitize: sanitize2,
	} = {},
) => {
	if (((validators = validators?.filter((x) => x)), !s)) {
		if (!validators?.length) return;
		((s = validators[0]), (validators = validators.slice(1)));
	}
	let doesHaveRef = undefined,
		replaceSchema = (schema2) => {
			if (coerce)
				return replaceSchemaType(schema2, [
					{ from: t.Number(), to: (options) => t.Numeric(options), untilObjectFound: true },
					{ from: t.Boolean(), to: (options) => t.BooleanString(options), untilObjectFound: true },
					...(Array.isArray(additionalCoerce) ? additionalCoerce : [additionalCoerce]),
				]);
			return replaceSchemaType(schema2, additionalCoerce);
		},
		mapSchema = (s2) => {
			if (s2 && typeof s2 !== "string" && "~standard" in s2) return s2;
			if (!s2) return;
			let schema2;
			if (typeof s2 !== "string") schema2 = s2;
			else if (
				((schema2 = modules && s2 in modules.$defs ? modules.Import(s2) : models[s2]), !schema2)
			)
				return;
			if (Kind in schema2) {
				if (schema2[Kind] === "Import") {
					if (!hasRef(schema2.$defs[schema2.$ref])) {
						if (((schema2 = schema2.$defs[schema2.$ref]), coerce || additionalCoerce))
							schema2 = replaceSchema(schema2);
					}
				} else if (hasRef(schema2)) {
					let id = randomId();
					schema2 = t.Module({ ...modules?.$defs, [id]: schema2 }).Import(id);
				} else if (coerce || additionalCoerce) schema2 = replaceSchema(schema2);
			}
			return schema2;
		},
		schema = mapSchema(s),
		_validators = validators;
	if (
		"~standard" in schema ||
		(validators?.length && validators.some((x) => x && typeof x !== "string" && "~standard" in x))
	) {
		let typeboxSubValidator = (schema2) => {
				let mirror2;
				if (normalize === true || normalize === "exactMirror")
					try {
						mirror2 = createMirror(schema2, { TypeCompiler, sanitize: sanitize2?.(), modules });
					} catch {
						(console.warn(
							"Failed to create exactMirror. Please report the following code to https://github.com/elysiajs/elysia/issues",
						),
							console.warn(schema2),
							(mirror2 = createCleaner(schema2)));
					}
				let vali = getSchemaValidator(schema2, {
					models,
					modules,
					dynamic,
					normalize,
					additionalProperties: true,
					forceAdditionalProperties: true,
					coerce,
					additionalCoerce,
				});
				return (
					(vali.Decode = mirror2),
					(v) => {
						if (vali.Check(v)) return { value: vali.Decode(v) };
						else return { issues: [...vali.Errors(v)] };
					}
				);
			},
			mainCheck = schema["~standard"] ? schema["~standard"].validate : typeboxSubValidator(schema),
			checkers = [];
		if (validators?.length)
			for (let validator2 of validators) {
				if (!validator2) continue;
				if (typeof validator2 === "string") continue;
				if (validator2?.["~standard"]) {
					checkers.push(validator2["~standard"]);
					continue;
				}
				if (Kind in validator2) {
					checkers.push(typeboxSubValidator(validator2));
					continue;
				}
			}
		async function Check2(value) {
			let v = mainCheck(value);
			if (v instanceof Promise) v = await v;
			if (v.issues) return v;
			let values = [];
			if (v && typeof v === "object") values.push(v.value);
			for (let i = 0; i < checkers.length; i++) {
				if (((v = checkers[i].validate(value)), v instanceof Promise)) v = await v;
				if (v.issues) return v;
				if (v && typeof v === "object") values.push(v.value);
			}
			if (!values.length) return { value: v };
			if (values.length === 1) return { value: values[0] };
			if (values.length === 2) return { value: mergeDeep(values[0], values[1]) };
			let newValue = mergeDeep(values[0], values[1]);
			for (let i = 2; i < values.length; i++) newValue = mergeDeep(newValue, values[i]);
			return { value: newValue };
		}
		let validator = {
			provider: "standard",
			schema,
			references: "",
			checkFunc: () => {},
			code: "",
			Check: Check2,
			Errors: (value) => Check2(value)?.then?.((x) => x?.issues),
			Code: () => "",
			Decode: Check2,
			Encode: (value) => value,
			hasAdditionalProperties: false,
			hasDefault: false,
			isOptional: false,
			hasTransform: false,
			hasRef: false,
		};
		return (
			(validator.parse = (v) => {
				try {
					return validator.Decode(validator.Clean?.(v) ?? v);
				} catch (error) {
					throw [...validator.Errors(v)].map(mapValueError);
				}
			}),
			(validator.safeParse = (v) => {
				try {
					return { success: true, data: validator.Decode(validator.Clean?.(v) ?? v), error: null };
				} catch (error) {
					let errors = [...compiled.Errors(v)].map(mapValueError);
					return { success: false, data: null, error: errors[0]?.summary, errors };
				}
			}),
			validator
		);
	} else if (validators?.length) {
		let hasAdditional = false,
			validators2 = _validators,
			{ schema: mergedObjectSchema, notObjects } = mergeObjectSchemas([
				schema,
				...validators2.map(mapSchema),
			]);
		if (notObjects) {
			if (
				((schema = t.Intersect([
					...(mergedObjectSchema ? [mergedObjectSchema] : []),
					...notObjects.map((x) => {
						let schema2 = mapSchema(x);
						if (schema2.type === "object" && "additionalProperties" in schema2) {
							if (!hasAdditional && schema2.additionalProperties === false) hasAdditional = true;
							delete schema2.additionalProperties;
						}
						return schema2;
					}),
				])),
				schema.type === "object" && hasAdditional)
			)
				schema.additionalProperties = false;
		}
	} else if (
		schema.type === "object" &&
		("additionalProperties" in schema === false || forceAdditionalProperties)
	)
		schema.additionalProperties = additionalProperties;
	else
		schema = replaceSchemaType(schema, {
			onlyFirst: "object",
			from: t.Object({}),
			to({ properties, ...options }) {
				if (!properties) return;
				if ("additionalProperties" in schema) return;
				return t.Object(properties, { ...options, additionalProperties: false });
			},
		});
	if (dynamic)
		if (Kind in schema) {
			let validator = {
				provider: "typebox",
				schema,
				references: "",
				checkFunc: () => {},
				code: "",
				Check: (value) => exports_value2.Check(schema, value),
				Errors: (value) => exports_value2.Errors(schema, value),
				Code: () => "",
				Clean: createCleaner(schema),
				Decode: (value) => exports_value2.Decode(schema, value),
				Encode: (value) => exports_value2.Encode(schema, value),
				get hasAdditionalProperties() {
					if ("~hasAdditionalProperties" in this) return this["~hasAdditionalProperties"];
					return (this["~hasAdditionalProperties"] = hasAdditionalProperties(schema));
				},
				get hasDefault() {
					if ("~hasDefault" in this) return this["~hasDefault"];
					return (this["~hasDefault"] = hasProperty("default", schema));
				},
				get isOptional() {
					if ("~isOptional" in this) return this["~isOptional"];
					return (this["~isOptional"] = isOptional(schema));
				},
				get hasTransform() {
					if ("~hasTransform" in this) return this["~hasTransform"];
					return (this["~hasTransform"] = hasTransform(schema));
				},
				"~hasRef": doesHaveRef,
				get hasRef() {
					if ("~hasRef" in this) return this["~hasRef"];
					return (this["~hasRef"] = hasTransform(schema));
				},
			};
			if (schema.config) {
				if (((validator.config = schema.config), validator?.schema?.config))
					delete validator.schema.config;
			}
			if (normalize && schema.additionalProperties === false)
				if (normalize === true || normalize === "exactMirror")
					try {
						validator.Clean = createMirror(schema, {
							TypeCompiler,
							sanitize: sanitize2?.(),
							modules,
						});
					} catch {
						(console.warn(
							"Failed to create exactMirror. Please report the following code to https://github.com/elysiajs/elysia/issues",
						),
							console.warn(schema),
							(validator.Clean = createCleaner(schema)));
					}
				else validator.Clean = createCleaner(schema);
			return (
				(validator.parse = (v) => {
					try {
						return validator.Decode(validator.Clean?.(v) ?? v);
					} catch (error) {
						throw [...validator.Errors(v)].map(mapValueError);
					}
				}),
				(validator.safeParse = (v) => {
					try {
						return {
							success: true,
							data: validator.Decode(validator.Clean?.(v) ?? v),
							error: null,
						};
					} catch (error) {
						let errors = [...compiled.Errors(v)].map(mapValueError);
						return { success: false, data: null, error: errors[0]?.summary, errors };
					}
				}),
				validator
			);
		} else {
			let validator = {
				provider: "standard",
				schema,
				references: "",
				checkFunc: () => {},
				code: "",
				Check: (v) => schema["~standard"].validate(v),
				Errors(value) {
					let response = schema["~standard"].validate(value);
					if (response instanceof Promise)
						throw Error("Async validation is not supported in non-dynamic schema");
					return response.issues;
				},
				Code: () => "",
				Decode(value) {
					let response = schema["~standard"].validate(value);
					if (response instanceof Promise)
						throw Error("Async validation is not supported in non-dynamic schema");
					return response;
				},
				Encode: (value) => value,
				hasAdditionalProperties: false,
				hasDefault: false,
				isOptional: false,
				hasTransform: false,
				hasRef: false,
			};
			return (
				(validator.parse = (v) => {
					try {
						return validator.Decode(validator.Clean?.(v) ?? v);
					} catch (error) {
						throw [...validator.Errors(v)].map(mapValueError);
					}
				}),
				(validator.safeParse = (v) => {
					try {
						return {
							success: true,
							data: validator.Decode(validator.Clean?.(v) ?? v),
							error: null,
						};
					} catch (error) {
						let errors = [...compiled.Errors(v)].map(mapValueError);
						return { success: false, data: null, error: errors[0]?.summary, errors };
					}
				}),
				validator
			);
		}
	let compiled;
	if (Kind in schema) {
		if (
			((compiled = TypeCompiler.Compile(
				schema,
				Object.values(models).filter((x) => Kind in x),
			)),
			(compiled.provider = "typebox"),
			schema.config)
		) {
			if (((compiled.config = schema.config), compiled?.schema?.config))
				delete compiled.schema.config;
		}
		if (normalize === true || normalize === "exactMirror")
			try {
				compiled.Clean = createMirror(schema, { TypeCompiler, sanitize: sanitize2?.(), modules });
			} catch (error) {
				(console.warn(
					"Failed to create exactMirror. Please report the following code to https://github.com/elysiajs/elysia/issues",
				),
					console.dir(schema, { depth: null }),
					(compiled.Clean = createCleaner(schema)));
			}
		else if (normalize === "typebox") compiled.Clean = createCleaner(schema);
	} else
		compiled = {
			provider: "standard",
			schema,
			references: "",
			checkFunc(value) {
				let response = schema["~standard"].validate(value);
				if (response instanceof Promise)
					throw Error("Async validation is not supported in non-dynamic schema");
				return response;
			},
			code: "",
			Check: (v) => schema["~standard"].validate(v),
			Errors(value) {
				let response = schema["~standard"].validate(value);
				if (response instanceof Promise)
					throw Error("Async validation is not supported in non-dynamic schema");
				return response.issues;
			},
			Code: () => "",
			Decode(value) {
				let response = schema["~standard"].validate(value);
				if (response instanceof Promise)
					throw Error("Async validation is not supported in non-dynamic schema");
				return response;
			},
			Encode: (value) => value,
			hasAdditionalProperties: false,
			hasDefault: false,
			isOptional: false,
			hasTransform: false,
			hasRef: false,
		};
	if (
		((compiled.parse = (v) => {
			try {
				return compiled.Decode(compiled.Clean?.(v) ?? v);
			} catch (error) {
				throw [...compiled.Errors(v)].map(mapValueError);
			}
		}),
		(compiled.safeParse = (v) => {
			try {
				return { success: true, data: compiled.Decode(compiled.Clean?.(v) ?? v), error: null };
			} catch (error) {
				let errors = [...compiled.Errors(v)].map(mapValueError);
				return { success: false, data: null, error: errors[0]?.summary, errors };
			}
		}),
		Kind in schema)
	)
		Object.assign(compiled, {
			get hasAdditionalProperties() {
				if ("~hasAdditionalProperties" in this) return this["~hasAdditionalProperties"];
				return (this["~hasAdditionalProperties"] = hasAdditionalProperties(compiled));
			},
			get hasDefault() {
				if ("~hasDefault" in this) return this["~hasDefault"];
				return (this["~hasDefault"] = hasProperty("default", compiled));
			},
			get isOptional() {
				if ("~isOptional" in this) return this["~isOptional"];
				return (this["~isOptional"] = isOptional(compiled));
			},
			get hasTransform() {
				if ("~hasTransform" in this) return this["~hasTransform"];
				return (this["~hasTransform"] = hasTransform(schema));
			},
			get hasRef() {
				if ("~hasRef" in this) return this["~hasRef"];
				return (this["~hasRef"] = hasRef(schema));
			},
			"~hasRef": doesHaveRef,
		});
	return compiled;
};
var isUnion = (schema) => schema[Kind] === "Union" || (!schema.schema && !!schema.anyOf);
var mergeObjectSchemas = (schemas) => {
	if (schemas.length === 0) return { schema: undefined, notObjects: [] };
	if (schemas.length === 1)
		return schemas[0].type === "object"
			? { schema: schemas[0], notObjects: [] }
			: { schema: undefined, notObjects: schemas };
	let newSchema,
		notObjects = [],
		additionalPropertiesIsTrue = false,
		additionalPropertiesIsFalse = false;
	for (let schema of schemas) {
		if (schema.type !== "object") {
			notObjects.push(schema);
			continue;
		}
		if ("additionalProperties" in schema) {
			if (schema.additionalProperties === true) additionalPropertiesIsTrue = true;
			else if (schema.additionalProperties === false) additionalPropertiesIsFalse = true;
		}
		if (!newSchema) {
			newSchema = schema;
			continue;
		}
		newSchema = {
			...newSchema,
			...schema,
			properties: { ...newSchema.properties, ...schema.properties },
			required: [...(newSchema?.required ?? []), ...(schema.required ?? [])],
		};
	}
	if (newSchema) {
		if (newSchema.required) newSchema.required = [...new Set(newSchema.required)];
		if (additionalPropertiesIsFalse) newSchema.additionalProperties = false;
		else if (additionalPropertiesIsTrue) newSchema.additionalProperties = true;
	}
	return { schema: newSchema, notObjects };
};
var getResponseSchemaValidator = (
	s,
	{
		models = {},
		modules,
		dynamic = false,
		normalize = false,
		additionalProperties = false,
		validators = [],
		sanitize: sanitize2,
	},
) => {
	if (((validators = validators.filter((x) => x)), !s)) {
		if (!validators?.length) return;
		((s = validators[0]), (validators = validators.slice(1)));
	}
	let maybeSchemaOrRecord;
	if (typeof s !== "string") maybeSchemaOrRecord = s;
	else if (
		((maybeSchemaOrRecord = modules && s in modules.$defs ? modules.Import(s) : models[s]),
		!maybeSchemaOrRecord)
	)
		return;
	if (!maybeSchemaOrRecord) return;
	if (Kind in maybeSchemaOrRecord || "~standard" in maybeSchemaOrRecord)
		return {
			200: getSchemaValidator(maybeSchemaOrRecord, {
				modules,
				models,
				additionalProperties,
				dynamic,
				normalize,
				coerce: false,
				additionalCoerce: [],
				validators: validators.map((x) => x[200]),
				sanitize: sanitize2,
			}),
		};
	let record = {};
	return (
		Object.keys(maybeSchemaOrRecord).forEach((status2) => {
			if (isNaN(+status2)) return;
			let maybeNameOrSchema = maybeSchemaOrRecord[+status2];
			if (typeof maybeNameOrSchema === "string") {
				if (maybeNameOrSchema in models) {
					let schema = models[maybeNameOrSchema];
					if (!schema) return;
					record[+status2] =
						Kind in schema || "~standard" in schema
							? getSchemaValidator(schema, {
									modules,
									models,
									additionalProperties,
									dynamic,
									normalize,
									coerce: false,
									additionalCoerce: [],
									validators: validators.map((x) => x[+status2]),
									sanitize: sanitize2,
								})
							: schema;
				}
				return;
			}
			record[+status2] =
				Kind in maybeNameOrSchema || "~standard" in maybeNameOrSchema
					? getSchemaValidator(maybeNameOrSchema, {
							modules,
							models,
							additionalProperties,
							dynamic,
							normalize,
							coerce: false,
							additionalCoerce: [],
							validators: validators.map((x) => x[+status2]),
							sanitize: sanitize2,
						})
					: maybeNameOrSchema;
		}),
		record
	);
};
var _stringToStructureCoercions;
var stringToStructureCoercions = () => {
	if (!_stringToStructureCoercions)
		_stringToStructureCoercions = [
			{ from: t.Object({}), to: () => t.ObjectString({}), excludeRoot: true },
			{ from: t.Array(t.Any()), to: () => t.ArrayString(t.Any()) },
		];
	return _stringToStructureCoercions;
};
var _queryCoercions;
var queryCoercions = () => {
	if (!_queryCoercions)
		_queryCoercions = [
			{ from: t.Object({}), to: () => t.ObjectString({}), excludeRoot: true },
			{ from: t.Array(t.Any()), to: () => t.ArrayQuery(t.Any()) },
		];
	return _queryCoercions;
};
var _coercePrimitiveRoot;
var coercePrimitiveRoot = () => {
	if (!_coercePrimitiveRoot)
		_coercePrimitiveRoot = [
			{ from: t.Number(), to: (options) => t.Numeric(options), rootOnly: true },
			{ from: t.Boolean(), to: (options) => t.BooleanString(options), rootOnly: true },
		];
	return _coercePrimitiveRoot;
};
var getCookieValidator = ({
	validator,
	modules,
	defaultConfig = {},
	config,
	dynamic,
	normalize = false,
	models,
	validators,
	sanitize: sanitize2,
}) => {
	let cookieValidator = validator?.provider
		? validator
		: getSchemaValidator(validator, {
				modules,
				dynamic,
				models,
				normalize,
				additionalProperties: true,
				coerce: true,
				additionalCoerce: stringToStructureCoercions(),
				validators,
				sanitize: sanitize2,
			});
	if (cookieValidator) cookieValidator.config = mergeCookie(cookieValidator.config, config);
	else
		((cookieValidator = getSchemaValidator(t.Cookie(t.Any()), {
			modules,
			dynamic,
			models,
			additionalProperties: true,
			validators,
			sanitize: sanitize2,
		})),
			(cookieValidator.config = defaultConfig));
	return cookieValidator;
};
var unwrapImportSchema = (schema) =>
	schema && schema[Kind] === "Import" && schema.$defs[schema.$ref][Kind] === "Object"
		? schema.$defs[schema.$ref]
		: schema;
var allocateIf = (value, condition) => (condition ? value : "");
var defaultParsers = [
	"json",
	"text",
	"urlencoded",
	"arrayBuffer",
	"formdata",
	"application/json",
	"text/plain",
	"application/x-www-form-urlencoded",
	"application/octet-stream",
	"multipart/form-data",
];
var createReport = ({ context = "c", trace = [], addFn }) => {
	if (!trace.length)
		return () => {
			return {
				resolveChild() {
					return () => {};
				},
				resolve() {},
			};
		};
	for (let i = 0; i < trace.length; i++)
		addFn(`let report${i},reportChild${i},reportErr${i},reportErrChild${i};let trace${i}=${context}[ELYSIA_TRACE]?.[${i}]??trace[${i}](${context});
`);
	return (event, { name, total = 0, alias } = {}) => {
		if (!name) name = "anonymous";
		let reporter = event === "error" ? "reportErr" : "report";
		for (let i = 0; i < trace.length; i++)
			if (
				(addFn(`${alias ? "const " : ""}${alias ?? reporter}${i}=trace${i}.${event}({id,event:'${event}',name:'${name}',begin:performance.now(),total:${total}})
`),
				alias)
			)
				addFn(`${reporter}${i}=${alias}${i}
`);
		return {
			resolve() {
				for (let i = 0; i < trace.length; i++)
					addFn(`${alias ?? reporter}${i}.resolve()
`);
			},
			resolveChild(name2) {
				for (let i = 0; i < trace.length; i++)
					addFn(`${reporter}Child${i}=${reporter}${i}.resolveChild?.shift()?.({id,event:'${event}',name:'${name2}',begin:performance.now()})
`);
				return (binding) => {
					for (let i = 0; i < trace.length; i++)
						if (binding)
							addFn(
								`if(${binding} instanceof Error){${reporter}Child${i}?.(${binding}) }else{${reporter}Child${i}?.()}`,
							);
						else
							addFn(`${reporter}Child${i}?.()
`);
				};
			},
		};
	};
};
var composeCleaner = ({
	schema,
	name,
	type,
	typeAlias = type,
	normalize,
	ignoreTryCatch = false,
}) => {
	if (!normalize || !schema.Clean) return "";
	if (normalize === true || normalize === "exactMirror") {
		if (ignoreTryCatch)
			return `${name}=validator.${typeAlias}.Clean(${name})
`;
		return `try{${name}=validator.${typeAlias}.Clean(${name})
}catch{}`;
	}
	if (normalize === "typebox")
		return `${name}=validator.${typeAlias}.Clean(${name})
`;
	return "";
};
var composeValidationFactory = ({
	injectResponse = "",
	normalize = false,
	validator,
	encodeSchema = false,
	isStaticResponse = false,
	hasSanitize = false,
	allowUnsafeValidationDetails = false,
}) => ({
	validate: (type, value = `c.${type}`, error) =>
		`c.set.status=422;throw new ValidationError('${type}',validator.${type},${value},${allowUnsafeValidationDetails}${error ? "," + error : ""})`,
	response: (name = "r") => {
		if (isStaticResponse || !validator.response) return "";
		let code =
			injectResponse +
			`
`;
		code += `if(${name} instanceof ElysiaCustomStatusResponse){c.set.status=${name}.code
${name}=${name}.response}if(${name} instanceof Response === false && typeof ${name}?.next !== 'function' && !(${name} instanceof ReadableStream))switch(c.set.status){`;
		for (let [status2, value] of Object.entries(validator.response)) {
			if (
				((code += `
case ${status2}:
`),
				value.provider === "standard")
			) {
				code += `let vare${status2}=validator.response[${status2}].Check(${name})
if(vare${status2} instanceof Promise)vare${status2}=await vare${status2}
if(vare${status2}.issues)throw new ValidationError('response',validator.response[${status2}],${name},${allowUnsafeValidationDetails},vare${status2}.issues)
${name}=vare${status2}.value
c.set.status=${status2}
break
`;
				continue;
			}
			let noValidate = value.schema?.noValidate === true;
			if (!noValidate && value.schema?.$ref && value.schema?.$defs) {
				let refKey = value.schema.$ref,
					defKey =
						typeof refKey === "string" && refKey.includes("/") ? refKey.split("/").pop() : refKey;
				if (value.schema.$defs[defKey]?.noValidate === true) noValidate = true;
			}
			let appliedCleaner = noValidate || hasSanitize,
				clean2 = ({ ignoreTryCatch = false } = {}) =>
					composeCleaner({
						name,
						schema: value,
						type: "response",
						typeAlias: `response[${status2}]`,
						normalize,
						ignoreTryCatch,
					});
			if (appliedCleaner) code += clean2();
			let applyErrorCleaner = !appliedCleaner && normalize && !noValidate;
			if (encodeSchema && value.hasTransform && !noValidate) {
				if (
					((code += `try{${name}=validator.response[${status2}].Encode(${name})
`),
					!appliedCleaner)
				)
					code += clean2({ ignoreTryCatch: true });
				code +=
					`c.set.status=${status2}}catch{` +
					(applyErrorCleaner
						? `try{
` +
							clean2({ ignoreTryCatch: true }) +
							`${name}=validator.response[${status2}].Encode(${name})
}catch{throw new ValidationError('response',validator.response[${status2}],${name},${allowUnsafeValidationDetails})}`
						: `throw new ValidationError('response',validator.response[${status2}],${name}),${allowUnsafeValidationDetails}`) +
					"}";
			} else {
				if (!appliedCleaner) code += clean2();
				if (!noValidate)
					code += `if(validator.response[${status2}].Check(${name})===false)throw new ValidationError('response',validator.response[${status2}],${name},${allowUnsafeValidationDetails})
c.set.status=${status2}
`;
			}
			code += `break
`;
		}
		return code + "}";
	},
});
var isAsyncName = (v) => {
	return (v?.fn ?? v).constructor.name === "AsyncFunction";
};
var matchResponseClone = /=>\s?response\.clone\(/;
var matchFnReturn = /(?:return|=>)\s?\S+\(|a(?:sync|wait)/;
var isAsync = (v) => {
	let isObject2 = typeof v === "object";
	if (isObject2 && v.isAsync !== undefined) return v.isAsync;
	let fn = isObject2 ? v.fn : v;
	if (fn.constructor.name === "AsyncFunction") return true;
	let literal = fn.toString();
	if (matchResponseClone.test(literal)) {
		if (isObject2) v.isAsync = false;
		return false;
	}
	let result = matchFnReturn.test(literal);
	if (isObject2) v.isAsync = result;
	return result;
};
var hasReturn = (v) => {
	let isObject2 = typeof v === "object";
	if (isObject2 && v.hasReturn !== undefined) return v.hasReturn;
	let fnLiteral = isObject2 ? v.fn.toString() : typeof v === "string" ? v.toString() : v,
		parenthesisEnd = fnLiteral.indexOf(")");
	if (
		fnLiteral.charCodeAt(parenthesisEnd + 2) === 61 &&
		fnLiteral.charCodeAt(parenthesisEnd + 5) !== 123
	) {
		if (isObject2) v.hasReturn = true;
		return true;
	}
	let result = fnLiteral.includes("return");
	if (isObject2) v.hasReturn = result;
	return result;
};
var isGenerator = (v) => {
	let fn = v?.fn ?? v;
	return (
		fn.constructor.name === "AsyncGeneratorFunction" || fn.constructor.name === "GeneratorFunction"
	);
};
var coerceTransformDecodeError = (
	fnLiteral,
	type,
	allowUnsafeValidationDetails = false,
	value = `c.${type}`,
) => `try{${fnLiteral}}catch(error){if(error.constructor.name === 'TransformDecodeError'){c.set.status=422
throw error.error ?? new ValidationError('${type}',validator.${type},${value},${allowUnsafeValidationDetails})}}`;
var composeHandler = ({
	app,
	path,
	method,
	hooks,
	validator,
	handler,
	allowMeta = false,
	inference,
}) => {
	let adapter = app["~adapter"].composeHandler,
		adapterHandler = app["~adapter"].handler,
		isHandleFn = typeof handler === "function";
	if (!isHandleFn) {
		handler = adapterHandler.mapResponse(handler, { headers: app.setHeaders ?? {} });
		let isResponse =
			handler instanceof Response ||
			(handler?.constructor?.name === "Response" && typeof handler?.clone === "function");
		if (
			hooks.parse?.length &&
			hooks.transform?.length &&
			hooks.beforeHandle?.length &&
			hooks.afterHandle?.length
		) {
			if (isResponse)
				return Function(
					"a",
					`"use strict";
return function(){return a.clone()}`,
				)(handler);
			return Function(
				"a",
				`"use strict";
return function(){return a}`,
			)(handler);
		}
		if (isResponse) {
			let response = handler;
			handler = () => response.clone();
		}
	}
	let handle = isHandleFn ? "handler(c)" : "handler",
		hasTrace = !!hooks.trace?.length,
		fnLiteral = "";
	if (
		((inference = sucrose(Object.assign({ handler }, hooks), inference, app.config.sucrose)),
		adapter.declare)
	) {
		let literal = adapter.declare(inference);
		if (literal) fnLiteral += literal;
	}
	if (inference.server)
		fnLiteral += `Object.defineProperty(c,'server',{get:function(){return getServer()}})
`;
	(validator.createBody?.(),
		validator.createQuery?.(),
		validator.createHeaders?.(),
		validator.createParams?.(),
		validator.createCookie?.(),
		validator.createResponse?.());
	let hasValidation =
			!!validator.body ||
			!!validator.headers ||
			!!validator.params ||
			!!validator.query ||
			!!validator.cookie ||
			!!validator.response,
		hasQuery = inference.query || !!validator.query,
		requestNoBody = hooks.parse?.length === 1 && hooks.parse[0].fn === "none",
		hasBody =
			method !== "" &&
			method !== "GET" &&
			method !== "HEAD" &&
			(inference.body || !!validator.body || !!hooks.parse?.length) &&
			!requestNoBody,
		defaultHeaders = app.setHeaders,
		hasDefaultHeaders = defaultHeaders && !!Object.keys(defaultHeaders).length,
		hasHeaders =
			inference.headers ||
			!!validator.headers ||
			(adapter.preferWebstandardHeaders !== true && inference.body),
		hasCookie = inference.cookie || !!validator.cookie,
		cookieMeta = validator.cookie?.config
			? mergeCookie(validator?.cookie?.config, app.config.cookie)
			: app.config.cookie,
		_encodeCookie = "",
		encodeCookie = () => {
			if (_encodeCookie) return _encodeCookie;
			if (cookieMeta?.sign) {
				if (!cookieMeta.secrets)
					throw Error(`t.Cookie required secret which is not set in (${method}) ${path}.`);
				let secret = !cookieMeta.secrets
					? undefined
					: typeof cookieMeta.secrets === "string"
						? cookieMeta.secrets
						: cookieMeta.secrets[0];
				if (
					((_encodeCookie += `const _setCookie = c.set.cookie
if(_setCookie){`),
					cookieMeta.sign === true)
				)
					_encodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)){c.set.cookie[key].value=await signCookie(cookie.value,'${secret}')}`;
				else
					for (let name of cookieMeta.sign)
						_encodeCookie += `if(_setCookie['${name}']?.value)c.set.cookie['${name}'].value=await signCookie(_setCookie['${name}'].value,'${secret}')
`;
				_encodeCookie += `}
`;
			}
			return _encodeCookie;
		},
		normalize = app.config.normalize,
		encodeSchema = app.config.encodeSchema,
		allowUnsafeValidationDetails = app.config.allowUnsafeValidationDetails,
		validation = composeValidationFactory({
			normalize,
			validator,
			encodeSchema,
			isStaticResponse: handler instanceof Response,
			hasSanitize: !!app.config.sanitize,
			allowUnsafeValidationDetails,
		});
	if (hasHeaders) fnLiteral += adapter.headers;
	if (hasTrace)
		fnLiteral += `const id=c[ELYSIA_REQUEST_ID]
`;
	let report = createReport({
		trace: hooks.trace,
		addFn: (word) => {
			fnLiteral += word;
		},
	});
	if (((fnLiteral += "try{"), hasCookie)) {
		let get = (name, defaultValue) => {
				let value = cookieMeta?.[name] ?? defaultValue;
				if (!value)
					return typeof defaultValue === "string"
						? `${name}:"${defaultValue}",`
						: `${name}:${defaultValue},`;
				if (typeof value === "string") return `${name}:'${value}',`;
				if (value instanceof Date) return `${name}: new Date(${value.getTime()}),`;
				return `${name}:${value},`;
			},
			options = cookieMeta
				? `{secrets:${cookieMeta.secrets !== undefined ? (typeof cookieMeta.secrets === "string" ? `'${cookieMeta.secrets}'` : "[" + cookieMeta.secrets.reduce((a, b) => a + `'${b}',`, "") + "]") : "undefined"},sign:${cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? "[" + cookieMeta.sign.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},` +
					get("domain") +
					get("expires") +
					get("httpOnly") +
					get("maxAge") +
					get("path", "/") +
					get("priority") +
					get("sameSite") +
					get("secure") +
					"}"
				: "undefined";
		if (hasHeaders)
			fnLiteral += `
c.cookie=await parseCookie(c.set,c.headers.cookie,${options})
`;
		else
			fnLiteral += `
c.cookie=await parseCookie(c.set,c.request.headers.get('cookie'),${options})
`;
	}
	if (hasQuery) {
		let arrayProperties = {},
			objectProperties = {},
			hasArrayProperty = false,
			hasObjectProperty = false;
		if (validator.query?.schema) {
			let schema = unwrapImportSchema(validator.query?.schema);
			if (Kind in schema && schema.properties)
				for (let [key, value] of Object.entries(schema.properties)) {
					if (hasElysiaMeta("ArrayQuery", value))
						((arrayProperties[key] = 1), (hasArrayProperty = true));
					if (hasElysiaMeta("ObjectString", value))
						((objectProperties[key] = 1), (hasObjectProperty = true));
				}
		}
		fnLiteral += `if(c.qi===-1){c.query=Object.create(null)}else{c.query=parseQueryFromURL(c.url,c.qi+1,${hasArrayProperty ? JSON.stringify(arrayProperties) : undefined},${hasObjectProperty ? JSON.stringify(objectProperties) : undefined})}`;
	}
	let isAsyncHandler = typeof handler === "function" && isAsync(handler),
		saveResponse = hasTrace || hooks.afterResponse?.length ? "c.response=c.responseValue= " : "",
		responseKeys = Object.keys(validator.response ?? {}),
		hasMultipleResponses = responseKeys.length > 1,
		hasSingle200 =
			responseKeys.length === 0 || (responseKeys.length === 1 && responseKeys[0] === "200"),
		maybeAsync =
			hasCookie ||
			hasBody ||
			isAsyncHandler ||
			!!hooks.parse?.length ||
			!!hooks.afterHandle?.some(isAsync) ||
			!!hooks.beforeHandle?.some(isAsync) ||
			!!hooks.transform?.some(isAsync) ||
			!!hooks.mapResponse?.some(isAsync) ||
			validator.body?.provider === "standard" ||
			validator.headers?.provider === "standard" ||
			validator.query?.provider === "standard" ||
			validator.params?.provider === "standard" ||
			validator.cookie?.provider === "standard" ||
			Object.values(validator.response ?? {}).find((x) => x.provider === "standard"),
		maybeStream =
			(typeof handler === "function" ? isGenerator(handler) : false) ||
			!!hooks.beforeHandle?.some(isGenerator) ||
			!!hooks.afterHandle?.some(isGenerator) ||
			!!hooks.transform?.some(isGenerator),
		hasSet =
			inference.cookie ||
			inference.set ||
			hasHeaders ||
			hasTrace ||
			hasMultipleResponses ||
			!hasSingle200 ||
			(isHandleFn && hasDefaultHeaders) ||
			maybeStream,
		_afterResponse,
		afterResponse = (hasStream = true) => {
			if (_afterResponse !== undefined) return _afterResponse;
			if (!hooks.afterResponse?.length && !hasTrace) return "";
			let afterResponse2 = "";
			afterResponse2 +=
				`
setImmediate(async()=>{if(c.responseValue){if(c.responseValue instanceof ElysiaCustomStatusResponse) c.set.status=c.responseValue.code
` +
				(hasStream
					? `if(typeof afterHandlerStreamListener!=='undefined')for await(const v of afterHandlerStreamListener){}
`
					: "") +
				`}
`;
			let reporter = createReport({
				trace: hooks.trace,
				addFn: (word) => {
					afterResponse2 += word;
				},
			})("afterResponse", { total: hooks.afterResponse?.length });
			if (hooks.afterResponse?.length && hooks.afterResponse)
				for (let i = 0; i < hooks.afterResponse.length; i++) {
					let endUnit = reporter.resolveChild(hooks.afterResponse[i].fn.name),
						prefix = isAsync(hooks.afterResponse[i]) ? "await " : "";
					((afterResponse2 += `
${prefix}e.afterResponse[${i}](c)
`),
						endUnit());
				}
			return (
				reporter.resolve(),
				(afterResponse2 += `})
`),
				(_afterResponse = afterResponse2)
			);
		},
		mapResponse3 = (r = "r") => {
			let after = afterResponse(),
				response = `${hasSet ? "mapResponse" : "mapCompactResponse"}(${saveResponse}${r}${hasSet ? ",c.set" : ""}${mapResponseContext})
`;
			if (!after) return `return ${response}`;
			return `const _res=${response}` + after + "return _res";
		},
		mapResponseContext =
			maybeStream || adapter.mapResponseContext ? `,${adapter.mapResponseContext}` : "";
	if (hasTrace || inference.route)
		fnLiteral += `c.route=\`${path}\`
`;
	if (hasTrace || hooks.afterResponse?.length)
		fnLiteral += `let afterHandlerStreamListener
`;
	let parseReporter = report("parse", { total: hooks.parse?.length });
	if (hasBody) {
		let hasBodyInference = !!hooks.parse?.length || inference.body || validator.body;
		if (adapter.parser.declare) fnLiteral += adapter.parser.declare;
		fnLiteral += `
try{`;
		let parser =
			typeof hooks.parse === "string"
				? hooks.parse
				: Array.isArray(hooks.parse) && hooks.parse.length === 1
					? typeof hooks.parse[0] === "string"
						? hooks.parse[0]
						: typeof hooks.parse[0].fn === "string"
							? hooks.parse[0].fn
							: undefined
					: undefined;
		if (!parser && validator.body && !hooks.parse?.length) {
			let schema = validator.body.schema;
			if (
				schema &&
				schema.anyOf &&
				schema[Kind] === "Union" &&
				schema.anyOf?.length === 2 &&
				schema.anyOf?.find((x) => x[Kind] === "ElysiaForm")
			)
				parser = "formdata";
		}
		if (parser && defaultParsers.includes(parser)) {
			let reporter = report("parse", { total: hooks.parse?.length }),
				isOptionalBody = !!validator.body?.isOptional;
			switch (parser) {
				case "json":
				case "application/json":
					fnLiteral += adapter.parser.json(isOptionalBody);
					break;
				case "text":
				case "text/plain":
					fnLiteral += adapter.parser.text(isOptionalBody);
					break;
				case "urlencoded":
				case "application/x-www-form-urlencoded":
					fnLiteral += adapter.parser.urlencoded(isOptionalBody);
					break;
				case "arrayBuffer":
				case "application/octet-stream":
					fnLiteral += adapter.parser.arrayBuffer(isOptionalBody);
					break;
				case "formdata":
				case "multipart/form-data":
					fnLiteral += adapter.parser.formData(isOptionalBody);
					break;
				default:
					if (parser[0] in app["~parser"])
						((fnLiteral += hasHeaders
							? "let contentType = c.headers['content-type']"
							: "let contentType = c.request.headers.get('content-type')"),
							(fnLiteral += `
if(contentType){const index=contentType.indexOf(';')
if(index!==-1)contentType=contentType.substring(0,index)}
else{contentType=''}c.contentType=contentType
let result=parser['${parser}'](c, contentType)
if(result instanceof Promise)result=await result
if(result instanceof ElysiaCustomStatusResponse)throw result
if(result!==undefined)c.body=result
delete c.contentType
`));
					break;
			}
			reporter.resolve();
		} else if (hasBodyInference) {
			((fnLiteral += `
`),
				(fnLiteral += `let contentType
if(c.request.body)`),
				(fnLiteral += hasHeaders
					? `contentType=c.headers['content-type']
`
					: `contentType=c.request.headers.get('content-type')
`));
			let hasDefaultParser = false;
			if (hooks.parse?.length)
				fnLiteral += `if(contentType){
const index=contentType.indexOf(';')

if(index!==-1)contentType=contentType.substring(0,index)}else{contentType=''}let used=false
c.contentType=contentType
`;
			else {
				hasDefaultParser = true;
				let isOptionalBody = !!validator.body?.isOptional;
				fnLiteral +=
					`if(contentType)switch(contentType.charCodeAt(12)){
case 106:` +
					adapter.parser.json(isOptionalBody) +
					`break
case 120:` +
					adapter.parser.urlencoded(isOptionalBody) +
					`break
case 111:` +
					adapter.parser.arrayBuffer(isOptionalBody) +
					`break
case 114:` +
					adapter.parser.formData(isOptionalBody) +
					`break
default:if(contentType.charCodeAt(0)===116){` +
					adapter.parser.text(isOptionalBody) +
					`}break
}`;
			}
			let reporter = report("parse", { total: hooks.parse?.length });
			if (hooks.parse)
				for (let i = 0; i < hooks.parse.length; i++) {
					let name = `bo${i}`;
					if (i !== 0)
						fnLiteral += `
if(!used){`;
					if (typeof hooks.parse[i].fn === "string") {
						let endUnit = reporter.resolveChild(hooks.parse[i].fn),
							isOptionalBody = !!validator.body?.isOptional;
						switch (hooks.parse[i].fn) {
							case "json":
							case "application/json":
								((hasDefaultParser = true), (fnLiteral += adapter.parser.json(isOptionalBody)));
								break;
							case "text":
							case "text/plain":
								((hasDefaultParser = true), (fnLiteral += adapter.parser.text(isOptionalBody)));
								break;
							case "urlencoded":
							case "application/x-www-form-urlencoded":
								((hasDefaultParser = true),
									(fnLiteral += adapter.parser.urlencoded(isOptionalBody)));
								break;
							case "arrayBuffer":
							case "application/octet-stream":
								((hasDefaultParser = true),
									(fnLiteral += adapter.parser.arrayBuffer(isOptionalBody)));
								break;
							case "formdata":
							case "multipart/form-data":
								((hasDefaultParser = true), (fnLiteral += adapter.parser.formData(isOptionalBody)));
								break;
							default:
								fnLiteral += `let ${name}=parser['${hooks.parse[i].fn}'](c,contentType)
if(${name} instanceof Promise)${name}=await ${name}
if(${name}!==undefined){c.body=${name};used=true;}
`;
						}
						endUnit();
					} else {
						let endUnit = reporter.resolveChild(hooks.parse[i].fn.name);
						((fnLiteral += `let ${name}=e.parse[${i}]
${name}=${name}(c,contentType)
if(${name} instanceof Promise)${name}=await ${name}
if(${name}!==undefined){c.body=${name};used=true}`),
							endUnit());
					}
					if (i !== 0) fnLiteral += "}";
					if (hasDefaultParser) break;
				}
			if ((reporter.resolve(), !hasDefaultParser)) {
				let isOptionalBody = !!validator.body?.isOptional;
				if (hooks.parse?.length)
					fnLiteral += `
if(!used){
`;
				fnLiteral +=
					`switch(contentType){case 'application/json':
` +
					adapter.parser.json(isOptionalBody) +
					`break
case 'text/plain':` +
					adapter.parser.text(isOptionalBody) +
					`break
case 'application/x-www-form-urlencoded':` +
					adapter.parser.urlencoded(isOptionalBody) +
					`break
case 'application/octet-stream':` +
					adapter.parser.arrayBuffer(isOptionalBody) +
					`break
case 'multipart/form-data':` +
					adapter.parser.formData(isOptionalBody) +
					`break
`;
				for (let key of Object.keys(app["~parser"]))
					fnLiteral +=
						`case '${key}':let bo${key}=parser['${key}'](c,contentType)
if(bo${key} instanceof Promise)bo${key}=await bo${key}
if(bo${key} instanceof ElysiaCustomStatusResponse){` +
						mapResponse3(`bo${key}`) +
						`}if(bo${key}!==undefined)c.body=bo${key}
break
`;
				if (hooks.parse?.length) fnLiteral += "}";
				fnLiteral += "}";
			}
			if (hooks.parse?.length)
				fnLiteral += `
delete c.contentType`;
		}
		fnLiteral += "}catch(error){throw new ParseError(error)}";
	}
	if ((parseReporter.resolve(), hooks?.transform || hasTrace)) {
		let reporter = report("transform", { total: hooks.transform?.length });
		if (hooks.transform?.length) {
			fnLiteral += `let transformed
`;
			for (let i = 0; i < hooks.transform.length; i++) {
				let transform2 = hooks.transform[i],
					endUnit = reporter.resolveChild(transform2.fn.name);
				if (
					((fnLiteral += isAsync(transform2)
						? `transformed=await e.transform[${i}](c)
`
						: `transformed=e.transform[${i}](c)
`),
					transform2.subType === "mapDerive")
				)
					fnLiteral +=
						"if(transformed instanceof ElysiaCustomStatusResponse){" +
						mapResponse3("transformed") +
						`}else{transformed.request=c.request
transformed.store=c.store
transformed.qi=c.qi
transformed.path=c.path
transformed.url=c.url
transformed.redirect=c.redirect
transformed.set=c.set
transformed.error=c.error
c=transformed}`;
				else
					fnLiteral +=
						"if(transformed instanceof ElysiaCustomStatusResponse){" +
						mapResponse3("transformed") +
						`}else Object.assign(c,transformed)
`;
				endUnit();
			}
		}
		reporter.resolve();
	}
	let fileUnions = [];
	if (validator) {
		if (validator.headers) {
			if (validator.headers.hasDefault)
				for (let [key, value] of Object.entries(
					exports_value2.Default(validator.headers.schema, {}),
				)) {
					let parsed =
						typeof value === "object"
							? JSON.stringify(value)
							: typeof value === "string"
								? `'${value}'`
								: value;
					if (parsed !== undefined)
						fnLiteral += `c.headers['${key}']??=${parsed}
`;
				}
			if (
				((fnLiteral += composeCleaner({
					name: "c.headers",
					schema: validator.headers,
					type: "headers",
					normalize,
				})),
				validator.headers.isOptional)
			)
				fnLiteral += "if(isNotEmpty(c.headers)){";
			if (validator.headers?.provider === "standard")
				fnLiteral +=
					`let vah=validator.headers.Check(c.headers)
if(vah instanceof Promise)vah=await vah
if(vah.issues){` +
					validation.validate("headers", undefined, "vah.issues") +
					`}else{c.headers=vah.value}
`;
			else if (validator.headers?.schema?.noValidate !== true)
				fnLiteral +=
					"if(validator.headers.Check(c.headers) === false){" +
					validation.validate("headers") +
					"}";
			if (validator.headers.hasTransform)
				fnLiteral += coerceTransformDecodeError(
					`c.headers=validator.headers.Decode(c.headers)
`,
					"headers",
					allowUnsafeValidationDetails,
				);
			if (validator.headers.isOptional) fnLiteral += "}";
		}
		if (validator.params) {
			if (validator.params.hasDefault)
				for (let [key, value] of Object.entries(
					exports_value2.Default(validator.params.schema, {}),
				)) {
					let parsed =
						typeof value === "object"
							? JSON.stringify(value)
							: typeof value === "string"
								? `'${value}'`
								: value;
					if (parsed !== undefined)
						fnLiteral += `c.params['${key}']??=${parsed}
`;
				}
			if (validator.params.provider === "standard")
				fnLiteral +=
					`let vap=validator.params.Check(c.params)
if(vap instanceof Promise)vap=await vap
if(vap.issues){` +
					validation.validate("params", undefined, "vap.issues") +
					`}else{c.params=vap.value}
`;
			else if (validator.params?.schema?.noValidate !== true)
				fnLiteral +=
					"if(validator.params.Check(c.params)===false){" + validation.validate("params") + "}";
			if (validator.params.hasTransform)
				fnLiteral += coerceTransformDecodeError(
					`c.params=validator.params.Decode(c.params)
`,
					"params",
					allowUnsafeValidationDetails,
				);
		}
		if (validator.query) {
			if (Kind in validator.query?.schema && validator.query.hasDefault)
				for (let [key, value] of Object.entries(
					exports_value2.Default(validator.query.schema, {}),
				)) {
					let parsed =
						typeof value === "object"
							? JSON.stringify(value)
							: typeof value === "string"
								? `'${value}'`
								: value;
					if (parsed !== undefined)
						fnLiteral += `if(c.query['${key}']===undefined)c.query['${key}']=${parsed}
`;
				}
			if (
				((fnLiteral += composeCleaner({
					name: "c.query",
					schema: validator.query,
					type: "query",
					normalize,
				})),
				validator.query.isOptional)
			)
				fnLiteral += "if(isNotEmpty(c.query)){";
			if (validator.query.provider === "standard")
				fnLiteral +=
					`let vaq=validator.query.Check(c.query)
if(vaq instanceof Promise)vaq=await vaq
if(vaq.issues){` +
					validation.validate("query", undefined, "vaq.issues") +
					`}else{c.query=vaq.value}
`;
			else if (validator.query?.schema?.noValidate !== true)
				fnLiteral +=
					"if(validator.query.Check(c.query)===false){" + validation.validate("query") + "}";
			if (validator.query.hasTransform)
				((fnLiteral += coerceTransformDecodeError(
					`c.query=validator.query.Decode(c.query)
`,
					"query",
					allowUnsafeValidationDetails,
				)),
					(fnLiteral += coerceTransformDecodeError(
						`c.query=validator.query.Decode(c.query)
`,
						"query",
						allowUnsafeValidationDetails,
					)));
			if (validator.query.isOptional) fnLiteral += "}";
		}
		if (hasBody && validator.body) {
			if (validator.body.hasTransform || validator.body.isOptional)
				fnLiteral += `const isNotEmptyObject=c.body&&(typeof c.body==="object"&&(isNotEmpty(c.body)||c.body instanceof ArrayBuffer))
`;
			let hasUnion = isUnion(validator.body.schema),
				hasNonUnionFileWithDefault = false;
			if (validator.body.hasDefault) {
				let value = exports_value2.Default(
						validator.body.schema,
						validator.body.schema.type === "object" ||
							unwrapImportSchema(validator.body.schema)[Kind] === "Object"
							? {}
							: undefined,
					),
					schema = unwrapImportSchema(validator.body.schema);
				if (
					!hasUnion &&
					value &&
					typeof value === "object" &&
					(hasType("File", schema) || hasType("Files", schema))
				) {
					hasNonUnionFileWithDefault = true;
					for (let [k2, v] of Object.entries(value))
						if (v === "File" || v === "Files") delete value[k2];
					if (!isNotEmpty(value)) value = undefined;
				}
				let parsed =
					typeof value === "object"
						? JSON.stringify(value)
						: typeof value === "string"
							? `'${value}'`
							: value;
				if (value !== undefined && value !== null)
					if (Array.isArray(value))
						fnLiteral += `if(!c.body)c.body=${parsed}
`;
					else if (typeof value === "object")
						fnLiteral += `c.body=Object.assign(${parsed},c.body)
`;
					else
						fnLiteral += `c.body=${parsed}
`;
				if (
					((fnLiteral += composeCleaner({
						name: "c.body",
						schema: validator.body,
						type: "body",
						normalize,
					})),
					validator.body.provider === "standard")
				)
					fnLiteral +=
						`let vab=validator.body.Check(c.body)
if(vab instanceof Promise)vab=await vab
if(vab.issues){` +
						validation.validate("body", undefined, "vab.issues") +
						`}else{c.body=vab.value}
`;
				else if (validator.body?.schema?.noValidate !== true)
					if (validator.body.isOptional)
						fnLiteral +=
							"if(isNotEmptyObject&&validator.body.Check(c.body)===false){" +
							validation.validate("body") +
							"}";
					else
						fnLiteral +=
							"if(validator.body.Check(c.body)===false){" + validation.validate("body") + "}";
			} else if (
				((fnLiteral += composeCleaner({
					name: "c.body",
					schema: validator.body,
					type: "body",
					normalize,
				})),
				validator.body.provider === "standard")
			)
				fnLiteral +=
					`let vab=validator.body.Check(c.body)
if(vab instanceof Promise)vab=await vab
if(vab.issues){` +
					validation.validate("body", undefined, "vab.issues") +
					`}else{c.body=vab.value}
`;
			else if (validator.body?.schema?.noValidate !== true)
				if (validator.body.isOptional)
					fnLiteral +=
						"if(isNotEmptyObject&&validator.body.Check(c.body)===false){" +
						validation.validate("body") +
						"}";
				else
					fnLiteral +=
						"if(validator.body.Check(c.body)===false){" + validation.validate("body") + "}";
			if (validator.body.hasTransform)
				fnLiteral += coerceTransformDecodeError(
					`if(isNotEmptyObject)c.body=validator.body.Decode(c.body)
`,
					"body",
					allowUnsafeValidationDetails,
				);
			if (hasUnion && validator.body.schema.anyOf?.length) {
				let iterator = Object.values(validator.body.schema.anyOf);
				for (let i = 0; i < iterator.length; i++) {
					let type = iterator[i];
					if (hasType("File", type) || hasType("Files", type)) {
						let candidate = getSchemaValidator(type, {
							modules: app.definitions.typebox,
							dynamic: !app.config.aot,
							models: app.definitions.type,
							normalize: app.config.normalize,
							additionalCoerce: coercePrimitiveRoot(),
							sanitize: () => app.config.sanitize,
						});
						if (candidate) {
							let isFirst = fileUnions.length === 0,
								iterator2 = Object.entries(type.properties),
								validator2 = isFirst
									? `
`
									: " else ";
							validator2 += `if(fileUnions[${fileUnions.length}].Check(c.body)){`;
							let validateFile2 = "",
								validatorLength = 0;
							for (let i2 = 0; i2 < iterator2.length; i2++) {
								let [k2, v] = iterator2[i2];
								if (!v.extension || (v[Kind] !== "File" && v[Kind] !== "Files")) continue;
								if (validatorLength) validateFile2 += ",";
								((validateFile2 += `fileType(c.body.${k2},${JSON.stringify(v.extension)},'body.${k2}')`),
									validatorLength++);
							}
							if (validateFile2) {
								if (validatorLength === 1)
									validator2 += `await ${validateFile2}
`;
								else if (validatorLength > 1)
									validator2 += `await Promise.all([${validateFile2}])
`;
								((validator2 += "}"), (fnLiteral += validator2), fileUnions.push(candidate));
							}
						}
					}
				}
			} else if (
				hasNonUnionFileWithDefault ||
				(!hasUnion &&
					(hasType("File", unwrapImportSchema(validator.body.schema)) ||
						hasType("Files", unwrapImportSchema(validator.body.schema))))
			) {
				let validateFile2 = "",
					i = 0;
				for (let [k2, v] of Object.entries(unwrapImportSchema(validator.body.schema).properties)) {
					if (!v.extension || (v[Kind] !== "File" && v[Kind] !== "Files")) continue;
					if (i) validateFile2 += ",";
					((validateFile2 += `fileType(c.body.${k2},${JSON.stringify(v.extension)},'body.${k2}')`),
						i++);
				}
				if (i)
					fnLiteral += `
`;
				if (i === 1)
					fnLiteral += `await ${validateFile2}
`;
				else if (i > 1)
					fnLiteral += `await Promise.all([${validateFile2}])
`;
			}
		}
		if (validator.cookie) {
			if (
				((validator.cookie.config = mergeCookie(
					validator.cookie.config,
					validator.cookie?.config ?? {},
				)),
				(fnLiteral += `let cookieValue={}
for(const [key,value] of Object.entries(c.cookie))cookieValue[key]=value.value
`),
				validator.cookie.isOptional)
			)
				fnLiteral += "if(isNotEmpty(c.cookie)){";
			if (validator.cookie.provider === "standard")
				((fnLiteral +=
					`let vac=validator.cookie.Check(cookieValue)
if(vac instanceof Promise)vac=await vac
if(vac.issues){` +
					validation.validate("cookie", undefined, "vac.issues") +
					`}else{cookieValue=vac.value}
`),
					(fnLiteral += `for(const k of Object.keys(cookieValue))c.cookie[k].value=cookieValue[k]
`));
			else if (validator.body?.schema?.noValidate !== true) {
				if (
					((fnLiteral +=
						"if(validator.cookie.Check(cookieValue)===false){" +
						validation.validate("cookie", "cookieValue") +
						"}"),
					validator.cookie.hasTransform)
				)
					fnLiteral += coerceTransformDecodeError(
						"for(const [key,value] of Object.entries(validator.cookie.Decode(cookieValue))){c.cookie[key].value=value}",
						"cookie",
						allowUnsafeValidationDetails,
					);
			}
			if (validator.cookie.isOptional) fnLiteral += "}";
		}
	}
	if (hooks?.beforeHandle || hasTrace) {
		let reporter = report("beforeHandle", { total: hooks.beforeHandle?.length }),
			hasResolve = false;
		if (hooks.beforeHandle?.length)
			for (let i = 0; i < hooks.beforeHandle.length; i++) {
				let beforeHandle = hooks.beforeHandle[i],
					endUnit = reporter.resolveChild(beforeHandle.fn.name),
					returning = hasReturn(beforeHandle);
				if (beforeHandle.subType === "resolve" || beforeHandle.subType === "mapResolve") {
					if (!hasResolve)
						((hasResolve = true),
							(fnLiteral += `
let resolved
`));
					if (
						((fnLiteral += isAsync(beforeHandle)
							? `resolved=await e.beforeHandle[${i}](c);
`
							: `resolved=e.beforeHandle[${i}](c);
`),
						beforeHandle.subType === "mapResolve")
					)
						fnLiteral +=
							"if(resolved instanceof ElysiaCustomStatusResponse){" +
							mapResponse3("resolved") +
							`}else{resolved.request=c.request
resolved.store=c.store
resolved.qi=c.qi
resolved.path=c.path
resolved.url=c.url
resolved.redirect=c.redirect
resolved.set=c.set
resolved.error=c.error
c=resolved}`;
					else
						fnLiteral +=
							"if(resolved instanceof ElysiaCustomStatusResponse){" +
							mapResponse3("resolved") +
							`}else Object.assign(c, resolved)
`;
					endUnit();
				} else if (!returning)
					((fnLiteral += isAsync(beforeHandle)
						? `await e.beforeHandle[${i}](c)
`
						: `e.beforeHandle[${i}](c)
`),
						endUnit());
				else {
					if (
						((fnLiteral += isAsync(beforeHandle)
							? `be=await e.beforeHandle[${i}](c)
`
							: `be=e.beforeHandle[${i}](c)
`),
						endUnit("be"),
						(fnLiteral += "if(be!==undefined){"),
						reporter.resolve(),
						hooks.afterHandle?.length || hasTrace)
					) {
						report("handle", { name: isHandleFn ? handler.name : undefined }).resolve();
						let reporter2 = report("afterHandle", { total: hooks.afterHandle?.length });
						if (hooks.afterHandle?.length)
							for (let i2 = 0; i2 < hooks.afterHandle.length; i2++) {
								let hook = hooks.afterHandle[i2],
									returning2 = hasReturn(hook),
									endUnit2 = reporter2.resolveChild(hook.fn.name);
								if (
									((fnLiteral += `c.response=c.responseValue=be
`),
									!returning2)
								)
									fnLiteral += isAsync(hook.fn)
										? `await e.afterHandle[${i2}](c, be)
`
										: `e.afterHandle[${i2}](c, be)
`;
								else
									((fnLiteral += isAsync(hook.fn)
										? `af=await e.afterHandle[${i2}](c)
`
										: `af=e.afterHandle[${i2}](c)
`),
										(fnLiteral += `if(af!==undefined) c.response=c.responseValue=be=af
`));
								endUnit2("af");
							}
						reporter2.resolve();
					}
					if (validator.response) fnLiteral += validation.response("be");
					let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
					if (hooks.mapResponse?.length) {
						fnLiteral += `c.response=c.responseValue=be
`;
						for (let i2 = 0; i2 < hooks.mapResponse.length; i2++) {
							let mapResponse4 = hooks.mapResponse[i2],
								endUnit2 = mapResponseReporter.resolveChild(mapResponse4.fn.name);
							((fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse4) ? "await " : ""}e.mapResponse[${i2}](c)
if(mr!==undefined)be=c.response=c.responseValue=mr}`),
								endUnit2());
						}
					}
					(mapResponseReporter.resolve(),
						(fnLiteral += afterResponse()),
						(fnLiteral += encodeCookie()),
						(fnLiteral += `return mapEarlyResponse(${saveResponse}be,c.set${mapResponseContext})}
`));
				}
			}
		reporter.resolve();
	}
	function reportHandler(name) {
		let handleReporter = report("handle", { name, alias: "reportHandler" });
		return () => {
			if (hasTrace)
				((fnLiteral +=
					'if(r&&(r[Symbol.iterator]||r[Symbol.asyncIterator])&&typeof r.next==="function"){' +
					(maybeAsync ? "" : "(async()=>{") +
					`const stream=await tee(r,3)
r=stream[0]
const listener=stream[1]
` +
					(hasTrace || hooks.afterResponse?.length
						? `afterHandlerStreamListener=stream[2]
`
						: "") +
					`setImmediate(async ()=>{if(listener)for await(const v of listener){}
`),
					handleReporter.resolve(),
					(fnLiteral += "})" + (maybeAsync ? "" : "})()") + "}else{"),
					handleReporter.resolve(),
					(fnLiteral += `}
`));
		};
	}
	if (hooks.afterHandle?.length || hasTrace) {
		let resolveHandler = reportHandler(isHandleFn ? handler.name : undefined);
		if (hooks.afterHandle?.length)
			fnLiteral += isAsyncHandler
				? `let r=c.response=c.responseValue=await ${handle}
`
				: `let r=c.response=c.responseValue=${handle}
`;
		else
			fnLiteral += isAsyncHandler
				? `let r=await ${handle}
`
				: `let r=${handle}
`;
		resolveHandler();
		let reporter = report("afterHandle", { total: hooks.afterHandle?.length });
		if (hooks.afterHandle?.length)
			for (let i = 0; i < hooks.afterHandle.length; i++) {
				let hook = hooks.afterHandle[i],
					returning = hasReturn(hook),
					endUnit = reporter.resolveChild(hook.fn.name);
				if (!returning)
					((fnLiteral += isAsync(hook.fn)
						? `await e.afterHandle[${i}](c)
`
						: `e.afterHandle[${i}](c)
`),
						endUnit());
				else if (
					((fnLiteral += isAsync(hook.fn)
						? `af=await e.afterHandle[${i}](c)
`
						: `af=e.afterHandle[${i}](c)
`),
					endUnit("af"),
					validator.response)
				)
					((fnLiteral += "if(af!==undefined){"),
						reporter.resolve(),
						(fnLiteral += validation.response("af")),
						(fnLiteral += "c.response=c.responseValue=af}"));
				else
					((fnLiteral += "if(af!==undefined){"),
						reporter.resolve(),
						(fnLiteral += "c.response=c.responseValue=af}"));
			}
		if ((reporter.resolve(), hooks.afterHandle?.length))
			fnLiteral += `r=c.response
`;
		if (validator.response) fnLiteral += validation.response();
		fnLiteral += encodeCookie();
		let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
		if (hooks.mapResponse?.length)
			for (let i = 0; i < hooks.mapResponse.length; i++) {
				let mapResponse4 = hooks.mapResponse[i],
					endUnit = mapResponseReporter.resolveChild(mapResponse4.fn.name);
				((fnLiteral += `mr=${isAsyncName(mapResponse4) ? "await " : ""}e.mapResponse[${i}](c)
if(mr!==undefined)r=c.response=c.responseValue=mr
`),
					endUnit());
			}
		(mapResponseReporter.resolve(), (fnLiteral += mapResponse3()));
	} else {
		let resolveHandler = reportHandler(isHandleFn ? handler.name : undefined);
		if (validator.response || hooks.mapResponse?.length || hasTrace) {
			if (
				((fnLiteral += isAsyncHandler
					? `let r=await ${handle}
`
					: `let r=${handle}
`),
				resolveHandler(),
				validator.response)
			)
				fnLiteral += validation.response();
			let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
			if (hooks.mapResponse?.length) {
				fnLiteral += `
c.response=c.responseValue=r
`;
				for (let i = 0; i < hooks.mapResponse.length; i++) {
					let mapResponse4 = hooks.mapResponse[i],
						endUnit = mapResponseReporter.resolveChild(mapResponse4.fn.name);
					((fnLiteral += `
if(mr===undefined){mr=${isAsyncName(mapResponse4) ? "await " : ""}e.mapResponse[${i}](c)
if(mr!==undefined)r=c.response=c.responseValue=mr}
`),
						endUnit());
				}
			}
			if (
				(mapResponseReporter.resolve(), (fnLiteral += encodeCookie()), handler instanceof Response)
			)
				((fnLiteral += afterResponse()),
					(fnLiteral += inference.set
						? `if(isNotEmpty(c.set.headers)||c.set.status!==200||c.set.redirect||c.set.cookie)return mapResponse(${saveResponse}${handle}.clone(),c.set${mapResponseContext})
else return ${handle}.clone()`
						: `return ${handle}.clone()`),
					(fnLiteral += `
`));
			else fnLiteral += mapResponse3();
		} else if (hasCookie || hasTrace) {
			((fnLiteral += isAsyncHandler
				? `let r=await ${handle}
`
				: `let r=${handle}
`),
				resolveHandler());
			let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
			if (hooks.mapResponse?.length) {
				fnLiteral += `c.response=c.responseValue= r
`;
				for (let i = 0; i < hooks.mapResponse.length; i++) {
					let mapResponse4 = hooks.mapResponse[i],
						endUnit = mapResponseReporter.resolveChild(mapResponse4.fn.name);
					((fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse4) ? "await " : ""}e.mapResponse[${i}](c)
if(mr!==undefined)r=c.response=c.responseValue=mr}`),
						endUnit());
				}
			}
			(mapResponseReporter.resolve(), (fnLiteral += encodeCookie() + mapResponse3()));
		} else {
			resolveHandler();
			let handled = isAsyncHandler ? `await ${handle}` : handle;
			if (handler instanceof Response)
				((fnLiteral += afterResponse()),
					(fnLiteral += inference.set
						? `if(isNotEmpty(c.set.headers)||c.set.status!==200||c.set.redirect||c.set.cookie)return mapResponse(${saveResponse}${handle}.clone(),c.set${mapResponseContext})
else return ${handle}.clone()
`
						: `return ${handle}.clone()
`));
			else fnLiteral += mapResponse3(handled);
		}
	}
	if (
		((fnLiteral += `
}catch(error){`),
		!maybeAsync && hooks.error?.length)
	)
		fnLiteral += "return(async()=>{";
	if (
		((fnLiteral += `const set=c.set
if(!set.status||set.status<300)set.status=error?.status||500
`),
		hasCookie)
	)
		fnLiteral += encodeCookie();
	if (hasTrace && hooks.trace)
		for (let i = 0; i < hooks.trace.length; i++)
			fnLiteral += `report${i}?.resolve(error);reportChild${i}?.(error)
`;
	let errorReporter = report("error", { total: hooks.error?.length });
	if (hooks.error?.length) {
		if (
			((fnLiteral += `c.error=error
`),
			hasValidation)
		)
			fnLiteral += `if(error instanceof TypeBoxError){c.code="VALIDATION"
c.set.status=422}else{c.code=error.code??error[ERROR_CODE]??"UNKNOWN"}`;
		else
			fnLiteral += `c.code=error.code??error[ERROR_CODE]??"UNKNOWN"
`;
		if (
			((fnLiteral += `let er
`),
			hooks.mapResponse?.length)
		)
			fnLiteral += `let mep
`;
		for (let i = 0; i < hooks.error.length; i++) {
			let endUnit = errorReporter.resolveChild(hooks.error[i].fn.name);
			if (isAsync(hooks.error[i]))
				fnLiteral += `er=await e.error[${i}](c)
`;
			else
				fnLiteral += `er=e.error[${i}](c)
if(er instanceof Promise)er=await er
`;
			if ((endUnit(), hooks.mapResponse?.length)) {
				let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
				for (let i2 = 0; i2 < hooks.mapResponse.length; i2++) {
					let mapResponse4 = hooks.mapResponse[i2],
						endUnit2 = mapResponseReporter.resolveChild(mapResponse4.fn.name);
					((fnLiteral += `c.response=c.responseValue=er
mep=e.mapResponse[${i2}](c)
if(mep instanceof Promise)er=await er
if(mep!==undefined)er=mep
`),
						endUnit2());
				}
				mapResponseReporter.resolve();
			}
			if (
				((fnLiteral += `er=mapEarlyResponse(er,set${mapResponseContext})
`),
				(fnLiteral += "if(er){"),
				hasTrace && hooks.trace)
			) {
				for (let i2 = 0; i2 < hooks.trace.length; i2++)
					fnLiteral += `report${i2}.resolve()
`;
				errorReporter.resolve();
			}
			((fnLiteral += afterResponse(false)), (fnLiteral += "return er}"));
		}
	}
	if (
		(errorReporter.resolve(),
		(fnLiteral += "return handleError(c,error,true)"),
		!maybeAsync && hooks.error?.length)
	)
		fnLiteral += "})()";
	fnLiteral += "}";
	let adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "",
		init =
			"const {handler,handleError,hooks:e, " +
			allocateIf("validator,", hasValidation) +
			"mapResponse,mapCompactResponse,mapEarlyResponse,isNotEmpty,utils:{" +
			allocateIf("parseQuery,", hasBody) +
			allocateIf("parseQueryFromURL,", hasQuery) +
			"},error:{" +
			allocateIf("ValidationError,", hasValidation) +
			allocateIf("ParseError", hasBody) +
			"},fileType,schema,definitions,tee,ERROR_CODE," +
			allocateIf("parseCookie,", hasCookie) +
			allocateIf("signCookie,", hasCookie) +
			allocateIf("decodeURIComponent,", hasQuery) +
			"ElysiaCustomStatusResponse," +
			allocateIf("ELYSIA_TRACE,", hasTrace) +
			allocateIf("ELYSIA_REQUEST_ID,", hasTrace) +
			allocateIf("parser,", hooks.parse?.length) +
			allocateIf("getServer,", inference.server) +
			allocateIf("fileUnions,", fileUnions.length) +
			adapterVariables +
			allocateIf("TypeBoxError", hasValidation) +
			`}=hooks
const trace=e.trace
return ${maybeAsync ? "async " : ""}function handle(c){`;
	if (hooks.beforeHandle?.length)
		init += `let be
`;
	if (hooks.afterHandle?.length)
		init += `let af
`;
	if (hooks.mapResponse?.length)
		init += `let mr
`;
	if (allowMeta)
		init += `c.schema=schema
c.defs=definitions
`;
	((fnLiteral = init + fnLiteral + "}"), (init = ""));
	try {
		return Function(
			"hooks",
			`"use strict";
` + fnLiteral,
		)({
			handler,
			hooks: lifeCycleToFn(hooks),
			validator: hasValidation ? validator : undefined,
			handleError: app.handleError,
			mapResponse: adapterHandler.mapResponse,
			mapCompactResponse: adapterHandler.mapCompactResponse,
			mapEarlyResponse: adapterHandler.mapEarlyResponse,
			isNotEmpty,
			utils: {
				parseQuery: hasBody ? parseQuery : undefined,
				parseQueryFromURL: hasQuery
					? validator.query?.provider === "standard"
						? parseQueryStandardSchema
						: parseQueryFromURL
					: undefined,
			},
			error: {
				ValidationError: hasValidation ? ValidationError : undefined,
				ParseError: hasBody ? ParseError2 : undefined,
			},
			fileType,
			schema: app.router.history,
			definitions: app.definitions.type,
			tee,
			ERROR_CODE,
			parseCookie: hasCookie ? parseCookie : undefined,
			signCookie: hasCookie ? signCookie : undefined,
			decodeURIComponent: hasQuery ? import_fast_decode_uri_component3.default : undefined,
			ElysiaCustomStatusResponse,
			ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined,
			ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined,
			getServer: inference.server ? () => app.getServer() : undefined,
			fileUnions: fileUnions.length ? fileUnions : undefined,
			TypeBoxError: hasValidation ? TypeBoxError : undefined,
			parser: app["~parser"],
			...adapter.inject,
		});
	} catch (error) {
		let debugHooks = lifeCycleToFn(hooks);
		(console.log("[Composer] failed to generate optimized handler"),
			console.log("---"),
			console.log({
				handler: typeof handler === "function" ? handler.toString() : handler,
				instruction: fnLiteral,
				hooks: {
					...debugHooks,
					transform: debugHooks?.transform?.map?.((x) => x.toString()),
					resolve: debugHooks?.resolve?.map?.((x) => x.toString()),
					beforeHandle: debugHooks?.beforeHandle?.map?.((x) => x.toString()),
					afterHandle: debugHooks?.afterHandle?.map?.((x) => x.toString()),
					mapResponse: debugHooks?.mapResponse?.map?.((x) => x.toString()),
					parse: debugHooks?.parse?.map?.((x) => x.toString()),
					error: debugHooks?.error?.map?.((x) => x.toString()),
					afterResponse: debugHooks?.afterResponse?.map?.((x) => x.toString()),
					stop: debugHooks?.stop?.map?.((x) => x.toString()),
				},
				validator,
				definitions: app.definitions.type,
				error,
			}),
			console.log("---"),
			process.exit(1));
	}
};
var createOnRequestHandler = (app, addFn) => {
	let fnLiteral = "",
		reporter = createReport({
			trace: app.event.trace,
			addFn:
				addFn ??
				((word) => {
					fnLiteral += word;
				}),
		})("request", { total: app.event.request?.length });
	if (app.event.request?.length) {
		fnLiteral += "try{";
		for (let i = 0; i < app.event.request.length; i++) {
			let hook = app.event.request[i],
				withReturn = hasReturn(hook),
				maybeAsync = isAsync(hook),
				endUnit = reporter.resolveChild(app.event.request[i].fn.name);
			if (withReturn)
				((fnLiteral += `re=mapEarlyResponse(${maybeAsync ? "await " : ""}onRequest[${i}](c),c.set)
`),
					endUnit("re"),
					(fnLiteral += `if(re!==undefined)return re
`));
			else
				((fnLiteral += `${maybeAsync ? "await " : ""}onRequest[${i}](c)
`),
					endUnit());
		}
		fnLiteral += "}catch(error){return app.handleError(c,error,false)}";
	}
	return (reporter.resolve(), fnLiteral);
};
var createHoc = (app, fnName = "map") => {
	let hoc = app.extender.higherOrderFunctions;
	if (!hoc.length) return "return " + fnName;
	let adapter = app["~adapter"].composeGeneralHandler,
		handler = fnName;
	for (let i = 0; i < hoc.length; i++) handler = `hoc[${i}](${handler},${adapter.parameters})`;
	return `return function hocMap(${adapter.parameters}){return ${handler}(${adapter.parameters})}`;
};
var composeGeneralHandler = (app) => {
	let adapter = app["~adapter"].composeGeneralHandler;
	app.router.http.build();
	let isWebstandard = app["~adapter"].isWebStandard,
		hasTrace = app.event.trace?.length,
		fnLiteral = "",
		router = app.router,
		findDynamicRoute = router.http.root.WS
			? "const route=router.find(r.method==='GET'&&r.headers.get('upgrade')==='websocket'?'WS':r.method,p)"
			: "const route=router.find(r.method,p)";
	if (
		((findDynamicRoute += router.http.root.ALL
			? `??router.find('ALL',p)
`
			: `
`),
		isWebstandard)
	)
		findDynamicRoute += `if(r.method==='HEAD'){const route=router.find('GET',p)
if(route){c.params=route.params
const _res=route.store.handler?route.store.handler(c):route.store.compile()(c)
if(_res)return getResponseLength(_res).then((length)=>{_res.headers.set('content-length', length)
return new Response(null,{status:_res.status,statusText:_res.statusText,headers:_res.headers})
})}}`;
	let afterResponse = `c.error=notFound
`;
	if (app.event.afterResponse?.length && !app.event.error) {
		afterResponse = `
c.error=notFound
`;
		let prefix = app.event.afterResponse.some(isAsync) ? "async" : "";
		afterResponse += `
setImmediate(${prefix}()=>{if(c.responseValue instanceof ElysiaCustomStatusResponse) c.set.status=c.responseValue.code
`;
		for (let i = 0; i < app.event.afterResponse.length; i++) {
			let fn2 = app.event.afterResponse[i].fn;
			afterResponse += `
${isAsyncName(fn2) ? "await " : ""}afterResponse[${i}](c)
`;
		}
		afterResponse += `})
`;
	}
	if (app.inference.query)
		afterResponse += `
if(c.qi===-1){c.query={}}else{c.query=parseQueryFromURL(c.url,c.qi+1)}`;
	let error404 = adapter.error404(
		!!app.event.request?.length,
		!!app.event.error?.length,
		afterResponse,
	);
	((findDynamicRoute += error404.code),
		(findDynamicRoute += `
c.params=route.params
if(route.store.handler)return route.store.handler(c)
return route.store.compile()(c)
`));
	let switchMap = "";
	for (let [path, methods] of Object.entries(router.static)) {
		if (((switchMap += `case'${path}':`), app.config.strictPath !== true))
			switchMap += `case'${getLoosePath(path)}':`;
		let encoded = encodePath(path);
		if (path !== encoded) switchMap += `case'${encoded}':`;
		if (((switchMap += "switch(r.method){"), "GET" in methods || "WS" in methods)) {
			if (((switchMap += "case 'GET':"), "WS" in methods)) {
				if (
					((switchMap += `if(r.headers.get('upgrade')==='websocket')return ht[${methods.WS}].composed(c)
`),
					"GET" in methods === false)
				)
					if ("ALL" in methods)
						switchMap += `return ht[${methods.ALL}].composed(c)
`;
					else
						switchMap += `break map
`;
			}
			if ("GET" in methods)
				switchMap += `return ht[${methods.GET}].composed(c)
`;
		}
		if (isWebstandard && ("GET" in methods || "ALL" in methods) && "HEAD" in methods === false)
			switchMap += `case 'HEAD':return Promise.resolve(ht[${methods.GET ?? methods.ALL}].composed(c)).then(_ht=>getResponseLength(_ht).then((length)=>{_ht.headers.set('content-length', length)
return new Response(null,{status:_ht.status,statusText:_ht.statusText,headers:_ht.headers})
}))
`;
		for (let [method, index] of Object.entries(methods)) {
			if (method === "ALL" || method === "GET" || method === "WS") continue;
			switchMap += `case '${method}':return ht[${index}].composed(c)
`;
		}
		if ("ALL" in methods)
			switchMap += `default:return ht[${methods.ALL}].composed(c)
`;
		else
			switchMap += `default:break map
`;
		switchMap += "}";
	}
	let maybeAsync = !!app.event.request?.some(isAsync),
		adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "";
	if (
		((fnLiteral +=
			`
const {app,mapEarlyResponse,NotFoundError,randomId,handleError,status,redirect,getResponseLength,ElysiaCustomStatusResponse,` +
			allocateIf("parseQueryFromURL,", app.inference.query) +
			allocateIf("ELYSIA_TRACE,", hasTrace) +
			allocateIf("ELYSIA_REQUEST_ID,", hasTrace) +
			adapterVariables +
			`}=data
const store=app.singleton.store
const decorator=app.singleton.decorator
const staticRouter=app.router.static.http
const ht=app.router.history
const router=app.router.http
const trace=app.event.trace?.map(x=>typeof x==='function'?x:x.fn)??[]
const notFound=new NotFoundError()
const hoc=app.extender.higherOrderFunctions.map(x=>x.fn)
`),
		app.event.request?.length)
	)
		fnLiteral += `const onRequest=app.event.request.map(x=>x.fn)
`;
	if (app.event.afterResponse?.length)
		fnLiteral += `const afterResponse=app.event.afterResponse.map(x=>x.fn)
`;
	if (((fnLiteral += error404.declare), app.event.trace?.length))
		fnLiteral +=
			"const " +
			app.event.trace.map((_2, i) => `tr${i}=app.event.trace[${i}].fn`).join(",") +
			`
`;
	if (
		((fnLiteral += `${maybeAsync ? "async " : ""}function map(${adapter.parameters}){`),
		app.event.request?.length)
	)
		fnLiteral += `let re
`;
	if (((fnLiteral += adapter.createContext(app)), app.event.trace?.length))
		fnLiteral +=
			"c[ELYSIA_TRACE]=[" +
			app.event.trace.map((_2, i) => `tr${i}(c)`).join(",") +
			`]
`;
	if (((fnLiteral += createOnRequestHandler(app)), switchMap))
		fnLiteral +=
			`
map: switch(p){
` +
			switchMap +
			"}";
	fnLiteral +=
		findDynamicRoute +
		`}
` +
		createHoc(app);
	let handleError = composeErrorHandler(app);
	app.handleError = handleError;
	let fn = Function(
		"data",
		`"use strict";
` + fnLiteral,
	)({
		app,
		mapEarlyResponse: app["~adapter"].handler.mapEarlyResponse,
		NotFoundError,
		randomId,
		handleError,
		status,
		redirect,
		getResponseLength,
		ElysiaCustomStatusResponse,
		parseQueryFromURL: app.inference.query ? parseQueryFromURL : undefined,
		ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined,
		ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined,
		...adapter.inject,
	});
	if (isBun) Bun.gc(false);
	return fn;
};
var composeErrorHandler = (app) => {
	let hooks = app.event,
		fnLiteral = "",
		adapter = app["~adapter"].composeError,
		adapterVariables = adapter.inject ? Object.keys(adapter.inject).join(",") + "," : "",
		hasTrace = !!app.event.trace?.length;
	if (
		((fnLiteral +=
			"const {mapResponse,ERROR_CODE,ElysiaCustomStatusResponse,ValidationError,TransformDecodeError," +
			allocateIf("onError,", app.event.error) +
			allocateIf("afterResponse,", app.event.afterResponse) +
			allocateIf("trace,", app.event.trace) +
			allocateIf("onMapResponse,", app.event.mapResponse) +
			allocateIf("ELYSIA_TRACE,", hasTrace) +
			allocateIf("ELYSIA_REQUEST_ID,", hasTrace) +
			adapterVariables +
			`}=inject
`),
		(fnLiteral += "return async function(context,error,skipGlobal){"),
		(fnLiteral += ""),
		hasTrace)
	)
		fnLiteral += `const id=context[ELYSIA_REQUEST_ID]
`;
	let report = createReport({
			context: "context",
			trace: hooks.trace,
			addFn: (word) => {
				fnLiteral += word;
			},
		}),
		afterResponse = () => {
			if (!hooks.afterResponse?.length && !hasTrace) return "";
			let afterResponse2 = "",
				prefix = hooks.afterResponse?.some(isAsync) ? "async" : "";
			afterResponse2 += `
setImmediate(${prefix}()=>{`;
			let reporter = createReport({
				context: "context",
				trace: hooks.trace,
				addFn: (word) => {
					afterResponse2 += word;
				},
			})("afterResponse", { total: hooks.afterResponse?.length, name: "context" });
			if (hooks.afterResponse?.length && hooks.afterResponse)
				for (let i = 0; i < hooks.afterResponse.length; i++) {
					let fn = hooks.afterResponse[i].fn,
						endUnit = reporter.resolveChild(fn.name);
					((afterResponse2 += `
${isAsyncName(fn) ? "await " : ""}afterResponse[${i}](context)
`),
						endUnit());
				}
			return (
				reporter.resolve(),
				(afterResponse2 += `})
`),
				afterResponse2
			);
		};
	if (
		((fnLiteral += `const set=context.set
let _r
if(!context.code)context.code=error.code??error[ERROR_CODE]
if(!(context.error instanceof Error))context.error=error
if(error instanceof ElysiaCustomStatusResponse){set.status=error.status=error.code
error.message=error.response}`),
		adapter.declare)
	)
		fnLiteral += adapter.declare;
	let saveResponse = hasTrace || !!hooks.afterResponse?.length ? "context.response = " : "";
	if (
		((fnLiteral += `if(typeof error?.toResponse==='function'&&!(error instanceof ValidationError)&&!(error instanceof TransformDecodeError)){try{let raw=error.toResponse()
if(typeof raw?.then==='function')raw=await raw
if(raw instanceof Response)set.status=raw.status
context.response=context.responseValue=raw
}catch(toResponseError){
}
}
`),
		app.event.error)
	)
		for (let i = 0; i < app.event.error.length; i++) {
			let handler = app.event.error[i],
				response = `${isAsync(handler) ? "await " : ""}onError[${i}](context)
`;
			if (((fnLiteral += "if(skipGlobal!==true&&!context.response){"), hasReturn(handler))) {
				fnLiteral +=
					`_r=${response}
if(_r!==undefined){if(_r instanceof Response){` +
					afterResponse() +
					`return mapResponse(_r,set${adapter.mapResponseContext})}if(_r instanceof ElysiaCustomStatusResponse){error.status=error.code
error.message = error.response}if(set.status===200||!set.status)set.status=error.status
`;
				let mapResponseReporter2 = report("mapResponse", {
					total: hooks.mapResponse?.length,
					name: "context",
				});
				if (hooks.mapResponse?.length)
					for (let i2 = 0; i2 < hooks.mapResponse.length; i2++) {
						let mapResponse3 = hooks.mapResponse[i2],
							endUnit = mapResponseReporter2.resolveChild(mapResponse3.fn.name);
						((fnLiteral += `context.response=context.responseValue=_r_r=${isAsyncName(mapResponse3) ? "await " : ""}onMapResponse[${i2}](context)
`),
							endUnit());
					}
				(mapResponseReporter2.resolve(),
					(fnLiteral +=
						afterResponse() +
						`return mapResponse(${saveResponse}_r,set${adapter.mapResponseContext})}`));
			} else fnLiteral += response;
			fnLiteral += "}";
		}
	((fnLiteral +=
		`if(error instanceof ValidationError||error instanceof TransformDecodeError){
if(error.error)error=error.error
set.status=error.status??422
` +
		afterResponse() +
		adapter.validationError +
		`
}
`),
		(fnLiteral +=
			"if(!context.response&&error instanceof Error){" +
			afterResponse() +
			adapter.unknownError +
			`
}`));
	let mapResponseReporter = report("mapResponse", {
		total: hooks.mapResponse?.length,
		name: "context",
	});
	if (
		((fnLiteral += `
if(!context.response)context.response=context.responseValue=error.message??error
`),
		hooks.mapResponse?.length)
	) {
		fnLiteral += `let mr
`;
		for (let i = 0; i < hooks.mapResponse.length; i++) {
			let mapResponse3 = hooks.mapResponse[i],
				endUnit = mapResponseReporter.resolveChild(mapResponse3.fn.name);
			((fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse3) ? "await " : ""}onMapResponse[${i}](context)
if(mr!==undefined)error=context.response=context.responseValue=mr}`),
				endUnit());
		}
	}
	(mapResponseReporter.resolve(),
		(fnLiteral +=
			afterResponse() +
			`
return mapResponse(${saveResponse}error,set${adapter.mapResponseContext})}`));
	let mapFn = (x) => (typeof x === "function" ? x : x.fn);
	return Function(
		"inject",
		`"use strict";
` + fnLiteral,
	)({
		mapResponse: app["~adapter"].handler.mapResponse,
		ERROR_CODE,
		ElysiaCustomStatusResponse,
		ValidationError,
		TransformDecodeError,
		onError: app.event.error?.map(mapFn),
		afterResponse: app.event.afterResponse?.map(mapFn),
		trace: app.event.trace?.map(mapFn),
		onMapResponse: app.event.mapResponse?.map(mapFn),
		ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined,
		ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined,
		...adapter.inject,
	});
};
var allocateIf2 = (value, condition) => (condition ? value : "");
var createContext = (app, route, inference, isInline = false) => {
	let fnLiteral = "",
		defaultHeaders = app.setHeaders,
		hasTrace = !!app.event.trace?.length;
	if (hasTrace)
		fnLiteral += `const id=randomId()
`;
	let isDynamic = /[:*]/.test(route.path),
		getQi = `const u=request.url,s=u.indexOf('/',${(app.config.handler?.standardHostname ?? true) ? 11 : 7}),qi=u.indexOf('?', s + 1)
`,
		needsQuery =
			inference.query ||
			!!route.hooks.query ||
			!!route.hooks.standaloneValidator?.find((x) => x.query) ||
			app.event.request?.length;
	if (needsQuery) fnLiteral += getQi;
	let getPath = !inference.path
		? ""
		: !isDynamic
			? `path:'${route.path}',`
			: "get path(){" +
				(needsQuery ? "" : getQi) +
				`if(qi===-1)return u.substring(s)
return u.substring(s,qi)
},`;
	if (
		((fnLiteral +=
			allocateIf2("const c=", !isInline) +
			"{request,store," +
			allocateIf2("qi,", needsQuery) +
			allocateIf2("params:request.params,", isDynamic) +
			getPath +
			allocateIf2("url:request.url,", hasTrace || inference.url || needsQuery) +
			"redirect,status,set:{headers:" +
			(isNotEmpty(defaultHeaders) ? "Object.assign({},app.setHeaders)" : "Object.create(null)") +
			",status:200}"),
		inference.server)
	)
		fnLiteral += ",get server(){return app.getServer()}";
	if (hasTrace) fnLiteral += ",[ELYSIA_REQUEST_ID]:id";
	{
		let decoratorsLiteral = "";
		for (let key of Object.keys(app.singleton.decorator))
			decoratorsLiteral += `,'${key}':decorator['${key}']`;
		fnLiteral += decoratorsLiteral;
	}
	return (
		(fnLiteral += `}
`),
		fnLiteral
	);
};
var createBunRouteHandler = (app, route) => {
	let hasTrace = !!app.event.trace?.length,
		hasHoc = !!app.extender.higherOrderFunctions.length,
		inference = sucrose(route.hooks, app.inference);
	inference = sucrose({ handler: route.handler }, inference);
	let fnLiteral =
		"const handler=data.handler,app=data.app,store=data.store,decorator=data.decorator,redirect=data.redirect,route=data.route,mapEarlyResponse=data.mapEarlyResponse," +
		allocateIf2("randomId=data.randomId,", hasTrace) +
		allocateIf2("ELYSIA_REQUEST_ID=data.ELYSIA_REQUEST_ID,", hasTrace) +
		allocateIf2("ELYSIA_TRACE=data.ELYSIA_TRACE,", hasTrace) +
		allocateIf2("trace=data.trace,", hasTrace) +
		allocateIf2("hoc=data.hoc,", hasHoc) +
		`status=data.status
`;
	if (app.event.request?.length)
		fnLiteral += `const onRequest=app.event.request.map(x=>x.fn)
`;
	fnLiteral += `${app.event.request?.find(isAsync) ? "async" : ""} function map(request){`;
	let needsQuery =
		inference.query ||
		!!route.hooks.query ||
		!!route.hooks.standaloneValidator?.find((x) => x.query);
	if (hasTrace || needsQuery || app.event.request?.length)
		((fnLiteral += createContext(app, route, inference)),
			(fnLiteral += createOnRequestHandler(app)),
			(fnLiteral += "return handler(c)}"));
	else fnLiteral += `return handler(${createContext(app, route, inference, true)})}`;
	return (
		(fnLiteral += createHoc(app)),
		Function(
			"data",
			fnLiteral,
		)({
			app,
			handler: route.compile?.() ?? route.composed,
			redirect,
			status,
			hoc: app.extender.higherOrderFunctions.map((x) => x.fn),
			store: app.store,
			decorator: app.decorator,
			route: route.path,
			randomId: hasTrace ? randomId : undefined,
			ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined,
			ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined,
			trace: hasTrace ? app.event.trace?.map((x) => x?.fn ?? x) : undefined,
			mapEarlyResponse: mapEarlyResponse2,
		})
	);
};
var createNativeStaticHandler = (handle, hooks, set2) => {
	if (typeof handle === "function" || handle instanceof Blob) return;
	if (isHTMLBundle(handle)) return () => handle;
	let response = mapResponse2(handle, set2 ?? { headers: {} });
	if (
		!hooks.parse?.length &&
		!hooks.transform?.length &&
		!hooks.beforeHandle?.length &&
		!hooks.afterHandle?.length
	) {
		if (response instanceof Promise)
			return response.then((response2) => {
				if (!response2) return;
				if (!response2.headers.has("content-type"))
					response2.headers.append("content-type", "text/plain");
				return response2.clone();
			});
		if (!response.headers.has("content-type"))
			response.headers.append("content-type", "text/plain");
		return () => response.clone();
	}
};
var websocket = {
	open(ws) {
		ws.data.open?.(ws);
	},
	message(ws, message) {
		ws.data.message?.(ws, message);
	},
	drain(ws) {
		ws.data.drain?.(ws);
	},
	close(ws, code, reason) {
		ws.data.close?.(ws, code, reason);
	},
	ping(ws) {
		ws.data.ping?.(ws);
	},
	pong(ws) {
		ws.data.pong?.(ws);
	},
};

class ElysiaWS {
	raw;
	data;
	body;
	constructor(raw, data, body = undefined) {
		this.raw = raw;
		this.data = data;
		this.body = body;
		((this.validator = raw.data?.validator),
			(this.sendText = raw.sendText.bind(raw)),
			(this.sendBinary = raw.sendBinary.bind(raw)),
			(this.close = raw.close.bind(raw)),
			(this.terminate = raw.terminate.bind(raw)),
			(this.publishText = raw.publishText.bind(raw)),
			(this.publishBinary = raw.publishBinary.bind(raw)),
			(this.subscribe = raw.subscribe.bind(raw)),
			(this.unsubscribe = raw.unsubscribe.bind(raw)),
			(this.isSubscribed = raw.isSubscribed.bind(raw)),
			(this.cork = raw.cork.bind(raw)),
			(this.remoteAddress = raw.remoteAddress),
			(this.binaryType = raw.binaryType),
			(this.data = raw.data),
			(this.send = this.send.bind(this)),
			(this.ping = this.ping.bind(this)),
			(this.pong = this.pong.bind(this)),
			(this.publish = this.publish.bind(this)));
	}
	send(data, compress) {
		if (Buffer.isBuffer(data)) return this.raw.send(data, compress);
		if (this.validator?.Check(data) === false)
			return this.raw.send(new ValidationError("message", this.validator, data).message);
		if (typeof data === "object") data = JSON.stringify(data);
		return this.raw.send(data, compress);
	}
	ping(data) {
		if (Buffer.isBuffer(data)) return this.raw.ping(data);
		if (this.validator?.Check(data) === false)
			return this.raw.send(new ValidationError("message", this.validator, data).message);
		if (typeof data === "object") data = JSON.stringify(data);
		return this.raw.ping(data);
	}
	pong(data) {
		if (Buffer.isBuffer(data)) return this.raw.pong(data);
		if (this.validator?.Check(data) === false)
			return this.raw.send(new ValidationError("message", this.validator, data).message);
		if (typeof data === "object") data = JSON.stringify(data);
		return this.raw.pong(data);
	}
	publish(topic, data, compress) {
		if (Buffer.isBuffer(data)) return this.raw.publish(topic, data, compress);
		if (this.validator?.Check(data) === false)
			return this.raw.send(new ValidationError("message", this.validator, data).message);
		if (typeof data === "object") data = JSON.stringify(data);
		return this.raw.publish(topic, data, compress);
	}
	sendText;
	sendBinary;
	close;
	terminate;
	publishText;
	publishBinary;
	subscribe;
	unsubscribe;
	isSubscribed;
	cork;
	remoteAddress;
	binaryType;
	get readyState() {
		return this.raw.readyState;
	}
	validator;
	["~types"];
	get id() {
		return this.data.id;
	}
}
var createWSMessageParser = (parse2) => {
	let parsers = typeof parse2 === "function" ? [parse2] : parse2;
	return async function (ws, message) {
		if (typeof message === "string") {
			let start = message?.charCodeAt(0);
			if (start === 34 || start === 47 || start === 91 || start === 123)
				try {
					message = JSON.parse(message);
				} catch {}
			else if (isNumericString(message)) message = +message;
			else if (message === "true") message = true;
			else if (message === "false") message = false;
			else if (message === "null") message = null;
		}
		if (parsers)
			for (let i = 0; i < parsers.length; i++) {
				let temp = parsers[i](ws, message);
				if (temp instanceof Promise) temp = await temp;
				if (temp !== undefined) return temp;
			}
		return message;
	};
};
var createHandleWSResponse = (validateResponse) => {
	let handleWSResponse = (ws, data) => {
		if (data instanceof Promise) return data.then((data2) => handleWSResponse(ws, data2));
		if (Buffer.isBuffer(data)) return ws.send(data.toString());
		if (data === undefined) return;
		let send = (datum) => {
			if (validateResponse?.Check(datum) === false)
				return ws.send(new ValidationError("message", validateResponse, datum).message);
			if (typeof datum === "object") return ws.send(JSON.stringify(datum));
			ws.send(datum);
		};
		if (typeof data?.next !== "function") return void send(data);
		let init = data.next();
		if (init instanceof Promise)
			return (async () => {
				let first = await init;
				if (validateResponse?.Check(first) === false)
					return ws.send(new ValidationError("message", validateResponse, first).message);
				if ((send(first.value), !first.done)) for await (let datum of data) send(datum);
			})();
		if ((send(init.value), !init.done)) for (let datum of data) send(datum);
	};
	return handleWSResponse;
};
var optionalParam = /:.+?\?(?=\/|$)/;
var getPossibleParams = (path) => {
	let match = optionalParam.exec(path);
	if (!match) return [path];
	let routes = [],
		head = path.slice(0, match.index),
		param = match[0].slice(0, -1),
		tail = path.slice(match.index + match[0].length);
	(routes.push(head.slice(0, -1)), routes.push(head + param));
	for (let fragment of getPossibleParams(tail)) {
		if (!fragment) continue;
		if (!fragment.startsWith("/:")) routes.push(head.slice(0, -1) + fragment);
		routes.push(head + param + fragment);
	}
	return routes;
};
var isHTMLBundle = (handle) => {
	return (
		typeof handle === "object" &&
		handle !== null &&
		(handle.toString() === "[object HTMLBundle]" || typeof handle.index === "string")
	);
};
var supportedMethods = {
	GET: true,
	HEAD: true,
	OPTIONS: true,
	DELETE: true,
	PATCH: true,
	POST: true,
	PUT: true,
};
var mapRoutes = (app) => {
	if (!app.config.aot || !app.config.systemRouter) return;
	let routes = {},
		add = (route, handler) => {
			let path = encodeURI(route.path);
			if (routes[path]) {
				if (!routes[path][route.method]) routes[path][route.method] = handler;
			} else routes[path] = { [route.method]: handler };
		},
		tree = app.routeTree;
	for (let route of app.router.history) {
		if (typeof route.handler !== "function") continue;
		let method = route.method;
		if (
			(method === "GET" && `WS_${route.path}` in tree) ||
			method === "WS" ||
			route.path.charCodeAt(route.path.length - 1) === 42 ||
			!(method in supportedMethods)
		)
			continue;
		if (method === "ALL") {
			if (!(`WS_${route.path}` in tree))
				routes[route.path] = route.hooks?.config?.mount
					? route.hooks.trace || app.event.trace || app.extender.higherOrderFunctions
						? createBunRouteHandler(app, route)
						: route.hooks.mount || route.handler
					: route.handler;
			continue;
		}
		let compiled,
			handler = app.config.precompile
				? createBunRouteHandler(app, route)
				: (request) => {
						if (compiled) return compiled(request);
						return (compiled = createBunRouteHandler(app, route))(request);
					};
		for (let path of getPossibleParams(route.path)) add({ method, path }, handler);
	}
	return routes;
};
var mergeRoutes = (r1, r2) => {
	if (!r2) return r1;
	for (let key of Object.keys(r2)) {
		if (r1[key] === r2[key]) continue;
		if (!r1[key]) {
			r1[key] = r2[key];
			continue;
		}
		if (r1[key] && r2[key]) {
			if (typeof r1[key] === "function" || r1[key] instanceof Response) {
				r1[key] = r2[key];
				continue;
			}
			r1[key] = { ...r1[key], ...r2[key] };
		}
	}
	return r1;
};
var BunAdapter = {
	...WebStandardAdapter,
	name: "bun",
	handler: {
		mapResponse: mapResponse2,
		mapEarlyResponse: mapEarlyResponse2,
		mapCompactResponse: mapCompactResponse2,
		createStaticHandler: createStaticHandler2,
		createNativeStaticHandler,
	},
	composeHandler: {
		...WebStandardAdapter.composeHandler,
		headers: hasHeaderShorthand
			? `c.headers=c.request.headers.toJSON()
`
			: `c.headers={}
for(const [k,v] of c.request.headers.entries())c.headers[k]=v
`,
	},
	listen(app) {
		return (options, callback) => {
			if (typeof Bun > "u")
				throw Error(
					".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch",
				);
			if ((app.compile(), typeof options === "string")) {
				if (!isNumericString(options)) throw Error("Port must be a numeric value");
				options = parseInt(options);
			}
			let createStaticRoute = (iterator, { withAsync = false } = {}) => {
					let staticRoutes = {},
						ops = [];
					for (let [path, route] of Object.entries(iterator))
						if (((path = encodeURI(path)), supportPerMethodInlineHandler)) {
							if (!route) continue;
							for (let [method, value] of Object.entries(route)) {
								if (!value || !(method in supportedMethods)) continue;
								if (value instanceof Promise) {
									if (withAsync) {
										if (!staticRoutes[path]) staticRoutes[path] = {};
										ops.push(
											value.then((awaited) => {
												if (awaited instanceof Response) staticRoutes[path][method] = awaited;
												if (isHTMLBundle(awaited)) staticRoutes[path][method] = awaited;
											}),
										);
									}
									continue;
								}
								if (!(value instanceof Response) && !isHTMLBundle(value)) continue;
								if (!staticRoutes[path]) staticRoutes[path] = {};
								staticRoutes[path][method] = value;
							}
						} else {
							if (!route) continue;
							if (route instanceof Promise) {
								if (withAsync) {
									if (!staticRoutes[path]) staticRoutes[path] = {};
									ops.push(
										route.then((awaited) => {
											if (awaited instanceof Response) staticRoutes[path] = awaited;
										}),
									);
								}
								continue;
							}
							if (!(route instanceof Response)) continue;
							staticRoutes[path] = route;
						}
					if (withAsync) return Promise.all(ops).then(() => staticRoutes);
					return staticRoutes;
				},
				serve =
					typeof options === "object"
						? {
								development: !isProduction,
								reusePort: true,
								idleTimeout: 30,
								...(app.config.serve || {}),
								...(options || {}),
								routes: mergeRoutes(
									mergeRoutes(createStaticRoute(app.router.response), mapRoutes(app)),
									app.config.serve?.routes,
								),
								websocket: {
									...(app.config.websocket || {}),
									...(websocket || {}),
									...(options.websocket || {}),
								},
								fetch: app.fetch,
							}
						: {
								development: !isProduction,
								reusePort: true,
								idleTimeout: 30,
								...(app.config.serve || {}),
								routes: mergeRoutes(
									mergeRoutes(createStaticRoute(app.router.response), mapRoutes(app)),
									app.config.serve?.routes,
								),
								websocket: { ...(app.config.websocket || {}), ...(websocket || {}) },
								port: options,
								fetch: app.fetch,
							};
			if (((app.server = Bun.serve(serve)), app.event.start))
				for (let i = 0; i < app.event.start.length; i++) app.event.start[i].fn(app);
			if (callback) callback(app.server);
			(process.on("beforeExit", async () => {
				if (app.server) {
					if ((await app.server.stop?.(), (app.server = null), app.event.stop))
						for (let i = 0; i < app.event.stop.length; i++) app.event.stop[i].fn(app);
				}
			}),
				app.promisedModules.then(async () => {
					(app.server?.reload({
						...serve,
						fetch: app.fetch,
						routes: mergeRoutes(
							mergeRoutes(
								await createStaticRoute(app.router.response, { withAsync: true }),
								mapRoutes(app),
							),
							app.config.serve?.routes,
						),
					}),
						Bun?.gc(false));
				}));
		};
	},
	async stop(app, closeActiveConnections) {
		if (app.server) {
			if (
				(await app.server.stop(closeActiveConnections), (app.server = null), app.event.stop?.length)
			)
				for (let i = 0; i < app.event.stop.length; i++) app.event.stop[i].fn(app);
		} else
			console.log("Elysia isn't running. Call `app.listen` to start the server.", Error().stack);
	},
	ws(app, path, options) {
		let { parse: parse2, body, response, ...rest } = options,
			validateMessage = getSchemaValidator(body, {
				modules: app.definitions.typebox,
				models: app.definitions.type,
				normalize: app.config.normalize,
			}),
			validateResponse = getSchemaValidator(response, {
				modules: app.definitions.typebox,
				models: app.definitions.type,
				normalize: app.config.normalize,
			});
		app.route(
			"WS",
			path,
			async (context) => {
				let server = context.server ?? app.server,
					{ set: set2, path: path2, qi, headers, query, params } = context;
				if (((context.validator = validateResponse), options.upgrade)) {
					if (typeof options.upgrade === "function") {
						let temp = options.upgrade(context);
						if (temp instanceof Promise) await temp;
					} else if (options.upgrade) Object.assign(set2.headers, options.upgrade);
				}
				if (set2.cookie && isNotEmpty(set2.cookie)) {
					let cookie = serializeCookie(set2.cookie);
					if (cookie) set2.headers["set-cookie"] = cookie;
				}
				if (set2.headers["set-cookie"] && Array.isArray(set2.headers["set-cookie"]))
					set2.headers = parseSetCookies(new Headers(set2.headers), set2.headers["set-cookie"]);
				let handleResponse3 = createHandleWSResponse(validateResponse),
					parseMessage = createWSMessageParser(parse2),
					_id;
				if (typeof options.beforeHandle === "function") {
					let result = options.beforeHandle(context);
					if (result instanceof Promise) await result;
				}
				let errorHandlers = [
						...(options.error
							? Array.isArray(options.error)
								? options.error
								: [options.error]
							: []),
						...(app.event.error ?? []).map((x) => (typeof x === "function" ? x : x.fn)),
					].filter((x) => x),
					hasCustomErrorHandlers = errorHandlers.length > 0,
					handleErrors = !hasCustomErrorHandlers
						? () => {}
						: async (ws, error) => {
								for (let handleError of errorHandlers) {
									let response2 = handleError(Object.assign(context, { error }));
									if (response2 instanceof Promise) response2 = await response2;
									if ((await handleResponse3(ws, response2), response2)) break;
								}
							};
				if (
					server?.upgrade(context.request, {
						headers: isNotEmpty(set2.headers) ? set2.headers : undefined,
						data: {
							...context,
							get id() {
								if (_id) return _id;
								return (_id = randomId());
							},
							validator: validateResponse,
							ping(ws, data) {
								options.ping?.(ws, data);
							},
							pong(ws, data) {
								options.pong?.(ws, data);
							},
							open: async (ws) => {
								try {
									await handleResponse3(ws, options.open?.(new ElysiaWS(ws, context)));
								} catch (error) {
									handleErrors(ws, error);
								}
							},
							message: async (ws, _message) => {
								let message = await parseMessage(ws, _message);
								if (validateMessage?.Check(message) === false) {
									let validationError = new ValidationError("message", validateMessage, message);
									if (!hasCustomErrorHandlers) return void ws.send(validationError.message);
									return handleErrors(ws, validationError);
								}
								try {
									await handleResponse3(
										ws,
										options.message?.(new ElysiaWS(ws, context, message), message),
									);
								} catch (error) {
									handleErrors(ws, error);
								}
							},
							drain: async (ws) => {
								try {
									await handleResponse3(ws, options.drain?.(new ElysiaWS(ws, context)));
								} catch (error) {
									handleErrors(ws, error);
								}
							},
							close: async (ws, code, reason) => {
								try {
									await handleResponse3(
										ws,
										options.close?.(new ElysiaWS(ws, context), code, reason),
									);
								} catch (error) {
									handleErrors(ws, error);
								}
							},
						},
					})
				)
					return;
				return status(400, "Expected a websocket connection");
			},
			{ ...rest, websocket: options },
		);
	},
};
var injectDefaultValues = (typeChecker, obj) => {
	let schema = typeChecker.schema;
	if (!schema) return;
	if (schema.$defs?.[schema.$ref]) schema = schema.$defs[schema.$ref];
	if (!schema?.properties) return;
	for (let [key, keySchema] of Object.entries(schema.properties)) obj[key] ??= keySchema.default;
};
var createDynamicHandler = (app) => {
	let { mapResponse: mapResponse3, mapEarlyResponse: mapEarlyResponse3 } = app["~adapter"].handler,
		defaultHeader = app.setHeaders;
	return async (request) => {
		let url = request.url,
			s = url.indexOf("/", 11),
			qi = url.indexOf("?", s + 1),
			path = qi === -1 ? url.substring(s) : url.substring(s, qi),
			set2 = { cookie: {}, status: 200, headers: defaultHeader ? { ...defaultHeader } : {} },
			context = Object.assign({}, app.singleton.decorator, {
				set: set2,
				store: app.singleton.store,
				request,
				path,
				qi,
				error: status,
				status,
				redirect,
			});
		try {
			if (app.event.request)
				for (let i = 0; i < app.event.request.length; i++) {
					let onRequest = app.event.request[i].fn,
						response2 = onRequest(context);
					if (response2 instanceof Promise) response2 = await response2;
					if (((response2 = mapEarlyResponse3(response2, set2)), response2))
						return (context.response = response2);
				}
			let methodKey =
					request.method === "GET" && request.headers.get("upgrade")?.toLowerCase() === "websocket"
						? "WS"
						: request.method,
				handler =
					app.router.dynamic.find(request.method, path) ??
					app.router.dynamic.find(methodKey, path) ??
					app.router.dynamic.find("ALL", path);
			if (!handler)
				throw (
					(context.query = qi === -1 ? {} : parseQuery(url.substring(qi + 1))),
					new NotFoundError()
				);
			let { handle, hooks, validator, content, route } = handler.store,
				body;
			if (request.method !== "GET" && request.method !== "HEAD")
				if (content)
					switch (content) {
						case "application/json":
							body = await request.json();
							break;
						case "text/plain":
							body = await request.text();
							break;
						case "application/x-www-form-urlencoded":
							body = parseQuery(await request.text());
							break;
						case "application/octet-stream":
							body = await request.arrayBuffer();
							break;
						case "multipart/form-data":
							body = {};
							let form2 = await request.formData();
							for (let key of form2.keys()) {
								if (body[key]) continue;
								let value = form2.getAll(key);
								if (value.length === 1) body[key] = value[0];
								else body[key] = value;
							}
							break;
					}
				else {
					let contentType;
					if (request.body) contentType = request.headers.get("content-type");
					if (contentType) {
						let index = contentType.indexOf(";");
						if (index !== -1) contentType = contentType.slice(0, index);
						if (((context.contentType = contentType), hooks.parse))
							for (let i = 0; i < hooks.parse.length; i++) {
								let hook = hooks.parse[i].fn;
								if (typeof hook === "string")
									switch (hook) {
										case "json":
										case "application/json":
											body = await request.json();
											break;
										case "text":
										case "text/plain":
											body = await request.text();
											break;
										case "urlencoded":
										case "application/x-www-form-urlencoded":
											body = parseQuery(await request.text());
											break;
										case "arrayBuffer":
										case "application/octet-stream":
											body = await request.arrayBuffer();
											break;
										case "formdata":
										case "multipart/form-data":
											body = {};
											let form2 = await request.formData();
											for (let key of form2.keys()) {
												if (body[key]) continue;
												let value = form2.getAll(key);
												if (value.length === 1) body[key] = value[0];
												else body[key] = value;
											}
											break;
										default:
											let parser = app["~parser"][hook];
											if (parser) {
												let temp = parser(context, contentType);
												if (temp instanceof Promise) temp = await temp;
												if (temp) {
													body = temp;
													break;
												}
											}
											break;
									}
								else {
									let temp = hook(context, contentType);
									if (temp instanceof Promise) temp = await temp;
									if (temp) {
										body = temp;
										break;
									}
								}
							}
						if ((delete context.contentType, body === undefined))
							switch (contentType) {
								case "application/json":
									body = await request.json();
									break;
								case "text/plain":
									body = await request.text();
									break;
								case "application/x-www-form-urlencoded":
									body = parseQuery(await request.text());
									break;
								case "application/octet-stream":
									body = await request.arrayBuffer();
									break;
								case "multipart/form-data":
									body = {};
									let form2 = await request.formData();
									for (let key of form2.keys()) {
										if (body[key]) continue;
										let value = form2.getAll(key);
										if (value.length === 1) body[key] = value[0];
										else body[key] = value;
									}
									break;
							}
					}
				}
			((context.route = route),
				(context.body = body),
				(context.params = handler?.params || undefined),
				(context.query = qi === -1 ? {} : parseQuery(url.substring(qi + 1))),
				(context.headers = {}));
			for (let [key, value] of request.headers.entries()) context.headers[key] = value;
			let cookieMeta = {
					domain: app.config.cookie?.domain ?? validator?.cookie?.config.domain,
					expires: app.config.cookie?.expires ?? validator?.cookie?.config.expires,
					httpOnly: app.config.cookie?.httpOnly ?? validator?.cookie?.config.httpOnly,
					maxAge: app.config.cookie?.maxAge ?? validator?.cookie?.config.maxAge,
					path: app.config.cookie?.path ?? validator?.cookie?.config.path,
					priority: app.config.cookie?.priority ?? validator?.cookie?.config.priority,
					partitioned: app.config.cookie?.partitioned ?? validator?.cookie?.config.partitioned,
					sameSite: app.config.cookie?.sameSite ?? validator?.cookie?.config.sameSite,
					secure: app.config.cookie?.secure ?? validator?.cookie?.config.secure,
					secrets: app.config.cookie?.secrets ?? validator?.cookie?.config.secrets,
					sign: app.config.cookie?.sign ?? validator?.cookie?.config.sign,
				},
				cookieHeaderValue = request.headers.get("cookie");
			context.cookie = await parseCookie(context.set, cookieHeaderValue, cookieMeta);
			let headerValidator = validator?.createHeaders?.();
			if (headerValidator) injectDefaultValues(headerValidator, context.headers);
			let paramsValidator = validator?.createParams?.();
			if (paramsValidator) injectDefaultValues(paramsValidator, context.params);
			let queryValidator = validator?.createQuery?.();
			if (queryValidator) injectDefaultValues(queryValidator, context.query);
			if (hooks.transform)
				for (let i = 0; i < hooks.transform.length; i++) {
					let hook = hooks.transform[i],
						response2 = hook.fn(context);
					if (response2 instanceof Promise) response2 = await response2;
					if (response2 instanceof ElysiaCustomStatusResponse) {
						let result = mapEarlyResponse3(response2, context.set);
						if (result) return (context.response = result);
					}
					if (hook.subType === "derive") Object.assign(context, response2);
				}
			if (validator) {
				if (headerValidator) {
					let _header = structuredClone(context.headers);
					for (let [key, value] of request.headers) _header[key] = value;
					if (validator.headers.Check(_header) === false)
						throw new ValidationError("header", validator.headers, _header);
				} else if (validator.headers?.Decode)
					context.headers = validator.headers.Decode(context.headers);
				if (paramsValidator?.Check(context.params) === false)
					throw new ValidationError("params", validator.params, context.params);
				else if (validator.params?.Decode) context.params = validator.params.Decode(context.params);
				if (validator.query?.schema) {
					let schema = validator.query.schema;
					if (schema.$defs?.[schema.$ref]) schema = schema.$defs[schema.$ref];
					let properties = schema.properties;
					for (let property of Object.keys(properties)) {
						let value = properties[property];
						if (
							(value.type === "array" || value.items?.type === "string") &&
							typeof context.query[property] === "string" &&
							context.query[property]
						)
							context.query[property] = context.query[property].split(",");
					}
				}
				if (queryValidator?.Check(context.query) === false)
					throw new ValidationError("query", validator.query, context.query);
				else if (validator.query?.Decode) context.query = validator.query.Decode(context.query);
				if (validator.createCookie?.()) {
					let cookieValue = {};
					for (let [key, value] of Object.entries(context.cookie)) cookieValue[key] = value.value;
					if (validator.cookie.Check(cookieValue) === false)
						throw new ValidationError("cookie", validator.cookie, cookieValue);
					else if (validator.cookie?.Decode) cookieValue = validator.cookie.Decode(cookieValue);
				}
				if (validator.createBody?.()?.Check(body) === false)
					throw new ValidationError("body", validator.body, body);
				else if (validator.body?.Decode) context.body = validator.body.Decode(body);
			}
			if (hooks.beforeHandle)
				for (let i = 0; i < hooks.beforeHandle.length; i++) {
					let hook = hooks.beforeHandle[i],
						response2 = hook.fn(context);
					if (response2 instanceof Promise) response2 = await response2;
					if (response2 instanceof ElysiaCustomStatusResponse) {
						let result = mapEarlyResponse3(response2, context.set);
						if (result) return (context.response = result);
					}
					if (hook.subType === "resolve") {
						Object.assign(context, response2);
						continue;
					}
					if (response2 !== undefined) {
						if (((context.response = response2), hooks.afterHandle))
							for (let i2 = 0; i2 < hooks.afterHandle.length; i2++) {
								let newResponse = hooks.afterHandle[i2].fn(context);
								if (newResponse instanceof Promise) newResponse = await newResponse;
								if (newResponse) response2 = newResponse;
							}
						let result = mapEarlyResponse3(response2, context.set);
						if (result) return (context.response = result);
					}
				}
			let response = typeof handle === "function" ? handle(context) : handle;
			if (response instanceof Promise) response = await response;
			if (!hooks.afterHandle?.length) {
				let isCustomStatuResponse = response instanceof ElysiaCustomStatusResponse,
					status2 = isCustomStatuResponse
						? response.code
						: set2.status
							? typeof set2.status === "string"
								? StatusMap[set2.status]
								: set2.status
							: 200;
				if (isCustomStatuResponse) ((set2.status = status2), (response = response.response));
				let responseValidator = validator?.createResponse?.()?.[status2];
				if (responseValidator?.Check(response) === false)
					if (responseValidator?.Clean) {
						let temp = responseValidator.Clean(response);
						if (responseValidator?.Check(temp) === false)
							throw new ValidationError("response", responseValidator, response);
						response = temp;
					} else throw new ValidationError("response", responseValidator, response);
				if (responseValidator?.Encode) response = responseValidator.Encode(response);
				if (responseValidator?.Clean) response = responseValidator.Clean(response);
			} else {
				context.response = response;
				for (let i = 0; i < hooks.afterHandle.length; i++) {
					let response2 = hooks.afterHandle[i].fn(context);
					if (response2 instanceof Promise) response2 = await response2;
					let isCustomStatuResponse = response2 instanceof ElysiaCustomStatusResponse,
						status2 = isCustomStatuResponse
							? response2.code
							: set2.status
								? typeof set2.status === "string"
									? StatusMap[set2.status]
									: set2.status
								: 200;
					if (isCustomStatuResponse) ((set2.status = status2), (response2 = response2.response));
					let responseValidator = validator?.createResponse?.()?.[status2];
					if (responseValidator?.Check(response2) === false)
						if (responseValidator?.Clean) {
							let temp = responseValidator.Clean(response2);
							if (responseValidator?.Check(temp) === false)
								throw new ValidationError("response", responseValidator, response2);
							response2 = temp;
						} else throw new ValidationError("response", responseValidator, response2);
					if (responseValidator?.Encode)
						context.response = response2 = responseValidator.Encode(response2);
					if (responseValidator?.Clean)
						context.response = response2 = responseValidator.Clean(response2);
					let result = mapEarlyResponse3(response2, context.set);
					if (result !== undefined) return (context.response = result);
				}
			}
			if (context.set.cookie && cookieMeta?.sign) {
				let secret = !cookieMeta.secrets
					? undefined
					: typeof cookieMeta.secrets === "string"
						? cookieMeta.secrets
						: cookieMeta.secrets[0];
				if (cookieMeta.sign === true) {
					if (secret)
						for (let [key, cookie] of Object.entries(context.set.cookie))
							context.set.cookie[key].value = await signCookie(cookie.value, secret);
				} else {
					let properties = validator?.cookie?.schema?.properties;
					if (secret)
						for (let name of cookieMeta.sign) {
							if (!(name in properties)) continue;
							if (context.set.cookie[name]?.value)
								context.set.cookie[name].value = await signCookie(
									context.set.cookie[name].value,
									secret,
								);
						}
				}
			}
			return mapResponse3((context.response = response), context.set);
		} catch (error) {
			let reportedError =
				error instanceof TransformDecodeError && error.error ? error.error : error;
			return app.handleError(context, reportedError);
		} finally {
			if (app.event.afterResponse)
				setImmediate(async () => {
					for (let afterResponse of app.event.afterResponse) await afterResponse.fn(context);
				});
		}
	};
};
var createDynamicErrorHandler = (app) => {
	let { mapResponse: mapResponse3 } = app["~adapter"].handler;
	return async (context, error) => {
		let errorContext = Object.assign(context, { error, code: error.code });
		if (
			((errorContext.set = context.set),
			typeof error?.toResponse === "function" &&
				!(error instanceof ValidationError) &&
				!(error instanceof TransformDecodeError))
		)
			try {
				let raw = error.toResponse();
				if (typeof raw?.then === "function") raw = await raw;
				if (raw instanceof Response) context.set.status = raw.status;
				context.response = raw;
			} catch (toResponseError) {}
		if (!context.response && app.event.error)
			for (let i = 0; i < app.event.error.length; i++) {
				let response = app.event.error[i].fn(errorContext);
				if (response instanceof Promise) response = await response;
				if (response !== undefined && response !== null)
					return (context.response = mapResponse3(response, context.set));
			}
		if (context.response) {
			if (app.event.mapResponse)
				for (let i = 0; i < app.event.mapResponse.length; i++) {
					let response = app.event.mapResponse[i].fn(errorContext);
					if (response instanceof Promise) response = await response;
					if (response !== undefined && response !== null) context.response = response;
				}
			return mapResponse3(context.response, context.set);
		}
		return new Response(typeof error.cause === "string" ? error.cause : error.message, {
			headers: context.set.headers,
			status: error.status ?? 500,
		});
	};
};

class Elysia {
	config;
	server = null;
	dependencies = {};
	"~Prefix" = "";
	"~Singleton" = null;
	"~Definitions" = null;
	"~Metadata" = null;
	"~Ephemeral" = null;
	"~Volatile" = null;
	"~Routes" = null;
	singleton = { decorator: {}, store: {}, derive: {}, resolve: {} };
	get store() {
		return this.singleton.store;
	}
	get decorator() {
		return this.singleton.decorator;
	}
	definitions = { typebox: t.Module({}), type: {}, error: {} };
	extender = { macro: {}, higherOrderFunctions: [] };
	validator = {
		global: null,
		scoped: null,
		local: null,
		getCandidate() {
			if (!this.global && !this.scoped && !this.local)
				return {
					body: undefined,
					headers: undefined,
					params: undefined,
					query: undefined,
					cookie: undefined,
					response: undefined,
				};
			return mergeSchemaValidator(mergeSchemaValidator(this.global, this.scoped), this.local);
		},
	};
	standaloneValidator = { global: null, scoped: null, local: null };
	event = {};
	telemetry;
	router = {
		"~http": undefined,
		get http() {
			if (!this["~http"])
				this["~http"] = new _({ lazy: true, onParam: import_fast_decode_uri_component4.default });
			return this["~http"];
		},
		"~dynamic": undefined,
		get dynamic() {
			if (!this["~dynamic"])
				this["~dynamic"] = new _({ onParam: import_fast_decode_uri_component4.default });
			return this["~dynamic"];
		},
		static: {},
		response: {},
		history: [],
	};
	routeTree = {};
	get routes() {
		return this.router.history;
	}
	getGlobalRoutes() {
		return this.router.history;
	}
	getGlobalDefinitions() {
		return this.definitions;
	}
	inference = {
		body: false,
		cookie: false,
		headers: false,
		query: false,
		set: false,
		server: false,
		path: false,
		route: false,
		url: false,
	};
	getServer() {
		return this.server;
	}
	getParent() {
		return null;
	}
	"~parser" = {};
	_promisedModules;
	get promisedModules() {
		if (!this._promisedModules) this._promisedModules = new PromiseGroup(console.error, () => {});
		return this._promisedModules;
	}
	constructor(config = {}) {
		if (config.tags)
			if (!config.detail) config.detail = { tags: config.tags };
			else config.detail.tags = config.tags;
		if (
			((this.config = {
				aot: env2.ELYSIA_AOT !== "false",
				nativeStaticResponse: true,
				systemRouter: true,
				encodeSchema: true,
				normalize: true,
				...config,
				prefix: config.prefix
					? config.prefix.charCodeAt(0) === 47
						? config.prefix
						: `/${config.prefix}`
					: undefined,
				cookie: { path: "/", ...config?.cookie },
				experimental: config?.experimental ?? {},
				seed: config?.seed === undefined ? "" : config?.seed,
			}),
			(this["~adapter"] = config.adapter ?? (typeof Bun < "u" ? BunAdapter : WebStandardAdapter)),
			config?.analytic && (config?.name || config?.seed !== undefined))
		)
			this.telemetry = { stack: Error().stack };
	}
	"~adapter";
	env(model, _env = env2) {
		if (
			getSchemaValidator(model, {
				modules: this.definitions.typebox,
				dynamic: true,
				additionalProperties: true,
				coerce: true,
				sanitize: () => this.config.sanitize,
			}).Check(_env) === false
		) {
			let error = new ValidationError("env", model, _env);
			throw Error(
				error.all.map((x) => x.summary).join(`
`),
			);
		}
		return this;
	}
	wrap(fn) {
		return (
			this.extender.higherOrderFunctions.push({
				checksum: checksum(
					JSON.stringify({
						name: this.config.name,
						seed: this.config.seed,
						content: fn.toString(),
					}),
				),
				fn,
			}),
			this
		);
	}
	get models() {
		let models = {};
		for (let name of Object.keys(this.definitions.type))
			models[name] = getSchemaValidator(this.definitions.typebox.Import(name));
		return ((models.modules = this.definitions.typebox), models);
	}
	add(method, path, handle, localHook, options) {
		let skipPrefix = options?.skipPrefix ?? false,
			allowMeta = options?.allowMeta ?? false;
		((localHook ??= {}), this.applyMacro(localHook));
		let standaloneValidators = [];
		if (localHook.standaloneValidator)
			standaloneValidators = standaloneValidators.concat(localHook.standaloneValidator);
		if (this.standaloneValidator.local)
			standaloneValidators = standaloneValidators.concat(this.standaloneValidator.local);
		if (this.standaloneValidator.scoped)
			standaloneValidators = standaloneValidators.concat(this.standaloneValidator.scoped);
		if (this.standaloneValidator.global)
			standaloneValidators = standaloneValidators.concat(this.standaloneValidator.global);
		if (path !== "" && path.charCodeAt(0) !== 47) path = "/" + path;
		if (this.config.prefix && !skipPrefix) path = this.config.prefix + path;
		if (localHook?.type)
			switch (localHook.type) {
				case "text":
					localHook.type = "text/plain";
					break;
				case "json":
					localHook.type = "application/json";
					break;
				case "formdata":
					localHook.type = "multipart/form-data";
					break;
				case "urlencoded":
					localHook.type = "application/x-www-form-urlencoded";
					break;
				case "arrayBuffer":
					localHook.type = "application/octet-stream";
					break;
				default:
					break;
			}
		let instanceValidator = this.validator.getCandidate(),
			cloned = {
				body: localHook?.body ?? instanceValidator?.body,
				headers: localHook?.headers ?? instanceValidator?.headers,
				params: localHook?.params ?? instanceValidator?.params,
				query: localHook?.query ?? instanceValidator?.query,
				cookie: localHook?.cookie ?? instanceValidator?.cookie,
				response: localHook?.response ?? instanceValidator?.response,
			},
			shouldPrecompile =
				this.config.precompile === true ||
				(typeof this.config.precompile === "object" && this.config.precompile.compose === true),
			createValidator = () => {
				let models = this.definitions.type,
					dynamic = !this.config.aot,
					normalize = this.config.normalize,
					modules = this.definitions.typebox,
					sanitize2 = () => this.config.sanitize,
					cookieValidator = () => {
						if (cloned.cookie || standaloneValidators.find((x) => x.cookie))
							return getCookieValidator({
								modules,
								validator: cloned.cookie,
								defaultConfig: this.config.cookie,
								normalize,
								config: cloned.cookie?.config ?? {},
								dynamic,
								models,
								validators: standaloneValidators.map((x) => x.cookie),
								sanitize: sanitize2,
							});
					};
				return shouldPrecompile
					? {
							body: getSchemaValidator(cloned.body, {
								modules,
								dynamic,
								models,
								normalize,
								additionalCoerce: coercePrimitiveRoot(),
								validators: standaloneValidators.map((x) => x.body),
								sanitize: sanitize2,
							}),
							headers: getSchemaValidator(cloned.headers, {
								modules,
								dynamic,
								models,
								additionalProperties: true,
								coerce: true,
								additionalCoerce: stringToStructureCoercions(),
								validators: standaloneValidators.map((x) => x.headers),
								sanitize: sanitize2,
							}),
							params: getSchemaValidator(cloned.params, {
								modules,
								dynamic,
								models,
								coerce: true,
								additionalCoerce: stringToStructureCoercions(),
								validators: standaloneValidators.map((x) => x.params),
								sanitize: sanitize2,
							}),
							query: getSchemaValidator(cloned.query, {
								modules,
								dynamic,
								models,
								normalize,
								coerce: true,
								additionalCoerce: queryCoercions(),
								validators: standaloneValidators.map((x) => x.query),
								sanitize: sanitize2,
							}),
							cookie: cookieValidator(),
							response: getResponseSchemaValidator(cloned.response, {
								modules,
								dynamic,
								models,
								normalize,
								validators: standaloneValidators.map((x) => x.response),
								sanitize: sanitize2,
							}),
						}
					: {
							createBody() {
								if (this.body) return this.body;
								return (this.body = getSchemaValidator(cloned.body, {
									modules,
									dynamic,
									models,
									normalize,
									additionalCoerce: coercePrimitiveRoot(),
									validators: standaloneValidators.map((x) => x.body),
									sanitize: sanitize2,
								}));
							},
							createHeaders() {
								if (this.headers) return this.headers;
								return (this.headers = getSchemaValidator(cloned.headers, {
									modules,
									dynamic,
									models,
									normalize,
									additionalProperties: !normalize,
									coerce: true,
									additionalCoerce: stringToStructureCoercions(),
									validators: standaloneValidators.map((x) => x.headers),
									sanitize: sanitize2,
								}));
							},
							createParams() {
								if (this.params) return this.params;
								return (this.params = getSchemaValidator(cloned.params, {
									modules,
									dynamic,
									models,
									normalize,
									coerce: true,
									additionalCoerce: stringToStructureCoercions(),
									validators: standaloneValidators.map((x) => x.params),
									sanitize: sanitize2,
								}));
							},
							createQuery() {
								if (this.query) return this.query;
								return (this.query = getSchemaValidator(cloned.query, {
									modules,
									dynamic,
									models,
									normalize,
									coerce: true,
									additionalCoerce: queryCoercions(),
									validators: standaloneValidators.map((x) => x.query),
									sanitize: sanitize2,
								}));
							},
							createCookie() {
								if (this.cookie) return this.cookie;
								return (this.cookie = cookieValidator());
							},
							createResponse() {
								if (this.response) return this.response;
								return (this.response = getResponseSchemaValidator(cloned.response, {
									modules,
									dynamic,
									models,
									normalize,
									validators: standaloneValidators.map((x) => x.response),
									sanitize: sanitize2,
								}));
							},
						};
			};
		if (
			instanceValidator.body ||
			instanceValidator.cookie ||
			instanceValidator.headers ||
			instanceValidator.params ||
			instanceValidator.query ||
			instanceValidator.response
		)
			localHook = mergeHook(localHook, instanceValidator);
		if (localHook.tags)
			if (!localHook.detail) localHook.detail = { tags: localHook.tags };
			else localHook.detail.tags = localHook.tags;
		if (isNotEmpty(this.config.detail))
			localHook.detail = mergeDeep(Object.assign({}, this.config.detail), localHook.detail);
		let hooks = isNotEmpty(this.event)
			? mergeHook(this.event, localHookToLifeCycleStore(localHook))
			: { ...lifeCycleToArray(localHookToLifeCycleStore(localHook)) };
		if (standaloneValidators.length)
			Object.assign(hooks, { standaloneValidator: standaloneValidators });
		if (this.config.aot === false) {
			let validator = createValidator();
			this.router.dynamic.add(method, path, {
				validator,
				hooks,
				content: localHook?.type,
				handle,
				route: path,
			});
			let encoded = encodePath(path, { dynamic: true });
			if (path !== encoded)
				this.router.dynamic.add(method, encoded, {
					validator,
					hooks,
					content: localHook?.type,
					handle,
					route: path,
				});
			if (!this.config.strictPath) {
				let loosePath = getLoosePath(path);
				this.router.dynamic.add(method, loosePath, {
					validator,
					hooks,
					content: localHook?.type,
					handle,
					route: path,
				});
				let encoded2 = encodePath(loosePath);
				if (loosePath !== encoded2)
					this.router.dynamic.add(method, loosePath, {
						validator,
						hooks,
						content: localHook?.type,
						handle,
						route: path,
					});
			}
			this.router.history.push({
				method,
				path,
				composed: null,
				handler: handle,
				compile: undefined,
				hooks,
			});
			return;
		}
		let adapter = this["~adapter"].handler,
			nativeStaticHandler =
				typeof handle !== "function"
					? () => {
							let context = {
								redirect,
								request: this["~adapter"].isWebStandard
									? new Request(`http://ely.sia${path}`, { method })
									: undefined,
								server: null,
								set: { headers: Object.assign({}, this.setHeaders) },
								status,
								store: this.store,
							};
							try {
								this.event.request?.map((x) => {
									if (typeof x.fn === "function") return x.fn(context);
									if (typeof x === "function") return x(context);
								});
							} catch (error) {
								let res;
								if (
									((context.error = error),
									this.event.error?.some((x) => {
										if (typeof x.fn === "function") return (res = x.fn(context));
										if (typeof x === "function") return (res = x(context));
									}),
									res !== undefined)
								)
									handle = res;
							}
							let fn = adapter.createNativeStaticHandler?.(handle, hooks, context.set);
							return fn instanceof Promise
								? fn.then((fn2) => {
										if (fn2) return fn2;
									})
								: fn?.();
						}
					: undefined,
			useNativeStaticResponse = this.config.nativeStaticResponse === true,
			addResponsePath = (path2) => {
				if (!useNativeStaticResponse || !nativeStaticHandler) return;
				if (supportPerMethodInlineHandler)
					if (this.router.response[path2])
						this.router.response[path2][method] = nativeStaticHandler();
					else this.router.response[path2] = { [method]: nativeStaticHandler() };
				else this.router.response[path2] = nativeStaticHandler();
			};
		addResponsePath(path);
		let compile2 = () => {
				let compiled = composeHandler({
					app: this,
					path,
					method,
					hooks,
					validator: createValidator(),
					handler:
						typeof handle !== "function" && typeof adapter.createStaticHandler !== "function"
							? () => handle
							: handle,
					allowMeta,
					inference: this.inference,
				});
				if (this.router.history[index]) this.router.history[index].composed = compiled;
				return compiled;
			},
			oldIndex;
		if (`${method}_${path}` in this.routeTree)
			for (let i = 0; i < this.router.history.length; i++) {
				let route2 = this.router.history[i];
				if (route2.path === path && route2.method === method) {
					oldIndex = i;
					break;
				}
			}
		else this.routeTree[`${method}_${path}`] = this.router.history.length;
		let index = oldIndex ?? this.router.history.length,
			route = this.router.history,
			mainHandler = shouldPrecompile
				? compile2()
				: (ctx) => (route[index].composed = compile2())(ctx);
		if (oldIndex !== undefined)
			this.router.history[oldIndex] = Object.assign(
				{ method, path, composed: mainHandler, compile: compile2, handler: handle, hooks },
				standaloneValidators.length ? { standaloneValidators } : undefined,
				localHook.webSocket ? { websocket: localHook.websocket } : undefined,
			);
		else
			this.router.history.push(
				Object.assign(
					{ method, path, composed: mainHandler, compile: compile2, handler: handle, hooks },
					localHook.webSocket ? { websocket: localHook.websocket } : undefined,
				),
			);
		let handler = {
				handler: shouldPrecompile ? route[index].composed : undefined,
				compile() {
					return (this.handler = compile2());
				},
			},
			staticRouter = this.router.static,
			isStaticPath = path.indexOf(":") === -1 && path.indexOf("*") === -1;
		if (method === "WS") {
			if (isStaticPath) {
				if (path in staticRouter) staticRouter[path][method] = index;
				else staticRouter[path] = { [method]: index };
				return;
			}
			if ((this.router.http.add("WS", path, handler), !this.config.strictPath))
				this.router.http.add("WS", getLoosePath(path), handler);
			let encoded = encodePath(path, { dynamic: true });
			if (path !== encoded) this.router.http.add("WS", encoded, handler);
			return;
		}
		if (isStaticPath) {
			if (path in staticRouter) staticRouter[path][method] = index;
			else staticRouter[path] = { [method]: index };
			if (!this.config.strictPath) addResponsePath(getLoosePath(path));
		} else {
			if ((this.router.http.add(method, path, handler), !this.config.strictPath)) {
				let loosePath = getLoosePath(path);
				(addResponsePath(loosePath), this.router.http.add(method, loosePath, handler));
			}
			let encoded = encodePath(path, { dynamic: true });
			if (path !== encoded)
				(this.router.http.add(method, encoded, handler), addResponsePath(encoded));
		}
	}
	setHeaders;
	headers(header) {
		if (!header) return this;
		if (!this.setHeaders) this.setHeaders = {};
		return ((this.setHeaders = mergeDeep(this.setHeaders, header)), this);
	}
	onStart(handler) {
		return (this.on("start", handler), this);
	}
	onRequest(handler) {
		return (this.on("request", handler), this);
	}
	onParse(options, handler) {
		if (!handler) {
			if (typeof options === "string") return this.on("parse", this["~parser"][options]);
			return this.on("parse", options);
		}
		return this.on(options, "parse", handler);
	}
	parser(name, parser) {
		return ((this["~parser"][name] = parser), this);
	}
	onTransform(options, handler) {
		if (!handler) return this.on("transform", options);
		return this.on(options, "transform", handler);
	}
	resolve(optionsOrResolve, resolve) {
		if (!resolve) ((resolve = optionsOrResolve), (optionsOrResolve = { as: "local" }));
		let hook = { subType: "resolve", fn: resolve };
		return this.onBeforeHandle(optionsOrResolve, hook);
	}
	mapResolve(optionsOrResolve, mapper) {
		if (!mapper) ((mapper = optionsOrResolve), (optionsOrResolve = { as: "local" }));
		let hook = { subType: "mapResolve", fn: mapper };
		return this.onBeforeHandle(optionsOrResolve, hook);
	}
	onBeforeHandle(options, handler) {
		if (!handler) return this.on("beforeHandle", options);
		return this.on(options, "beforeHandle", handler);
	}
	onAfterHandle(options, handler) {
		if (!handler) return this.on("afterHandle", options);
		return this.on(options, "afterHandle", handler);
	}
	mapResponse(options, handler) {
		if (!handler) return this.on("mapResponse", options);
		return this.on(options, "mapResponse", handler);
	}
	onAfterResponse(options, handler) {
		if (!handler) return this.on("afterResponse", options);
		return this.on(options, "afterResponse", handler);
	}
	trace(options, handler) {
		if (!handler) ((handler = options), (options = { as: "local" }));
		if (!Array.isArray(handler)) handler = [handler];
		for (let fn of handler) this.on(options, "trace", createTracer(fn));
		return this;
	}
	error(name, error) {
		switch (typeof name) {
			case "string":
				return ((error.prototype[ERROR_CODE] = name), (this.definitions.error[name] = error), this);
			case "function":
				return ((this.definitions.error = name(this.definitions.error)), this);
		}
		for (let [code, error2] of Object.entries(name))
			((error2.prototype[ERROR_CODE] = code), (this.definitions.error[code] = error2));
		return this;
	}
	onError(options, handler) {
		if (!handler) return this.on("error", options);
		return this.on(options, "error", handler);
	}
	onStop(handler) {
		return (this.on("stop", handler), this);
	}
	on(optionsOrType, typeOrHandlers, handlers) {
		let type;
		switch (typeof optionsOrType) {
			case "string":
				((type = optionsOrType), (handlers = typeOrHandlers));
				break;
			case "object":
				if (
					((type = typeOrHandlers),
					!Array.isArray(typeOrHandlers) && typeof typeOrHandlers === "object")
				)
					handlers = typeOrHandlers;
				break;
		}
		if (Array.isArray(handlers)) handlers = fnToContainer(handlers);
		else if (typeof handlers === "function") handlers = [{ fn: handlers }];
		else handlers = [handlers];
		let handles = handlers;
		for (let handle of handles)
			if (
				((handle.scope =
					typeof optionsOrType === "string" ? "local" : (optionsOrType?.as ?? "local")),
				type === "resolve" || type === "derive")
			)
				handle.subType = type;
		if (type !== "trace")
			this.inference = sucrose(
				{ [type]: handles.map((x) => x.fn) },
				this.inference,
				this.config.sucrose,
			);
		for (let handle of handles) {
			let fn = asHookType(handle, "global", { skipIfHasType: true });
			switch (type) {
				case "start":
					((this.event.start ??= []), this.event.start.push(fn));
					break;
				case "request":
					((this.event.request ??= []), this.event.request.push(fn));
					break;
				case "parse":
					((this.event.parse ??= []), this.event.parse.push(fn));
					break;
				case "transform":
					((this.event.transform ??= []), this.event.transform.push(fn));
					break;
				case "derive":
					((this.event.transform ??= []), this.event.transform.push(fnToContainer(fn, "derive")));
					break;
				case "beforeHandle":
					((this.event.beforeHandle ??= []), this.event.beforeHandle.push(fn));
					break;
				case "resolve":
					((this.event.beforeHandle ??= []),
						this.event.beforeHandle.push(fnToContainer(fn, "resolve")));
					break;
				case "afterHandle":
					((this.event.afterHandle ??= []), this.event.afterHandle.push(fn));
					break;
				case "mapResponse":
					((this.event.mapResponse ??= []), this.event.mapResponse.push(fn));
					break;
				case "afterResponse":
					((this.event.afterResponse ??= []), this.event.afterResponse.push(fn));
					break;
				case "trace":
					((this.event.trace ??= []), this.event.trace.push(fn));
					break;
				case "error":
					((this.event.error ??= []), this.event.error.push(fn));
					break;
				case "stop":
					((this.event.stop ??= []), this.event.stop.push(fn));
					break;
			}
		}
		return this;
	}
	as(type) {
		if (
			(promoteEvent(this.event.parse, type),
			promoteEvent(this.event.transform, type),
			promoteEvent(this.event.beforeHandle, type),
			promoteEvent(this.event.afterHandle, type),
			promoteEvent(this.event.mapResponse, type),
			promoteEvent(this.event.afterResponse, type),
			promoteEvent(this.event.trace, type),
			promoteEvent(this.event.error, type),
			type === "scoped")
		) {
			if (
				((this.validator.scoped = mergeSchemaValidator(
					this.validator.scoped,
					this.validator.local,
				)),
				(this.validator.local = null),
				this.standaloneValidator.local !== null)
			)
				((this.standaloneValidator.scoped ||= []),
					this.standaloneValidator.scoped.push(...this.standaloneValidator.local),
					(this.standaloneValidator.local = null));
		} else if (type === "global") {
			if (
				((this.validator.global = mergeSchemaValidator(
					this.validator.global,
					mergeSchemaValidator(this.validator.scoped, this.validator.local),
				)),
				(this.validator.scoped = null),
				(this.validator.local = null),
				this.standaloneValidator.local !== null)
			)
				((this.standaloneValidator.scoped ||= []),
					this.standaloneValidator.scoped.push(...this.standaloneValidator.local),
					(this.standaloneValidator.local = null));
			if (this.standaloneValidator.scoped !== null)
				((this.standaloneValidator.global ||= []),
					this.standaloneValidator.global.push(...this.standaloneValidator.scoped),
					(this.standaloneValidator.scoped = null));
		}
		return this;
	}
	group(prefix, schemaOrRun, run) {
		let instance = new Elysia({ ...this.config, prefix: "" });
		((instance.singleton = { ...this.singleton }),
			(instance.definitions = { ...this.definitions }),
			(instance.getServer = () => this.getServer()),
			(instance.inference = cloneInference(this.inference)),
			(instance.extender = { ...this.extender }),
			(instance["~parser"] = this["~parser"]),
			(instance.standaloneValidator = {
				local: [...(this.standaloneValidator.local ?? [])],
				scoped: [...(this.standaloneValidator.scoped ?? [])],
				global: [...(this.standaloneValidator.global ?? [])],
			}));
		let isSchema = typeof schemaOrRun === "object",
			sandbox = (isSchema ? run : schemaOrRun)(instance);
		if (
			((this.singleton = mergeDeep(this.singleton, instance.singleton)),
			(this.definitions = mergeDeep(this.definitions, instance.definitions)),
			sandbox.event.request?.length)
		)
			this.event.request = [...(this.event.request || []), ...(sandbox.event.request || [])];
		if (sandbox.event.mapResponse?.length)
			this.event.mapResponse = [
				...(this.event.mapResponse || []),
				...(sandbox.event.mapResponse || []),
			];
		return (
			this.model(sandbox.definitions.type),
			Object.values(instance.router.history).forEach(({ method, path, handler, hooks }) => {
				if (((path = (isSchema ? "" : (this.config.prefix ?? "")) + prefix + path), isSchema)) {
					let { body, headers, query, params, cookie, response, ...hook } = schemaOrRun,
						localHook = hooks,
						hasStandaloneSchema = body || headers || query || params || cookie || response;
					this.add(
						method,
						path,
						handler,
						mergeHook(hook, {
							...(localHook || {}),
							error: !localHook.error
								? sandbox.event.error
								: Array.isArray(localHook.error)
									? [...(localHook.error ?? []), ...(sandbox.event.error ?? [])]
									: [localHook.error, ...(sandbox.event.error ?? [])],
							standaloneValidator: !hasStandaloneSchema
								? localHook.standaloneValidator
								: [
										...(localHook.standaloneValidator ?? []),
										{ body, headers, query, params, cookie, response },
									],
						}),
						undefined,
					);
				} else
					this.add(method, path, handler, mergeHook(hooks, { error: sandbox.event.error }), {
						skipPrefix: true,
					});
			}),
			this
		);
	}
	guard(hook, run) {
		if (!run) {
			if (typeof hook === "object") {
				if ((this.applyMacro(hook), hook.detail))
					if (this.config.detail)
						this.config.detail = mergeDeep(Object.assign({}, this.config.detail), hook.detail);
					else this.config.detail = hook.detail;
				if (hook.tags)
					if (!this.config.detail) this.config.detail = { tags: hook.tags };
					else this.config.detail.tags = hook.tags;
				let type = hook.as ?? "local";
				if (hook.schema === "standalone") {
					if (!this.standaloneValidator[type]) this.standaloneValidator[type] = [];
					let response = !hook?.response
						? undefined
						: typeof hook.response === "string" ||
							  Kind in hook.response ||
							  "~standard" in hook.response
							? { 200: hook.response }
							: hook?.response;
					this.standaloneValidator[type].push({
						body: hook.body,
						headers: hook.headers,
						params: hook.params,
						query: hook.query,
						response,
						cookie: hook.cookie,
					});
				} else
					this.validator[type] = {
						body: hook.body ?? this.validator[type]?.body,
						headers: hook.headers ?? this.validator[type]?.headers,
						params: hook.params ?? this.validator[type]?.params,
						query: hook.query ?? this.validator[type]?.query,
						response: hook.response ?? this.validator[type]?.response,
						cookie: hook.cookie ?? this.validator[type]?.cookie,
					};
				if (hook.parse) this.on({ as: type }, "parse", hook.parse);
				if (hook.transform) this.on({ as: type }, "transform", hook.transform);
				if (hook.derive) this.on({ as: type }, "derive", hook.derive);
				if (hook.beforeHandle) this.on({ as: type }, "beforeHandle", hook.beforeHandle);
				if (hook.resolve) this.on({ as: type }, "resolve", hook.resolve);
				if (hook.afterHandle) this.on({ as: type }, "afterHandle", hook.afterHandle);
				if (hook.mapResponse) this.on({ as: type }, "mapResponse", hook.mapResponse);
				if (hook.afterResponse) this.on({ as: type }, "afterResponse", hook.afterResponse);
				if (hook.error) this.on({ as: type }, "error", hook.error);
				return this;
			}
			return this.guard({}, hook);
		}
		let instance = new Elysia({ ...this.config, prefix: "" });
		((instance.singleton = { ...this.singleton }),
			(instance.definitions = { ...this.definitions }),
			(instance.inference = cloneInference(this.inference)),
			(instance.extender = { ...this.extender }),
			(instance.getServer = () => this.getServer()));
		let sandbox = run(instance);
		if (
			((this.singleton = mergeDeep(this.singleton, instance.singleton)),
			(this.definitions = mergeDeep(this.definitions, instance.definitions)),
			(sandbox.getServer = () => this.server),
			sandbox.event.request?.length)
		)
			this.event.request = [...(this.event.request || []), ...(sandbox.event.request || [])];
		if (sandbox.event.mapResponse?.length)
			this.event.mapResponse = [
				...(this.event.mapResponse || []),
				...(sandbox.event.mapResponse || []),
			];
		return (
			this.model(sandbox.definitions.type),
			Object.values(instance.router.history).forEach(
				({ method, path, handler, hooks: localHook }) => {
					let { body, headers, query, params, cookie, response, ...guardHook } = hook,
						hasStandaloneSchema = body || headers || query || params || cookie || response;
					this.add(
						method,
						path,
						handler,
						mergeHook(guardHook, {
							...(localHook || {}),
							error: !localHook.error
								? sandbox.event.error
								: Array.isArray(localHook.error)
									? [...(localHook.error ?? []), ...(sandbox.event.error ?? [])]
									: [localHook.error, ...(sandbox.event.error ?? [])],
							standaloneValidator: !hasStandaloneSchema
								? localHook.standaloneValidator
								: [
										...(localHook.standaloneValidator ?? []),
										{ body, headers, query, params, cookie, response },
									],
						}),
					);
				},
			),
			this
		);
	}
	use(plugin) {
		if (!plugin) return this;
		if (Array.isArray(plugin)) {
			let app = this;
			for (let p of plugin) app = app.use(p);
			return app;
		}
		if (plugin instanceof Promise)
			return (
				this.promisedModules.add(
					plugin
						.then((plugin2) => {
							if (typeof plugin2 === "function") return plugin2(this);
							if (plugin2 instanceof Elysia) return this._use(plugin2).compile();
							if (plugin2.constructor?.name === "Elysia") return this._use(plugin2).compile();
							if (typeof plugin2.default === "function") return plugin2.default(this);
							if (plugin2.default instanceof Elysia) return this._use(plugin2.default);
							if (plugin2.constructor?.name === "Elysia") return this._use(plugin2.default);
							if (plugin2.constructor?.name === "_Elysia") return this._use(plugin2.default);
							try {
								return this._use(plugin2.default);
							} catch (error) {
								throw (
									console.error(
										'Invalid plugin type. Expected Elysia instance, function, or module with "default" as Elysia instance or function that returns Elysia instance.',
									),
									error
								);
							}
						})
						.then((v) => {
							if (v && typeof v.compile === "function") v.compile();
							return v;
						}),
				),
				this
			);
		return this._use(plugin);
	}
	propagatePromiseModules(plugin) {
		if (plugin.promisedModules.size <= 0) return this;
		for (let promise of plugin.promisedModules.promises)
			this.promisedModules.add(
				promise.then((v) => {
					if (!v) return;
					let t2 = this._use(v);
					if (t2 instanceof Promise)
						return t2.then((v2) => {
							if (v2) v2.compile();
							else v.compile();
						});
					return v.compile();
				}),
			);
		return this;
	}
	_use(plugin) {
		if (typeof plugin === "function") {
			let instance = plugin(this);
			if (instance instanceof Promise)
				return (
					this.promisedModules.add(
						instance
							.then((plugin2) => {
								if (plugin2 instanceof Elysia) {
									((plugin2.getServer = () => this.getServer()),
										(plugin2.getGlobalRoutes = () => this.getGlobalRoutes()),
										(plugin2.getGlobalDefinitions = () => this.getGlobalDefinitions()),
										plugin2.model(this.definitions.type),
										plugin2.error(this.definitions.error));
									for (let { method, path, handler, hooks } of Object.values(
										plugin2.router.history,
									))
										this.add(method, path, handler, hooks, undefined);
									if (plugin2 === this) return;
									return (this.propagatePromiseModules(plugin2), plugin2);
								}
								if (typeof plugin2 === "function") return plugin2(this);
								if (typeof plugin2.default === "function") return plugin2.default(this);
								return this._use(plugin2);
							})
							.then((v) => {
								if (v && typeof v.compile === "function") v.compile();
								return v;
							}),
					),
					this
				);
			return instance;
		}
		this.propagatePromiseModules(plugin);
		let name = plugin.config.name,
			seed = plugin.config.seed;
		if (
			((plugin.getParent = () => this),
			(plugin.getServer = () => this.getServer()),
			(plugin.getGlobalRoutes = () => this.getGlobalRoutes()),
			(plugin.getGlobalDefinitions = () => this.getGlobalDefinitions()),
			plugin.standaloneValidator?.scoped)
		)
			if (this.standaloneValidator.local)
				this.standaloneValidator.local = this.standaloneValidator.local.concat(
					plugin.standaloneValidator.scoped,
				);
			else this.standaloneValidator.local = plugin.standaloneValidator.scoped;
		if (plugin.standaloneValidator?.global)
			if (this.standaloneValidator.global)
				this.standaloneValidator.global = this.standaloneValidator.global.concat(
					plugin.standaloneValidator.global,
				);
			else this.standaloneValidator.global = plugin.standaloneValidator.global;
		if (isNotEmpty(plugin["~parser"]))
			this["~parser"] = { ...plugin["~parser"], ...this["~parser"] };
		if (plugin.setHeaders) this.headers(plugin.setHeaders);
		if (name) {
			if (!(name in this.dependencies)) this.dependencies[name] = [];
			let current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
			if (!this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
				((this.extender.macro = { ...this.extender.macro, ...plugin.extender.macro }),
					(this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(
						plugin.extender.higherOrderFunctions,
					)));
		} else {
			if (isNotEmpty(plugin.extender.macro))
				this.extender.macro = { ...this.extender.macro, ...plugin.extender.macro };
			if (plugin.extender.higherOrderFunctions.length)
				this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(
					plugin.extender.higherOrderFunctions,
				);
		}
		if (plugin.extender.higherOrderFunctions.length) {
			deduplicateChecksum(this.extender.higherOrderFunctions);
			let hofHashes = [];
			for (let i = 0; i < this.extender.higherOrderFunctions.length; i++) {
				let hof = this.extender.higherOrderFunctions[i];
				if (hof.checksum) {
					if (hofHashes.includes(hof.checksum))
						(this.extender.higherOrderFunctions.splice(i, 1), i--);
					hofHashes.push(hof.checksum);
				}
			}
			hofHashes.length = 0;
		}
		if (
			((this.inference = mergeInference(this.inference, plugin.inference)),
			isNotEmpty(plugin.singleton.decorator))
		)
			this.decorate(plugin.singleton.decorator);
		if (isNotEmpty(plugin.singleton.store)) this.state(plugin.singleton.store);
		if (isNotEmpty(plugin.definitions.type)) this.model(plugin.definitions.type);
		if (isNotEmpty(plugin.definitions.error)) this.error(plugin.definitions.error);
		if (isNotEmpty(plugin.extender.macro))
			this.extender.macro = { ...this.extender.macro, ...plugin.extender.macro };
		for (let { method, path, handler, hooks } of Object.values(plugin.router.history))
			this.add(method, path, handler, hooks);
		if (name) {
			if (!(name in this.dependencies)) this.dependencies[name] = [];
			let current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
			if (this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
				return this;
			if (
				(this.dependencies[name].push(
					this.config?.analytic
						? {
								name: plugin.config.name,
								seed: plugin.config.seed,
								checksum: current,
								dependencies: plugin.dependencies,
								stack: plugin.telemetry?.stack,
								routes: plugin.router.history,
								decorators: plugin.singleton,
								store: plugin.singleton.store,
								error: plugin.definitions.error,
								derive: plugin.event.transform
									?.filter((x) => x?.subType === "derive")
									.map((x) => ({ fn: x.toString(), stack: Error().stack ?? "" })),
								resolve: plugin.event.transform
									?.filter((x) => x?.subType === "resolve")
									.map((x) => ({ fn: x.toString(), stack: Error().stack ?? "" })),
							}
						: {
								name: plugin.config.name,
								seed: plugin.config.seed,
								checksum: current,
								dependencies: plugin.dependencies,
							},
				),
				isNotEmpty(plugin.event))
			)
				this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event), current);
		} else if (isNotEmpty(plugin.event))
			this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event));
		if (plugin.validator.global)
			this.validator.global = mergeHook(this.validator.global, { ...plugin.validator.global });
		if (plugin.validator.scoped)
			this.validator.local = mergeHook(this.validator.local, { ...plugin.validator.scoped });
		return this;
	}
	macro(macroOrName, macro) {
		if (typeof macroOrName === "string" && !macro) throw Error("Macro function is required");
		if (typeof macroOrName === "string") this.extender.macro[macroOrName] = macro;
		else this.extender.macro = { ...this.extender.macro, ...macroOrName };
		return this;
	}
	applyMacro(localHook, appliable = localHook, { iteration = 0, applied = {} } = {}) {
		if (iteration >= 16) return;
		let macro = this.extender.macro;
		for (let [key, value] of Object.entries(appliable)) {
			if (key in macro === false) continue;
			let macroHook = typeof macro[key] === "function" ? macro[key](value) : macro[key];
			if (!macroHook || (typeof macro[key] === "object" && value === false)) return;
			let seed = checksum(key + JSON.stringify(macroHook.seed ?? value));
			if (seed in applied) continue;
			applied[seed] = true;
			for (let [k2, value2] of Object.entries(macroHook)) {
				if (k2 === "seed") continue;
				if (k2 in emptySchema) {
					(insertStandaloneValidator(localHook, k2, value2), delete localHook[key]);
					continue;
				}
				if (k2 === "introspect") {
					(value2?.(localHook), delete localHook[key]);
					continue;
				}
				if (k2 === "detail") {
					if (!localHook.detail) localHook.detail = {};
					((localHook.detail = mergeDeep(localHook.detail, value2, { mergeArray: true })),
						delete localHook[key]);
					continue;
				}
				if (k2 in macro) {
					(this.applyMacro(localHook, { [k2]: value2 }, { applied, iteration: iteration + 1 }),
						delete localHook[key]);
					continue;
				}
				if ((k2 === "derive" || k2 === "resolve") && typeof value2 === "function")
					value2 = { fn: value2, subType: k2 };
				switch (typeof localHook[k2]) {
					case "function":
						localHook[k2] = [localHook[k2], value2];
						break;
					case "object":
						if (Array.isArray(localHook[k2])) localHook[k2].push(value2);
						else localHook[k2] = [localHook[k2], value2];
						break;
					case "undefined":
						localHook[k2] = value2;
						break;
				}
				delete localHook[key];
			}
		}
	}
	mount(path, handleOrConfig, config) {
		if (path instanceof Elysia || typeof path === "function" || path.length === 0 || path === "/") {
			let run =
					typeof path === "function"
						? path
						: path instanceof Elysia
							? path.compile().fetch
							: handleOrConfig instanceof Elysia
								? handleOrConfig.compile().fetch
								: typeof handleOrConfig === "function"
									? handleOrConfig
									: (() => {
											throw Error("Invalid handler");
										})(),
				handler2 = ({ request, path: path2 }) =>
					run(
						new Request(replaceUrlPath(request.url, path2), {
							method: request.method,
							headers: request.headers,
							signal: request.signal,
							credentials: request.credentials,
							referrerPolicy: request.referrerPolicy,
							duplex: request.duplex,
							redirect: request.redirect,
							mode: request.mode,
							keepalive: request.keepalive,
							integrity: request.integrity,
							body: request.body,
						}),
					);
			return (
				this.route("ALL", "/*", handler2, {
					parse: "none",
					...config,
					detail: { ...config?.detail, hide: true },
					config: { mount: run },
				}),
				this
			);
		}
		let handle =
				handleOrConfig instanceof Elysia
					? handleOrConfig.compile().fetch
					: typeof handleOrConfig === "function"
						? handleOrConfig
						: (() => {
								throw Error("Invalid handler");
							})(),
			length = path.length - (path.endsWith("*") ? 1 : 0),
			handler = ({ request, path: path2 }) =>
				handle(
					new Request(replaceUrlPath(request.url, path2.slice(length) || "/"), {
						method: request.method,
						headers: request.headers,
						signal: request.signal,
						credentials: request.credentials,
						referrerPolicy: request.referrerPolicy,
						duplex: request.duplex,
						redirect: request.redirect,
						mode: request.mode,
						keepalive: request.keepalive,
						integrity: request.integrity,
						body: request.body,
					}),
				);
		return (
			this.route("ALL", path, handler, {
				parse: "none",
				...config,
				detail: { ...config?.detail, hide: true },
				config: { mount: handle },
			}),
			this.route("ALL", path + (path.endsWith("/") ? "*" : "/*"), handler, {
				parse: "none",
				...config,
				detail: { ...config?.detail, hide: true },
				config: { mount: handle },
			}),
			this
		);
	}
	get(path, handler, hook) {
		return (this.add("GET", path, handler, hook), this);
	}
	post(path, handler, hook) {
		return (this.add("POST", path, handler, hook), this);
	}
	put(path, handler, hook) {
		return (this.add("PUT", path, handler, hook), this);
	}
	patch(path, handler, hook) {
		return (this.add("PATCH", path, handler, hook), this);
	}
	delete(path, handler, hook) {
		return (this.add("DELETE", path, handler, hook), this);
	}
	options(path, handler, hook) {
		return (this.add("OPTIONS", path, handler, hook), this);
	}
	all(path, handler, hook) {
		return (this.add("ALL", path, handler, hook), this);
	}
	head(path, handler, hook) {
		return (this.add("HEAD", path, handler, hook), this);
	}
	connect(path, handler, hook) {
		return (this.add("CONNECT", path, handler, hook), this);
	}
	route(method, path, handler, hook) {
		return (this.add(method.toUpperCase(), path, handler, hook, hook?.config), this);
	}
	ws(path, options) {
		if (this["~adapter"].ws) this["~adapter"].ws(this, path, options);
		else console.warn("Current adapter doesn't support WebSocket");
		return this;
	}
	state(options, name, value) {
		if (name === undefined) ((value = options), (options = { as: "append" }), (name = ""));
		else if (value === undefined) {
			if (typeof options === "string")
				((value = name), (name = options), (options = { as: "append" }));
			else if (typeof options === "object") ((value = name), (name = ""));
		}
		let { as } = options;
		if (typeof name !== "string") return this;
		switch (typeof value) {
			case "object":
				if (!value || !isNotEmpty(value)) return this;
				if (name) {
					if (name in this.singleton.store)
						this.singleton.store[name] = mergeDeep(this.singleton.store[name], value, {
							override: as === "override",
						});
					else this.singleton.store[name] = value;
					return this;
				}
				if (value === null) return this;
				return (
					(this.singleton.store = mergeDeep(this.singleton.store, value, {
						override: as === "override",
					})),
					this
				);
			case "function":
				if (name) {
					if (as === "override" || !(name in this.singleton.store))
						this.singleton.store[name] = value;
				} else this.singleton.store = value(this.singleton.store);
				return this;
			default:
				if (as === "override" || !(name in this.singleton.store))
					this.singleton.store[name] = value;
				return this;
		}
	}
	decorate(options, name, value) {
		if (name === undefined) ((value = options), (options = { as: "append" }), (name = ""));
		else if (value === undefined) {
			if (typeof options === "string")
				((value = name), (name = options), (options = { as: "append" }));
			else if (typeof options === "object") ((value = name), (name = ""));
		}
		let { as } = options;
		if (typeof name !== "string") return this;
		switch (typeof value) {
			case "object":
				if (name) {
					if (name in this.singleton.decorator)
						this.singleton.decorator[name] = mergeDeep(this.singleton.decorator[name], value, {
							override: as === "override",
						});
					else this.singleton.decorator[name] = value;
					return this;
				}
				if (value === null) return this;
				return (
					(this.singleton.decorator = mergeDeep(this.singleton.decorator, value, {
						override: as === "override",
					})),
					this
				);
			case "function":
				if (name) {
					if (as === "override" || !(name in this.singleton.decorator))
						this.singleton.decorator[name] = value;
				} else this.singleton.decorator = value(this.singleton.decorator);
				return this;
			default:
				if (as === "override" || !(name in this.singleton.decorator))
					this.singleton.decorator[name] = value;
				return this;
		}
	}
	derive(optionsOrTransform, transform2) {
		if (!transform2) ((transform2 = optionsOrTransform), (optionsOrTransform = { as: "local" }));
		let hook = { subType: "derive", fn: transform2 };
		return this.onTransform(optionsOrTransform, hook);
	}
	model(name, model) {
		let onlyTypebox = (a) => {
			let res = {};
			for (let key in a) if (!("~standard" in a[key])) res[key] = a[key];
			return res;
		};
		switch (typeof name) {
			case "object":
				let parsedTypebox = {},
					kvs = Object.entries(name);
				if (!kvs.length) return this;
				for (let [key, value] of kvs) {
					if (key in this.definitions.type) continue;
					if ("~standard" in value) this.definitions.type[key] = value;
					else
						((parsedTypebox[key] = this.definitions.type[key] = value),
							(parsedTypebox[key].$id ??= `#/components/schemas/${key}`));
				}
				return (
					(this.definitions.typebox = t.Module({
						...this.definitions.typebox.$defs,
						...parsedTypebox,
					})),
					this
				);
			case "function":
				let result = name(this.definitions.type);
				return (
					(this.definitions.type = result),
					(this.definitions.typebox = t.Module(onlyTypebox(result))),
					this
				);
			case "string":
				if (!model) break;
				if (((this.definitions.type[name] = model), "~standard" in model)) return this;
				let newModel = { ...model, id: model.$id ?? `#/components/schemas/${name}` };
				return (
					(this.definitions.typebox = t.Module({ ...this.definitions.typebox.$defs, ...newModel })),
					this
				);
		}
		if (!model) return this;
		if (((this.definitions.type[name] = model), "~standard" in model)) return this;
		return (
			(this.definitions.typebox = t.Module({ ...this.definitions.typebox.$defs, [name]: model })),
			this
		);
	}
	Ref(key) {
		return t.Ref(key);
	}
	mapDerive(optionsOrDerive, mapper) {
		if (!mapper) ((mapper = optionsOrDerive), (optionsOrDerive = { as: "local" }));
		let hook = { subType: "mapDerive", fn: mapper };
		return this.onTransform(optionsOrDerive, hook);
	}
	affix(base, type, word) {
		if (word === "") return this;
		let delimieter = ["_", "-", " "],
			capitalize = (word2) => word2[0].toUpperCase() + word2.slice(1),
			joinKey =
				base === "prefix"
					? (prefix, word2) =>
							delimieter.includes(prefix.at(-1) ?? "") ? prefix + word2 : prefix + capitalize(word2)
					: delimieter.includes(word.at(-1) ?? "")
						? (suffix, word2) => word2 + suffix
						: (suffix, word2) => word2 + capitalize(suffix),
			remap = (type2) => {
				let store = {};
				switch (type2) {
					case "decorator":
						for (let key in this.singleton.decorator)
							store[joinKey(word, key)] = this.singleton.decorator[key];
						this.singleton.decorator = store;
						break;
					case "state":
						for (let key in this.singleton.store)
							store[joinKey(word, key)] = this.singleton.store[key];
						this.singleton.store = store;
						break;
					case "model":
						for (let key in this.definitions.type)
							store[joinKey(word, key)] = this.definitions.type[key];
						this.definitions.type = store;
						break;
					case "error":
						for (let key in this.definitions.error)
							store[joinKey(word, key)] = this.definitions.error[key];
						this.definitions.error = store;
						break;
				}
			},
			types = Array.isArray(type) ? type : [type];
		for (let type2 of types.some((x) => x === "all")
			? ["decorator", "state", "model", "error"]
			: types)
			remap(type2);
		return this;
	}
	prefix(type, word) {
		return this.affix("prefix", type, word);
	}
	suffix(type, word) {
		return this.affix("suffix", type, word);
	}
	compile() {
		if ((this["~adapter"].beforeCompile?.(this), this["~adapter"].isWebStandard)) {
			if (
				((this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this)),
				typeof this.server?.reload === "function")
			)
				this.server.reload({ ...(this.server || {}), fetch: this.fetch });
			return this;
		}
		if (typeof this.server?.reload === "function") this.server.reload(this.server || {});
		return ((this._handle = composeGeneralHandler(this)), this);
	}
	handle = async (request) => this.fetch(request);
	fetch = (request) => {
		return (this.fetch = this.config.aot
			? composeGeneralHandler(this)
			: createDynamicHandler(this))(request);
	};
	handleError = async (context, error) => {
		return (this.handleError = this.config.aot
			? composeErrorHandler(this)
			: createDynamicErrorHandler(this))(context, error);
	};
	listen = (options, callback) => {
		return (this["~adapter"].listen(this)(options, callback), this);
	};
	stop = async (closeActiveConnections) => {
		return (await this["~adapter"].stop?.(this, closeActiveConnections), this);
	};
	[Symbol.dispose] = () => {
		if (this.server) this.stop();
	};
	get modules() {
		return this.promisedModules;
	}
}

// node_modules/@elysiajs/cors/dist/index.mjs
var isBun3 = typeof new Headers()?.toJSON === "function";
var processHeaders = (headers) => {
	if (isBun3) return Object.keys(headers.toJSON()).join(", ");
	let keys = "";
	let i = 0;
	headers.forEach((_2, key) => {
		if (i) keys = keys + ", " + key;
		else keys = key;
		i++;
	});
	return keys;
};
var cors = (config) => {
	let {
		aot = true,
		origin = true,
		methods = true,
		allowedHeaders = true,
		exposeHeaders = true,
		credentials = true,
		maxAge = 5,
		preflight = true,
	} = config ?? {};
	if (Array.isArray(allowedHeaders)) allowedHeaders = allowedHeaders.join(", ");
	if (Array.isArray(exposeHeaders)) exposeHeaders = exposeHeaders.join(", ");
	const origins =
		typeof origin === "boolean" ? undefined : Array.isArray(origin) ? origin : [origin];
	const app = new Elysia({
		name: "@elysiajs/cors",
		seed: config,
		aot,
	});
	const anyOrigin = origins?.some((o) => o === "*");
	const originMap = {};
	if (origins) {
		for (const origin2 of origins) if (typeof origin2 === "string") originMap[origin2] = true;
	}
	const processOrigin = (origin2, request, from) => {
		if (Array.isArray(origin2)) return origin2.some((o) => processOrigin(o, request, from));
		switch (typeof origin2) {
			case "string":
				if (from in originMap) return true;
				const fromProtocol = from.indexOf("://");
				if (fromProtocol !== -1) from = from.slice(fromProtocol + 3);
				return origin2 === from;
			case "function":
				return origin2(request) === true;
			case "object":
				if (origin2 instanceof RegExp) return origin2.test(from);
		}
		return false;
	};
	const handleOrigin = (set2, request) => {
		if (origin === true) {
			set2.headers.vary = "*";
			set2.headers["access-control-allow-origin"] = request.headers.get("Origin") || "*";
			return;
		}
		if (anyOrigin) {
			set2.headers.vary = "*";
			set2.headers["access-control-allow-origin"] = "*";
			return;
		}
		if (!origins?.length) return;
		const headers = [];
		if (origins.length) {
			const from = request.headers.get("Origin") ?? "";
			for (let i = 0; i < origins.length; i++) {
				const value = processOrigin(origins[i], request, from);
				if (value === true) {
					set2.headers.vary = origin ? "Origin" : "*";
					set2.headers["access-control-allow-origin"] = from || "*";
					return;
				}
			}
		}
		set2.headers.vary = "Origin";
		if (headers.length) set2.headers["access-control-allow-origin"] = headers.join(", ");
	};
	const handleMethod = (set2, method) => {
		if (!method) return;
		if (methods === true) return (set2.headers["access-control-allow-methods"] = method ?? "*");
		if (methods === false || !methods?.length) return;
		if (methods === "*") return (set2.headers["access-control-allow-methods"] = "*");
		if (!Array.isArray(methods)) return (set2.headers["access-control-allow-methods"] = methods);
		set2.headers["access-control-allow-methods"] = methods.join(", ");
	};
	const defaultHeaders = {};
	if (typeof exposeHeaders === "string")
		defaultHeaders["access-control-expose-headers"] = exposeHeaders;
	if (typeof allowedHeaders === "string")
		defaultHeaders["access-control-allow-headers"] = allowedHeaders;
	if (credentials === true) defaultHeaders["access-control-allow-credentials"] = "true";
	app.headers(defaultHeaders);
	function handleOption({ set: set2, request, headers }) {
		handleOrigin(set2, request);
		handleMethod(set2, request.headers.get("access-control-request-method"));
		if (allowedHeaders === true || exposeHeaders === true) {
			if (allowedHeaders === true)
				set2.headers["access-control-allow-headers"] = headers["access-control-request-headers"];
			if (exposeHeaders === true)
				set2.headers["access-control-expose-headers"] = Object.keys(headers).join(",");
		}
		if (maxAge) set2.headers["access-control-max-age"] = maxAge.toString();
		return new Response(null, {
			status: 204,
		});
	}
	if (preflight) app.options("/", handleOption).options("/*", handleOption);
	return app.onRequest(function processCors({ set: set2, request }) {
		handleOrigin(set2, request);
		handleMethod(set2, request.method);
		if (allowedHeaders === true || exposeHeaders === true) {
			const headers = processHeaders(request.headers);
			if (allowedHeaders === true) set2.headers["access-control-allow-headers"] = headers;
			if (exposeHeaders === true) set2.headers["access-control-expose-headers"] = headers;
		}
	});
};

// node_modules/@elysiajs/html/dist/index.mjs
import { Readable as Readable22 } from "stream";

// node_modules/@kitajs/html/suspense.js
var { contentsToString, contentToString } = require_html();
var { Readable: Readable2, PassThrough: PassThrough2 } = __require("stream");
if (!globalThis.SUSPENSE_ROOT) {
	globalThis.SUSPENSE_ROOT = {
		requests: new Map(),
		requestCounter: 1,
		autoScript: true,
	};
}
var SuspenseScript = `
      <script id="kita-html-suspense">
        /*! MIT License https://kita.js.org */
        function $KITA_RC(i){
          // simple aliases
          var d=document,q=d.querySelector.bind(d),
            // div sent as the fallback wrapper
            v=q('div[id="B:'+i+'"][data-sf]'),
            // template and script sent after promise finishes
            t=q('template[id="N:'+i+'"][data-sr]'),s=q('script[id="S:'+i+'"][data-ss]'),
            // fragment created to avoid inserting element one by one
            f=d.createDocumentFragment(),
            // used by iterators
            c,j,
            // all pending hydrations
            r;

          // if div or template is not found, let this hydration as pending
          if(t&&v&&s){
            // appends into the fragment
            while(c=t.content.firstChild)
              f.appendChild(c);

            // replaces the div and removes the script and template
            v.parentNode.replaceChild(f,v);
            t.remove();
            s.remove();

            // looks for pending templates
            r=d.querySelectorAll('template[id][data-sr]');

            do{
              // resets j & c from previous loop
              c=j=0;

              // loops over every found pending template and 
              for(;c<r.length;c++)
                if(r[c]!=t)
                  // let j as true while at least on $KITA_RC call returns true
                  j=$KITA_RC(r[c].id.slice(2))?!0:j;
            }while(j)

            // we know at least the original template was substituted
            return!0;
          }
        }
      </script>
    `
	.replace(/^\s*\/\/.*/gm, "")
	.replace(/\n\s*/g, "");
function renderToStream(html, rid) {
	if (!rid) {
		rid = SUSPENSE_ROOT.requestCounter++;
	} else if (SUSPENSE_ROOT.requests.has(rid)) {
		const error = new Error(`The provided Request Id is already in use: ${rid}.`);
		return new Readable2({
			read() {
				this.emit("error", error);
				this.push(null);
			},
		});
	}
	if (typeof html === "function") {
		try {
			html = html(rid);
		} catch (error) {
			SUSPENSE_ROOT.requests.delete(rid);
			return new Readable2({
				read() {
					this.emit("error", error);
					this.push(null);
				},
			});
		}
	}
	const requestData = SUSPENSE_ROOT.requests.get(rid);
	if (!requestData) {
		if (typeof html === "string") {
			return Readable2.from([html]);
		}
		return new Readable2({
			read() {
				html
					.then((result) => {
						this.push(result);
						this.push(null);
					})
					.catch((error) => {
						this.emit("error", error);
					});
			},
		});
	}
	return resolveHtmlStream(html, requestData);
}
function resolveHtmlStream(template, requestData) {
	if (typeof template === "string") {
		requestData.stream.push(template);
		return requestData.stream;
	}
	const prepended = new PassThrough2();
	template.then(
		(result) => {
			prepended.push(result);
			requestData.stream.pipe(prepended);
		},
		(error) => {
			prepended.emit("error", error);
		},
	);
	return prepended;
}
var $renderToStream = renderToStream;

// node_modules/@elysiajs/html/dist/index.mjs
import { Readable as Readable3 } from "stream";
function isHtml(value) {
	if (typeof value !== "string") return false;
	value = value.trim();
	const length = value.length;
	return length >= 7 && value[0] === "<" && value[length - 1] === ">";
}
function isTagHtml(value) {
	return value.trimStart().slice(0, 5).startsWith("<html");
}
function handleHtml(value, options, hasContentType) {
	if (value instanceof Promise) return value.then((v) => handleHtml(v, options, hasContentType));
	if (typeof value === "string") {
		if (options.autoDoctype && isHtml(value) && isTagHtml(value)) value = "<!doctype html>" + value;
		return new Response(
			value,
			hasContentType ? undefined : { headers: { "content-type": options.contentType } },
		);
	}
	let stream = Readable3.toWeb(value);
	if (options.autoDoctype) {
		let first = true;
		stream = stream.pipeThrough(
			new TransformStream({
				transform(chunk, controller) {
					let str = chunk.toString();
					if (first && isTagHtml(str) && isTagHtml(str)) {
						first = false;
						str = "<!doctype html>" + str;
					}
					controller.enqueue(str);
				},
			}),
		);
	}
	return new Response(
		stream,
		hasContentType ? undefined : { headers: { "content-type": options.contentType } },
	);
}
function html(options = {}) {
	options.contentType ??= "text/html; charset=utf8";
	options.autoDetect ??= true;
	options.isHtml ??= isHtml;
	options.autoDoctype ??= true;
	const instance = new Elysia({
		name: "@elysiajs/html",
		seed: options,
	}).derive({ as: "global" }, function htmlPlugin({ set: set2 }) {
		return {
			html(value) {
				return handleHtml(value, options, "content-type" in set2.headers);
			},
			stream(value, args) {
				return handleHtml(
					$renderToStream((id) => value({ ...args, id })),
					options,
					"content-type" in set2.headers,
				);
			},
		};
	});
	if (options.autoDetect)
		instance.mapResponse(
			{ as: "global" },
			function handlerPossibleHtml({ responseValue: value, set: set2 }) {
				if (!(isHtml(value) || (value instanceof Readable22 && "rid" in value))) return;
				return handleHtml(value, options, "content-type" in set2.headers);
			},
		);
	return instance;
}

// node_modules/@elysiajs/static/dist/index.mjs
var import_fast_decode_uri_component5 = __toESM(require_fast_decode_uri_component2(), 1);

// node_modules/@elysiajs/static/dist/utils.mjs
var fs;
var path;
var isBun5 = typeof Bun < "u" && !!Bun.file;
function getBuiltinModule() {
	if (
		(fs || (fs = process.getBuiltinModule("fs/promises")),
		path || (path = process.getBuiltinModule("path")),
		!path)
	) {
		console.warn("@elysiajs/static require path to be available.");
		return;
	}
	return [fs, path];
}
async function listHTMLFiles(dir) {
	if ((fs || getBuiltinModule(), isBun5)) {
		const glob = new Bun.Glob("**/*.html"),
			files = [];
		for await (const file of glob.scan(dir)) files.push(path.join(dir, file));
		return files;
	}
	return [];
}
async function listFiles(dir) {
	if ((fs || getBuiltinModule(), isBun5)) {
		const glob = new Bun.Glob("**/*"),
			files2 = [];
		for await (const file of glob.scan(dir)) files2.push(path.join(dir, file));
		return files2;
	}
	const files = await fs.readdir(dir).catch(() => []);
	return (
		await Promise.all(
			files.map(async (name) => {
				const file = dir + path.sep + name,
					stats = await fs.stat(file).catch(() => null);
				return stats
					? stats.isDirectory()
						? await listFiles(file)
						: [path.resolve(dir, file)]
					: [];
			}),
		)
	).flat();
}
function fileExists(path2) {
	return (
		fs || getBuiltinModule(),
		fs.stat(path2).then(
			() => true,
			() => false,
		)
	);
}

class LRUCache {
	constructor(max = 250, ttl = 10800) {
		this.max = max;
		this.ttl = ttl;
		this.map = /* @__PURE__ */ new Map();
	}
	get(key) {
		const entry = this.map.get(key);
		if (entry)
			return entry[1] <= Date.now()
				? void this.delete(key)
				: (this.map.delete(key), this.map.set(key, entry), entry[0]);
	}
	set(key, value) {
		if (
			(this.interval ||
				(this.interval = setInterval(() => {
					const now = Date.now();
					for (const [key2, entry] of this.map) entry[1] <= now && this.map.delete(key2);
				}, this.ttl)),
			this.map.has(key))
		)
			this.map.delete(key);
		else if (this.map.size >= this.max) {
			const oldestKey = this.map.keys().next().value;
			oldestKey !== undefined && this.delete(oldestKey);
		}
		this.map.set(key, [value, Date.now() + this.ttl * 1000]);
	}
	delete(key) {
		this.map.get(key) && this.map.delete(key);
	}
	clear() {
		this.map.clear();
	}
	size() {
		return this.map.size;
	}
	[Symbol.dispose]() {
		this.interval && clearInterval(this.interval);
	}
}
function isCached(headers, etag, filePath) {
	if (headers["cache-control"] && /no-cache|no-store/.test(headers["cache-control"])) return false;
	if ("if-none-match" in headers) {
		const ifNoneMatch = headers["if-none-match"];
		return ifNoneMatch === "*"
			? true
			: ifNoneMatch === null || typeof etag != "string"
				? false
				: ifNoneMatch === etag;
	}
	if (headers["if-modified-since"]) {
		const ifModifiedSince = headers["if-modified-since"];
		try {
			return fs.stat(filePath).then((stat2) => {
				if (stat2.mtime !== undefined && stat2.mtime.getTime() <= Date.parse(ifModifiedSince))
					return true;
			});
		} catch {}
	}
	return false;
}
var Crypto;
function getFile(path2) {
	return isBun5 ? Bun.file(path2) : (fs || getBuiltinModule(), fs.readFile(path2));
}
async function generateETag(file) {
	return isBun5
		? new Bun.CryptoHasher("md5").update(await file.arrayBuffer()).digest("base64")
		: (Crypto || (Crypto = process.getBuiltinModule("crypto")),
			Crypto
				? Crypto.createHash("md5").update(file).digest("base64")
				: void console.warn("[@elysiajs/static] crypto is required to generate etag."));
}
var isNotEmpty2 = (obj) => {
	if (!obj) return false;
	for (const _2 in obj) return true;
	return false;
};

// node_modules/@elysiajs/static/dist/index.mjs
async function staticPlugin({
	assets = "public",
	prefix = "/public",
	staticLimit = 1024,
	alwaysStatic = false,
	ignorePatterns = [".DS_Store", ".git", ".env"],
	headers: initialHeaders,
	maxAge = 86400,
	directive = "public",
	etag: useETag = true,
	extension = true,
	indexHTML = true,
	decodeURI: decodeURI2,
	silent,
} = {}) {
	if (typeof process > "u" || typeof process.getBuiltinModule > "u")
		return (
			silent ||
				console.warn(
					"[@elysiajs/static] require process.getBuiltinModule. Static plugin is disabled",
				),
			new Elysia()
		);
	const builtinModule = getBuiltinModule();
	if (!builtinModule) return new Elysia();
	const [fs2, path2] = builtinModule,
		normalizePath = path2.sep !== "/" ? (p) => p.replace(/\\/g, "/") : (p) => p,
		fileCache = new LRUCache();
	prefix === path2.sep && (prefix = "");
	const assetsDir = path2.resolve(assets),
		shouldIgnore = ignorePatterns.length
			? (file) =>
					ignorePatterns.find((pattern) =>
						typeof pattern == "string" ? pattern.includes(file) : pattern.test(file),
					)
			: () => false,
		app = new Elysia({
			name: "static",
			seed: prefix,
		});
	if (alwaysStatic) {
		const files = await listFiles(path2.resolve(assets));
		if (files.length <= staticLimit)
			for (const absolutePath of files) {
				let handleCache2 = function ({ headers: requestHeaders }) {
					if (etag) {
						let cached = isCached(requestHeaders, etag, absolutePath);
						if (cached === true)
							return new Response(null, {
								status: 304,
								headers: isNotEmpty2(initialHeaders) ? initialHeaders : undefined,
							});
						if (cached !== false) {
							const cache2 = fileCache.get(pathName);
							return cache2
								? cache2.clone()
								: cached.then((cached2) => {
										if (cached2)
											return new Response(null, {
												status: 304,
												headers: initialHeaders || undefined,
											});
										const response2 = new Response(file, {
											headers: Object.assign(
												{
													"Cache-Control": maxAge ? `${directive}, max-age=${maxAge}` : directive,
												},
												initialHeaders,
												etag ? { Etag: etag } : {},
											),
										});
										return (fileCache.set(prefix, response2), response2.clone());
									});
						}
					}
					const cache = fileCache.get(pathName);
					if (cache) return cache.clone();
					const response = new Response(file, {
						headers: Object.assign(
							{
								"Cache-Control": maxAge ? `${directive}, max-age=${maxAge}` : directive,
							},
							initialHeaders,
							etag ? { Etag: etag } : {},
						),
					});
					return (fileCache.set(pathName, response), response.clone());
				};
				var handleCache = handleCache2;
				if (!absolutePath || shouldIgnore(absolutePath)) continue;
				let relativePath = absolutePath.replace(assetsDir, "");
				decodeURI2 &&
					(relativePath = import_fast_decode_uri_component5.default(relativePath) ?? relativePath);
				let pathName = normalizePath(path2.join(prefix, relativePath));
				if (isBun5 && absolutePath.endsWith(".html")) {
					const htmlBundle = await import(absolutePath);
					(app.get(pathName, htmlBundle.default),
						indexHTML &&
							pathName.endsWith("/index.html") &&
							app.get(pathName.replace("/index.html", ""), htmlBundle.default));
					continue;
				}
				extension || (pathName = normalizePath(pathName.slice(0, pathName.lastIndexOf("."))));
				const file = isBun5 ? getFile(absolutePath) : await getFile(absolutePath);
				if (!file)
					return (
						silent || console.warn(`[@elysiajs/static] Failed to load file: ${absolutePath}`),
						new Elysia()
					);
				const etag = await generateETag(file);
				(app.get(
					pathName,
					useETag
						? handleCache2
						: new Response(
								file,
								isNotEmpty2(initialHeaders)
									? {
											headers: initialHeaders,
										}
									: undefined,
							),
				),
					indexHTML &&
						pathName.endsWith("/index.html") &&
						app.get(
							pathName.replace("/index.html", ""),
							useETag
								? handleCache2
								: new Response(
										file,
										isNotEmpty2(initialHeaders)
											? {
													headers: initialHeaders,
												}
											: undefined,
									),
						));
			}
		return app;
	}
	if (!(`GET_${prefix}/*` in app.routeTree)) {
		if (isBun5) {
			const htmls = await listHTMLFiles(path2.resolve(assets));
			for (const absolutePath of htmls) {
				if (!absolutePath || shouldIgnore(absolutePath)) continue;
				let relativePath = absolutePath.replace(assetsDir, "");
				const pathName = normalizePath(path2.join(prefix, relativePath)),
					htmlBundle = await import(absolutePath);
				(app.get(pathName, htmlBundle.default),
					indexHTML &&
						pathName.endsWith("/index.html") &&
						app.get(pathName.replace("/index.html", ""), htmlBundle.default));
			}
		}
		app
			.onError(() => {})
			.get(
				`${prefix.endsWith("/") ? prefix.slice(0, -1) : prefix}/*`,
				async ({ params, headers: requestHeaders }) => {
					const pathName = normalizePath(
						path2.join(
							assets,
							decodeURI2
								? (import_fast_decode_uri_component5.default(params["*"]) ?? params["*"])
								: params["*"],
						),
					);
					if (shouldIgnore(pathName)) throw new NotFoundError();
					const cache = fileCache.get(pathName);
					if (cache) return cache.clone();
					try {
						const fileStat = await fs2.stat(pathName).catch(() => null);
						if (!fileStat) throw new NotFoundError();
						if (!indexHTML && fileStat.isDirectory()) throw new NotFoundError();
						let file;
						if (!isBun5 && indexHTML) {
							const htmlPath = path2.join(pathName, "index.html"),
								cache2 = fileCache.get(htmlPath);
							if (cache2) return cache2.clone();
							(await fileExists(htmlPath)) && (file = await getFile(htmlPath));
						}
						if (!file && !fileStat.isDirectory() && (await fileExists(pathName)))
							file = await getFile(pathName);
						else throw new NotFoundError();
						if (!useETag)
							return new Response(
								file,
								isNotEmpty2(initialHeaders) ? { headers: initialHeaders } : undefined,
							);
						const etag = await generateETag(file);
						if (etag && (await isCached(requestHeaders, etag, pathName)))
							return new Response(null, {
								status: 304,
							});
						const response = new Response(file, {
							headers: Object.assign(
								{
									"Cache-Control": maxAge ? `${directive}, max-age=${maxAge}` : directive,
								},
								initialHeaders,
								etag ? { Etag: etag } : {},
							),
						});
						return (fileCache.set(pathName, response), response.clone());
					} catch (error) {
						throw error instanceof NotFoundError
							? error
							: (silent || console.error("[@elysiajs/static]", error), new NotFoundError());
					}
				},
			);
	}
	return app;
}

// node_modules/@scalar/themes/dist/presets/alternate.css2.js
var a = `/* basic theme */
:root {
  --scalar-text-decoration: underline;
  --scalar-text-decoration-hover: underline;
}
.light-mode,
.light-mode .dark-mode {
  --scalar-background-1: #f9f9f9;
  --scalar-background-2: #f1f1f1;
  --scalar-background-3: #e7e7e7;
  --scalar-background-card: #fff;

  --scalar-color-1: #2a2f45;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;

  --scalar-color-accent: var(--scalar-color-1);
  --scalar-background-accent: var(--scalar-background-3);

  --scalar-border-color: rgba(0, 0, 0, 0.1);
}
.dark-mode {
  --scalar-background-1: #131313;
  --scalar-background-2: #1d1d1d;
  --scalar-background-3: #272727;
  --scalar-background-card: #1d1d1d;

  --scalar-color-1: rgba(255, 255, 255, 0.9);
  --scalar-color-2: rgba(255, 255, 255, 0.62);
  --scalar-color-3: rgba(255, 255, 255, 0.44);

  --scalar-color-accent: var(--scalar-color-1);
  --scalar-background-accent: var(--scalar-background-3);

  --scalar-border-color: #2a2b2a;
}
/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-hover-color: currentColor;

  --scalar-sidebar-item-active-background: var(--scalar-background-accent);
  --scalar-sidebar-color-active: var(--scalar-color-accent);

  --scalar-sidebar-search-background: transparent;
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
}
/* advanced */
.light-mode .dark-mode,
.light-mode {
  --scalar-color-green: #069061;
  --scalar-color-red: #ef0006;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #0082d0;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: #00b648;
  --scalar-color-red: #dd2f2c;
  --scalar-color-yellow: #ffc90d;
  --scalar-color-blue: #4eb3ec;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}

.scalar-api-client__item,
.scalar-card,
.dark-mode .dark-mode.scalar-card {
  --scalar-background-1: var(--scalar-background-card);
  --scalar-background-2: var(--scalar-background-1);
  --scalar-background-3: var(--scalar-background-1);
}
.dark-mode .dark-mode.scalar-card {
  --scalar-background-3: var(--scalar-background-3);
}
.t-doc__sidebar {
  --scalar-color-green: var(--scalar-color-1);
  --scalar-color-red: var(--scalar-color-1);
  --scalar-color-yellow: var(--scalar-color-1);
  --scalar-color-blue: var(--scalar-color-1);
  --scalar-color-orange: var(--scalar-color-1);
  --scalar-color-purple: var(--scalar-color-1);
}
.light-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-blue), transparent 70%);
}
.dark-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-blue), transparent 50%);
}
`;

// node_modules/@scalar/themes/dist/presets/bluePlanet.css2.js
var a2 = `/* basic theme */
:root {
  --scalar-text-decoration: underline;
  --scalar-text-decoration-hover: underline;
}
.light-mode {
  --scalar-background-1: #f0f2f5;
  --scalar-background-2: #eaecf0;
  --scalar-background-3: #e0e2e6;
  --scalar-border-color: rgb(213 213 213);

  --scalar-color-1: rgb(9, 9, 11);
  --scalar-color-2: rgb(113, 113, 122);
  --scalar-color-3: rgba(25, 25, 28, 0.5);

  --scalar-color-accent: var(--scalar-color-1);
  --scalar-background-accent: #8ab4f81f;
}
.light-mode .scalar-card.dark-mode,
.dark-mode {
  --scalar-background-1: #000e23;
  --scalar-background-2: #01132e;
  --scalar-background-3: #03193b;
  --scalar-border-color: #2e394c;

  --scalar-color-1: #fafafa;
  --scalar-color-2: rgb(161, 161, 170);
  --scalar-color-3: rgba(255, 255, 255, 0.533);

  --scalar-color-accent: var(--scalar-color-1);
  --scalar-background-accent: #8ab4f81f;

  --scalar-code-language-color-supersede: var(--scalar-color-1);
}
/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-hover-color: currentColor;

  --scalar-sidebar-item-active-background: var(--scalar-background-3);
  --scalar-sidebar-color-active: var(--scalar-color-accent);

  --scalar-sidebar-search-background: rgba(255, 255, 255, 0.1);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
  --scalar-sidebar-search-color: var(--scalar-color-3);
  z-index: 1;
}
.light-mode .t-doc__sidebar {
  --scalar-sidebar-search-background: white;
}
/* advanced */
.light-mode {
  --scalar-color-green: #069061;
  --scalar-color-red: #ef0006;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #0082d0;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: rgba(69, 255, 165, 0.823);
  --scalar-color-red: #ff8589;
  --scalar-color-yellow: #ffcc4d;
  --scalar-color-blue: #6bc1fe;
  --scalar-color-orange: #f98943;
  --scalar-color-purple: #b191f9;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
/* Custom theme */
/* Document header */
@keyframes headerbackground {
  from {
    background: transparent;
    backdrop-filter: none;
  }
  to {
    background: var(--header-background-1);
    backdrop-filter: blur(12px);
  }
}
.dark-mode h2.t-editor__heading,
.dark-mode .t-editor__page-title h1,
.dark-mode h1.section-header:not(::selection),
.dark-mode .markdown h1,
.dark-mode .markdown h2,
.dark-mode .markdown h3,
.dark-mode .markdown h4,
.dark-mode .markdown h5,
.dark-mode .markdown h6 {
  -webkit-text-fill-color: transparent;
  background-image: linear-gradient(to right bottom, rgb(255, 255, 255) 30%, rgba(255, 255, 255, 0.38));
  -webkit-background-clip: text;
  background-clip: text;
}
/* Hero Section Flare */
.section-flare-item:nth-of-type(1) {
  --c1: #ffffff;
  --c2: #babfd8;
  --c3: #2e8bb2;
  --c4: #1a8593;
  --c5: #0a143e;
  --c6: #0a0f52;
  --c7: #2341b8;

  --solid: var(--c1), var(--c2), var(--c3), var(--c4), var(--c5), var(--c6), var(--c7);
  --solid-wrap: var(--solid), var(--c1);
  --trans:
    var(--c1), transparent, var(--c2), transparent, var(--c3),
    transparent, var(--c4), transparent, var(--c5), transparent, var(--c6),
    transparent, var(--c7);
  --trans-wrap: var(--trans), transparent, var(--c1);

  background: radial-gradient(circle, var(--trans)), conic-gradient(from 180deg, var(--trans-wrap)),
    radial-gradient(circle, var(--trans)), conic-gradient(var(--solid-wrap));
  width: 70vw;
  height: 700px;
  border-radius: 50%;
  filter: blur(100px);
  z-index: 0;
  right: 0;
  position: absolute;
  transform: rotate(-45deg);
  top: -300px;
  opacity: 0.3;
}
.section-flare-item:nth-of-type(3) {
  --star-color: #6b9acc;
  --star-color2: #446b8d;
  --star-color3: #3e5879;
  background-image: radial-gradient(2px 2px at 20px 30px, var(--star-color2), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 40px 70px, var(--star-color), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 50px 160px, var(--star-color3), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 90px 40px, var(--star-color), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 130px 80px, var(--star-color), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 160px 120px, var(--star-color3), rgba(0, 0, 0, 0));
  background-repeat: repeat;
  background-size: 200px 200px;
  width: 100%;
  height: 100%;
  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
}
.section-flare {
  top: -150px !important;
  height: 100vh;
  background: linear-gradient(#000, var(--scalar-background-1));
  width: 100vw;
  overflow-x: hidden;
}
.light-mode .section-flare {
  display: none;
}
.light-mode .scalar-card {
  --scalar-background-1: #fff;
  --scalar-background-2: #fff;
  --scalar-background-3: #fff;
}

*::selection {
  background-color: color-mix(in srgb, var(--scalar-color-blue), transparent 60%);
}
`;

// node_modules/@scalar/themes/dist/presets/deepSpace.css2.js
var a3 = `/* basic theme */
:root {
  --scalar-text-decoration: underline;
  --scalar-text-decoration-hover: underline;
}
.light-mode {
  --scalar-color-1: rgb(9, 9, 11);
  --scalar-color-2: rgb(113, 113, 122);
  --scalar-color-3: rgba(25, 25, 28, 0.5);
  --scalar-color-accent: var(--scalar-color-1);

  --scalar-background-1: #fff;
  --scalar-background-2: #f4f4f5;
  --scalar-background-3: #e3e3e6;
  --scalar-background-accent: #8ab4f81f;

  --scalar-border-color: rgb(228, 228, 231);
  --scalar-code-language-color-supersede: var(--scalar-color-1);
}
.dark-mode {
  --scalar-color-1: #fafafa;
  --scalar-color-2: rgb(161, 161, 170);
  --scalar-color-3: rgba(255, 255, 255, 0.533);
  --scalar-color-accent: var(--scalar-color-1);

  --scalar-background-1: #09090b;
  --scalar-background-2: #18181b;
  --scalar-background-3: #2c2c30;
  --scalar-background-accent: #8ab4f81f;

  --scalar-border-color: rgba(255, 255, 255, 0.16);
  --scalar-code-language-color-supersede: var(--scalar-color-1);
}

/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-2);

  --scalar-sidebar-item-active-background: var(--scalar-background-3);
  --scalar-sidebar-color-active: var(--scalar-color-accent);

  --scalar-sidebar-search-background: transparent;
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
  --scalar-sidebar-search-color: var(--scalar-color-3);
}
.light-mode .t-doc__sidebar {
  --scalar-sidebar-item-active-background: var(--scalar-background-2);
}
/* advanced */
.light-mode {
  --scalar-color-green: #069061;
  --scalar-color-red: #ef0006;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #0082d0;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: rgba(69, 255, 165, 0.823);
  --scalar-color-red: #ff8589;
  --scalar-color-yellow: #ffcc4d;
  --scalar-color-blue: #6bc1fe;
  --scalar-color-orange: #f98943;
  --scalar-color-purple: #b191f9;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
/* Custom theme */
.dark-mode h2.t-editor__heading,
.dark-mode .t-editor__page-title h1,
.dark-mode h1.section-header:not(::selection),
.dark-mode .markdown h1,
.dark-mode .markdown h2,
.dark-mode .markdown h3,
.dark-mode .markdown h4,
.dark-mode .markdown h5,
.dark-mode .markdown h6 {
  -webkit-text-fill-color: transparent;
  background-image: linear-gradient(to right bottom, rgb(255, 255, 255) 30%, rgba(255, 255, 255, 0.38));
  -webkit-background-clip: text;
  background-clip: text;
}
.examples .scalar-card-footer {
  --scalar-background-3: transparent;
  padding-top: 0;
}
/* Hero section flare */
.section-flare {
  width: 100vw;
  height: 550px;
  position: absolute;
}
.section-flare-item:nth-of-type(1) {
  position: absolute;
  width: 100vw;
  height: 550px;
  --stripesDark: repeating-linear-gradient(100deg, #000 0%, #000 7%, transparent 10%, transparent 12%, #000 16%);
  --rainbow: repeating-linear-gradient(100deg, #fff 10%, #fff 16%, #fff 22%, #fff 30%);
  background-image: var(--stripesDark), var(--rainbow);
  background-size: 300%, 200%;
  background-position: 50% 50%, 50% 50%;
  filter: invert(100%);
  -webkit-mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  pointer-events: none;
  opacity: 0.07;
}
.dark-mode .section-flare-item:nth-of-type(1) {
  background-image: var(--stripesDark), var(--rainbow);
  filter: opacity(50%) saturate(200%);
  opacity: 0.25;
  height: 350px;
}
.section-flare-item:nth-of-type(1):after {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-image: var(--stripesDark), var(--rainbow);
  background-size: 200%, 100%;
  background-attachment: fixed;
  mix-blend-mode: difference;
}
.dark-mode .section-flare:after {
  background-image: var(--stripesDark), var(--rainbow);
}
.section-flare-item:nth-of-type(2) {
  --star-color: #fff;
  --star-color2: #fff;
  --star-color3: #fff;
  width: 100%;
  height: 100%;
  position: absolute;
  background-image: radial-gradient(2px 2px at 20px 30px, var(--star-color2), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 40px 70px, var(--star-color), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 50px 160px, var(--star-color3), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 90px 40px, var(--star-color), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 130px 80px, var(--star-color), rgba(0, 0, 0, 0)),
    radial-gradient(2px 2px at 160px 120px, var(--star-color3), rgba(0, 0, 0, 0));
  background-repeat: repeat;
  background-size: 200px 200px;
  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  opacity: 0.2;
}
.light-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-blue), transparent 70%);
}
.dark-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-blue), transparent 50%);
}
`;

// node_modules/@scalar/themes/dist/presets/default.css2.js
var r = `/* basic theme */
.light-mode {
  --scalar-background-1: #fff;
  --scalar-background-2: #f6f6f6;
  --scalar-background-3: #e7e7e7;
  --scalar-background-accent: #8ab4f81f;

  --scalar-color-1: #2a2f45;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;

  --scalar-color-accent: #0099ff;
  --scalar-border-color: #dfdfdf;
}
.dark-mode {
  --scalar-background-1: #0f0f0f;
  --scalar-background-2: #1a1a1a;
  --scalar-background-3: #272727;

  --scalar-color-1: #e7e7e7;
  --scalar-color-2: #a4a4a4;
  --scalar-color-3: #797979;

  --scalar-color-accent: #3ea6ff;
  --scalar-background-accent: #3ea6ff1f;

  --scalar-border-color: #2d2d2d;
}
/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-hover-color: currentColor;

  --scalar-sidebar-item-active-background: var(--scalar-background-2);
  --scalar-sidebar-color-active: var(--scalar-color-1);

  --scalar-sidebar-indent-border: var(--scalar-sidebar-border-color);
  --scalar-sidebar-indent-border-hover: var(--scalar-sidebar-border-color);
  --scalar-sidebar-indent-border-active: var(--scalar-sidebar-border-color);

  --scalar-sidebar-search-background: transparent;
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
}
/* advanced */
.light-mode {
  --scalar-color-green: #069061;
  --scalar-color-red: #ef0006;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #0082d0;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);

  --scalar-color-danger: color-mix(in srgb, var(--scalar-color-red), var(--scalar-color-1) 20%);

  --scalar-background-alert: color-mix(in srgb, var(--scalar-color-orange), var(--scalar-background-1) 95%);
  --scalar-background-danger: color-mix(in srgb, var(--scalar-color-red), var(--scalar-background-1) 95%);
}
.dark-mode {
  --scalar-color-green: #00b648;
  --scalar-color-red: #dc1b19;
  --scalar-color-yellow: #ffc90d;
  --scalar-color-blue: #4eb3ec;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;

  --scalar-color-danger: color-mix(in srgb, var(--scalar-color-red), var(--scalar-background-1) 20%);

  --scalar-background-alert: color-mix(in srgb, var(--scalar-color-orange), var(--scalar-background-1) 95%);
  --scalar-background-danger: color-mix(in srgb, var(--scalar-color-red), var(--scalar-background-1) 95%);
}
@supports (color: color(display-p3 1 1 1)) {
  .light-mode {
    --scalar-color-accent: color(display-p3 0.0 0.6 1.0 / 1.0);
    --scalar-color-green: color(display-p3 0.023529 0.564706 0.380392 / 1.0);
    --scalar-color-red: color(display-p3 0.937255 0.0 0.023529 / 1.0);
    --scalar-color-yellow: color(display-p3 0.929412 0.745098 0.12549 / 1.0);
    --scalar-color-blue: color(display-p3 0.0 0.509804 0.815686 / 1.0);
    --scalar-color-orange: color(display-p3 0.984314 0.537255 0.172549 / 1.0);
    --scalar-color-purple: color(display-p3 0.321569 0.011765 0.819608 / 1.0);
  }
  .dark-mode {
    --scalar-color-accent: color(display-p3 0.243137 0.65098 1.0 / 1.0);
    --scalar-color-green: color(display-p3 0.0 0.713725 0.282353 / 1.0);
    --scalar-color-red: color(display-p3 0.862745 0.105882 0.098039 / 1.0);
    --scalar-color-yellow: color(display-p3 1.0 0.788235 0.05098 / 1.0);
    --scalar-color-blue: color(display-p3 0.305882 0.701961 0.92549 / 1.0);
    --scalar-color-orange: color(display-p3 1.0 0.552941 0.301961 / 1.0);
    --scalar-color-purple: color(display-p3 0.694118 0.568627 0.976471 / 1.0);
  }
}
`;

// node_modules/@scalar/themes/dist/presets/elysiajs.css2.js
var a4 = `.light-mode {
  --scalar-color-1: #2a2f45;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;
  --scalar-color-accent: #f06292;

  --scalar-background-1: #fff;
  --scalar-background-2: #f6f6f6;
  --scalar-background-3: #e7e7e7;

  --scalar-border-color: rgba(0, 0, 0, 0.1);
}
.dark-mode {
  --scalar-color-1: rgba(255, 255, 255, 0.9);
  --scalar-color-2: rgba(156, 163, 175, 1);
  --scalar-color-3: rgba(255, 255, 255, 0.44);
  --scalar-color-accent: #f06292;

  --scalar-background-1: #111728;
  --scalar-background-2: #1e293b;
  --scalar-background-3: #334155;
  --scalar-background-accent: #f062921f;

  --scalar-border-color: rgba(255, 255, 255, 0.1);
}

/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-hover-color: currentColor;

  --scalar-sidebar-item-active-background: #f062921f;
  --scalar-sidebar-color-active: var(--scalar-color-accent);

  --scalar-sidebar-search-background: transparent;
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
}

/* advanced */
.light-mode {
  --scalar-button-1: rgb(49 53 56);
  --scalar-button-1-color: #fff;
  --scalar-button-1-hover: rgb(28 31 33);

  --scalar-color-green: #069061;
  --scalar-color-red: #ef0006;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #0082d0;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;

  --scalar-scrollbar-color: rgba(0, 0, 0, 0.18);
  --scalar-scrollbar-color-active: rgba(0, 0, 0, 0.36);
}
.dark-mode {
  --scalar-button-1: #f6f6f6;
  --scalar-button-1-color: #000;
  --scalar-button-1-hover: #e7e7e7;

  --scalar-color-green: #a3ffa9;
  --scalar-color-red: #ffa3a3;
  --scalar-color-yellow: #fffca3;
  --scalar-color-blue: #a5d6ff;
  --scalar-color-orange: #e2ae83;
  --scalar-color-purple: #d2a8ff;

  --scalar-scrollbar-color: rgba(255, 255, 255, 0.24);
  --scalar-scrollbar-color-active: rgba(255, 255, 255, 0.48);
}
.section-flare {
  width: 100%;
  height: 400px;
  position: absolute;
}
.section-flare-item:first-of-type:before {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  --stripes: repeating-linear-gradient(100deg, #fff 0%, #fff 0%, transparent 2%, transparent 12%, #fff 17%);
  --stripesDark: repeating-linear-gradient(100deg, #000 0%, #000 0%, transparent 10%, transparent 12%, #000 17%);
  --rainbow: repeating-linear-gradient(100deg, #60a5fa 10%, #e879f9 16%, #5eead4 22%, #60a5fa 30%);
  contain: strict;
  contain-intrinsic-size: 100vw 40vh;
  background-image: var(--stripesDark), var(--rainbow);
  background-size: 300%, 200%;
  background-position: 50% 50%, 50% 50%;
  filter: opacity(20%) saturate(200%);
  -webkit-mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  pointer-events: none;
}
.section-flare-item:first-of-type:after {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-image: var(--stripes), var(--rainbow);
  background-size: 200%, 100%;
  background-attachment: fixed;
  mix-blend-mode: difference;
  background-image: var(--stripesDark), var(--rainbow);
  pointer-events: none;
}
.light-mode .section-flare-item:first-of-type:after,
.light-mode .section-flare-item:first-of-type:before {
  background-image: var(--stripes), var(--rainbow);
  filter: opacity(4%) saturate(200%);
}
`;

// node_modules/@scalar/themes/dist/presets/fastify.css2.js
var a5 = `.light-mode {
  color-scheme: light;
  --scalar-color-1: #1c1e21;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;
  --scalar-color-disabled: #b4b1b1;
  --scalar-color-ghost: #a7a7a7;
  --scalar-color-accent: #2f8555;
  --scalar-background-1: #fff;
  --scalar-background-2: #f5f5f5;
  --scalar-background-3: #ededed;
  --scalar-background-4: rgba(0, 0, 0, 0.06);
  --scalar-background-accent: #2f85551f;

  --scalar-border-color: rgba(0, 0, 0, 0.1);
  --scalar-scrollbar-color: rgba(0, 0, 0, 0.18);
  --scalar-scrollbar-color-active: rgba(0, 0, 0, 0.36);
  --scalar-lifted-brightness: 1;
  --scalar-backdrop-brightness: 1;

  --scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, 0.11);
  --scalar-shadow-2: rgba(0, 0, 0, 0.08) 0px 13px 20px 0px, rgba(0, 0, 0, 0.08) 0px 3px 8px 0px, #eeeeed 0px 0 0 1px;

  --scalar-button-1: rgb(49 53 56);
  --scalar-button-1-color: #fff;
  --scalar-button-1-hover: rgb(28 31 33);

  --scalar-color-green: #007300;
  --scalar-color-red: #af272b;
  --scalar-color-yellow: #b38200;
  --scalar-color-blue: #3b8ba5;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;
}

.dark-mode {
  color-scheme: dark;
  --scalar-color-1: rgba(255, 255, 255, 0.9);
  --scalar-color-2: rgba(255, 255, 255, 0.62);
  --scalar-color-3: rgba(255, 255, 255, 0.44);
  --scalar-color-disabled: rgba(255, 255, 255, 0.34);
  --scalar-color-ghost: rgba(255, 255, 255, 0.26);
  --scalar-color-accent: #27c2a0;
  --scalar-background-1: #1b1b1d;
  --scalar-background-2: #242526;
  --scalar-background-3: #3b3b3b;
  --scalar-background-4: rgba(255, 255, 255, 0.06);
  --scalar-background-accent: #27c2a01f;

  --scalar-border-color: rgba(255, 255, 255, 0.1);
  --scalar-scrollbar-color: rgba(255, 255, 255, 0.24);
  --scalar-scrollbar-color-active: rgba(255, 255, 255, 0.48);
  --scalar-lifted-brightness: 1.45;
  --scalar-backdrop-brightness: 0.5;

  --scalar-shadow-1: 0 1px 3px 0 rgb(0, 0, 0, 0.1);
  --scalar-shadow-2: rgba(15, 15, 15, 0.2) 0px 3px 6px, rgba(15, 15, 15, 0.4) 0px 9px 24px, 0 0 0 1px
    rgba(255, 255, 255, 0.1);

  --scalar-button-1: #f6f6f6;
  --scalar-button-1-color: #000;
  --scalar-button-1-hover: #e7e7e7;

  --scalar-color-green: #26b226;
  --scalar-color-red: #fb565b;
  --scalar-color-yellow: #ffc426;
  --scalar-color-blue: #6ecfef;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;
}
`;

// node_modules/@scalar/themes/dist/presets/kepler.css2.js
var a6 = `/* basic theme */
.light-mode {
  --scalar-color-1: #2a2f45;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;
  --scalar-color-accent: #7070ff;

  --scalar-background-1: #fff;
  --scalar-background-2: #f6f6f6;
  --scalar-background-3: #e7e7e7;
  --scalar-background-accent: #7070ff1f;

  --scalar-border-color: rgba(0, 0, 0, 0.1);

  --scalar-code-language-color-supersede: var(--scalar-color-3);
}
.dark-mode {
  --scalar-color-1: #f7f8f8;
  --scalar-color-2: rgb(180, 188, 208);
  --scalar-color-3: #b4bcd099;
  --scalar-color-accent: #828fff;

  --scalar-background-1: #000212;
  --scalar-background-2: #0d0f1e;
  --scalar-background-3: #232533;
  --scalar-background-accent: #8ab4f81f;

  --scalar-border-color: #313245;
  --scalar-code-language-color-supersede: var(--scalar-color-3);
}
/* Document Sidebar */
.light-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-active-background: var(--scalar-background-accent);
  --scalar-sidebar-border-color: var(--scalar-border-color);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-color-active: var(--scalar-color-accent);
  --scalar-sidebar-search-background: rgba(0, 0, 0, 0.05);
  --scalar-sidebar-search-border-color: 1px solid rgba(0, 0, 0, 0.05);
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-background-2: rgba(0, 0, 0, 0.03);
}
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-active-background: rgba(255, 255, 255, 0.1);
  --scalar-sidebar-border-color: var(--scalar-border-color);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-color-active: var(--scalar-color-accent);
  --scalar-sidebar-search-background: rgba(255, 255, 255, 0.1);
  --scalar-sidebar-search-border-color: 1px solid rgba(255, 255, 255, 0.05);
  --scalar-sidebar-search-color: var(--scalar-color-3);
}
/* advanced */
.light-mode {
  --scalar-color-green: #069061;
  --scalar-color-red: #ef0006;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #0082d0;
  --scalar-color-orange: #fb892c;
  --scalar-color-purple: #5203d1;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: #00b648;
  --scalar-color-red: #dc1b19;
  --scalar-color-yellow: #ffc90d;
  --scalar-color-blue: #4eb3ec;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
/* Custom Theme */
.dark-mode h2.t-editor__heading,
.dark-mode .t-editor__page-title h1,
.dark-mode h1.section-header:not(::selection),
.dark-mode .markdown h1,
.dark-mode .markdown h2,
.dark-mode .markdown h3,
.dark-mode .markdown h4,
.dark-mode .markdown h5,
.dark-mode .markdown h6 {
  -webkit-text-fill-color: transparent;
  background-image: linear-gradient(to right bottom, rgb(255, 255, 255) 30%, rgba(255, 255, 255, 0.38));
  -webkit-background-clip: text;
  background-clip: text;
}
.sidebar-search {
  backdrop-filter: blur(12px);
}
@keyframes headerbackground {
  from {
    background: transparent;
    backdrop-filter: none;
  }
  to {
    background: var(--header-background-1);
    backdrop-filter: blur(12px);
  }
}
.dark-mode .scalar-card {
  background: rgba(255, 255, 255, 0.05) !important;
}
.dark-mode .scalar-card * {
  --scalar-background-2: transparent !important;
  --scalar-background-1: transparent !important;
}
.light-mode .dark-mode.scalar-card *,
.light-mode .dark-mode.scalar-card {
  --scalar-background-1: #0d0f1e !important;
  --scalar-background-2: #0d0f1e !important;
  --scalar-background-3: #191b29 !important;
}
.light-mode .dark-mode.scalar-card {
  background: #191b29 !important;
}
.badge {
  box-shadow: 0 0 0 1px var(--scalar-border-color);
  margin-right: 6px;
}

.table-row.required-parameter .table-row-item:nth-of-type(2):after {
  background: transparent;
  box-shadow: none;
}
/* Hero Section Flare */
.section-flare {
  width: 100vw;
  background: radial-gradient(ellipse 80% 50% at 50% -20%, rgba(120, 119, 198, 0.3), transparent);
  height: 100vh;
}
.light-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-accent), transparent 70%);
}
.dark-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-accent), transparent 50%);
}
`;

// node_modules/@scalar/themes/dist/presets/mars.css2.js
var a7 = `/* basic theme */
:root {
  --scalar-text-decoration: underline;
  --scalar-text-decoration-hover: underline;
}
.light-mode {
  --scalar-background-1: #f9f6f0;
  --scalar-background-2: #f2efe8;
  --scalar-background-3: #e9e7e2;
  --scalar-border-color: rgba(203, 165, 156, 0.6);

  --scalar-color-1: #c75549;
  --scalar-color-2: #c75549;
  --scalar-color-3: #c75549;

  --scalar-color-accent: #c75549;
  --scalar-background-accent: #dcbfa81f;

  --scalar-code-language-color-supersede: var(--scalar-color-1);
}
.dark-mode {
  --scalar-background-1: #140507;
  --scalar-background-2: #20090c;
  --scalar-background-3: #321116;
  --scalar-border-color: #3c3031;

  --scalar-color-1: rgba(255, 255, 255, 0.9);
  --scalar-color-2: rgba(255, 255, 255, 0.62);
  --scalar-color-3: rgba(255, 255, 255, 0.44);

  --scalar-color-accent: rgba(255, 255, 255, 0.9);
  --scalar-background-accent: #441313;

  --scalar-code-language-color-supersede: var(--scalar-color-1);
}

/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-2);

  --scalar-sidebar-item-active-background: var(--scalar-background-3);
  --scalar-sidebar-color-active: var(--scalar-color-accent);

  --scalar-sidebar-search-background: rgba(255, 255, 255, 0.1);
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
  z-index: 1;
}
/* advanced */
.light-mode {
  --scalar-color-green: #09533a;
  --scalar-color-red: #aa181d;
  --scalar-color-yellow: #ab8d2b;
  --scalar-color-blue: #19689a;
  --scalar-color-orange: #b26c34;
  --scalar-color-purple: #4c2191;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: rgba(69, 255, 165, 0.823);
  --scalar-color-red: #ff8589;
  --scalar-color-yellow: #ffcc4d;
  --scalar-color-blue: #6bc1fe;
  --scalar-color-orange: #f98943;
  --scalar-color-purple: #b191f9;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
/* Custom Theme */
.dark-mode h2.t-editor__heading,
.dark-mode .t-editor__page-title h1,
.dark-mode h1.section-header:not(::selection),
.dark-mode .markdown h1,
.dark-mode .markdown h2,
.dark-mode .markdown h3,
.dark-mode .markdown h4,
.dark-mode .markdown h5,
.dark-mode .markdown h6 {
  -webkit-text-fill-color: transparent;
  background-image: linear-gradient(to right bottom, rgb(255, 255, 255) 30%, rgba(255, 255, 255, 0.38));
  -webkit-background-clip: text;
  background-clip: text;
}
.light-mode .t-doc__sidebar {
  --scalar-sidebar-search-background: white;
}
.examples .scalar-card-footer {
  --scalar-background-3: transparent;
  padding-top: 0;
}
/* Hero section flare */
.section-flare {
  overflow-x: hidden;
  height: 100vh;
  left: initial;
}
.section-flare-item:nth-of-type(1) {
  background: #d25019;
  position: relative;
  top: -150px;
  right: -400px;
  width: 80vw;
  height: 500px;
  margin-top: -150px;
  border-radius: 50%;
  filter: blur(100px);
  z-index: 0;
}
.light-mode .section-flare {
  display: none;
}
*::selection {
  background-color: color-mix(in srgb, var(--scalar-color-red), transparent 75%);
}
`;

// node_modules/@scalar/themes/dist/presets/moon.css2.js
var a8 = `.light-mode {
  color-scheme: light;
  --scalar-color-1: #000000;
  --scalar-color-2: #000000;
  --scalar-color-3: #000000;
  --scalar-color-accent: #645b0f;
  --scalar-background-1: #ccc9b3;
  --scalar-background-2: #c2bfaa;
  --scalar-background-3: #b8b5a1;
  --scalar-background-accent: #000000;

  --scalar-border-color: rgba(0, 0, 0, 0.2);
  --scalar-scrollbar-color: rgba(0, 0, 0, 0.18);
  --scalar-scrollbar-color-active: rgba(0, 0, 0, 0.36);
  --scalar-lifted-brightness: 1;
  --scalar-backdrop-brightness: 1;

  --scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, 0.11);
  --scalar-shadow-2: rgba(0, 0, 0, 0.08) 0px 13px 20px 0px, rgba(0, 0, 0, 0.08) 0px 3px 8px 0px,
    var(--scalar-border-color) 0px 0 0 1px;

  --scalar-button-1: rgb(49 53 56);
  --scalar-button-1-color: #fff;
  --scalar-button-1-hover: rgb(28 31 33);

  --scalar-color-red: #b91c1c;
  --scalar-color-orange: #a16207;
  --scalar-color-green: #047857;
  --scalar-color-blue: #1d4ed8;
  --scalar-color-orange: #c2410c;
  --scalar-color-purple: #6d28d9;
}

.dark-mode {
  color-scheme: dark;
  --scalar-color-1: #fffef3;
  --scalar-color-2: #fffef3;
  --scalar-color-3: #fffef3;
  --scalar-color-accent: #c3b531;
  --scalar-background-1: #313332;
  --scalar-background-2: #393b3a;
  --scalar-background-3: #414342;
  --scalar-background-accent: #fffef3;

  --scalar-border-color: #505452;
  --scalar-scrollbar-color: rgba(255, 255, 255, 0.24);
  --scalar-scrollbar-color-active: rgba(255, 255, 255, 0.48);
  --scalar-lifted-brightness: 1.45;
  --scalar-backdrop-brightness: 0.5;

  --scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, 0.11);
  --scalar-shadow-2: rgba(15, 15, 15, 0.2) 0px 3px 6px, rgba(15, 15, 15, 0.4) 0px 9px 24px, 0 0 0 1px
    rgba(255, 255, 255, 0.1);

  --scalar-button-1: #f6f6f6;
  --scalar-button-1-color: #000;
  --scalar-button-1-hover: #e7e7e7;

  --scalar-color-green: #00b648;
  --scalar-color-red: #dc1b19;
  --scalar-color-yellow: #ffc90d;
  --scalar-color-blue: #4eb3ec;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;
}

/* Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-hover-color: currentColor;

  --scalar-sidebar-item-active-background: var(--scalar-background-3);
  --scalar-sidebar-color-active: var(--scalar-color-1);

  --scalar-sidebar-search-background: transparent;
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
}
*::selection {
  background-color: color-mix(in srgb, var(--scalar-color-accent), transparent 80%);
}
`;

// node_modules/@scalar/themes/dist/presets/purple.css2.js
var a9 = `/* basic theme */
.light-mode {
  --scalar-background-1: #fff;
  --scalar-background-2: #f5f6f8;
  --scalar-background-3: #eceef1;

  --scalar-color-1: #2a2f45;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;

  --scalar-color-accent: #5469d4;
  --scalar-background-accent: #5469d41f;

  --scalar-border-color: rgba(215, 215, 206, 0.68);
}
.dark-mode {
  --scalar-background-1: #15171c;
  --scalar-background-2: #1c1e24;
  --scalar-background-3: #22252b;

  --scalar-color-1: #fafafa;
  --scalar-color-2: #c9ced8;
  --scalar-color-3: #8c99ad;

  --scalar-color-accent: #5469d4;
  --scalar-background-accent: #5469d41f;

  --scalar-border-color: #3f4145;
}
/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-3);

  --scalar-sidebar-item-active-background: var(--scalar-background-accent);
  --scalar-sidebar-color-active: var(--scalar-color-accent);

  --scalar-sidebar-search-background: var(--scalar-background-1);
  --scalar-sidebar-search-color: var(--scalar-color-3);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
}

/* advanced */
.light-mode {
  --scalar-color-green: #17803d;
  --scalar-color-red: #e10909;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #1763a6;
  --scalar-color-orange: #e25b09;
  --scalar-color-purple: #5c3993;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: #30a159;
  --scalar-color-red: #dc1b19;
  --scalar-color-yellow: #eec644;
  --scalar-color-blue: #2b7abf;
  --scalar-color-orange: #f07528;
  --scalar-color-purple: #7a59b1;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
.light-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-accent), transparent 70%);
}
.dark-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-accent), transparent 50%);
}
`;

// node_modules/@scalar/themes/dist/presets/saturn.css2.js
var a10 = `/* basic theme */
.light-mode {
  --scalar-background-1: #f3f3ee;
  --scalar-background-2: #e8e8e3;
  --scalar-background-3: #e4e4df;
  --scalar-border-color: rgba(215, 215, 206, 0.85);

  --scalar-color-1: #2a2f45;
  --scalar-color-2: #757575;
  --scalar-color-3: #8e8e8e;

  --scalar-color-accent: #1763a6;
  --scalar-background-accent: #1f648e1f;
}
.dark-mode {
  --scalar-background-1: #09090b;
  --scalar-background-2: #18181b;
  --scalar-background-3: #2c2c30;
  --scalar-border-color: rgba(255, 255, 255, 0.17);

  --scalar-color-1: #fafafa;
  --scalar-color-2: rgb(161, 161, 170);
  --scalar-color-3: rgba(255, 255, 255, 0.533);

  --scalar-color-accent: #4eb3ec;
  --scalar-background-accent: #8ab4f81f;
}
/* Document Sidebar */
.light-mode .t-doc__sidebar,
.dark-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-border-color: var(--scalar-border-color);

  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-hover-color: currentColor;

  --scalar-sidebar-item-active-background: var(--scalar-background-3);
  --scalar-sidebar-color-active: var(--scalar-color-1);

  --scalar-sidebar-search-background: var(--scalar-background-1);
  --scalar-sidebar-search-border-color: var(--scalar-border-color);
  --scalar-sidebar-search-color: var(--scalar-color-3);
}

/* advanced */
.light-mode {
  --scalar-color-green: #17803d;
  --scalar-color-red: #e10909;
  --scalar-color-yellow: #edbe20;
  --scalar-color-blue: #1763a6;
  --scalar-color-orange: #e25b09;
  --scalar-color-purple: #5c3993;

  --scalar-button-1: rgba(0, 0, 0, 1);
  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);
  --scalar-button-1-color: rgba(255, 255, 255, 0.9);
}
.dark-mode {
  --scalar-color-green: #30a159;
  --scalar-color-red: #dc1b19;
  --scalar-color-yellow: #eec644;
  --scalar-color-blue: #2b7abf;
  --scalar-color-orange: #f07528;
  --scalar-color-purple: #7a59b1;

  --scalar-button-1: rgba(255, 255, 255, 1);
  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);
  --scalar-button-1-color: black;
}
.dark-mode h2.t-editor__heading,
.dark-mode .t-editor__page-title h1,
.dark-mode h1.section-header:not(::selection),
.dark-mode .markdown h1,
.dark-mode .markdown h2,
.dark-mode .markdown h3,
.dark-mode .markdown h4,
.dark-mode .markdown h5,
.dark-mode .markdown h6 {
  -webkit-text-fill-color: transparent;
  background-image: linear-gradient(to right bottom, rgb(255, 255, 255) 30%, rgba(255, 255, 255, 0.38));
  -webkit-background-clip: text;
  background-clip: text;
}
.light-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-accent), transparent 70%);
}
.dark-mode *::selection {
  background-color: color-mix(in srgb, var(--scalar-color-accent), transparent 50%);
}
`;

// node_modules/@scalar/themes/dist/presets/solarized.css2.js
var a11 = `.light-mode {
  color-scheme: light;
  --scalar-color-1: #584c27;
  --scalar-color-2: #616161;
  --scalar-color-3: #a89f84;
  --scalar-color-accent: #b58900;
  --scalar-background-1: #fdf6e3;
  --scalar-background-2: #eee8d5;
  --scalar-background-3: #ddd6c1;
  --scalar-background-accent: #b589001f;

  --scalar-border-color: #ded8c8;
  --scalar-scrollbar-color: rgba(0, 0, 0, 0.18);
  --scalar-scrollbar-color-active: rgba(0, 0, 0, 0.36);
  --scalar-lifted-brightness: 1;
  --scalar-backdrop-brightness: 1;

  --scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, 0.11);
  --scalar-shadow-2: rgba(0, 0, 0, 0.08) 0px 13px 20px 0px, rgba(0, 0, 0, 0.08) 0px 3px 8px 0px, #eeeeed 0px 0 0 1px;

  --scalar-button-1: rgb(49 53 56);
  --scalar-button-1-color: #fff;
  --scalar-button-1-hover: rgb(28 31 33);

  --scalar-color-red: #b91c1c;
  --scalar-color-orange: #a16207;
  --scalar-color-green: #047857;
  --scalar-color-blue: #1d4ed8;
  --scalar-color-orange: #c2410c;
  --scalar-color-purple: #6d28d9;
}

.dark-mode {
  color-scheme: dark;
  --scalar-color-1: #fff;
  --scalar-color-2: #cccccc;
  --scalar-color-3: #6d8890;
  --scalar-color-accent: #007acc;
  --scalar-background-1: #00212b;
  --scalar-background-2: #012b36;
  --scalar-background-3: #004052;
  --scalar-background-accent: #015a6f;

  --scalar-border-color: #2f4851;
  --scalar-scrollbar-color: rgba(255, 255, 255, 0.24);
  --scalar-scrollbar-color-active: rgba(255, 255, 255, 0.48);
  --scalar-lifted-brightness: 1.45;
  --scalar-backdrop-brightness: 0.5;

  --scalar-shadow-1: 0 1px 3px 0 rgb(0, 0, 0, 0.1);
  --scalar-shadow-2: rgba(15, 15, 15, 0.2) 0px 3px 6px, rgba(15, 15, 15, 0.4) 0px 9px 24px, 0 0 0 1px
    rgba(255, 255, 255, 0.1);

  --scalar-button-1: #f6f6f6;
  --scalar-button-1-color: #000;
  --scalar-button-1-hover: #e7e7e7;

  --scalar-color-green: #00b648;
  --scalar-color-red: #dc1b19;
  --scalar-color-yellow: #ffc90d;
  --scalar-color-blue: #4eb3ec;
  --scalar-color-orange: #ff8d4d;
  --scalar-color-purple: #b191f9;
}

/* Sidebar */
.light-mode .t-doc__sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-active-background: var(--scalar-background-accent);
  --scalar-sidebar-border-color: var(--scalar-border-color);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-color-active: var(--scalar-color-accent);
  --scalar-sidebar-search-background: var(--scalar-background-2);
  --scalar-sidebar-search-border-color: var(--scalar-sidebar-search-background);
  --scalar-sidebar-search--color: var(--scalar-color-3);
}

.dark-mode .sidebar {
  --scalar-sidebar-background-1: var(--scalar-background-1);
  --scalar-sidebar-item-hover-color: currentColor;
  --scalar-sidebar-item-hover-background: var(--scalar-background-2);
  --scalar-sidebar-item-active-background: var(--scalar-background-accent);
  --scalar-sidebar-border-color: var(--scalar-border-color);
  --scalar-sidebar-color-1: var(--scalar-color-1);
  --scalar-sidebar-color-2: var(--scalar-color-2);
  --scalar-sidebar-color-active: var(--scalar-sidebar-color-1);
  --scalar-sidebar-search-background: var(--scalar-background-2);
  --scalar-sidebar-search-border-color: var(--scalar-sidebar-search-background);
  --scalar-sidebar-search--color: var(--scalar-color-3);
}
*::selection {
  background-color: color-mix(in srgb, var(--scalar-color-accent), transparent 70%);
}
`;

// node_modules/@scalar/themes/node_modules/@scalar/types/node_modules/zod/v3/external.js
var exports_external = {};
__export(exports_external, {
	void: () => voidType,
	util: () => util,
	unknown: () => unknownType,
	union: () => unionType,
	undefined: () => undefinedType,
	tuple: () => tupleType,
	transformer: () => effectsType,
	symbol: () => symbolType,
	string: () => stringType,
	strictObject: () => strictObjectType,
	setErrorMap: () => setErrorMap,
	set: () => setType,
	record: () => recordType,
	quotelessJson: () => quotelessJson,
	promise: () => promiseType,
	preprocess: () => preprocessType,
	pipeline: () => pipelineType,
	ostring: () => ostring,
	optional: () => optionalType,
	onumber: () => onumber,
	oboolean: () => oboolean,
	objectUtil: () => objectUtil,
	object: () => objectType,
	number: () => numberType,
	nullable: () => nullableType,
	null: () => nullType,
	never: () => neverType,
	nativeEnum: () => nativeEnumType,
	nan: () => nanType,
	map: () => mapType,
	makeIssue: () => makeIssue,
	literal: () => literalType,
	lazy: () => lazyType,
	late: () => late,
	isValid: () => isValid,
	isDirty: () => isDirty,
	isAsync: () => isAsync2,
	isAborted: () => isAborted,
	intersection: () => intersectionType,
	instanceof: () => instanceOfType,
	getParsedType: () => getParsedType,
	getErrorMap: () => getErrorMap,
	function: () => functionType,
	enum: () => enumType,
	effect: () => effectsType,
	discriminatedUnion: () => discriminatedUnionType,
	defaultErrorMap: () => en_default,
	datetimeRegex: () => datetimeRegex,
	date: () => dateType,
	custom: () => custom,
	coerce: () => coerce,
	boolean: () => booleanType,
	bigint: () => bigIntType,
	array: () => arrayType,
	any: () => anyType,
	addIssueToContext: () => addIssueToContext,
	ZodVoid: () => ZodVoid,
	ZodUnknown: () => ZodUnknown,
	ZodUnion: () => ZodUnion,
	ZodUndefined: () => ZodUndefined,
	ZodType: () => ZodType,
	ZodTuple: () => ZodTuple,
	ZodTransformer: () => ZodEffects,
	ZodSymbol: () => ZodSymbol,
	ZodString: () => ZodString,
	ZodSet: () => ZodSet,
	ZodSchema: () => ZodType,
	ZodRecord: () => ZodRecord,
	ZodReadonly: () => ZodReadonly,
	ZodPromise: () => ZodPromise,
	ZodPipeline: () => ZodPipeline,
	ZodParsedType: () => ZodParsedType,
	ZodOptional: () => ZodOptional,
	ZodObject: () => ZodObject,
	ZodNumber: () => ZodNumber,
	ZodNullable: () => ZodNullable,
	ZodNull: () => ZodNull,
	ZodNever: () => ZodNever,
	ZodNativeEnum: () => ZodNativeEnum,
	ZodNaN: () => ZodNaN,
	ZodMap: () => ZodMap,
	ZodLiteral: () => ZodLiteral,
	ZodLazy: () => ZodLazy,
	ZodIssueCode: () => ZodIssueCode,
	ZodIntersection: () => ZodIntersection,
	ZodFunction: () => ZodFunction,
	ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
	ZodError: () => ZodError,
	ZodEnum: () => ZodEnum,
	ZodEffects: () => ZodEffects,
	ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
	ZodDefault: () => ZodDefault,
	ZodDate: () => ZodDate,
	ZodCatch: () => ZodCatch,
	ZodBranded: () => ZodBranded,
	ZodBoolean: () => ZodBoolean,
	ZodBigInt: () => ZodBigInt,
	ZodArray: () => ZodArray,
	ZodAny: () => ZodAny,
	Schema: () => ZodType,
	ParseStatus: () => ParseStatus,
	OK: () => OK,
	NEVER: () => NEVER,
	INVALID: () => INVALID,
	EMPTY_PATH: () => EMPTY_PATH,
	DIRTY: () => DIRTY,
	BRAND: () => BRAND,
});

// node_modules/@scalar/themes/node_modules/@scalar/types/node_modules/zod/v3/helpers/util.js
var util;
(function (util2) {
	util2.assertEqual = (_2) => {};
	function assertIs(_arg) {}
	util2.assertIs = assertIs;
	function assertNever(_x) {
		throw new Error();
	}
	util2.assertNever = assertNever;
	util2.arrayToEnum = (items) => {
		const obj = {};
		for (const item of items) {
			obj[item] = item;
		}
		return obj;
	};
	util2.getValidEnumValues = (obj) => {
		const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
		const filtered = {};
		for (const k2 of validKeys) {
			filtered[k2] = obj[k2];
		}
		return util2.objectValues(filtered);
	};
	util2.objectValues = (obj) => {
		return util2.objectKeys(obj).map(function (e) {
			return obj[e];
		});
	};
	util2.objectKeys =
		typeof Object.keys === "function"
			? (obj) => Object.keys(obj)
			: (object) => {
					const keys = [];
					for (const key in object) {
						if (Object.prototype.hasOwnProperty.call(object, key)) {
							keys.push(key);
						}
					}
					return keys;
				};
	util2.find = (arr, checker) => {
		for (const item of arr) {
			if (checker(item)) return item;
		}
		return;
	};
	util2.isInteger =
		typeof Number.isInteger === "function"
			? (val) => Number.isInteger(val)
			: (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
	function joinValues(array, separator = " | ") {
		return array.map((val) => (typeof val === "string" ? `'${val}'` : val)).join(separator);
	}
	util2.joinValues = joinValues;
	util2.jsonStringifyReplacer = (_2, value) => {
		if (typeof value === "bigint") {
			return value.toString();
		}
		return value;
	};
})(util || (util = {}));
var objectUtil;
(function (objectUtil2) {
	objectUtil2.mergeShapes = (first, second) => {
		return {
			...first,
			...second,
		};
	};
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
	"string",
	"nan",
	"number",
	"integer",
	"float",
	"boolean",
	"date",
	"bigint",
	"symbol",
	"function",
	"undefined",
	"null",
	"array",
	"object",
	"unknown",
	"promise",
	"void",
	"never",
	"map",
	"set",
]);
var getParsedType = (data) => {
	const t2 = typeof data;
	switch (t2) {
		case "undefined":
			return ZodParsedType.undefined;
		case "string":
			return ZodParsedType.string;
		case "number":
			return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
		case "boolean":
			return ZodParsedType.boolean;
		case "function":
			return ZodParsedType.function;
		case "bigint":
			return ZodParsedType.bigint;
		case "symbol":
			return ZodParsedType.symbol;
		case "object":
			if (Array.isArray(data)) {
				return ZodParsedType.array;
			}
			if (data === null) {
				return ZodParsedType.null;
			}
			if (
				data.then &&
				typeof data.then === "function" &&
				data.catch &&
				typeof data.catch === "function"
			) {
				return ZodParsedType.promise;
			}
			if (typeof Map !== "undefined" && data instanceof Map) {
				return ZodParsedType.map;
			}
			if (typeof Set !== "undefined" && data instanceof Set) {
				return ZodParsedType.set;
			}
			if (typeof Date !== "undefined" && data instanceof Date) {
				return ZodParsedType.date;
			}
			return ZodParsedType.object;
		default:
			return ZodParsedType.unknown;
	}
};

// node_modules/@scalar/themes/node_modules/@scalar/types/node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
	"invalid_type",
	"invalid_literal",
	"custom",
	"invalid_union",
	"invalid_union_discriminator",
	"invalid_enum_value",
	"unrecognized_keys",
	"invalid_arguments",
	"invalid_return_type",
	"invalid_date",
	"invalid_string",
	"too_small",
	"too_big",
	"invalid_intersection_types",
	"not_multiple_of",
	"not_finite",
]);
var quotelessJson = (obj) => {
	const json = JSON.stringify(obj, null, 2);
	return json.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
	get errors() {
		return this.issues;
	}
	constructor(issues) {
		super();
		this.issues = [];
		this.addIssue = (sub) => {
			this.issues = [...this.issues, sub];
		};
		this.addIssues = (subs = []) => {
			this.issues = [...this.issues, ...subs];
		};
		const actualProto = new.target.prototype;
		if (Object.setPrototypeOf) {
			Object.setPrototypeOf(this, actualProto);
		} else {
			this.__proto__ = actualProto;
		}
		this.name = "ZodError";
		this.issues = issues;
	}
	format(_mapper) {
		const mapper =
			_mapper ||
			function (issue) {
				return issue.message;
			};
		const fieldErrors = { _errors: [] };
		const processError = (error) => {
			for (const issue of error.issues) {
				if (issue.code === "invalid_union") {
					issue.unionErrors.map(processError);
				} else if (issue.code === "invalid_return_type") {
					processError(issue.returnTypeError);
				} else if (issue.code === "invalid_arguments") {
					processError(issue.argumentsError);
				} else if (issue.path.length === 0) {
					fieldErrors._errors.push(mapper(issue));
				} else {
					let curr = fieldErrors;
					let i = 0;
					while (i < issue.path.length) {
						const el = issue.path[i];
						const terminal = i === issue.path.length - 1;
						if (!terminal) {
							curr[el] = curr[el] || { _errors: [] };
						} else {
							curr[el] = curr[el] || { _errors: [] };
							curr[el]._errors.push(mapper(issue));
						}
						curr = curr[el];
						i++;
					}
				}
			}
		};
		processError(this);
		return fieldErrors;
	}
	static assert(value) {
		if (!(value instanceof ZodError)) {
			throw new Error(`Not a ZodError: ${value}`);
		}
	}
	toString() {
		return this.message;
	}
	get message() {
		return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
	}
	get isEmpty() {
		return this.issues.length === 0;
	}
	flatten(mapper = (issue) => issue.message) {
		const fieldErrors = {};
		const formErrors = [];
		for (const sub of this.issues) {
			if (sub.path.length > 0) {
				const firstEl = sub.path[0];
				fieldErrors[firstEl] = fieldErrors[firstEl] || [];
				fieldErrors[firstEl].push(mapper(sub));
			} else {
				formErrors.push(mapper(sub));
			}
		}
		return { formErrors, fieldErrors };
	}
	get formErrors() {
		return this.flatten();
	}
}
ZodError.create = (issues) => {
	const error = new ZodError(issues);
	return error;
};

// node_modules/@scalar/themes/node_modules/@scalar/types/node_modules/zod/v3/locales/en.js
var errorMap = (issue, _ctx) => {
	let message;
	switch (issue.code) {
		case ZodIssueCode.invalid_type:
			if (issue.received === ZodParsedType.undefined) {
				message = "Required";
			} else {
				message = `Expected ${issue.expected}, received ${issue.received}`;
			}
			break;
		case ZodIssueCode.invalid_literal:
			message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
			break;
		case ZodIssueCode.unrecognized_keys:
			message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
			break;
		case ZodIssueCode.invalid_union:
			message = "Invalid input";
			break;
		case ZodIssueCode.invalid_union_discriminator:
			message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
			break;
		case ZodIssueCode.invalid_enum_value:
			message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
			break;
		case ZodIssueCode.invalid_arguments:
			message = "Invalid function arguments";
			break;
		case ZodIssueCode.invalid_return_type:
			message = "Invalid function return type";
			break;
		case ZodIssueCode.invalid_date:
			message = "Invalid date";
			break;
		case ZodIssueCode.invalid_string:
			if (typeof issue.validation === "object") {
				if ("includes" in issue.validation) {
					message = `Invalid input: must include "${issue.validation.includes}"`;
					if (typeof issue.validation.position === "number") {
						message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
					}
				} else if ("startsWith" in issue.validation) {
					message = `Invalid input: must start with "${issue.validation.startsWith}"`;
				} else if ("endsWith" in issue.validation) {
					message = `Invalid input: must end with "${issue.validation.endsWith}"`;
				} else {
					util.assertNever(issue.validation);
				}
			} else if (issue.validation !== "regex") {
				message = `Invalid ${issue.validation}`;
			} else {
				message = "Invalid";
			}
			break;
		case ZodIssueCode.too_small:
			if (issue.type === "array")
				message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? "at least" : "more than"} ${issue.minimum} element(s)`;
			else if (issue.type === "string")
				message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? "at least" : "over"} ${issue.minimum} character(s)`;
			else if (issue.type === "number")
				message = `Number must be ${issue.exact ? "exactly equal to " : issue.inclusive ? "greater than or equal to " : "greater than "}${issue.minimum}`;
			else if (issue.type === "bigint")
				message = `Number must be ${issue.exact ? "exactly equal to " : issue.inclusive ? "greater than or equal to " : "greater than "}${issue.minimum}`;
			else if (issue.type === "date")
				message = `Date must be ${issue.exact ? "exactly equal to " : issue.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(issue.minimum))}`;
			else message = "Invalid input";
			break;
		case ZodIssueCode.too_big:
			if (issue.type === "array")
				message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? "at most" : "less than"} ${issue.maximum} element(s)`;
			else if (issue.type === "string")
				message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? "at most" : "under"} ${issue.maximum} character(s)`;
			else if (issue.type === "number")
				message = `Number must be ${issue.exact ? "exactly" : issue.inclusive ? "less than or equal to" : "less than"} ${issue.maximum}`;
			else if (issue.type === "bigint")
				message = `BigInt must be ${issue.exact ? "exactly" : issue.inclusive ? "less than or equal to" : "less than"} ${issue.maximum}`;
			else if (issue.type === "date")
				message = `Date must be ${issue.exact ? "exactly" : issue.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(issue.maximum))}`;
			else message = "Invalid input";
			break;
		case ZodIssueCode.custom:
			message = "Invalid input";
			break;
		case ZodIssueCode.invalid_intersection_types:
			message = "Intersection results could not be merged";
			break;
		case ZodIssueCode.not_multiple_of:
			message = `Number must be a multiple of ${issue.multipleOf}`;
			break;
		case ZodIssueCode.not_finite:
			message = "Number must be finite";
			break;
		default:
			message = _ctx.defaultError;
			util.assertNever(issue);
	}
	return { message };
};
var en_default = errorMap;

// node_modules/@scalar/themes/node_modules/@scalar/types/node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function setErrorMap(map3) {
	overrideErrorMap = map3;
}
function getErrorMap() {
	return overrideErrorMap;
}
// node_modules/@scalar/themes/node_modules/@scalar/types/node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = (params) => {
	const { data, path: path2, errorMaps, issueData } = params;
	const fullPath = [...path2, ...(issueData.path || [])];
	const fullIssue = {
		...issueData,
		path: fullPath,
	};
	if (issueData.message !== undefined) {
		return {
			...issueData,
			path: fullPath,
			message: issueData.message,
		};
	}
	let errorMessage = "";
	const maps = errorMaps
		.filter((m) => !!m)
		.slice()
		.reverse();
	for (const map3 of maps) {
		errorMessage = map3(fullIssue, { data, defaultError: errorMessage }).message;
	}
	return {
		...issueData,
		path: fullPath,
		message: errorMessage,
	};
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
	const overrideMap = getErrorMap();
	const issue = makeIssue({
		issueData,
		data: ctx.data,
		path: ctx.path,
		errorMaps: [
			ctx.common.contextualErrorMap,
			ctx.schemaErrorMap,
			overrideMap,
			overrideMap === en_default ? undefined : en_default,
		].filter((x) => !!x),
	});
	ctx.common.issues.push(issue);
}

class ParseStatus {
	constructor() {
		this.value = "valid";
	}
	dirty() {
		if (this.value === "valid") this.value = "dirty";
	}
	abort() {
		if (this.value !== "aborted") this.value = "aborted";
	}
	static mergeArray(status2, results) {
		const arrayValue = [];
		for (const s of results) {
			if (s.status === "aborted") return INVALID;
			if (s.status === "dirty") status2.dirty();
			arrayValue.push(s.value);
		}
		return { status: status2.value, value: arrayValue };
	}
	static async mergeObjectAsync(status2, pairs) {
		const syncPairs = [];
		for (const pair of pairs) {
			const key = await pair.key;
			const value = await pair.value;
			syncPairs.push({
				key,
				value,
			});
		}
		return ParseStatus.mergeObjectSync(status2, syncPairs);
	}
	static mergeObjectSync(status2, pairs) {
		const finalObject = {};
		for (const pair of pairs) {
			const { key, value } = pair;
			if (key.status === "aborted") return INVALID;
			if (value.status === "aborted") return INVALID;
			if (key.status === "dirty") status2.dirty();
			if (value.status === "dirty") status2.dirty();
			if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
				finalObject[key.value] = value.value;
			}
		}
		return { status: status2.value, value: finalObject };
	}
}
var INVALID = Object.freeze({
	status: "aborted",
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync2 = (x) => typeof Promise !== "undefined" && x instanceof Promise;
// node_modules/@scalar/themes/node_modules/@scalar/types/node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function (errorUtil2) {
	errorUtil2.errToObj = (message) => (typeof message === "string" ? { message } : message || {});
	errorUtil2.toString = (message) => (typeof message === "string" ? message : message?.message);
})(errorUtil || (errorUtil = {}));

// node_modules/@scalar/themes/node_modules/@scalar/types/node_modules/zod/v3/types.js
class ParseInputLazyPath {
	constructor(parent, value, path2, key) {
		this._cachedPath = [];
		this.parent = parent;
		this.data = value;
		this._path = path2;
		this._key = key;
	}
	get path() {
		if (!this._cachedPath.length) {
			if (Array.isArray(this._key)) {
				this._cachedPath.push(...this._path, ...this._key);
			} else {
				this._cachedPath.push(...this._path, this._key);
			}
		}
		return this._cachedPath;
	}
}
var handleResult = (ctx, result) => {
	if (isValid(result)) {
		return { success: true, data: result.value };
	} else {
		if (!ctx.common.issues.length) {
			throw new Error("Validation failed but no issues detected.");
		}
		return {
			success: false,
			get error() {
				if (this._error) return this._error;
				const error = new ZodError(ctx.common.issues);
				this._error = error;
				return this._error;
			},
		};
	}
};
function processCreateParams(params) {
	if (!params) return {};
	const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
	if (errorMap2 && (invalid_type_error || required_error)) {
		throw new Error(
			'Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.',
		);
	}
	if (errorMap2) return { errorMap: errorMap2, description };
	const customMap = (iss, ctx) => {
		const { message } = params;
		if (iss.code === "invalid_enum_value") {
			return { message: message ?? ctx.defaultError };
		}
		if (typeof ctx.data === "undefined") {
			return { message: message ?? required_error ?? ctx.defaultError };
		}
		if (iss.code !== "invalid_type") return { message: ctx.defaultError };
		return { message: message ?? invalid_type_error ?? ctx.defaultError };
	};
	return { errorMap: customMap, description };
}

class ZodType {
	get description() {
		return this._def.description;
	}
	_getType(input) {
		return getParsedType(input.data);
	}
	_getOrReturnCtx(input, ctx) {
		return (
			ctx || {
				common: input.parent.common,
				data: input.data,
				parsedType: getParsedType(input.data),
				schemaErrorMap: this._def.errorMap,
				path: input.path,
				parent: input.parent,
			}
		);
	}
	_processInputParams(input) {
		return {
			status: new ParseStatus(),
			ctx: {
				common: input.parent.common,
				data: input.data,
				parsedType: getParsedType(input.data),
				schemaErrorMap: this._def.errorMap,
				path: input.path,
				parent: input.parent,
			},
		};
	}
	_parseSync(input) {
		const result = this._parse(input);
		if (isAsync2(result)) {
			throw new Error("Synchronous parse encountered promise.");
		}
		return result;
	}
	_parseAsync(input) {
		const result = this._parse(input);
		return Promise.resolve(result);
	}
	parse(data, params) {
		const result = this.safeParse(data, params);
		if (result.success) return result.data;
		throw result.error;
	}
	safeParse(data, params) {
		const ctx = {
			common: {
				issues: [],
				async: params?.async ?? false,
				contextualErrorMap: params?.errorMap,
			},
			path: params?.path || [],
			schemaErrorMap: this._def.errorMap,
			parent: null,
			data,
			parsedType: getParsedType(data),
		};
		const result = this._parseSync({ data, path: ctx.path, parent: ctx });
		return handleResult(ctx, result);
	}
	"~validate"(data) {
		const ctx = {
			common: {
				issues: [],
				async: !!this["~standard"].async,
			},
			path: [],
			schemaErrorMap: this._def.errorMap,
			parent: null,
			data,
			parsedType: getParsedType(data),
		};
		if (!this["~standard"].async) {
			try {
				const result = this._parseSync({ data, path: [], parent: ctx });
				return isValid(result)
					? {
							value: result.value,
						}
					: {
							issues: ctx.common.issues,
						};
			} catch (err) {
				if (err?.message?.toLowerCase()?.includes("encountered")) {
					this["~standard"].async = true;
				}
				ctx.common = {
					issues: [],
					async: true,
				};
			}
		}
		return this._parseAsync({ data, path: [], parent: ctx }).then((result) =>
			isValid(result)
				? {
						value: result.value,
					}
				: {
						issues: ctx.common.issues,
					},
		);
	}
	async parseAsync(data, params) {
		const result = await this.safeParseAsync(data, params);
		if (result.success) return result.data;
		throw result.error;
	}
	async safeParseAsync(data, params) {
		const ctx = {
			common: {
				issues: [],
				contextualErrorMap: params?.errorMap,
				async: true,
			},
			path: params?.path || [],
			schemaErrorMap: this._def.errorMap,
			parent: null,
			data,
			parsedType: getParsedType(data),
		};
		const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
		const result = await (isAsync2(maybeAsyncResult)
			? maybeAsyncResult
			: Promise.resolve(maybeAsyncResult));
		return handleResult(ctx, result);
	}
	refine(check2, message) {
		const getIssueProperties = (val) => {
			if (typeof message === "string" || typeof message === "undefined") {
				return { message };
			} else if (typeof message === "function") {
				return message(val);
			} else {
				return message;
			}
		};
		return this._refinement((val, ctx) => {
			const result = check2(val);
			const setError = () =>
				ctx.addIssue({
					code: ZodIssueCode.custom,
					...getIssueProperties(val),
				});
			if (typeof Promise !== "undefined" && result instanceof Promise) {
				return result.then((data) => {
					if (!data) {
						setError();
						return false;
					} else {
						return true;
					}
				});
			}
			if (!result) {
				setError();
				return false;
			} else {
				return true;
			}
		});
	}
	refinement(check2, refinementData) {
		return this._refinement((val, ctx) => {
			if (!check2(val)) {
				ctx.addIssue(
					typeof refinementData === "function" ? refinementData(val, ctx) : refinementData,
				);
				return false;
			} else {
				return true;
			}
		});
	}
	_refinement(refinement) {
		return new ZodEffects({
			schema: this,
			typeName: ZodFirstPartyTypeKind.ZodEffects,
			effect: { type: "refinement", refinement },
		});
	}
	superRefine(refinement) {
		return this._refinement(refinement);
	}
	constructor(def) {
		this.spa = this.safeParseAsync;
		this._def = def;
		this.parse = this.parse.bind(this);
		this.safeParse = this.safeParse.bind(this);
		this.parseAsync = this.parseAsync.bind(this);
		this.safeParseAsync = this.safeParseAsync.bind(this);
		this.spa = this.spa.bind(this);
		this.refine = this.refine.bind(this);
		this.refinement = this.refinement.bind(this);
		this.superRefine = this.superRefine.bind(this);
		this.optional = this.optional.bind(this);
		this.nullable = this.nullable.bind(this);
		this.nullish = this.nullish.bind(this);
		this.array = this.array.bind(this);
		this.promise = this.promise.bind(this);
		this.or = this.or.bind(this);
		this.and = this.and.bind(this);
		this.transform = this.transform.bind(this);
		this.brand = this.brand.bind(this);
		this.default = this.default.bind(this);
		this.catch = this.catch.bind(this);
		this.describe = this.describe.bind(this);
		this.pipe = this.pipe.bind(this);
		this.readonly = this.readonly.bind(this);
		this.isNullable = this.isNullable.bind(this);
		this.isOptional = this.isOptional.bind(this);
		this["~standard"] = {
			version: 1,
			vendor: "zod",
			validate: (data) => this["~validate"](data),
		};
	}
	optional() {
		return ZodOptional.create(this, this._def);
	}
	nullable() {
		return ZodNullable.create(this, this._def);
	}
	nullish() {
		return this.nullable().optional();
	}
	array() {
		return ZodArray.create(this);
	}
	promise() {
		return ZodPromise.create(this, this._def);
	}
	or(option) {
		return ZodUnion.create([this, option], this._def);
	}
	and(incoming) {
		return ZodIntersection.create(this, incoming, this._def);
	}
	transform(transform2) {
		return new ZodEffects({
			...processCreateParams(this._def),
			schema: this,
			typeName: ZodFirstPartyTypeKind.ZodEffects,
			effect: { type: "transform", transform: transform2 },
		});
	}
	default(def) {
		const defaultValueFunc = typeof def === "function" ? def : () => def;
		return new ZodDefault({
			...processCreateParams(this._def),
			innerType: this,
			defaultValue: defaultValueFunc,
			typeName: ZodFirstPartyTypeKind.ZodDefault,
		});
	}
	brand() {
		return new ZodBranded({
			typeName: ZodFirstPartyTypeKind.ZodBranded,
			type: this,
			...processCreateParams(this._def),
		});
	}
	catch(def) {
		const catchValueFunc = typeof def === "function" ? def : () => def;
		return new ZodCatch({
			...processCreateParams(this._def),
			innerType: this,
			catchValue: catchValueFunc,
			typeName: ZodFirstPartyTypeKind.ZodCatch,
		});
	}
	describe(description) {
		const This = this.constructor;
		return new This({
			...this._def,
			description,
		});
	}
	pipe(target) {
		return ZodPipeline.create(this, target);
	}
	readonly() {
		return ZodReadonly.create(this);
	}
	isOptional() {
		return this.safeParse(undefined).success;
	}
	isNullable() {
		return this.safeParse(null).success;
	}
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex =
	/^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex =
	/^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex =
	/^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
var emojiRegex;
var ipv4Regex =
	/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex =
	/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex =
	/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex =
	/^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource =
	"((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))";
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
	let secondsRegexSource = "[0-5]\\d";
	if (args.precision) {
		secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
	} else if (args.precision == null) {
		secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
	}
	const secondsQuantifier = args.precision ? "+" : "?";
	return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
	return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
	let regex2 = `${dateRegexSource}T${timeRegexSource(args)}`;
	const opts = [];
	opts.push(args.local ? "Z?" : "Z");
	if (args.offset) opts.push("([+-]\\d{2}:?\\d{2})");
	regex2 = `${regex2}(${opts.join("|")})`;
	return new RegExp(`^${regex2}$`);
}
function isValidIP(ip, version) {
	if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
		return true;
	}
	if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
		return true;
	}
	return false;
}
function isValidJWT(jwt, alg) {
	if (!jwtRegex.test(jwt)) return false;
	try {
		const [header] = jwt.split(".");
		if (!header) return false;
		const base64 = header
			.replace(/-/g, "+")
			.replace(/_/g, "/")
			.padEnd(header.length + ((4 - (header.length % 4)) % 4), "=");
		const decoded = JSON.parse(atob(base64));
		if (typeof decoded !== "object" || decoded === null) return false;
		if ("typ" in decoded && decoded?.typ !== "JWT") return false;
		if (!decoded.alg) return false;
		if (alg && decoded.alg !== alg) return false;
		return true;
	} catch {
		return false;
	}
}
function isValidCidr(ip, version) {
	if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
		return true;
	}
	if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
		return true;
	}
	return false;
}

class ZodString extends ZodType {
	_parse(input) {
		if (this._def.coerce) {
			input.data = String(input.data);
		}
		const parsedType = this._getType(input);
		if (parsedType !== ZodParsedType.string) {
			const ctx2 = this._getOrReturnCtx(input);
			addIssueToContext(ctx2, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.string,
				received: ctx2.parsedType,
			});
			return INVALID;
		}
		const status2 = new ParseStatus();
		let ctx = undefined;
		for (const check2 of this._def.checks) {
			if (check2.kind === "min") {
				if (input.data.length < check2.value) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.too_small,
						minimum: check2.value,
						type: "string",
						inclusive: true,
						exact: false,
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "max") {
				if (input.data.length > check2.value) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.too_big,
						maximum: check2.value,
						type: "string",
						inclusive: true,
						exact: false,
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "length") {
				const tooBig = input.data.length > check2.value;
				const tooSmall = input.data.length < check2.value;
				if (tooBig || tooSmall) {
					ctx = this._getOrReturnCtx(input, ctx);
					if (tooBig) {
						addIssueToContext(ctx, {
							code: ZodIssueCode.too_big,
							maximum: check2.value,
							type: "string",
							inclusive: true,
							exact: true,
							message: check2.message,
						});
					} else if (tooSmall) {
						addIssueToContext(ctx, {
							code: ZodIssueCode.too_small,
							minimum: check2.value,
							type: "string",
							inclusive: true,
							exact: true,
							message: check2.message,
						});
					}
					status2.dirty();
				}
			} else if (check2.kind === "email") {
				if (!emailRegex.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "email",
						code: ZodIssueCode.invalid_string,
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "emoji") {
				if (!emojiRegex) {
					emojiRegex = new RegExp(_emojiRegex, "u");
				}
				if (!emojiRegex.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "emoji",
						code: ZodIssueCode.invalid_string,
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "uuid") {
				if (!uuidRegex.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "uuid",
						code: ZodIssueCode.invalid_string,
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "nanoid") {
				if (!nanoidRegex.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "nanoid",
						code: ZodIssueCode.invalid_string,
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "cuid") {
				if (!cuidRegex.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "cuid",
						code: ZodIssueCode.invalid_string,
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "cuid2") {
				if (!cuid2Regex.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "cuid2",
						code: ZodIssueCode.invalid_string,
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "ulid") {
				if (!ulidRegex.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "ulid",
						code: ZodIssueCode.invalid_string,
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "url") {
				try {
					new URL(input.data);
				} catch {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "url",
						code: ZodIssueCode.invalid_string,
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "regex") {
				check2.regex.lastIndex = 0;
				const testResult = check2.regex.test(input.data);
				if (!testResult) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "regex",
						code: ZodIssueCode.invalid_string,
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "trim") {
				input.data = input.data.trim();
			} else if (check2.kind === "includes") {
				if (!input.data.includes(check2.value, check2.position)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.invalid_string,
						validation: { includes: check2.value, position: check2.position },
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "toLowerCase") {
				input.data = input.data.toLowerCase();
			} else if (check2.kind === "toUpperCase") {
				input.data = input.data.toUpperCase();
			} else if (check2.kind === "startsWith") {
				if (!input.data.startsWith(check2.value)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.invalid_string,
						validation: { startsWith: check2.value },
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "endsWith") {
				if (!input.data.endsWith(check2.value)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.invalid_string,
						validation: { endsWith: check2.value },
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "datetime") {
				const regex2 = datetimeRegex(check2);
				if (!regex2.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.invalid_string,
						validation: "datetime",
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "date") {
				const regex2 = dateRegex;
				if (!regex2.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.invalid_string,
						validation: "date",
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "time") {
				const regex2 = timeRegex(check2);
				if (!regex2.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.invalid_string,
						validation: "time",
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "duration") {
				if (!durationRegex.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "duration",
						code: ZodIssueCode.invalid_string,
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "ip") {
				if (!isValidIP(input.data, check2.version)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "ip",
						code: ZodIssueCode.invalid_string,
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "jwt") {
				if (!isValidJWT(input.data, check2.alg)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "jwt",
						code: ZodIssueCode.invalid_string,
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "cidr") {
				if (!isValidCidr(input.data, check2.version)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "cidr",
						code: ZodIssueCode.invalid_string,
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "base64") {
				if (!base64Regex.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "base64",
						code: ZodIssueCode.invalid_string,
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "base64url") {
				if (!base64urlRegex.test(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						validation: "base64url",
						code: ZodIssueCode.invalid_string,
						message: check2.message,
					});
					status2.dirty();
				}
			} else {
				util.assertNever(check2);
			}
		}
		return { status: status2.value, value: input.data };
	}
	_regex(regex2, validation, message) {
		return this.refinement((data) => regex2.test(data), {
			validation,
			code: ZodIssueCode.invalid_string,
			...errorUtil.errToObj(message),
		});
	}
	_addCheck(check2) {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, check2],
		});
	}
	email(message) {
		return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
	}
	url(message) {
		return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
	}
	emoji(message) {
		return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
	}
	uuid(message) {
		return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
	}
	nanoid(message) {
		return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
	}
	cuid(message) {
		return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
	}
	cuid2(message) {
		return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
	}
	ulid(message) {
		return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
	}
	base64(message) {
		return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
	}
	base64url(message) {
		return this._addCheck({
			kind: "base64url",
			...errorUtil.errToObj(message),
		});
	}
	jwt(options) {
		return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
	}
	ip(options) {
		return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
	}
	cidr(options) {
		return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
	}
	datetime(options) {
		if (typeof options === "string") {
			return this._addCheck({
				kind: "datetime",
				precision: null,
				offset: false,
				local: false,
				message: options,
			});
		}
		return this._addCheck({
			kind: "datetime",
			precision: typeof options?.precision === "undefined" ? null : options?.precision,
			offset: options?.offset ?? false,
			local: options?.local ?? false,
			...errorUtil.errToObj(options?.message),
		});
	}
	date(message) {
		return this._addCheck({ kind: "date", message });
	}
	time(options) {
		if (typeof options === "string") {
			return this._addCheck({
				kind: "time",
				precision: null,
				message: options,
			});
		}
		return this._addCheck({
			kind: "time",
			precision: typeof options?.precision === "undefined" ? null : options?.precision,
			...errorUtil.errToObj(options?.message),
		});
	}
	duration(message) {
		return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
	}
	regex(regex2, message) {
		return this._addCheck({
			kind: "regex",
			regex: regex2,
			...errorUtil.errToObj(message),
		});
	}
	includes(value, options) {
		return this._addCheck({
			kind: "includes",
			value,
			position: options?.position,
			...errorUtil.errToObj(options?.message),
		});
	}
	startsWith(value, message) {
		return this._addCheck({
			kind: "startsWith",
			value,
			...errorUtil.errToObj(message),
		});
	}
	endsWith(value, message) {
		return this._addCheck({
			kind: "endsWith",
			value,
			...errorUtil.errToObj(message),
		});
	}
	min(minLength, message) {
		return this._addCheck({
			kind: "min",
			value: minLength,
			...errorUtil.errToObj(message),
		});
	}
	max(maxLength, message) {
		return this._addCheck({
			kind: "max",
			value: maxLength,
			...errorUtil.errToObj(message),
		});
	}
	length(len, message) {
		return this._addCheck({
			kind: "length",
			value: len,
			...errorUtil.errToObj(message),
		});
	}
	nonempty(message) {
		return this.min(1, errorUtil.errToObj(message));
	}
	trim() {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, { kind: "trim" }],
		});
	}
	toLowerCase() {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, { kind: "toLowerCase" }],
		});
	}
	toUpperCase() {
		return new ZodString({
			...this._def,
			checks: [...this._def.checks, { kind: "toUpperCase" }],
		});
	}
	get isDatetime() {
		return !!this._def.checks.find((ch) => ch.kind === "datetime");
	}
	get isDate() {
		return !!this._def.checks.find((ch) => ch.kind === "date");
	}
	get isTime() {
		return !!this._def.checks.find((ch) => ch.kind === "time");
	}
	get isDuration() {
		return !!this._def.checks.find((ch) => ch.kind === "duration");
	}
	get isEmail() {
		return !!this._def.checks.find((ch) => ch.kind === "email");
	}
	get isURL() {
		return !!this._def.checks.find((ch) => ch.kind === "url");
	}
	get isEmoji() {
		return !!this._def.checks.find((ch) => ch.kind === "emoji");
	}
	get isUUID() {
		return !!this._def.checks.find((ch) => ch.kind === "uuid");
	}
	get isNANOID() {
		return !!this._def.checks.find((ch) => ch.kind === "nanoid");
	}
	get isCUID() {
		return !!this._def.checks.find((ch) => ch.kind === "cuid");
	}
	get isCUID2() {
		return !!this._def.checks.find((ch) => ch.kind === "cuid2");
	}
	get isULID() {
		return !!this._def.checks.find((ch) => ch.kind === "ulid");
	}
	get isIP() {
		return !!this._def.checks.find((ch) => ch.kind === "ip");
	}
	get isCIDR() {
		return !!this._def.checks.find((ch) => ch.kind === "cidr");
	}
	get isBase64() {
		return !!this._def.checks.find((ch) => ch.kind === "base64");
	}
	get isBase64url() {
		return !!this._def.checks.find((ch) => ch.kind === "base64url");
	}
	get minLength() {
		let min = null;
		for (const ch of this._def.checks) {
			if (ch.kind === "min") {
				if (min === null || ch.value > min) min = ch.value;
			}
		}
		return min;
	}
	get maxLength() {
		let max = null;
		for (const ch of this._def.checks) {
			if (ch.kind === "max") {
				if (max === null || ch.value < max) max = ch.value;
			}
		}
		return max;
	}
}
ZodString.create = (params) => {
	return new ZodString({
		checks: [],
		typeName: ZodFirstPartyTypeKind.ZodString,
		coerce: params?.coerce ?? false,
		...processCreateParams(params),
	});
};
function floatSafeRemainder(val, step) {
	const valDecCount = (val.toString().split(".")[1] || "").length;
	const stepDecCount = (step.toString().split(".")[1] || "").length;
	const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
	const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
	const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
	return (valInt % stepInt) / 10 ** decCount;
}

class ZodNumber extends ZodType {
	constructor() {
		super(...arguments);
		this.min = this.gte;
		this.max = this.lte;
		this.step = this.multipleOf;
	}
	_parse(input) {
		if (this._def.coerce) {
			input.data = Number(input.data);
		}
		const parsedType = this._getType(input);
		if (parsedType !== ZodParsedType.number) {
			const ctx2 = this._getOrReturnCtx(input);
			addIssueToContext(ctx2, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.number,
				received: ctx2.parsedType,
			});
			return INVALID;
		}
		let ctx = undefined;
		const status2 = new ParseStatus();
		for (const check2 of this._def.checks) {
			if (check2.kind === "int") {
				if (!util.isInteger(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.invalid_type,
						expected: "integer",
						received: "float",
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "min") {
				const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
				if (tooSmall) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.too_small,
						minimum: check2.value,
						type: "number",
						inclusive: check2.inclusive,
						exact: false,
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "max") {
				const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
				if (tooBig) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.too_big,
						maximum: check2.value,
						type: "number",
						inclusive: check2.inclusive,
						exact: false,
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "multipleOf") {
				if (floatSafeRemainder(input.data, check2.value) !== 0) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.not_multiple_of,
						multipleOf: check2.value,
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "finite") {
				if (!Number.isFinite(input.data)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.not_finite,
						message: check2.message,
					});
					status2.dirty();
				}
			} else {
				util.assertNever(check2);
			}
		}
		return { status: status2.value, value: input.data };
	}
	gte(value, message) {
		return this.setLimit("min", value, true, errorUtil.toString(message));
	}
	gt(value, message) {
		return this.setLimit("min", value, false, errorUtil.toString(message));
	}
	lte(value, message) {
		return this.setLimit("max", value, true, errorUtil.toString(message));
	}
	lt(value, message) {
		return this.setLimit("max", value, false, errorUtil.toString(message));
	}
	setLimit(kind, value, inclusive, message) {
		return new ZodNumber({
			...this._def,
			checks: [
				...this._def.checks,
				{
					kind,
					value,
					inclusive,
					message: errorUtil.toString(message),
				},
			],
		});
	}
	_addCheck(check2) {
		return new ZodNumber({
			...this._def,
			checks: [...this._def.checks, check2],
		});
	}
	int(message) {
		return this._addCheck({
			kind: "int",
			message: errorUtil.toString(message),
		});
	}
	positive(message) {
		return this._addCheck({
			kind: "min",
			value: 0,
			inclusive: false,
			message: errorUtil.toString(message),
		});
	}
	negative(message) {
		return this._addCheck({
			kind: "max",
			value: 0,
			inclusive: false,
			message: errorUtil.toString(message),
		});
	}
	nonpositive(message) {
		return this._addCheck({
			kind: "max",
			value: 0,
			inclusive: true,
			message: errorUtil.toString(message),
		});
	}
	nonnegative(message) {
		return this._addCheck({
			kind: "min",
			value: 0,
			inclusive: true,
			message: errorUtil.toString(message),
		});
	}
	multipleOf(value, message) {
		return this._addCheck({
			kind: "multipleOf",
			value,
			message: errorUtil.toString(message),
		});
	}
	finite(message) {
		return this._addCheck({
			kind: "finite",
			message: errorUtil.toString(message),
		});
	}
	safe(message) {
		return this._addCheck({
			kind: "min",
			inclusive: true,
			value: Number.MIN_SAFE_INTEGER,
			message: errorUtil.toString(message),
		})._addCheck({
			kind: "max",
			inclusive: true,
			value: Number.MAX_SAFE_INTEGER,
			message: errorUtil.toString(message),
		});
	}
	get minValue() {
		let min = null;
		for (const ch of this._def.checks) {
			if (ch.kind === "min") {
				if (min === null || ch.value > min) min = ch.value;
			}
		}
		return min;
	}
	get maxValue() {
		let max = null;
		for (const ch of this._def.checks) {
			if (ch.kind === "max") {
				if (max === null || ch.value < max) max = ch.value;
			}
		}
		return max;
	}
	get isInt() {
		return !!this._def.checks.find(
			(ch) => ch.kind === "int" || (ch.kind === "multipleOf" && util.isInteger(ch.value)),
		);
	}
	get isFinite() {
		let max = null;
		let min = null;
		for (const ch of this._def.checks) {
			if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
				return true;
			} else if (ch.kind === "min") {
				if (min === null || ch.value > min) min = ch.value;
			} else if (ch.kind === "max") {
				if (max === null || ch.value < max) max = ch.value;
			}
		}
		return Number.isFinite(min) && Number.isFinite(max);
	}
}
ZodNumber.create = (params) => {
	return new ZodNumber({
		checks: [],
		typeName: ZodFirstPartyTypeKind.ZodNumber,
		coerce: params?.coerce || false,
		...processCreateParams(params),
	});
};

class ZodBigInt extends ZodType {
	constructor() {
		super(...arguments);
		this.min = this.gte;
		this.max = this.lte;
	}
	_parse(input) {
		if (this._def.coerce) {
			try {
				input.data = BigInt(input.data);
			} catch {
				return this._getInvalidInput(input);
			}
		}
		const parsedType = this._getType(input);
		if (parsedType !== ZodParsedType.bigint) {
			return this._getInvalidInput(input);
		}
		let ctx = undefined;
		const status2 = new ParseStatus();
		for (const check2 of this._def.checks) {
			if (check2.kind === "min") {
				const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
				if (tooSmall) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.too_small,
						type: "bigint",
						minimum: check2.value,
						inclusive: check2.inclusive,
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "max") {
				const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
				if (tooBig) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.too_big,
						type: "bigint",
						maximum: check2.value,
						inclusive: check2.inclusive,
						message: check2.message,
					});
					status2.dirty();
				}
			} else if (check2.kind === "multipleOf") {
				if (input.data % check2.value !== BigInt(0)) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.not_multiple_of,
						multipleOf: check2.value,
						message: check2.message,
					});
					status2.dirty();
				}
			} else {
				util.assertNever(check2);
			}
		}
		return { status: status2.value, value: input.data };
	}
	_getInvalidInput(input) {
		const ctx = this._getOrReturnCtx(input);
		addIssueToContext(ctx, {
			code: ZodIssueCode.invalid_type,
			expected: ZodParsedType.bigint,
			received: ctx.parsedType,
		});
		return INVALID;
	}
	gte(value, message) {
		return this.setLimit("min", value, true, errorUtil.toString(message));
	}
	gt(value, message) {
		return this.setLimit("min", value, false, errorUtil.toString(message));
	}
	lte(value, message) {
		return this.setLimit("max", value, true, errorUtil.toString(message));
	}
	lt(value, message) {
		return this.setLimit("max", value, false, errorUtil.toString(message));
	}
	setLimit(kind, value, inclusive, message) {
		return new ZodBigInt({
			...this._def,
			checks: [
				...this._def.checks,
				{
					kind,
					value,
					inclusive,
					message: errorUtil.toString(message),
				},
			],
		});
	}
	_addCheck(check2) {
		return new ZodBigInt({
			...this._def,
			checks: [...this._def.checks, check2],
		});
	}
	positive(message) {
		return this._addCheck({
			kind: "min",
			value: BigInt(0),
			inclusive: false,
			message: errorUtil.toString(message),
		});
	}
	negative(message) {
		return this._addCheck({
			kind: "max",
			value: BigInt(0),
			inclusive: false,
			message: errorUtil.toString(message),
		});
	}
	nonpositive(message) {
		return this._addCheck({
			kind: "max",
			value: BigInt(0),
			inclusive: true,
			message: errorUtil.toString(message),
		});
	}
	nonnegative(message) {
		return this._addCheck({
			kind: "min",
			value: BigInt(0),
			inclusive: true,
			message: errorUtil.toString(message),
		});
	}
	multipleOf(value, message) {
		return this._addCheck({
			kind: "multipleOf",
			value,
			message: errorUtil.toString(message),
		});
	}
	get minValue() {
		let min = null;
		for (const ch of this._def.checks) {
			if (ch.kind === "min") {
				if (min === null || ch.value > min) min = ch.value;
			}
		}
		return min;
	}
	get maxValue() {
		let max = null;
		for (const ch of this._def.checks) {
			if (ch.kind === "max") {
				if (max === null || ch.value < max) max = ch.value;
			}
		}
		return max;
	}
}
ZodBigInt.create = (params) => {
	return new ZodBigInt({
		checks: [],
		typeName: ZodFirstPartyTypeKind.ZodBigInt,
		coerce: params?.coerce ?? false,
		...processCreateParams(params),
	});
};

class ZodBoolean extends ZodType {
	_parse(input) {
		if (this._def.coerce) {
			input.data = Boolean(input.data);
		}
		const parsedType = this._getType(input);
		if (parsedType !== ZodParsedType.boolean) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.boolean,
				received: ctx.parsedType,
			});
			return INVALID;
		}
		return OK(input.data);
	}
}
ZodBoolean.create = (params) => {
	return new ZodBoolean({
		typeName: ZodFirstPartyTypeKind.ZodBoolean,
		coerce: params?.coerce || false,
		...processCreateParams(params),
	});
};

class ZodDate extends ZodType {
	_parse(input) {
		if (this._def.coerce) {
			input.data = new Date(input.data);
		}
		const parsedType = this._getType(input);
		if (parsedType !== ZodParsedType.date) {
			const ctx2 = this._getOrReturnCtx(input);
			addIssueToContext(ctx2, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.date,
				received: ctx2.parsedType,
			});
			return INVALID;
		}
		if (Number.isNaN(input.data.getTime())) {
			const ctx2 = this._getOrReturnCtx(input);
			addIssueToContext(ctx2, {
				code: ZodIssueCode.invalid_date,
			});
			return INVALID;
		}
		const status2 = new ParseStatus();
		let ctx = undefined;
		for (const check2 of this._def.checks) {
			if (check2.kind === "min") {
				if (input.data.getTime() < check2.value) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.too_small,
						message: check2.message,
						inclusive: true,
						exact: false,
						minimum: check2.value,
						type: "date",
					});
					status2.dirty();
				}
			} else if (check2.kind === "max") {
				if (input.data.getTime() > check2.value) {
					ctx = this._getOrReturnCtx(input, ctx);
					addIssueToContext(ctx, {
						code: ZodIssueCode.too_big,
						message: check2.message,
						inclusive: true,
						exact: false,
						maximum: check2.value,
						type: "date",
					});
					status2.dirty();
				}
			} else {
				util.assertNever(check2);
			}
		}
		return {
			status: status2.value,
			value: new Date(input.data.getTime()),
		};
	}
	_addCheck(check2) {
		return new ZodDate({
			...this._def,
			checks: [...this._def.checks, check2],
		});
	}
	min(minDate, message) {
		return this._addCheck({
			kind: "min",
			value: minDate.getTime(),
			message: errorUtil.toString(message),
		});
	}
	max(maxDate, message) {
		return this._addCheck({
			kind: "max",
			value: maxDate.getTime(),
			message: errorUtil.toString(message),
		});
	}
	get minDate() {
		let min = null;
		for (const ch of this._def.checks) {
			if (ch.kind === "min") {
				if (min === null || ch.value > min) min = ch.value;
			}
		}
		return min != null ? new Date(min) : null;
	}
	get maxDate() {
		let max = null;
		for (const ch of this._def.checks) {
			if (ch.kind === "max") {
				if (max === null || ch.value < max) max = ch.value;
			}
		}
		return max != null ? new Date(max) : null;
	}
}
ZodDate.create = (params) => {
	return new ZodDate({
		checks: [],
		coerce: params?.coerce || false,
		typeName: ZodFirstPartyTypeKind.ZodDate,
		...processCreateParams(params),
	});
};

class ZodSymbol extends ZodType {
	_parse(input) {
		const parsedType = this._getType(input);
		if (parsedType !== ZodParsedType.symbol) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.symbol,
				received: ctx.parsedType,
			});
			return INVALID;
		}
		return OK(input.data);
	}
}
ZodSymbol.create = (params) => {
	return new ZodSymbol({
		typeName: ZodFirstPartyTypeKind.ZodSymbol,
		...processCreateParams(params),
	});
};

class ZodUndefined extends ZodType {
	_parse(input) {
		const parsedType = this._getType(input);
		if (parsedType !== ZodParsedType.undefined) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.undefined,
				received: ctx.parsedType,
			});
			return INVALID;
		}
		return OK(input.data);
	}
}
ZodUndefined.create = (params) => {
	return new ZodUndefined({
		typeName: ZodFirstPartyTypeKind.ZodUndefined,
		...processCreateParams(params),
	});
};

class ZodNull extends ZodType {
	_parse(input) {
		const parsedType = this._getType(input);
		if (parsedType !== ZodParsedType.null) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.null,
				received: ctx.parsedType,
			});
			return INVALID;
		}
		return OK(input.data);
	}
}
ZodNull.create = (params) => {
	return new ZodNull({
		typeName: ZodFirstPartyTypeKind.ZodNull,
		...processCreateParams(params),
	});
};

class ZodAny extends ZodType {
	constructor() {
		super(...arguments);
		this._any = true;
	}
	_parse(input) {
		return OK(input.data);
	}
}
ZodAny.create = (params) => {
	return new ZodAny({
		typeName: ZodFirstPartyTypeKind.ZodAny,
		...processCreateParams(params),
	});
};

class ZodUnknown extends ZodType {
	constructor() {
		super(...arguments);
		this._unknown = true;
	}
	_parse(input) {
		return OK(input.data);
	}
}
ZodUnknown.create = (params) => {
	return new ZodUnknown({
		typeName: ZodFirstPartyTypeKind.ZodUnknown,
		...processCreateParams(params),
	});
};

class ZodNever extends ZodType {
	_parse(input) {
		const ctx = this._getOrReturnCtx(input);
		addIssueToContext(ctx, {
			code: ZodIssueCode.invalid_type,
			expected: ZodParsedType.never,
			received: ctx.parsedType,
		});
		return INVALID;
	}
}
ZodNever.create = (params) => {
	return new ZodNever({
		typeName: ZodFirstPartyTypeKind.ZodNever,
		...processCreateParams(params),
	});
};

class ZodVoid extends ZodType {
	_parse(input) {
		const parsedType = this._getType(input);
		if (parsedType !== ZodParsedType.undefined) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.void,
				received: ctx.parsedType,
			});
			return INVALID;
		}
		return OK(input.data);
	}
}
ZodVoid.create = (params) => {
	return new ZodVoid({
		typeName: ZodFirstPartyTypeKind.ZodVoid,
		...processCreateParams(params),
	});
};

class ZodArray extends ZodType {
	_parse(input) {
		const { ctx, status: status2 } = this._processInputParams(input);
		const def = this._def;
		if (ctx.parsedType !== ZodParsedType.array) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.array,
				received: ctx.parsedType,
			});
			return INVALID;
		}
		if (def.exactLength !== null) {
			const tooBig = ctx.data.length > def.exactLength.value;
			const tooSmall = ctx.data.length < def.exactLength.value;
			if (tooBig || tooSmall) {
				addIssueToContext(ctx, {
					code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
					minimum: tooSmall ? def.exactLength.value : undefined,
					maximum: tooBig ? def.exactLength.value : undefined,
					type: "array",
					inclusive: true,
					exact: true,
					message: def.exactLength.message,
				});
				status2.dirty();
			}
		}
		if (def.minLength !== null) {
			if (ctx.data.length < def.minLength.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: def.minLength.value,
					type: "array",
					inclusive: true,
					exact: false,
					message: def.minLength.message,
				});
				status2.dirty();
			}
		}
		if (def.maxLength !== null) {
			if (ctx.data.length > def.maxLength.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: def.maxLength.value,
					type: "array",
					inclusive: true,
					exact: false,
					message: def.maxLength.message,
				});
				status2.dirty();
			}
		}
		if (ctx.common.async) {
			return Promise.all(
				[...ctx.data].map((item, i) => {
					return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
				}),
			).then((result2) => {
				return ParseStatus.mergeArray(status2, result2);
			});
		}
		const result = [...ctx.data].map((item, i) => {
			return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
		});
		return ParseStatus.mergeArray(status2, result);
	}
	get element() {
		return this._def.type;
	}
	min(minLength, message) {
		return new ZodArray({
			...this._def,
			minLength: { value: minLength, message: errorUtil.toString(message) },
		});
	}
	max(maxLength, message) {
		return new ZodArray({
			...this._def,
			maxLength: { value: maxLength, message: errorUtil.toString(message) },
		});
	}
	length(len, message) {
		return new ZodArray({
			...this._def,
			exactLength: { value: len, message: errorUtil.toString(message) },
		});
	}
	nonempty(message) {
		return this.min(1, message);
	}
}
ZodArray.create = (schema, params) => {
	return new ZodArray({
		type: schema,
		minLength: null,
		maxLength: null,
		exactLength: null,
		typeName: ZodFirstPartyTypeKind.ZodArray,
		...processCreateParams(params),
	});
};
function deepPartialify(schema) {
	if (schema instanceof ZodObject) {
		const newShape = {};
		for (const key in schema.shape) {
			const fieldSchema = schema.shape[key];
			newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
		}
		return new ZodObject({
			...schema._def,
			shape: () => newShape,
		});
	} else if (schema instanceof ZodArray) {
		return new ZodArray({
			...schema._def,
			type: deepPartialify(schema.element),
		});
	} else if (schema instanceof ZodOptional) {
		return ZodOptional.create(deepPartialify(schema.unwrap()));
	} else if (schema instanceof ZodNullable) {
		return ZodNullable.create(deepPartialify(schema.unwrap()));
	} else if (schema instanceof ZodTuple) {
		return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
	} else {
		return schema;
	}
}

class ZodObject extends ZodType {
	constructor() {
		super(...arguments);
		this._cached = null;
		this.nonstrict = this.passthrough;
		this.augment = this.extend;
	}
	_getCached() {
		if (this._cached !== null) return this._cached;
		const shape = this._def.shape();
		const keys = util.objectKeys(shape);
		this._cached = { shape, keys };
		return this._cached;
	}
	_parse(input) {
		const parsedType = this._getType(input);
		if (parsedType !== ZodParsedType.object) {
			const ctx2 = this._getOrReturnCtx(input);
			addIssueToContext(ctx2, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.object,
				received: ctx2.parsedType,
			});
			return INVALID;
		}
		const { status: status2, ctx } = this._processInputParams(input);
		const { shape, keys: shapeKeys } = this._getCached();
		const extraKeys = [];
		if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
			for (const key in ctx.data) {
				if (!shapeKeys.includes(key)) {
					extraKeys.push(key);
				}
			}
		}
		const pairs = [];
		for (const key of shapeKeys) {
			const keyValidator = shape[key];
			const value = ctx.data[key];
			pairs.push({
				key: { status: "valid", value: key },
				value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
				alwaysSet: key in ctx.data,
			});
		}
		if (this._def.catchall instanceof ZodNever) {
			const unknownKeys = this._def.unknownKeys;
			if (unknownKeys === "passthrough") {
				for (const key of extraKeys) {
					pairs.push({
						key: { status: "valid", value: key },
						value: { status: "valid", value: ctx.data[key] },
					});
				}
			} else if (unknownKeys === "strict") {
				if (extraKeys.length > 0) {
					addIssueToContext(ctx, {
						code: ZodIssueCode.unrecognized_keys,
						keys: extraKeys,
					});
					status2.dirty();
				}
			} else if (unknownKeys === "strip") {
			} else {
				throw new Error("Internal ZodObject error: invalid unknownKeys value.");
			}
		} else {
			const catchall = this._def.catchall;
			for (const key of extraKeys) {
				const value = ctx.data[key];
				pairs.push({
					key: { status: "valid", value: key },
					value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
					alwaysSet: key in ctx.data,
				});
			}
		}
		if (ctx.common.async) {
			return Promise.resolve()
				.then(async () => {
					const syncPairs = [];
					for (const pair of pairs) {
						const key = await pair.key;
						const value = await pair.value;
						syncPairs.push({
							key,
							value,
							alwaysSet: pair.alwaysSet,
						});
					}
					return syncPairs;
				})
				.then((syncPairs) => {
					return ParseStatus.mergeObjectSync(status2, syncPairs);
				});
		} else {
			return ParseStatus.mergeObjectSync(status2, pairs);
		}
	}
	get shape() {
		return this._def.shape();
	}
	strict(message) {
		errorUtil.errToObj;
		return new ZodObject({
			...this._def,
			unknownKeys: "strict",
			...(message !== undefined
				? {
						errorMap: (issue, ctx) => {
							const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
							if (issue.code === "unrecognized_keys")
								return {
									message: errorUtil.errToObj(message).message ?? defaultError,
								};
							return {
								message: defaultError,
							};
						},
					}
				: {}),
		});
	}
	strip() {
		return new ZodObject({
			...this._def,
			unknownKeys: "strip",
		});
	}
	passthrough() {
		return new ZodObject({
			...this._def,
			unknownKeys: "passthrough",
		});
	}
	extend(augmentation) {
		return new ZodObject({
			...this._def,
			shape: () => ({
				...this._def.shape(),
				...augmentation,
			}),
		});
	}
	merge(merging) {
		const merged = new ZodObject({
			unknownKeys: merging._def.unknownKeys,
			catchall: merging._def.catchall,
			shape: () => ({
				...this._def.shape(),
				...merging._def.shape(),
			}),
			typeName: ZodFirstPartyTypeKind.ZodObject,
		});
		return merged;
	}
	setKey(key, schema) {
		return this.augment({ [key]: schema });
	}
	catchall(index) {
		return new ZodObject({
			...this._def,
			catchall: index,
		});
	}
	pick(mask) {
		const shape = {};
		for (const key of util.objectKeys(mask)) {
			if (mask[key] && this.shape[key]) {
				shape[key] = this.shape[key];
			}
		}
		return new ZodObject({
			...this._def,
			shape: () => shape,
		});
	}
	omit(mask) {
		const shape = {};
		for (const key of util.objectKeys(this.shape)) {
			if (!mask[key]) {
				shape[key] = this.shape[key];
			}
		}
		return new ZodObject({
			...this._def,
			shape: () => shape,
		});
	}
	deepPartial() {
		return deepPartialify(this);
	}
	partial(mask) {
		const newShape = {};
		for (const key of util.objectKeys(this.shape)) {
			const fieldSchema = this.shape[key];
			if (mask && !mask[key]) {
				newShape[key] = fieldSchema;
			} else {
				newShape[key] = fieldSchema.optional();
			}
		}
		return new ZodObject({
			...this._def,
			shape: () => newShape,
		});
	}
	required(mask) {
		const newShape = {};
		for (const key of util.objectKeys(this.shape)) {
			if (mask && !mask[key]) {
				newShape[key] = this.shape[key];
			} else {
				const fieldSchema = this.shape[key];
				let newField = fieldSchema;
				while (newField instanceof ZodOptional) {
					newField = newField._def.innerType;
				}
				newShape[key] = newField;
			}
		}
		return new ZodObject({
			...this._def,
			shape: () => newShape,
		});
	}
	keyof() {
		return createZodEnum(util.objectKeys(this.shape));
	}
}
ZodObject.create = (shape, params) => {
	return new ZodObject({
		shape: () => shape,
		unknownKeys: "strip",
		catchall: ZodNever.create(),
		typeName: ZodFirstPartyTypeKind.ZodObject,
		...processCreateParams(params),
	});
};
ZodObject.strictCreate = (shape, params) => {
	return new ZodObject({
		shape: () => shape,
		unknownKeys: "strict",
		catchall: ZodNever.create(),
		typeName: ZodFirstPartyTypeKind.ZodObject,
		...processCreateParams(params),
	});
};
ZodObject.lazycreate = (shape, params) => {
	return new ZodObject({
		shape,
		unknownKeys: "strip",
		catchall: ZodNever.create(),
		typeName: ZodFirstPartyTypeKind.ZodObject,
		...processCreateParams(params),
	});
};

class ZodUnion extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		const options = this._def.options;
		function handleResults(results) {
			for (const result of results) {
				if (result.result.status === "valid") {
					return result.result;
				}
			}
			for (const result of results) {
				if (result.result.status === "dirty") {
					ctx.common.issues.push(...result.ctx.common.issues);
					return result.result;
				}
			}
			const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_union,
				unionErrors,
			});
			return INVALID;
		}
		if (ctx.common.async) {
			return Promise.all(
				options.map(async (option) => {
					const childCtx = {
						...ctx,
						common: {
							...ctx.common,
							issues: [],
						},
						parent: null,
					};
					return {
						result: await option._parseAsync({
							data: ctx.data,
							path: ctx.path,
							parent: childCtx,
						}),
						ctx: childCtx,
					};
				}),
			).then(handleResults);
		} else {
			let dirty = undefined;
			const issues = [];
			for (const option of options) {
				const childCtx = {
					...ctx,
					common: {
						...ctx.common,
						issues: [],
					},
					parent: null,
				};
				const result = option._parseSync({
					data: ctx.data,
					path: ctx.path,
					parent: childCtx,
				});
				if (result.status === "valid") {
					return result;
				} else if (result.status === "dirty" && !dirty) {
					dirty = { result, ctx: childCtx };
				}
				if (childCtx.common.issues.length) {
					issues.push(childCtx.common.issues);
				}
			}
			if (dirty) {
				ctx.common.issues.push(...dirty.ctx.common.issues);
				return dirty.result;
			}
			const unionErrors = issues.map((issues2) => new ZodError(issues2));
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_union,
				unionErrors,
			});
			return INVALID;
		}
	}
	get options() {
		return this._def.options;
	}
}
ZodUnion.create = (types, params) => {
	return new ZodUnion({
		options: types,
		typeName: ZodFirstPartyTypeKind.ZodUnion,
		...processCreateParams(params),
	});
};
var getDiscriminator = (type) => {
	if (type instanceof ZodLazy) {
		return getDiscriminator(type.schema);
	} else if (type instanceof ZodEffects) {
		return getDiscriminator(type.innerType());
	} else if (type instanceof ZodLiteral) {
		return [type.value];
	} else if (type instanceof ZodEnum) {
		return type.options;
	} else if (type instanceof ZodNativeEnum) {
		return util.objectValues(type.enum);
	} else if (type instanceof ZodDefault) {
		return getDiscriminator(type._def.innerType);
	} else if (type instanceof ZodUndefined) {
		return [undefined];
	} else if (type instanceof ZodNull) {
		return [null];
	} else if (type instanceof ZodOptional) {
		return [undefined, ...getDiscriminator(type.unwrap())];
	} else if (type instanceof ZodNullable) {
		return [null, ...getDiscriminator(type.unwrap())];
	} else if (type instanceof ZodBranded) {
		return getDiscriminator(type.unwrap());
	} else if (type instanceof ZodReadonly) {
		return getDiscriminator(type.unwrap());
	} else if (type instanceof ZodCatch) {
		return getDiscriminator(type._def.innerType);
	} else {
		return [];
	}
};

class ZodDiscriminatedUnion extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.object) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.object,
				received: ctx.parsedType,
			});
			return INVALID;
		}
		const discriminator = this.discriminator;
		const discriminatorValue = ctx.data[discriminator];
		const option = this.optionsMap.get(discriminatorValue);
		if (!option) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_union_discriminator,
				options: Array.from(this.optionsMap.keys()),
				path: [discriminator],
			});
			return INVALID;
		}
		if (ctx.common.async) {
			return option._parseAsync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx,
			});
		} else {
			return option._parseSync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx,
			});
		}
	}
	get discriminator() {
		return this._def.discriminator;
	}
	get options() {
		return this._def.options;
	}
	get optionsMap() {
		return this._def.optionsMap;
	}
	static create(discriminator, options, params) {
		const optionsMap = new Map();
		for (const type of options) {
			const discriminatorValues = getDiscriminator(type.shape[discriminator]);
			if (!discriminatorValues.length) {
				throw new Error(
					`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`,
				);
			}
			for (const value of discriminatorValues) {
				if (optionsMap.has(value)) {
					throw new Error(
						`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`,
					);
				}
				optionsMap.set(value, type);
			}
		}
		return new ZodDiscriminatedUnion({
			typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
			discriminator,
			options,
			optionsMap,
			...processCreateParams(params),
		});
	}
}
function mergeValues(a12, b) {
	const aType = getParsedType(a12);
	const bType = getParsedType(b);
	if (a12 === b) {
		return { valid: true, data: a12 };
	} else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
		const bKeys = util.objectKeys(b);
		const sharedKeys = util.objectKeys(a12).filter((key) => bKeys.indexOf(key) !== -1);
		const newObj = { ...a12, ...b };
		for (const key of sharedKeys) {
			const sharedValue = mergeValues(a12[key], b[key]);
			if (!sharedValue.valid) {
				return { valid: false };
			}
			newObj[key] = sharedValue.data;
		}
		return { valid: true, data: newObj };
	} else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
		if (a12.length !== b.length) {
			return { valid: false };
		}
		const newArray = [];
		for (let index = 0; index < a12.length; index++) {
			const itemA = a12[index];
			const itemB = b[index];
			const sharedValue = mergeValues(itemA, itemB);
			if (!sharedValue.valid) {
				return { valid: false };
			}
			newArray.push(sharedValue.data);
		}
		return { valid: true, data: newArray };
	} else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a12 === +b) {
		return { valid: true, data: a12 };
	} else {
		return { valid: false };
	}
}

class ZodIntersection extends ZodType {
	_parse(input) {
		const { status: status2, ctx } = this._processInputParams(input);
		const handleParsed = (parsedLeft, parsedRight) => {
			if (isAborted(parsedLeft) || isAborted(parsedRight)) {
				return INVALID;
			}
			const merged = mergeValues(parsedLeft.value, parsedRight.value);
			if (!merged.valid) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.invalid_intersection_types,
				});
				return INVALID;
			}
			if (isDirty(parsedLeft) || isDirty(parsedRight)) {
				status2.dirty();
			}
			return { status: status2.value, value: merged.data };
		};
		if (ctx.common.async) {
			return Promise.all([
				this._def.left._parseAsync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx,
				}),
				this._def.right._parseAsync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx,
				}),
			]).then(([left, right]) => handleParsed(left, right));
		} else {
			return handleParsed(
				this._def.left._parseSync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx,
				}),
				this._def.right._parseSync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx,
				}),
			);
		}
	}
}
ZodIntersection.create = (left, right, params) => {
	return new ZodIntersection({
		left,
		right,
		typeName: ZodFirstPartyTypeKind.ZodIntersection,
		...processCreateParams(params),
	});
};

class ZodTuple extends ZodType {
	_parse(input) {
		const { status: status2, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.array) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.array,
				received: ctx.parsedType,
			});
			return INVALID;
		}
		if (ctx.data.length < this._def.items.length) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.too_small,
				minimum: this._def.items.length,
				inclusive: true,
				exact: false,
				type: "array",
			});
			return INVALID;
		}
		const rest = this._def.rest;
		if (!rest && ctx.data.length > this._def.items.length) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.too_big,
				maximum: this._def.items.length,
				inclusive: true,
				exact: false,
				type: "array",
			});
			status2.dirty();
		}
		const items = [...ctx.data]
			.map((item, itemIndex) => {
				const schema = this._def.items[itemIndex] || this._def.rest;
				if (!schema) return null;
				return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
			})
			.filter((x) => !!x);
		if (ctx.common.async) {
			return Promise.all(items).then((results) => {
				return ParseStatus.mergeArray(status2, results);
			});
		} else {
			return ParseStatus.mergeArray(status2, items);
		}
	}
	get items() {
		return this._def.items;
	}
	rest(rest) {
		return new ZodTuple({
			...this._def,
			rest,
		});
	}
}
ZodTuple.create = (schemas, params) => {
	if (!Array.isArray(schemas)) {
		throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
	}
	return new ZodTuple({
		items: schemas,
		typeName: ZodFirstPartyTypeKind.ZodTuple,
		rest: null,
		...processCreateParams(params),
	});
};

class ZodRecord extends ZodType {
	get keySchema() {
		return this._def.keyType;
	}
	get valueSchema() {
		return this._def.valueType;
	}
	_parse(input) {
		const { status: status2, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.object) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.object,
				received: ctx.parsedType,
			});
			return INVALID;
		}
		const pairs = [];
		const keyType = this._def.keyType;
		const valueType = this._def.valueType;
		for (const key in ctx.data) {
			pairs.push({
				key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
				value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
				alwaysSet: key in ctx.data,
			});
		}
		if (ctx.common.async) {
			return ParseStatus.mergeObjectAsync(status2, pairs);
		} else {
			return ParseStatus.mergeObjectSync(status2, pairs);
		}
	}
	get element() {
		return this._def.valueType;
	}
	static create(first, second, third) {
		if (second instanceof ZodType) {
			return new ZodRecord({
				keyType: first,
				valueType: second,
				typeName: ZodFirstPartyTypeKind.ZodRecord,
				...processCreateParams(third),
			});
		}
		return new ZodRecord({
			keyType: ZodString.create(),
			valueType: first,
			typeName: ZodFirstPartyTypeKind.ZodRecord,
			...processCreateParams(second),
		});
	}
}

class ZodMap extends ZodType {
	get keySchema() {
		return this._def.keyType;
	}
	get valueSchema() {
		return this._def.valueType;
	}
	_parse(input) {
		const { status: status2, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.map) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.map,
				received: ctx.parsedType,
			});
			return INVALID;
		}
		const keyType = this._def.keyType;
		const valueType = this._def.valueType;
		const pairs = [...ctx.data.entries()].map(([key, value], index) => {
			return {
				key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
				value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"])),
			};
		});
		if (ctx.common.async) {
			const finalMap = new Map();
			return Promise.resolve().then(async () => {
				for (const pair of pairs) {
					const key = await pair.key;
					const value = await pair.value;
					if (key.status === "aborted" || value.status === "aborted") {
						return INVALID;
					}
					if (key.status === "dirty" || value.status === "dirty") {
						status2.dirty();
					}
					finalMap.set(key.value, value.value);
				}
				return { status: status2.value, value: finalMap };
			});
		} else {
			const finalMap = new Map();
			for (const pair of pairs) {
				const key = pair.key;
				const value = pair.value;
				if (key.status === "aborted" || value.status === "aborted") {
					return INVALID;
				}
				if (key.status === "dirty" || value.status === "dirty") {
					status2.dirty();
				}
				finalMap.set(key.value, value.value);
			}
			return { status: status2.value, value: finalMap };
		}
	}
}
ZodMap.create = (keyType, valueType, params) => {
	return new ZodMap({
		valueType,
		keyType,
		typeName: ZodFirstPartyTypeKind.ZodMap,
		...processCreateParams(params),
	});
};

class ZodSet extends ZodType {
	_parse(input) {
		const { status: status2, ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.set) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.set,
				received: ctx.parsedType,
			});
			return INVALID;
		}
		const def = this._def;
		if (def.minSize !== null) {
			if (ctx.data.size < def.minSize.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_small,
					minimum: def.minSize.value,
					type: "set",
					inclusive: true,
					exact: false,
					message: def.minSize.message,
				});
				status2.dirty();
			}
		}
		if (def.maxSize !== null) {
			if (ctx.data.size > def.maxSize.value) {
				addIssueToContext(ctx, {
					code: ZodIssueCode.too_big,
					maximum: def.maxSize.value,
					type: "set",
					inclusive: true,
					exact: false,
					message: def.maxSize.message,
				});
				status2.dirty();
			}
		}
		const valueType = this._def.valueType;
		function finalizeSet(elements2) {
			const parsedSet = new Set();
			for (const element of elements2) {
				if (element.status === "aborted") return INVALID;
				if (element.status === "dirty") status2.dirty();
				parsedSet.add(element.value);
			}
			return { status: status2.value, value: parsedSet };
		}
		const elements = [...ctx.data.values()].map((item, i) =>
			valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)),
		);
		if (ctx.common.async) {
			return Promise.all(elements).then((elements2) => finalizeSet(elements2));
		} else {
			return finalizeSet(elements);
		}
	}
	min(minSize, message) {
		return new ZodSet({
			...this._def,
			minSize: { value: minSize, message: errorUtil.toString(message) },
		});
	}
	max(maxSize, message) {
		return new ZodSet({
			...this._def,
			maxSize: { value: maxSize, message: errorUtil.toString(message) },
		});
	}
	size(size, message) {
		return this.min(size, message).max(size, message);
	}
	nonempty(message) {
		return this.min(1, message);
	}
}
ZodSet.create = (valueType, params) => {
	return new ZodSet({
		valueType,
		minSize: null,
		maxSize: null,
		typeName: ZodFirstPartyTypeKind.ZodSet,
		...processCreateParams(params),
	});
};

class ZodFunction extends ZodType {
	constructor() {
		super(...arguments);
		this.validate = this.implement;
	}
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.function) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.function,
				received: ctx.parsedType,
			});
			return INVALID;
		}
		function makeArgsIssue(args, error) {
			return makeIssue({
				data: args,
				path: ctx.path,
				errorMaps: [
					ctx.common.contextualErrorMap,
					ctx.schemaErrorMap,
					getErrorMap(),
					en_default,
				].filter((x) => !!x),
				issueData: {
					code: ZodIssueCode.invalid_arguments,
					argumentsError: error,
				},
			});
		}
		function makeReturnsIssue(returns, error) {
			return makeIssue({
				data: returns,
				path: ctx.path,
				errorMaps: [
					ctx.common.contextualErrorMap,
					ctx.schemaErrorMap,
					getErrorMap(),
					en_default,
				].filter((x) => !!x),
				issueData: {
					code: ZodIssueCode.invalid_return_type,
					returnTypeError: error,
				},
			});
		}
		const params = { errorMap: ctx.common.contextualErrorMap };
		const fn = ctx.data;
		if (this._def.returns instanceof ZodPromise) {
			const me = this;
			return OK(async function (...args) {
				const error = new ZodError([]);
				const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
					error.addIssue(makeArgsIssue(args, e));
					throw error;
				});
				const result = await Reflect.apply(fn, this, parsedArgs);
				const parsedReturns = await me._def.returns._def.type
					.parseAsync(result, params)
					.catch((e) => {
						error.addIssue(makeReturnsIssue(result, e));
						throw error;
					});
				return parsedReturns;
			});
		} else {
			const me = this;
			return OK(function (...args) {
				const parsedArgs = me._def.args.safeParse(args, params);
				if (!parsedArgs.success) {
					throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
				}
				const result = Reflect.apply(fn, this, parsedArgs.data);
				const parsedReturns = me._def.returns.safeParse(result, params);
				if (!parsedReturns.success) {
					throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
				}
				return parsedReturns.data;
			});
		}
	}
	parameters() {
		return this._def.args;
	}
	returnType() {
		return this._def.returns;
	}
	args(...items) {
		return new ZodFunction({
			...this._def,
			args: ZodTuple.create(items).rest(ZodUnknown.create()),
		});
	}
	returns(returnType) {
		return new ZodFunction({
			...this._def,
			returns: returnType,
		});
	}
	implement(func) {
		const validatedFunc = this.parse(func);
		return validatedFunc;
	}
	strictImplement(func) {
		const validatedFunc = this.parse(func);
		return validatedFunc;
	}
	static create(args, returns, params) {
		return new ZodFunction({
			args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
			returns: returns || ZodUnknown.create(),
			typeName: ZodFirstPartyTypeKind.ZodFunction,
			...processCreateParams(params),
		});
	}
}

class ZodLazy extends ZodType {
	get schema() {
		return this._def.getter();
	}
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		const lazySchema = this._def.getter();
		return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
	}
}
ZodLazy.create = (getter, params) => {
	return new ZodLazy({
		getter,
		typeName: ZodFirstPartyTypeKind.ZodLazy,
		...processCreateParams(params),
	});
};

class ZodLiteral extends ZodType {
	_parse(input) {
		if (input.data !== this._def.value) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				received: ctx.data,
				code: ZodIssueCode.invalid_literal,
				expected: this._def.value,
			});
			return INVALID;
		}
		return { status: "valid", value: input.data };
	}
	get value() {
		return this._def.value;
	}
}
ZodLiteral.create = (value, params) => {
	return new ZodLiteral({
		value,
		typeName: ZodFirstPartyTypeKind.ZodLiteral,
		...processCreateParams(params),
	});
};
function createZodEnum(values, params) {
	return new ZodEnum({
		values,
		typeName: ZodFirstPartyTypeKind.ZodEnum,
		...processCreateParams(params),
	});
}

class ZodEnum extends ZodType {
	_parse(input) {
		if (typeof input.data !== "string") {
			const ctx = this._getOrReturnCtx(input);
			const expectedValues = this._def.values;
			addIssueToContext(ctx, {
				expected: util.joinValues(expectedValues),
				received: ctx.parsedType,
				code: ZodIssueCode.invalid_type,
			});
			return INVALID;
		}
		if (!this._cache) {
			this._cache = new Set(this._def.values);
		}
		if (!this._cache.has(input.data)) {
			const ctx = this._getOrReturnCtx(input);
			const expectedValues = this._def.values;
			addIssueToContext(ctx, {
				received: ctx.data,
				code: ZodIssueCode.invalid_enum_value,
				options: expectedValues,
			});
			return INVALID;
		}
		return OK(input.data);
	}
	get options() {
		return this._def.values;
	}
	get enum() {
		const enumValues = {};
		for (const val of this._def.values) {
			enumValues[val] = val;
		}
		return enumValues;
	}
	get Values() {
		const enumValues = {};
		for (const val of this._def.values) {
			enumValues[val] = val;
		}
		return enumValues;
	}
	get Enum() {
		const enumValues = {};
		for (const val of this._def.values) {
			enumValues[val] = val;
		}
		return enumValues;
	}
	extract(values, newDef = this._def) {
		return ZodEnum.create(values, {
			...this._def,
			...newDef,
		});
	}
	exclude(values, newDef = this._def) {
		return ZodEnum.create(
			this.options.filter((opt) => !values.includes(opt)),
			{
				...this._def,
				...newDef,
			},
		);
	}
}
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
	_parse(input) {
		const nativeEnumValues = util.getValidEnumValues(this._def.values);
		const ctx = this._getOrReturnCtx(input);
		if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
			const expectedValues = util.objectValues(nativeEnumValues);
			addIssueToContext(ctx, {
				expected: util.joinValues(expectedValues),
				received: ctx.parsedType,
				code: ZodIssueCode.invalid_type,
			});
			return INVALID;
		}
		if (!this._cache) {
			this._cache = new Set(util.getValidEnumValues(this._def.values));
		}
		if (!this._cache.has(input.data)) {
			const expectedValues = util.objectValues(nativeEnumValues);
			addIssueToContext(ctx, {
				received: ctx.data,
				code: ZodIssueCode.invalid_enum_value,
				options: expectedValues,
			});
			return INVALID;
		}
		return OK(input.data);
	}
	get enum() {
		return this._def.values;
	}
}
ZodNativeEnum.create = (values, params) => {
	return new ZodNativeEnum({
		values,
		typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
		...processCreateParams(params),
	});
};

class ZodPromise extends ZodType {
	unwrap() {
		return this._def.type;
	}
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.promise,
				received: ctx.parsedType,
			});
			return INVALID;
		}
		const promisified =
			ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
		return OK(
			promisified.then((data) => {
				return this._def.type.parseAsync(data, {
					path: ctx.path,
					errorMap: ctx.common.contextualErrorMap,
				});
			}),
		);
	}
}
ZodPromise.create = (schema, params) => {
	return new ZodPromise({
		type: schema,
		typeName: ZodFirstPartyTypeKind.ZodPromise,
		...processCreateParams(params),
	});
};

class ZodEffects extends ZodType {
	innerType() {
		return this._def.schema;
	}
	sourceType() {
		return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects
			? this._def.schema.sourceType()
			: this._def.schema;
	}
	_parse(input) {
		const { status: status2, ctx } = this._processInputParams(input);
		const effect = this._def.effect || null;
		const checkCtx = {
			addIssue: (arg) => {
				addIssueToContext(ctx, arg);
				if (arg.fatal) {
					status2.abort();
				} else {
					status2.dirty();
				}
			},
			get path() {
				return ctx.path;
			},
		};
		checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
		if (effect.type === "preprocess") {
			const processed = effect.transform(ctx.data, checkCtx);
			if (ctx.common.async) {
				return Promise.resolve(processed).then(async (processed2) => {
					if (status2.value === "aborted") return INVALID;
					const result = await this._def.schema._parseAsync({
						data: processed2,
						path: ctx.path,
						parent: ctx,
					});
					if (result.status === "aborted") return INVALID;
					if (result.status === "dirty") return DIRTY(result.value);
					if (status2.value === "dirty") return DIRTY(result.value);
					return result;
				});
			} else {
				if (status2.value === "aborted") return INVALID;
				const result = this._def.schema._parseSync({
					data: processed,
					path: ctx.path,
					parent: ctx,
				});
				if (result.status === "aborted") return INVALID;
				if (result.status === "dirty") return DIRTY(result.value);
				if (status2.value === "dirty") return DIRTY(result.value);
				return result;
			}
		}
		if (effect.type === "refinement") {
			const executeRefinement = (acc) => {
				const result = effect.refinement(acc, checkCtx);
				if (ctx.common.async) {
					return Promise.resolve(result);
				}
				if (result instanceof Promise) {
					throw new Error(
						"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.",
					);
				}
				return acc;
			};
			if (ctx.common.async === false) {
				const inner = this._def.schema._parseSync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx,
				});
				if (inner.status === "aborted") return INVALID;
				if (inner.status === "dirty") status2.dirty();
				executeRefinement(inner.value);
				return { status: status2.value, value: inner.value };
			} else {
				return this._def.schema
					._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
					.then((inner) => {
						if (inner.status === "aborted") return INVALID;
						if (inner.status === "dirty") status2.dirty();
						return executeRefinement(inner.value).then(() => {
							return { status: status2.value, value: inner.value };
						});
					});
			}
		}
		if (effect.type === "transform") {
			if (ctx.common.async === false) {
				const base = this._def.schema._parseSync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx,
				});
				if (!isValid(base)) return INVALID;
				const result = effect.transform(base.value, checkCtx);
				if (result instanceof Promise) {
					throw new Error(
						"Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.",
					);
				}
				return { status: status2.value, value: result };
			} else {
				return this._def.schema
					._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })
					.then((base) => {
						if (!isValid(base)) return INVALID;
						return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
							status: status2.value,
							value: result,
						}));
					});
			}
		}
		util.assertNever(effect);
	}
}
ZodEffects.create = (schema, effect, params) => {
	return new ZodEffects({
		schema,
		typeName: ZodFirstPartyTypeKind.ZodEffects,
		effect,
		...processCreateParams(params),
	});
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
	return new ZodEffects({
		schema,
		effect: { type: "preprocess", transform: preprocess },
		typeName: ZodFirstPartyTypeKind.ZodEffects,
		...processCreateParams(params),
	});
};
class ZodOptional extends ZodType {
	_parse(input) {
		const parsedType = this._getType(input);
		if (parsedType === ZodParsedType.undefined) {
			return OK(undefined);
		}
		return this._def.innerType._parse(input);
	}
	unwrap() {
		return this._def.innerType;
	}
}
ZodOptional.create = (type, params) => {
	return new ZodOptional({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodOptional,
		...processCreateParams(params),
	});
};

class ZodNullable extends ZodType {
	_parse(input) {
		const parsedType = this._getType(input);
		if (parsedType === ZodParsedType.null) {
			return OK(null);
		}
		return this._def.innerType._parse(input);
	}
	unwrap() {
		return this._def.innerType;
	}
}
ZodNullable.create = (type, params) => {
	return new ZodNullable({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodNullable,
		...processCreateParams(params),
	});
};

class ZodDefault extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		let data = ctx.data;
		if (ctx.parsedType === ZodParsedType.undefined) {
			data = this._def.defaultValue();
		}
		return this._def.innerType._parse({
			data,
			path: ctx.path,
			parent: ctx,
		});
	}
	removeDefault() {
		return this._def.innerType;
	}
}
ZodDefault.create = (type, params) => {
	return new ZodDefault({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodDefault,
		defaultValue: typeof params.default === "function" ? params.default : () => params.default,
		...processCreateParams(params),
	});
};

class ZodCatch extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		const newCtx = {
			...ctx,
			common: {
				...ctx.common,
				issues: [],
			},
		};
		const result = this._def.innerType._parse({
			data: newCtx.data,
			path: newCtx.path,
			parent: {
				...newCtx,
			},
		});
		if (isAsync2(result)) {
			return result.then((result2) => {
				return {
					status: "valid",
					value:
						result2.status === "valid"
							? result2.value
							: this._def.catchValue({
									get error() {
										return new ZodError(newCtx.common.issues);
									},
									input: newCtx.data,
								}),
				};
			});
		} else {
			return {
				status: "valid",
				value:
					result.status === "valid"
						? result.value
						: this._def.catchValue({
								get error() {
									return new ZodError(newCtx.common.issues);
								},
								input: newCtx.data,
							}),
			};
		}
	}
	removeCatch() {
		return this._def.innerType;
	}
}
ZodCatch.create = (type, params) => {
	return new ZodCatch({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodCatch,
		catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
		...processCreateParams(params),
	});
};

class ZodNaN extends ZodType {
	_parse(input) {
		const parsedType = this._getType(input);
		if (parsedType !== ZodParsedType.nan) {
			const ctx = this._getOrReturnCtx(input);
			addIssueToContext(ctx, {
				code: ZodIssueCode.invalid_type,
				expected: ZodParsedType.nan,
				received: ctx.parsedType,
			});
			return INVALID;
		}
		return { status: "valid", value: input.data };
	}
}
ZodNaN.create = (params) => {
	return new ZodNaN({
		typeName: ZodFirstPartyTypeKind.ZodNaN,
		...processCreateParams(params),
	});
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
	_parse(input) {
		const { ctx } = this._processInputParams(input);
		const data = ctx.data;
		return this._def.type._parse({
			data,
			path: ctx.path,
			parent: ctx,
		});
	}
	unwrap() {
		return this._def.type;
	}
}

class ZodPipeline extends ZodType {
	_parse(input) {
		const { status: status2, ctx } = this._processInputParams(input);
		if (ctx.common.async) {
			const handleAsync = async () => {
				const inResult = await this._def.in._parseAsync({
					data: ctx.data,
					path: ctx.path,
					parent: ctx,
				});
				if (inResult.status === "aborted") return INVALID;
				if (inResult.status === "dirty") {
					status2.dirty();
					return DIRTY(inResult.value);
				} else {
					return this._def.out._parseAsync({
						data: inResult.value,
						path: ctx.path,
						parent: ctx,
					});
				}
			};
			return handleAsync();
		} else {
			const inResult = this._def.in._parseSync({
				data: ctx.data,
				path: ctx.path,
				parent: ctx,
			});
			if (inResult.status === "aborted") return INVALID;
			if (inResult.status === "dirty") {
				status2.dirty();
				return {
					status: "dirty",
					value: inResult.value,
				};
			} else {
				return this._def.out._parseSync({
					data: inResult.value,
					path: ctx.path,
					parent: ctx,
				});
			}
		}
	}
	static create(a12, b) {
		return new ZodPipeline({
			in: a12,
			out: b,
			typeName: ZodFirstPartyTypeKind.ZodPipeline,
		});
	}
}

class ZodReadonly extends ZodType {
	_parse(input) {
		const result = this._def.innerType._parse(input);
		const freeze = (data) => {
			if (isValid(data)) {
				data.value = Object.freeze(data.value);
			}
			return data;
		};
		return isAsync2(result) ? result.then((data) => freeze(data)) : freeze(result);
	}
	unwrap() {
		return this._def.innerType;
	}
}
ZodReadonly.create = (type, params) => {
	return new ZodReadonly({
		innerType: type,
		typeName: ZodFirstPartyTypeKind.ZodReadonly,
		...processCreateParams(params),
	});
};
function cleanParams(params, data) {
	const p =
		typeof params === "function"
			? params(data)
			: typeof params === "string"
				? { message: params }
				: params;
	const p2 = typeof p === "string" ? { message: p } : p;
	return p2;
}
function custom(check2, _params = {}, fatal) {
	if (check2)
		return ZodAny.create().superRefine((data, ctx) => {
			const r2 = check2(data);
			if (r2 instanceof Promise) {
				return r2.then((r3) => {
					if (!r3) {
						const params = cleanParams(_params, data);
						const _fatal = params.fatal ?? fatal ?? true;
						ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
					}
				});
			}
			if (!r2) {
				const params = cleanParams(_params, data);
				const _fatal = params.fatal ?? fatal ?? true;
				ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
			}
			return;
		});
	return ZodAny.create();
}
var late = {
	object: ZodObject.lazycreate,
};
var ZodFirstPartyTypeKind;
(function (ZodFirstPartyTypeKind2) {
	ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
	ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
	ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
	ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
	ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
	ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
	ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
	ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
	ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
	ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
	ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
	ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
	ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
	ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
	ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
	ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
	ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
	ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
	ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
	ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
	ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
	ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
	ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
	ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
	ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
	ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
	ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
	ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
	ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
	ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
	ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
	ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
	ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
	ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
	ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
	ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (
	cls,
	params = {
		message: `Input not instance of ${cls.name}`,
	},
) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
	string: (arg) => ZodString.create({ ...arg, coerce: true }),
	number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
	boolean: (arg) =>
		ZodBoolean.create({
			...arg,
			coerce: true,
		}),
	bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
	date: (arg) => ZodDate.create({ ...arg, coerce: true }),
};
var NEVER = INVALID;
// node_modules/@scalar/themes/node_modules/@scalar/types/dist/api-reference/api-reference-plugin.js
var OpenApiExtensionSchema = exports_external.object({
	name: exports_external.string().regex(/^x-/),
	component: exports_external.unknown(),
});
var ApiReferencePluginSchema = exports_external.function().returns(
	exports_external.object({
		name: exports_external.string(),
		extensions: exports_external.array(OpenApiExtensionSchema),
	}),
);

// node_modules/@scalar/themes/node_modules/@scalar/types/dist/api-reference/helpers/migrate-theme-variables.js
var PREFIX_MIGRATIONS = [
	["--theme-", "--scalar-"],
	["--sidebar-", "--scalar-sidebar-"],
];
var LEGACY_PREFIXES = PREFIX_MIGRATIONS.map(([legacy]) => legacy);
function migrateThemeVariables(styles) {
	const hasLegacyPrefixes = LEGACY_PREFIXES.some((p) => styles.includes(p));
	if (!hasLegacyPrefixes) {
		return styles;
	}
	console.warn(
		"DEPRECATION WARNING: It looks like you're using legacy CSS variables in your custom CSS string. Please migrate them to use the updated prefixes. See https://github.com/scalar/scalar/blob/main/documentation/themes.md#theme-prefix-changes",
	);
	return PREFIX_MIGRATIONS.reduce((s, [o, n]) => s.replaceAll(o, n), styles);
}

// node_modules/@scalar/themes/node_modules/@scalar/types/dist/api-reference/api-reference-configuration.js
var themeIdEnum = exports_external.enum([
	"alternate",
	"default",
	"moon",
	"purple",
	"solarized",
	"bluePlanet",
	"deepSpace",
	"saturn",
	"kepler",
	"elysiajs",
	"fastify",
	"mars",
	"none",
]);
var searchHotKeyEnum = exports_external.enum([
	"a",
	"b",
	"c",
	"d",
	"e",
	"f",
	"g",
	"h",
	"i",
	"j",
	"k",
	"l",
	"m",
	"n",
	"o",
	"p",
	"q",
	"r",
	"s",
	"t",
	"u",
	"v",
	"w",
	"x",
	"y",
	"z",
]);
var integrationEnum = exports_external
	.enum([
		"adonisjs",
		"docusaurus",
		"dotnet",
		"elysiajs",
		"express",
		"fastapi",
		"fastify",
		"go",
		"hono",
		"html",
		"laravel",
		"litestar",
		"nestjs",
		"nextjs",
		"nitro",
		"nuxt",
		"platformatic",
		"react",
		"rust",
		"vue",
	])
	.nullable();
var specConfigurationSchema = exports_external.object({
	url: exports_external.string().optional(),
	content: exports_external
		.union([
			exports_external.string(),
			exports_external.record(exports_external.any()),
			exports_external.function().returns(exports_external.record(exports_external.any())),
			exports_external.null(),
		])
		.optional(),
	title: exports_external.string().optional(),
	slug: exports_external.string().optional(),
});
var pathRoutingSchema = exports_external.object({
	basePath: exports_external.string(),
});
var apiClientConfigurationSchema = exports_external.object({
	url: exports_external.string().optional(),
	content: exports_external
		.union([
			exports_external.string(),
			exports_external.record(exports_external.any()),
			exports_external.function().returns(exports_external.record(exports_external.any())),
			exports_external.null(),
		])
		.optional(),
	title: exports_external.string().optional(),
	slug: exports_external.string().optional(),
	spec: specConfigurationSchema.optional(),
	authentication: exports_external.any().optional(),
	baseServerURL: exports_external.string().optional(),
	hideClientButton: exports_external.boolean().optional().default(false).catch(false),
	proxyUrl: exports_external.string().optional(),
	searchHotKey: searchHotKeyEnum.optional(),
	servers: exports_external.array(exports_external.any()).optional(),
	showSidebar: exports_external.boolean().optional().default(true).catch(true),
	theme: themeIdEnum.optional().default("default").catch("default"),
	_integration: integrationEnum.optional(),
	onRequestSent: exports_external
		.function()
		.args(exports_external.string())
		.returns(exports_external.void())
		.optional(),
});
var OLD_PROXY_URL = "https://api.scalar.com/request-proxy";
var NEW_PROXY_URL = "https://proxy.scalar.com";
var _apiReferenceConfigurationSchema = apiClientConfigurationSchema.merge(
	exports_external.object({
		layout: exports_external
			.enum(["modern", "classic"])
			.optional()
			.default("modern")
			.catch("modern"),
		proxy: exports_external.string().optional(),
		plugins: exports_external.array(ApiReferencePluginSchema).optional(),
		isEditable: exports_external.boolean().optional().default(false).catch(false),
		isLoading: exports_external.boolean().optional().default(false).catch(false),
		hideModels: exports_external.boolean().optional().default(false).catch(false),
		hideDownloadButton: exports_external.boolean().optional().default(false).catch(false),
		hideTestRequestButton: exports_external.boolean().optional().default(false).catch(false),
		hideSearch: exports_external.boolean().optional().default(false).catch(false),
		darkMode: exports_external.boolean().optional(),
		forceDarkModeState: exports_external.enum(["dark", "light"]).optional(),
		hideDarkModeToggle: exports_external.boolean().optional().default(false).catch(false),
		metaData: exports_external.any().optional(),
		favicon: exports_external.string().optional(),
		hiddenClients: exports_external
			.union([
				exports_external.record(
					exports_external.union([
						exports_external.boolean(),
						exports_external.array(exports_external.string()),
					]),
				),
				exports_external.array(exports_external.string()),
				exports_external.literal(true),
			])
			.optional(),
		defaultHttpClient: exports_external
			.object({
				targetKey: exports_external.custom(),
				clientKey: exports_external.string(),
			})
			.optional(),
		customCss: exports_external.string().optional(),
		onSpecUpdate: exports_external
			.function()
			.args(exports_external.string())
			.returns(exports_external.void())
			.optional(),
		onServerChange: exports_external
			.function()
			.args(exports_external.string())
			.returns(exports_external.void())
			.optional(),
		onDocumentSelect: exports_external
			.function()
			.returns(exports_external.void().or(exports_external.void().promise()))
			.optional(),
		onLoaded: exports_external
			.function()
			.returns(exports_external.void().or(exports_external.void().promise()))
			.optional(),
		onShowMore: exports_external
			.function()
			.args(exports_external.string())
			.returns(exports_external.void().or(exports_external.void().promise()))
			.optional(),
		onSidebarClick: exports_external
			.function()
			.args(exports_external.string())
			.returns(exports_external.void().or(exports_external.void().promise()))
			.optional(),
		pathRouting: pathRoutingSchema.optional(),
		generateHeadingSlug: exports_external
			.function()
			.args(
				exports_external.object({
					slug: exports_external.string().default("headingSlug"),
				}),
			)
			.returns(exports_external.string())
			.optional(),
		generateModelSlug: exports_external
			.function()
			.args(
				exports_external.object({
					name: exports_external.string().default("modelName"),
				}),
			)
			.returns(exports_external.string())
			.optional(),
		generateTagSlug: exports_external
			.function()
			.args(
				exports_external.object({
					name: exports_external.string().default("tagName"),
				}),
			)
			.returns(exports_external.string())
			.optional(),
		generateOperationSlug: exports_external
			.function()
			.args(
				exports_external.object({
					path: exports_external.string(),
					operationId: exports_external.string().optional(),
					method: exports_external.string(),
					summary: exports_external.string().optional(),
				}),
			)
			.returns(exports_external.string())
			.optional(),
		generateWebhookSlug: exports_external
			.function()
			.args(
				exports_external.object({
					name: exports_external.string(),
					method: exports_external.string().optional(),
				}),
			)
			.returns(exports_external.string())
			.optional(),
		redirect: exports_external
			.function()
			.args(exports_external.string())
			.returns(exports_external.string().nullable().optional())
			.optional(),
		withDefaultFonts: exports_external.boolean().optional().default(true).catch(true),
		defaultOpenAllTags: exports_external.boolean().optional(),
		tagsSorter: exports_external
			.union([
				exports_external.literal("alpha"),
				exports_external
					.function()
					.args(exports_external.any(), exports_external.any())
					.returns(exports_external.number()),
			])
			.optional(),
		operationsSorter: exports_external
			.union([
				exports_external.literal("alpha"),
				exports_external.literal("method"),
				exports_external
					.function()
					.args(exports_external.any(), exports_external.any())
					.returns(exports_external.number()),
			])
			.optional(),
	}),
);
var migrateConfiguration = (_configuration) => {
	const configuration = { ..._configuration };
	if (configuration.spec?.url) {
		console.warn(
			"[DEPRECATED] You're using the deprecated 'spec.url' attribute. Remove the spec prefix and move the 'url' attribute to the top level.",
		);
		configuration.url = configuration.spec.url;
		delete configuration.spec;
	}
	if (configuration.spec?.content) {
		console.warn(
			"[DEPRECATED] You're using the deprecated 'spec.content' attribute. Remove the spec prefix and move the 'content' attribute to the top level.",
		);
		configuration.content = configuration.spec.content;
		delete configuration.spec;
	}
	if (configuration.customCss) {
		configuration.customCss = migrateThemeVariables(configuration.customCss);
	}
	if (configuration.proxy) {
		console.warn(
			"[DEPRECATED] You're using the deprecated 'proxy' attribute, rename it to 'proxyUrl' or update the package.",
		);
		if (!configuration.proxyUrl) {
			configuration.proxyUrl = configuration.proxy;
		}
		delete configuration.proxy;
	}
	if (configuration.proxyUrl === OLD_PROXY_URL) {
		console.warn(
			`[DEPRECATED] Warning: configuration.proxyUrl points to our old proxy (${OLD_PROXY_URL}).`,
		);
		console.warn(
			`[DEPRECATED] We are overwriting the value and use the new proxy URL (${NEW_PROXY_URL}) instead.`,
		);
		console.warn(
			`[DEPRECATED] Action Required: You should manually update your configuration to use the new URL (${NEW_PROXY_URL}). Read more: https://github.com/scalar/scalar`,
		);
		configuration.proxyUrl = NEW_PROXY_URL;
	}
	return configuration;
};
var apiReferenceConfigurationSchema =
	_apiReferenceConfigurationSchema.transform(migrateConfiguration);
// node_modules/@scalar/themes/node_modules/@scalar/types/dist/api-reference/html-rendering-configuration.js
var htmlRenderingConfigurationSchema = exports_external.object({
	cdn: exports_external
		.string()
		.optional()
		.default("https://cdn.jsdelivr.net/npm/@scalar/api-reference"),
	pageTitle: exports_external.string().optional().default("Scalar API Reference"),
});
// node_modules/@scalar/themes/dist/index.js
var m = {
	alternate: a,
	default: r,
	moon: a8,
	elysiajs: a4,
	fastify: a5,
	purple: a9,
	solarized: a11,
	bluePlanet: a2,
	deepSpace: a3,
	saturn: a10,
	kepler: a6,
	mars: a7,
};
var K = Object.keys(m);

// node_modules/@elysiajs/swagger/dist/index.mjs
function isSchemaObject(schema) {
	return "type" in schema || "properties" in schema || "items" in schema;
}
function isDateTimeProperty(key, schema) {
	return (
		(key === "createdAt" || key === "updatedAt") && "anyOf" in schema && Array.isArray(schema.anyOf)
	);
}
function transformDateProperties(schema) {
	if (!isSchemaObject(schema) || typeof schema !== "object" || schema === null) {
		return schema;
	}
	const newSchema = { ...schema };
	Object.entries(newSchema).forEach(([key, value]) => {
		if (isSchemaObject(value)) {
			if (isDateTimeProperty(key, value)) {
				const dateTimeFormat = value.anyOf?.find(
					(item) => isSchemaObject(item) && item.format === "date-time",
				);
				if (dateTimeFormat) {
					const dateTimeSchema = {
						type: "string",
						format: "date-time",
						default: dateTimeFormat.default,
					};
					newSchema[key] = dateTimeSchema;
				}
			} else {
				newSchema[key] = transformDateProperties(value);
			}
		}
	});
	return newSchema;
}
var SwaggerUIRender = (info, version, theme, stringifiedSwaggerOptions, autoDarkMode) => {
	const swaggerOptions = JSON.parse(stringifiedSwaggerOptions);
	if (swaggerOptions.components && swaggerOptions.components.schemas) {
		swaggerOptions.components.schemas = Object.fromEntries(
			Object.entries(swaggerOptions.components.schemas).map(([key, schema]) => [
				key,
				transformDateProperties(schema),
			]),
		);
	}
	const transformedStringifiedSwaggerOptions = JSON.stringify(swaggerOptions);
	return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>${info.title}</title>
    <meta
        name="description"
        content="${info.description}"
    />
    <meta
        name="og:description"
        content="${info.description}"
    />
    ${
			autoDarkMode && typeof theme === "string"
				? `
    <style>
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #222;
                color: #faf9a;
            }
            .swagger-ui {
                filter: invert(92%) hue-rotate(180deg);
            }

            .swagger-ui .microlight {
                filter: invert(100%) hue-rotate(180deg);
            }
        }
    </style>`
				: ""
		}
    ${
			typeof theme === "string"
				? `<link rel="stylesheet" href="${theme}" />`
				: `<link rel="stylesheet" media="(prefers-color-scheme: light)" href="${theme.light}" />
<link rel="stylesheet" media="(prefers-color-scheme: dark)" href="${theme.dark}" />`
		}
</head>
<body>
    <div id="swagger-ui"></div>
    <script src="https://unpkg.com/swagger-ui-dist@${version}/swagger-ui-bundle.js" crossorigin></script>
    <script>
        window.onload = () => {
            window.ui = SwaggerUIBundle(${transformedStringifiedSwaggerOptions});
        };
    </script>
</body>
</html>`;
};
var ScalarRender = (info, version, config, cdn) => `<!doctype html>
<html>
  <head>
    <title>${info.title}</title>
    <meta
        name="description"
        content="${info.description}"
    />
    <meta
        name="og:description"
        content="${info.description}"
    />
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1" />
    <style>
      body {
        margin: 0;
      }
    </style>
    <style>
      ${config.customCss ?? a4}
    </style>
  </head>
  <body>
    <script
      id="api-reference"
      data-url="${config.spec?.url}"
      data-configuration='${JSON.stringify(config)}'
    >
    </script>
    <script src="${cdn ? cdn : `https://cdn.jsdelivr.net/npm/@scalar/api-reference@${version}/dist/browser/standalone.min.js`}" crossorigin></script>
  </body>
</html>`;
var TransformKind2 = Symbol.for("TypeBox.Transform");
var ReadonlyKind2 = Symbol.for("TypeBox.Readonly");
var OptionalKind2 = Symbol.for("TypeBox.Optional");
var Hint3 = Symbol.for("TypeBox.Hint");
var Kind2 = Symbol.for("TypeBox.Kind");
var toOpenAPIPath = (path2) =>
	path2
		.split("/")
		.map((x) => {
			if (x.startsWith(":")) {
				x = x.slice(1, x.length);
				if (x.endsWith("?")) x = x.slice(0, -1);
				x = `{${x}}`;
			}
			return x;
		})
		.join("/");
var mapProperties = (name, schema, models) => {
	if (schema === undefined) return [];
	if (typeof schema === "string")
		if (schema in models) schema = models[schema];
		else throw new Error(`Can't find model ${schema}`);
	return Object.entries(schema?.properties ?? []).map(([key, value]) => {
		const { type: valueType = undefined, description, examples, ...schemaKeywords } = value;
		return {
			description,
			examples,
			schema: { type: valueType, ...schemaKeywords },
			in: name,
			name: key,
			required: schema.required?.includes(key) ?? false,
		};
	});
};
var mapTypesResponse = (types2, schema) => {
	if (typeof schema === "object" && ["void", "undefined", "null"].includes(schema.type)) return;
	const responses = {};
	for (const type of types2) {
		responses[type] = {
			schema:
				typeof schema === "string"
					? {
							$ref: `#/components/schemas/${schema}`,
						}
					: "$ref" in schema && Kind2 in schema && schema[Kind2] === "Ref"
						? {
								...schema,
								$ref: `#/components/schemas/${schema.$ref}`,
							}
						: replaceSchemaType(
								{ ...schema },
								{
									from: t.Ref(""),
									to: ({ $ref, ...options }) => {
										if (!$ref.startsWith("#/components/schemas/"))
											return t.Ref(`#/components/schemas/${$ref}`, options);
										return t.Ref($ref, options);
									},
								},
							),
		};
	}
	return responses;
};
var capitalize = (word) => word.charAt(0).toUpperCase() + word.slice(1);
var generateOperationId = (method, paths) => {
	let operationId = method.toLowerCase();
	if (paths === "/") return operationId + "Index";
	for (const path2 of paths.split("/")) {
		if (path2.charCodeAt(0) === 123) {
			operationId += "By" + capitalize(path2.slice(1, -1));
		} else {
			operationId += capitalize(path2);
		}
	}
	return operationId;
};
var cloneHook = (hook) => {
	if (!hook) return;
	if (typeof hook === "string") return hook;
	if (Array.isArray(hook)) return [...hook];
	return { ...hook };
};
var registerSchemaPath = ({ schema, path: path2, method, hook, models }) => {
	hook = cloneHook(hook);
	if (hook.parse && !Array.isArray(hook.parse)) hook.parse = [hook.parse];
	let contentType = hook.parse
		?.map((x) => {
			switch (typeof x) {
				case "string":
					return x;
				case "object":
					if (x && typeof x?.fn !== "string") return;
					switch (x?.fn) {
						case "json":
						case "application/json":
							return "application/json";
						case "text":
						case "text/plain":
							return "text/plain";
						case "urlencoded":
						case "application/x-www-form-urlencoded":
							return "application/x-www-form-urlencoded";
						case "arrayBuffer":
						case "application/octet-stream":
							return "application/octet-stream";
						case "formdata":
						case "multipart/form-data":
							return "multipart/form-data";
					}
			}
		})
		.filter((x) => x !== undefined);
	if (!contentType || contentType.length === 0)
		contentType = ["application/json", "multipart/form-data", "text/plain"];
	path2 = toOpenAPIPath(path2);
	const contentTypes =
		typeof contentType === "string" ? [contentType] : (contentType ?? ["application/json"]);
	const bodySchema = cloneHook(hook?.body);
	const paramsSchema = cloneHook(hook?.params);
	const headerSchema = cloneHook(hook?.headers);
	const querySchema = cloneHook(hook?.query);
	let responseSchema = cloneHook(hook?.response);
	if (typeof responseSchema === "object") {
		if (Kind2 in responseSchema) {
			const { type, properties, required, additionalProperties, patternProperties, $ref, ...rest } =
				responseSchema;
			responseSchema = {
				200: {
					...rest,
					description: rest.description,
					content: mapTypesResponse(
						contentTypes,
						type === "object" || type === "array"
							? {
									type,
									properties,
									patternProperties,
									items: responseSchema.items,
									required,
								}
							: responseSchema,
					),
				},
			};
		} else {
			Object.entries(responseSchema).forEach(([key, value]) => {
				if (typeof value === "string") {
					if (!models[value]) return;
					const {
						type,
						properties,
						required,
						additionalProperties: _1,
						patternProperties: _2,
						...rest
					} = models[value];
					responseSchema[key] = {
						...rest,
						description: rest.description,
						content: mapTypesResponse(contentTypes, value),
					};
				} else {
					const { type, properties, required, additionalProperties, patternProperties, ...rest } =
						value;
					responseSchema[key] = {
						...rest,
						description: rest.description,
						content: mapTypesResponse(
							contentTypes,
							type === "object" || type === "array"
								? {
										type,
										properties,
										patternProperties,
										items: value.items,
										required,
									}
								: value,
						),
					};
				}
			});
		}
	} else if (typeof responseSchema === "string") {
		if (!(responseSchema in models)) return;
		const {
			type,
			properties,
			required,
			$ref,
			additionalProperties: _1,
			patternProperties: _2,
			...rest
		} = models[responseSchema];
		responseSchema = {
			200: {
				...rest,
				content: mapTypesResponse(contentTypes, responseSchema),
			},
		};
	}
	const parameters = [
		...mapProperties("header", headerSchema, models),
		...mapProperties("path", paramsSchema, models),
		...mapProperties("query", querySchema, models),
	];
	schema[path2] = {
		...(schema[path2] ? schema[path2] : {}),
		[method.toLowerCase()]: {
			...(headerSchema || paramsSchema || querySchema || bodySchema ? { parameters } : {}),
			...(responseSchema
				? {
						responses: responseSchema,
					}
				: {}),
			operationId: hook?.detail?.operationId ?? generateOperationId(method, path2),
			...hook?.detail,
			...(bodySchema
				? {
						requestBody: {
							required: true,
							content: mapTypesResponse(
								contentTypes,
								typeof bodySchema === "string"
									? {
											$ref: `#/components/schemas/${bodySchema}`,
										}
									: bodySchema,
							),
						},
					}
				: null),
		},
	};
};
var filterPaths = (paths, { excludeStaticFile = true, exclude = [] }) => {
	const newPaths = {};
	for (const [key, value] of Object.entries(paths))
		if (
			!exclude.some((x) => {
				if (typeof x === "string") return key === x;
				return x.test(key);
			}) &&
			!key.includes("*") &&
			(excludeStaticFile ? !key.includes(".") : true)
		) {
			Object.keys(value).forEach((method) => {
				const schema = value[method];
				if (key.includes("{")) {
					if (!schema.parameters) schema.parameters = [];
					schema.parameters = [
						...key
							.split("/")
							.filter(
								(x) =>
									x.startsWith("{") &&
									!schema.parameters.find(
										(params) => params.in === "path" && params.name === x.slice(1, x.length - 1),
									),
							)
							.map((x) => ({
								schema: { type: "string" },
								in: "path",
								name: x.slice(1, x.length - 1),
								required: true,
							})),
						...schema.parameters,
					];
				}
				if (!schema.responses)
					schema.responses = {
						200: {},
					};
			});
			newPaths[key] = value;
		}
	return newPaths;
};
var swagger = ({
	provider = "scalar",
	scalarVersion = "latest",
	scalarCDN = "",
	scalarConfig = {},
	documentation = {},
	version = "5.9.0",
	excludeStaticFile = true,
	path: path2 = "/swagger",
	specPath = `${path2}/json`,
	exclude = [],
	swaggerOptions = {},
	theme = `https://unpkg.com/swagger-ui-dist@${version}/swagger-ui.css`,
	autoDarkMode = true,
	excludeMethods = ["OPTIONS"],
	excludeTags = [],
} = {}) => {
	const schema = {};
	let totalRoutes = 0;
	if (!version) version = `https://unpkg.com/swagger-ui-dist@${version}/swagger-ui.css`;
	const info = {
		title: "Elysia Documentation",
		description: "Development documentation",
		version: "0.0.0",
		...documentation.info,
	};
	const relativePath = specPath.startsWith("/") ? specPath.slice(1) : specPath;
	const app = new Elysia({ name: "@elysiajs/swagger" });
	const page = new Response(
		provider === "swagger-ui"
			? SwaggerUIRender(
					info,
					version,
					theme,
					JSON.stringify(
						{
							url: relativePath,
							dom_id: "#swagger-ui",
							...swaggerOptions,
						},
						(_2, value) => (typeof value === "function" ? undefined : value),
					),
					autoDarkMode,
				)
			: ScalarRender(
					info,
					scalarVersion,
					{
						spec: {
							url: relativePath,
							...scalarConfig.spec,
						},
						...scalarConfig,
						_integration: "elysiajs",
					},
					scalarCDN,
				),
		{
			headers: {
				"content-type": "text/html; charset=utf8",
			},
		},
	);
	app
		.get(path2, page, {
			detail: {
				hide: true,
			},
		})
		.get(
			specPath,
			function openAPISchema() {
				const routes = app.getGlobalRoutes();
				if (routes.length !== totalRoutes) {
					const ALLOWED_METHODS = [
						"GET",
						"PUT",
						"POST",
						"DELETE",
						"OPTIONS",
						"HEAD",
						"PATCH",
						"TRACE",
					];
					totalRoutes = routes.length;
					routes.forEach((route) => {
						if (route.hooks?.detail?.hide === true) return;
						if (excludeMethods.includes(route.method)) return;
						if (ALLOWED_METHODS.includes(route.method) === false && route.method !== "ALL") return;
						if (route.method === "ALL")
							ALLOWED_METHODS.forEach((method) => {
								registerSchemaPath({
									schema,
									hook: route.hooks,
									method,
									path: route.path,
									models: app.getGlobalDefinitions?.().type,
									contentType: route.hooks.type,
								});
							});
						else
							registerSchemaPath({
								schema,
								hook: route.hooks,
								method: route.method,
								path: route.path,
								models: app.getGlobalDefinitions?.().type,
								contentType: route.hooks.type,
							});
					});
				}
				return {
					openapi: "3.0.3",
					...{
						...documentation,
						tags: documentation.tags?.filter((tag) => !excludeTags?.includes(tag?.name)),
						info: {
							title: "Elysia Documentation",
							description: "Development documentation",
							version: "0.0.0",
							...documentation.info,
						},
					},
					paths: {
						...filterPaths(schema, {
							excludeStaticFile,
							exclude: Array.isArray(exclude) ? exclude : [exclude],
						}),
						...documentation.paths,
					},
					components: {
						...documentation.components,
						schemas: {
							...app.getGlobalDefinitions?.().type,
							...documentation.components?.schemas,
						},
					},
				};
			},
			{
				detail: {
					hide: true,
				},
			},
		);
	return app;
};

// node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
	return function wrap() {
		return fn.apply(thisArg, arguments);
	};
}

// node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var { iterator, toStringTag } = Symbol;
var kindOf = ((cache) => (thing) => {
	const str = toString.call(thing);
	return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));
var kindOfTest = (type) => {
	type = type.toLowerCase();
	return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
	return (
		val !== null &&
		!isUndefined(val) &&
		val.constructor !== null &&
		!isUndefined(val.constructor) &&
		isFunction(val.constructor.isBuffer) &&
		val.constructor.isBuffer(val)
	);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
	let result;
	if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
		result = ArrayBuffer.isView(val);
	} else {
		result = val && val.buffer && isArrayBuffer(val.buffer);
	}
	return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject2 = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
	if (kindOf(val) !== "object") {
		return false;
	}
	const prototype = getPrototypeOf(val);
	return (
		(prototype === null ||
			prototype === Object.prototype ||
			Object.getPrototypeOf(prototype) === null) &&
		!(toStringTag in val) &&
		!(iterator in val)
	);
};
var isEmptyObject = (val) => {
	if (!isObject2(val) || isBuffer(val)) {
		return false;
	}
	try {
		return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
	} catch (e) {
		return false;
	}
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject2(val) && isFunction(val.pipe);
var isFormData = (thing) => {
	let kind;
	return (
		thing &&
		((typeof FormData === "function" && thing instanceof FormData) ||
			(isFunction(thing.append) &&
				((kind = kindOf(thing)) === "formdata" ||
					(kind === "object" &&
						isFunction(thing.toString) &&
						thing.toString() === "[object FormData]"))))
	);
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = [
	"ReadableStream",
	"Request",
	"Response",
	"Headers",
].map(kindOfTest);
var trim = (str) => (str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""));
function forEach(obj, fn, { allOwnKeys = false } = {}) {
	if (obj === null || typeof obj === "undefined") {
		return;
	}
	let i;
	let l2;
	if (typeof obj !== "object") {
		obj = [obj];
	}
	if (isArray(obj)) {
		for (i = 0, l2 = obj.length; i < l2; i++) {
			fn.call(null, obj[i], i, obj);
		}
	} else {
		if (isBuffer(obj)) {
			return;
		}
		const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
		const len = keys.length;
		let key;
		for (i = 0; i < len; i++) {
			key = keys[i];
			fn.call(null, obj[key], key, obj);
		}
	}
}
function findKey(obj, key) {
	if (isBuffer(obj)) {
		return null;
	}
	key = key.toLowerCase();
	const keys = Object.keys(obj);
	let i = keys.length;
	let _key;
	while (i-- > 0) {
		_key = keys[i];
		if (key === _key.toLowerCase()) {
			return _key;
		}
	}
	return null;
}
var _global = (() => {
	if (typeof globalThis !== "undefined") return globalThis;
	return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
	const { caseless, skipUndefined } = (isContextDefined(this) && this) || {};
	const result = {};
	const assignValue = (val, key) => {
		const targetKey = (caseless && findKey(result, key)) || key;
		if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
			result[targetKey] = merge(result[targetKey], val);
		} else if (isPlainObject(val)) {
			result[targetKey] = merge({}, val);
		} else if (isArray(val)) {
			result[targetKey] = val.slice();
		} else if (!skipUndefined || !isUndefined(val)) {
			result[targetKey] = val;
		}
	};
	for (let i = 0, l2 = arguments.length; i < l2; i++) {
		arguments[i] && forEach(arguments[i], assignValue);
	}
	return result;
}
var extend = (a12, b, thisArg, { allOwnKeys } = {}) => {
	forEach(
		b,
		(val, key) => {
			if (thisArg && isFunction(val)) {
				a12[key] = bind(val, thisArg);
			} else {
				a12[key] = val;
			}
		},
		{ allOwnKeys },
	);
	return a12;
};
var stripBOM = (content) => {
	if (content.charCodeAt(0) === 65279) {
		content = content.slice(1);
	}
	return content;
};
var inherits = (constructor, superConstructor, props, descriptors) => {
	constructor.prototype = Object.create(superConstructor.prototype, descriptors);
	constructor.prototype.constructor = constructor;
	Object.defineProperty(constructor, "super", {
		value: superConstructor.prototype,
	});
	props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
	let props;
	let i;
	let prop;
	const merged = {};
	destObj = destObj || {};
	if (sourceObj == null) return destObj;
	do {
		props = Object.getOwnPropertyNames(sourceObj);
		i = props.length;
		while (i-- > 0) {
			prop = props[i];
			if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
				destObj[prop] = sourceObj[prop];
				merged[prop] = true;
			}
		}
		sourceObj = filter !== false && getPrototypeOf(sourceObj);
	} while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
	return destObj;
};
var endsWith = (str, searchString, position) => {
	str = String(str);
	if (position === undefined || position > str.length) {
		position = str.length;
	}
	position -= searchString.length;
	const lastIndex = str.indexOf(searchString, position);
	return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
	if (!thing) return null;
	if (isArray(thing)) return thing;
	let i = thing.length;
	if (!isNumber(i)) return null;
	const arr = new Array(i);
	while (i-- > 0) {
		arr[i] = thing[i];
	}
	return arr;
};
var isTypedArray = ((TypedArray) => {
	return (thing) => {
		return TypedArray && thing instanceof TypedArray;
	};
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
	const generator = obj && obj[iterator];
	const _iterator = generator.call(obj);
	let result;
	while ((result = _iterator.next()) && !result.done) {
		const pair = result.value;
		fn.call(obj, pair[0], pair[1]);
	}
};
var matchAll = (regExp, str) => {
	let matches;
	const arr = [];
	while ((matches = regExp.exec(str)) !== null) {
		arr.push(matches);
	}
	return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
	return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m2, p1, p2) {
		return p1.toUpperCase() + p2;
	});
};
var hasOwnProperty = (
	({ hasOwnProperty: hasOwnProperty2 }) =>
	(obj, prop) =>
		hasOwnProperty2.call(obj, prop)
)(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
	const descriptors = Object.getOwnPropertyDescriptors(obj);
	const reducedDescriptors = {};
	forEach(descriptors, (descriptor, name) => {
		let ret;
		if ((ret = reducer(descriptor, name, obj)) !== false) {
			reducedDescriptors[name] = ret || descriptor;
		}
	});
	Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
	reduceDescriptors(obj, (descriptor, name) => {
		if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
			return false;
		}
		const value = obj[name];
		if (!isFunction(value)) return;
		descriptor.enumerable = false;
		if ("writable" in descriptor) {
			descriptor.writable = false;
			return;
		}
		if (!descriptor.set) {
			descriptor.set = () => {
				throw Error("Can not rewrite read-only method '" + name + "'");
			};
		}
	});
};
var toObjectSet = (arrayOrString, delimiter) => {
	const obj = {};
	const define2 = (arr) => {
		arr.forEach((value) => {
			obj[value] = true;
		});
	};
	isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
	return obj;
};
var noop = () => {};
var toFiniteNumber = (value, defaultValue) => {
	return value != null && Number.isFinite((value = +value)) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
	return !!(
		thing &&
		isFunction(thing.append) &&
		thing[toStringTag] === "FormData" &&
		thing[iterator]
	);
}
var toJSONObject = (obj) => {
	const stack = new Array(10);
	const visit = (source, i) => {
		if (isObject2(source)) {
			if (stack.indexOf(source) >= 0) {
				return;
			}
			if (isBuffer(source)) {
				return source;
			}
			if (!("toJSON" in source)) {
				stack[i] = source;
				const target = isArray(source) ? [] : {};
				forEach(source, (value, key) => {
					const reducedValue = visit(value, i + 1);
					!isUndefined(reducedValue) && (target[key] = reducedValue);
				});
				stack[i] = undefined;
				return target;
			}
		}
		return source;
	};
	return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) =>
	thing &&
	(isObject2(thing) || isFunction(thing)) &&
	isFunction(thing.then) &&
	isFunction(thing.catch);
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
	if (setImmediateSupported) {
		return setImmediate;
	}
	return postMessageSupported
		? ((token, callbacks) => {
				_global.addEventListener(
					"message",
					({ source, data }) => {
						if (source === _global && data === token) {
							callbacks.length && callbacks.shift()();
						}
					},
					false,
				);
				return (cb) => {
					callbacks.push(cb);
					_global.postMessage(token, "*");
				};
			})(`axios@${Math.random()}`, [])
		: (cb) => setTimeout(cb);
})(typeof setImmediate === "function", isFunction(_global.postMessage));
var asap =
	typeof queueMicrotask !== "undefined"
		? queueMicrotask.bind(_global)
		: (typeof process !== "undefined" && process.nextTick) || _setImmediate;
var isIterable = (thing) => thing != null && isFunction(thing[iterator]);
var utils_default = {
	isArray,
	isArrayBuffer,
	isBuffer,
	isFormData,
	isArrayBufferView,
	isString,
	isNumber,
	isBoolean,
	isObject: isObject2,
	isPlainObject,
	isEmptyObject,
	isReadableStream,
	isRequest,
	isResponse,
	isHeaders,
	isUndefined,
	isDate,
	isFile,
	isBlob,
	isRegExp,
	isFunction,
	isStream,
	isURLSearchParams,
	isTypedArray,
	isFileList,
	forEach,
	merge,
	extend,
	trim,
	stripBOM,
	inherits,
	toFlatObject,
	kindOf,
	kindOfTest,
	endsWith,
	toArray,
	forEachEntry,
	matchAll,
	isHTMLForm,
	hasOwnProperty,
	hasOwnProp: hasOwnProperty,
	reduceDescriptors,
	freezeMethods,
	toObjectSet,
	toCamelCase,
	noop,
	toFiniteNumber,
	findKey,
	global: _global,
	isContextDefined,
	isSpecCompliantForm,
	toJSONObject,
	isAsyncFn,
	isThenable,
	setImmediate: _setImmediate,
	asap,
	isIterable,
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request, response) {
	Error.call(this);
	if (Error.captureStackTrace) {
		Error.captureStackTrace(this, this.constructor);
	} else {
		this.stack = new Error().stack;
	}
	this.message = message;
	this.name = "AxiosError";
	code && (this.code = code);
	config && (this.config = config);
	request && (this.request = request);
	if (response) {
		this.response = response;
		this.status = response.status ? response.status : null;
	}
}
utils_default.inherits(AxiosError, Error, {
	toJSON: function toJSON() {
		return {
			message: this.message,
			name: this.name,
			description: this.description,
			number: this.number,
			fileName: this.fileName,
			lineNumber: this.lineNumber,
			columnNumber: this.columnNumber,
			stack: this.stack,
			config: utils_default.toJSONObject(this.config),
			code: this.code,
			status: this.status,
		};
	},
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
	"ERR_BAD_OPTION_VALUE",
	"ERR_BAD_OPTION",
	"ECONNABORTED",
	"ETIMEDOUT",
	"ERR_NETWORK",
	"ERR_FR_TOO_MANY_REDIRECTS",
	"ERR_DEPRECATED",
	"ERR_BAD_RESPONSE",
	"ERR_BAD_REQUEST",
	"ERR_CANCELED",
	"ERR_NOT_SUPPORT",
	"ERR_INVALID_URL",
].forEach((code) => {
	descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
	const axiosError = Object.create(prototype);
	utils_default.toFlatObject(
		error,
		axiosError,
		function filter(obj) {
			return obj !== Error.prototype;
		},
		(prop) => {
			return prop !== "isAxiosError";
		},
	);
	const msg = error && error.message ? error.message : "Error";
	const errCode = code == null && error ? error.code : code;
	AxiosError.call(axiosError, msg, errCode, config, request, response);
	if (error && axiosError.cause == null) {
		Object.defineProperty(axiosError, "cause", { value: error, configurable: true });
	}
	axiosError.name = (error && error.name) || "Error";
	customProps && Object.assign(axiosError, customProps);
	return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/platform/node/classes/FormData.js
var import_form_data = __toESM(require_form_data(), 1);
var FormData_default = import_form_data.default;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
	return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
	return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path2, key, dots) {
	if (!path2) return key;
	return path2
		.concat(key)
		.map(function each(token, i) {
			token = removeBrackets(token);
			return !dots && i ? "[" + token + "]" : token;
		})
		.join(dots ? "." : "");
}
function isFlatArray(arr) {
	return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
	return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
	if (!utils_default.isObject(obj)) {
		throw new TypeError("target must be an object");
	}
	formData = formData || new (FormData_default || FormData)();
	options = utils_default.toFlatObject(
		options,
		{
			metaTokens: true,
			dots: false,
			indexes: false,
		},
		false,
		function defined(option, source) {
			return !utils_default.isUndefined(source[option]);
		},
	);
	const metaTokens = options.metaTokens;
	const visitor = options.visitor || defaultVisitor;
	const dots = options.dots;
	const indexes = options.indexes;
	const _Blob = options.Blob || (typeof Blob !== "undefined" && Blob);
	const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
	if (!utils_default.isFunction(visitor)) {
		throw new TypeError("visitor must be a function");
	}
	function convertValue(value) {
		if (value === null) return "";
		if (utils_default.isDate(value)) {
			return value.toISOString();
		}
		if (utils_default.isBoolean(value)) {
			return value.toString();
		}
		if (!useBlob && utils_default.isBlob(value)) {
			throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
		}
		if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
			return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
		}
		return value;
	}
	function defaultVisitor(value, key, path2) {
		let arr = value;
		if (value && !path2 && typeof value === "object") {
			if (utils_default.endsWith(key, "{}")) {
				key = metaTokens ? key : key.slice(0, -2);
				value = JSON.stringify(value);
			} else if (
				(utils_default.isArray(value) && isFlatArray(value)) ||
				((utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) &&
					(arr = utils_default.toArray(value)))
			) {
				key = removeBrackets(key);
				arr.forEach(function each(el, index) {
					!(utils_default.isUndefined(el) || el === null) &&
						formData.append(
							indexes === true
								? renderKey([key], index, dots)
								: indexes === null
									? key
									: key + "[]",
							convertValue(el),
						);
				});
				return false;
			}
		}
		if (isVisitable(value)) {
			return true;
		}
		formData.append(renderKey(path2, key, dots), convertValue(value));
		return false;
	}
	const stack = [];
	const exposedHelpers = Object.assign(predicates, {
		defaultVisitor,
		convertValue,
		isVisitable,
	});
	function build(value, path2) {
		if (utils_default.isUndefined(value)) return;
		if (stack.indexOf(value) !== -1) {
			throw Error("Circular reference detected in " + path2.join("."));
		}
		stack.push(value);
		utils_default.forEach(value, function each(el, key) {
			const result =
				!(utils_default.isUndefined(el) || el === null) &&
				visitor.call(
					formData,
					el,
					utils_default.isString(key) ? key.trim() : key,
					path2,
					exposedHelpers,
				);
			if (result === true) {
				build(el, path2 ? path2.concat(key) : [key]);
			}
		});
		stack.pop();
	}
	if (!utils_default.isObject(obj)) {
		throw new TypeError("data must be an object");
	}
	build(obj);
	return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode2(str) {
	const charMap = {
		"!": "%21",
		"'": "%27",
		"(": "%28",
		")": "%29",
		"~": "%7E",
		"%20": "+",
		"%00": "\x00",
	};
	return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
		return charMap[match];
	});
}
function AxiosURLSearchParams(params, options) {
	this._pairs = [];
	params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
	this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder2) {
	const _encode = encoder2
		? function (value) {
				return encoder2.call(this, value, encode2);
			}
		: encode2;
	return this._pairs
		.map(function each(pair) {
			return _encode(pair[0]) + "=" + _encode(pair[1]);
		}, "")
		.join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode3(val) {
	return encodeURIComponent(val)
		.replace(/%3A/gi, ":")
		.replace(/%24/g, "$")
		.replace(/%2C/gi, ",")
		.replace(/%20/g, "+");
}
function buildURL(url, params, options) {
	if (!params) {
		return url;
	}
	const _encode = (options && options.encode) || encode3;
	if (utils_default.isFunction(options)) {
		options = {
			serialize: options,
		};
	}
	const serializeFn = options && options.serialize;
	let serializedParams;
	if (serializeFn) {
		serializedParams = serializeFn(params, options);
	} else {
		serializedParams = utils_default.isURLSearchParams(params)
			? params.toString()
			: new AxiosURLSearchParams_default(params, options).toString(_encode);
	}
	if (serializedParams) {
		const hashmarkIndex = url.indexOf("#");
		if (hashmarkIndex !== -1) {
			url = url.slice(0, hashmarkIndex);
		}
		url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
	}
	return url;
}

// node_modules/axios/lib/core/InterceptorManager.js
class InterceptorManager {
	constructor() {
		this.handlers = [];
	}
	use(fulfilled, rejected, options) {
		this.handlers.push({
			fulfilled,
			rejected,
			synchronous: options ? options.synchronous : false,
			runWhen: options ? options.runWhen : null,
		});
		return this.handlers.length - 1;
	}
	eject(id) {
		if (this.handlers[id]) {
			this.handlers[id] = null;
		}
	}
	clear() {
		if (this.handlers) {
			this.handlers = [];
		}
	}
	forEach(fn) {
		utils_default.forEach(this.handlers, function forEachHandler(h) {
			if (h !== null) {
				fn(h);
			}
		});
	}
}
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
	silentJSONParsing: true,
	forcedJSONParsing: true,
	clarifyTimeoutError: false,
};

// node_modules/axios/lib/platform/node/index.js
import crypto2 from "crypto";

// node_modules/axios/lib/platform/node/classes/URLSearchParams.js
import url from "url";
var URLSearchParams_default = url.URLSearchParams;

// node_modules/axios/lib/platform/node/index.js
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
	DIGIT,
	ALPHA,
	ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT,
};
var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
	let str = "";
	const { length } = alphabet;
	const randomValues = new Uint32Array(size);
	crypto2.randomFillSync(randomValues);
	for (let i = 0; i < size; i++) {
		str += alphabet[randomValues[i] % length];
	}
	return str;
};
var node_default = {
	isNode: true,
	classes: {
		URLSearchParams: URLSearchParams_default,
		FormData: FormData_default,
		Blob: (typeof Blob !== "undefined" && Blob) || null,
	},
	ALPHABET,
	generateString,
	protocols: ["http", "https", "file", "data"],
};

// node_modules/axios/lib/platform/common/utils.js
var exports_utils = {};
__export(exports_utils, {
	origin: () => origin,
	navigator: () => _navigator,
	hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
	hasStandardBrowserEnv: () => hasStandardBrowserEnv,
	hasBrowserEnv: () => hasBrowserEnv,
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = (typeof navigator === "object" && navigator) || undefined;
var hasStandardBrowserEnv =
	hasBrowserEnv &&
	(!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = (() => {
	return (
		typeof WorkerGlobalScope !== "undefined" &&
		self instanceof WorkerGlobalScope &&
		typeof self.importScripts === "function"
	);
})();
var origin = (hasBrowserEnv && window.location.href) || "http://localhost";

// node_modules/axios/lib/platform/index.js
var platform_default = {
	...exports_utils,
	...node_default,
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
	return toFormData_default(data, new platform_default.classes.URLSearchParams(), {
		visitor: function (value, key, path2, helpers) {
			if (platform_default.isNode && utils_default.isBuffer(value)) {
				this.append(key, value.toString("base64"));
				return false;
			}
			return helpers.defaultVisitor.apply(this, arguments);
		},
		...options,
	});
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
	return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
		return match[0] === "[]" ? "" : match[1] || match[0];
	});
}
function arrayToObject(arr) {
	const obj = {};
	const keys = Object.keys(arr);
	let i;
	const len = keys.length;
	let key;
	for (i = 0; i < len; i++) {
		key = keys[i];
		obj[key] = arr[key];
	}
	return obj;
}
function formDataToJSON(formData) {
	function buildPath(path2, value, target, index) {
		let name = path2[index++];
		if (name === "__proto__") return true;
		const isNumericKey = Number.isFinite(+name);
		const isLast = index >= path2.length;
		name = !name && utils_default.isArray(target) ? target.length : name;
		if (isLast) {
			if (utils_default.hasOwnProp(target, name)) {
				target[name] = [target[name], value];
			} else {
				target[name] = value;
			}
			return !isNumericKey;
		}
		if (!target[name] || !utils_default.isObject(target[name])) {
			target[name] = [];
		}
		const result = buildPath(path2, value, target[name], index);
		if (result && utils_default.isArray(target[name])) {
			target[name] = arrayToObject(target[name]);
		}
		return !isNumericKey;
	}
	if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
		const obj = {};
		utils_default.forEachEntry(formData, (name, value) => {
			buildPath(parsePropPath(name), value, obj, 0);
		});
		return obj;
	}
	return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder2) {
	if (utils_default.isString(rawValue)) {
		try {
			(parser || JSON.parse)(rawValue);
			return utils_default.trim(rawValue);
		} catch (e) {
			if (e.name !== "SyntaxError") {
				throw e;
			}
		}
	}
	return (encoder2 || JSON.stringify)(rawValue);
}
var defaults = {
	transitional: transitional_default,
	adapter: ["xhr", "http", "fetch"],
	transformRequest: [
		function transformRequest(data, headers) {
			const contentType = headers.getContentType() || "";
			const hasJSONContentType = contentType.indexOf("application/json") > -1;
			const isObjectPayload = utils_default.isObject(data);
			if (isObjectPayload && utils_default.isHTMLForm(data)) {
				data = new FormData(data);
			}
			const isFormData2 = utils_default.isFormData(data);
			if (isFormData2) {
				return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
			}
			if (
				utils_default.isArrayBuffer(data) ||
				utils_default.isBuffer(data) ||
				utils_default.isStream(data) ||
				utils_default.isFile(data) ||
				utils_default.isBlob(data) ||
				utils_default.isReadableStream(data)
			) {
				return data;
			}
			if (utils_default.isArrayBufferView(data)) {
				return data.buffer;
			}
			if (utils_default.isURLSearchParams(data)) {
				headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
				return data.toString();
			}
			let isFileList2;
			if (isObjectPayload) {
				if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
					return toURLEncodedForm(data, this.formSerializer).toString();
				}
				if (
					(isFileList2 = utils_default.isFileList(data)) ||
					contentType.indexOf("multipart/form-data") > -1
				) {
					const _FormData = this.env && this.env.FormData;
					return toFormData_default(
						isFileList2 ? { "files[]": data } : data,
						_FormData && new _FormData(),
						this.formSerializer,
					);
				}
			}
			if (isObjectPayload || hasJSONContentType) {
				headers.setContentType("application/json", false);
				return stringifySafely(data);
			}
			return data;
		},
	],
	transformResponse: [
		function transformResponse(data) {
			const transitional = this.transitional || defaults.transitional;
			const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
			const JSONRequested = this.responseType === "json";
			if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
				return data;
			}
			if (
				data &&
				utils_default.isString(data) &&
				((forcedJSONParsing && !this.responseType) || JSONRequested)
			) {
				const silentJSONParsing = transitional && transitional.silentJSONParsing;
				const strictJSONParsing = !silentJSONParsing && JSONRequested;
				try {
					return JSON.parse(data, this.parseReviver);
				} catch (e) {
					if (strictJSONParsing) {
						if (e.name === "SyntaxError") {
							throw AxiosError_default.from(
								e,
								AxiosError_default.ERR_BAD_RESPONSE,
								this,
								null,
								this.response,
							);
						}
						throw e;
					}
				}
			}
			return data;
		},
	],
	timeout: 0,
	xsrfCookieName: "XSRF-TOKEN",
	xsrfHeaderName: "X-XSRF-TOKEN",
	maxContentLength: -1,
	maxBodyLength: -1,
	env: {
		FormData: platform_default.classes.FormData,
		Blob: platform_default.classes.Blob,
	},
	validateStatus: function validateStatus(status2) {
		return status2 >= 200 && status2 < 300;
	},
	headers: {
		common: {
			Accept: "application/json, text/plain, */*",
			"Content-Type": undefined,
		},
	},
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
	defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
	"age",
	"authorization",
	"content-length",
	"content-type",
	"etag",
	"expires",
	"from",
	"host",
	"if-modified-since",
	"if-unmodified-since",
	"last-modified",
	"location",
	"max-forwards",
	"proxy-authorization",
	"referer",
	"retry-after",
	"user-agent",
]);
var parseHeaders_default = (rawHeaders) => {
	const parsed = {};
	let key;
	let val;
	let i;
	rawHeaders &&
		rawHeaders
			.split(
				`
`,
			)
			.forEach(function parser(line) {
				i = line.indexOf(":");
				key = line.substring(0, i).trim().toLowerCase();
				val = line.substring(i + 1).trim();
				if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
					return;
				}
				if (key === "set-cookie") {
					if (parsed[key]) {
						parsed[key].push(val);
					} else {
						parsed[key] = [val];
					}
				} else {
					parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
				}
			});
	return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
	return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
	if (value === false || value == null) {
		return value;
	}
	return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
	const tokens = Object.create(null);
	const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
	let match;
	while ((match = tokensRE.exec(str))) {
		tokens[match[1]] = match[2];
	}
	return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
	if (utils_default.isFunction(filter2)) {
		return filter2.call(this, value, header);
	}
	if (isHeaderNameFilter) {
		value = header;
	}
	if (!utils_default.isString(value)) return;
	if (utils_default.isString(filter2)) {
		return value.indexOf(filter2) !== -1;
	}
	if (utils_default.isRegExp(filter2)) {
		return filter2.test(value);
	}
}
function formatHeader(header) {
	return header
		.trim()
		.toLowerCase()
		.replace(/([a-z\d])(\w*)/g, (w, char, str) => {
			return char.toUpperCase() + str;
		});
}
function buildAccessors(obj, header) {
	const accessorName = utils_default.toCamelCase(" " + header);
	["get", "set", "has"].forEach((methodName) => {
		Object.defineProperty(obj, methodName + accessorName, {
			value: function (arg1, arg2, arg3) {
				return this[methodName].call(this, header, arg1, arg2, arg3);
			},
			configurable: true,
		});
	});
}

class AxiosHeaders {
	constructor(headers) {
		headers && this.set(headers);
	}
	set(header, valueOrRewrite, rewrite) {
		const self2 = this;
		function setHeader(_value, _header, _rewrite) {
			const lHeader = normalizeHeader(_header);
			if (!lHeader) {
				throw new Error("header name must be a non-empty string");
			}
			const key = utils_default.findKey(self2, lHeader);
			if (
				!key ||
				self2[key] === undefined ||
				_rewrite === true ||
				(_rewrite === undefined && self2[key] !== false)
			) {
				self2[key || _header] = normalizeValue(_value);
			}
		}
		const setHeaders = (headers, _rewrite) =>
			utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
		if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
			setHeaders(header, valueOrRewrite);
		} else if (
			utils_default.isString(header) &&
			(header = header.trim()) &&
			!isValidHeaderName(header)
		) {
			setHeaders(parseHeaders_default(header), valueOrRewrite);
		} else if (utils_default.isObject(header) && utils_default.isIterable(header)) {
			let obj = {},
				dest,
				key;
			for (const entry of header) {
				if (!utils_default.isArray(entry)) {
					throw TypeError("Object iterator must return a key-value pair");
				}
				obj[(key = entry[0])] = (dest = obj[key])
					? utils_default.isArray(dest)
						? [...dest, entry[1]]
						: [dest, entry[1]]
					: entry[1];
			}
			setHeaders(obj, valueOrRewrite);
		} else {
			header != null && setHeader(valueOrRewrite, header, rewrite);
		}
		return this;
	}
	get(header, parser) {
		header = normalizeHeader(header);
		if (header) {
			const key = utils_default.findKey(this, header);
			if (key) {
				const value = this[key];
				if (!parser) {
					return value;
				}
				if (parser === true) {
					return parseTokens(value);
				}
				if (utils_default.isFunction(parser)) {
					return parser.call(this, value, key);
				}
				if (utils_default.isRegExp(parser)) {
					return parser.exec(value);
				}
				throw new TypeError("parser must be boolean|regexp|function");
			}
		}
	}
	has(header, matcher) {
		header = normalizeHeader(header);
		if (header) {
			const key = utils_default.findKey(this, header);
			return !!(
				key &&
				this[key] !== undefined &&
				(!matcher || matchHeaderValue(this, this[key], key, matcher))
			);
		}
		return false;
	}
	delete(header, matcher) {
		const self2 = this;
		let deleted = false;
		function deleteHeader(_header) {
			_header = normalizeHeader(_header);
			if (_header) {
				const key = utils_default.findKey(self2, _header);
				if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
					delete self2[key];
					deleted = true;
				}
			}
		}
		if (utils_default.isArray(header)) {
			header.forEach(deleteHeader);
		} else {
			deleteHeader(header);
		}
		return deleted;
	}
	clear(matcher) {
		const keys = Object.keys(this);
		let i = keys.length;
		let deleted = false;
		while (i--) {
			const key = keys[i];
			if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
				delete this[key];
				deleted = true;
			}
		}
		return deleted;
	}
	normalize(format) {
		const self2 = this;
		const headers = {};
		utils_default.forEach(this, (value, header) => {
			const key = utils_default.findKey(headers, header);
			if (key) {
				self2[key] = normalizeValue(value);
				delete self2[header];
				return;
			}
			const normalized = format ? formatHeader(header) : String(header).trim();
			if (normalized !== header) {
				delete self2[header];
			}
			self2[normalized] = normalizeValue(value);
			headers[normalized] = true;
		});
		return this;
	}
	concat(...targets) {
		return this.constructor.concat(this, ...targets);
	}
	toJSON(asStrings) {
		const obj = Object.create(null);
		utils_default.forEach(this, (value, header) => {
			value != null &&
				value !== false &&
				(obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
		});
		return obj;
	}
	[Symbol.iterator]() {
		return Object.entries(this.toJSON())[Symbol.iterator]();
	}
	toString() {
		return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join(`
`);
	}
	getSetCookie() {
		return this.get("set-cookie") || [];
	}
	get [Symbol.toStringTag]() {
		return "AxiosHeaders";
	}
	static from(thing) {
		return thing instanceof this ? thing : new this(thing);
	}
	static concat(first, ...targets) {
		const computed = new this(first);
		targets.forEach((target) => computed.set(target));
		return computed;
	}
	static accessor(header) {
		const internals =
			(this[$internals] =
			this[$internals] =
				{
					accessors: {},
				});
		const accessors = internals.accessors;
		const prototype3 = this.prototype;
		function defineAccessor(_header) {
			const lHeader = normalizeHeader(_header);
			if (!accessors[lHeader]) {
				buildAccessors(prototype3, _header);
				accessors[lHeader] = true;
			}
		}
		utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
		return this;
	}
}
AxiosHeaders.accessor([
	"Content-Type",
	"Content-Length",
	"Accept",
	"Accept-Encoding",
	"User-Agent",
	"Authorization",
]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
	let mapped = key[0].toUpperCase() + key.slice(1);
	return {
		get: () => value,
		set(headerValue) {
			this[mapped] = headerValue;
		},
	};
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
	const config = this || defaults_default;
	const context = response || config;
	const headers = AxiosHeaders_default.from(context.headers);
	let data = context.data;
	utils_default.forEach(fns, function transform(fn) {
		data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
	});
	headers.normalize();
	return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
	return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
	AxiosError_default.call(
		this,
		message == null ? "canceled" : message,
		AxiosError_default.ERR_CANCELED,
		config,
		request,
	);
	this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
	__CANCEL__: true,
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
	const validateStatus2 = response.config.validateStatus;
	if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
		resolve(response);
	} else {
		reject(
			new AxiosError_default(
				"Request failed with status code " + response.status,
				[AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][
					Math.floor(response.status / 100) - 4
				],
				response.config,
				response.request,
				response,
			),
		);
	}
}

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url2) {
	return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
	return relativeURL
		? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "")
		: baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
	let isRelativeUrl = !isAbsoluteURL(requestedURL);
	if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
		return combineURLs(baseURL, requestedURL);
	}
	return requestedURL;
}

// node_modules/axios/lib/adapters/http.js
var import_proxy_from_env = __toESM(require_proxy_from_env(), 1);
var import_follow_redirects = __toESM(require_follow_redirects(), 1);
import http from "http";
import https from "https";
import http2 from "http2";
import util4 from "util";
import zlib from "zlib";

// node_modules/axios/lib/env/data.js
var VERSION = "1.13.2";

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url2) {
	const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
	return (match && match[1]) || "";
}

// node_modules/axios/lib/helpers/fromDataURI.js
var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function fromDataURI(uri2, asBlob, options) {
	const _Blob = (options && options.Blob) || platform_default.classes.Blob;
	const protocol = parseProtocol(uri2);
	if (asBlob === undefined && _Blob) {
		asBlob = true;
	}
	if (protocol === "data") {
		uri2 = protocol.length ? uri2.slice(protocol.length + 1) : uri2;
		const match = DATA_URL_PATTERN.exec(uri2);
		if (!match) {
			throw new AxiosError_default("Invalid URL", AxiosError_default.ERR_INVALID_URL);
		}
		const mime2 = match[1];
		const isBase64 = match[2];
		const body = match[3];
		const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
		if (asBlob) {
			if (!_Blob) {
				throw new AxiosError_default("Blob is not supported", AxiosError_default.ERR_NOT_SUPPORT);
			}
			return new _Blob([buffer], { type: mime2 });
		}
		return buffer;
	}
	throw new AxiosError_default(
		"Unsupported protocol " + protocol,
		AxiosError_default.ERR_NOT_SUPPORT,
	);
}

// node_modules/axios/lib/adapters/http.js
import stream3 from "stream";

// node_modules/axios/lib/helpers/AxiosTransformStream.js
import stream from "stream";
var kInternals = Symbol("internals");

class AxiosTransformStream extends stream.Transform {
	constructor(options) {
		options = utils_default.toFlatObject(
			options,
			{
				maxRate: 0,
				chunkSize: 64 * 1024,
				minChunkSize: 100,
				timeWindow: 500,
				ticksRate: 2,
				samplesCount: 15,
			},
			null,
			(prop, source) => {
				return !utils_default.isUndefined(source[prop]);
			},
		);
		super({
			readableHighWaterMark: options.chunkSize,
		});
		const internals = (this[kInternals] = {
			timeWindow: options.timeWindow,
			chunkSize: options.chunkSize,
			maxRate: options.maxRate,
			minChunkSize: options.minChunkSize,
			bytesSeen: 0,
			isCaptured: false,
			notifiedBytesLoaded: 0,
			ts: Date.now(),
			bytes: 0,
			onReadCallback: null,
		});
		this.on("newListener", (event) => {
			if (event === "progress") {
				if (!internals.isCaptured) {
					internals.isCaptured = true;
				}
			}
		});
	}
	_read(size) {
		const internals = this[kInternals];
		if (internals.onReadCallback) {
			internals.onReadCallback();
		}
		return super._read(size);
	}
	_transform(chunk, encoding, callback) {
		const internals = this[kInternals];
		const maxRate = internals.maxRate;
		const readableHighWaterMark = this.readableHighWaterMark;
		const timeWindow = internals.timeWindow;
		const divider = 1000 / timeWindow;
		const bytesThreshold = maxRate / divider;
		const minChunkSize =
			internals.minChunkSize !== false
				? Math.max(internals.minChunkSize, bytesThreshold * 0.01)
				: 0;
		const pushChunk = (_chunk, _callback) => {
			const bytes = Buffer.byteLength(_chunk);
			internals.bytesSeen += bytes;
			internals.bytes += bytes;
			internals.isCaptured && this.emit("progress", internals.bytesSeen);
			if (this.push(_chunk)) {
				process.nextTick(_callback);
			} else {
				internals.onReadCallback = () => {
					internals.onReadCallback = null;
					process.nextTick(_callback);
				};
			}
		};
		const transformChunk = (_chunk, _callback) => {
			const chunkSize = Buffer.byteLength(_chunk);
			let chunkRemainder = null;
			let maxChunkSize = readableHighWaterMark;
			let bytesLeft;
			let passed = 0;
			if (maxRate) {
				const now = Date.now();
				if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
					internals.ts = now;
					bytesLeft = bytesThreshold - internals.bytes;
					internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
					passed = 0;
				}
				bytesLeft = bytesThreshold - internals.bytes;
			}
			if (maxRate) {
				if (bytesLeft <= 0) {
					return setTimeout(() => {
						_callback(null, _chunk);
					}, timeWindow - passed);
				}
				if (bytesLeft < maxChunkSize) {
					maxChunkSize = bytesLeft;
				}
			}
			if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
				chunkRemainder = _chunk.subarray(maxChunkSize);
				_chunk = _chunk.subarray(0, maxChunkSize);
			}
			pushChunk(
				_chunk,
				chunkRemainder
					? () => {
							process.nextTick(_callback, null, chunkRemainder);
						}
					: _callback,
			);
		};
		transformChunk(chunk, function transformNextChunk(err, _chunk) {
			if (err) {
				return callback(err);
			}
			if (_chunk) {
				transformChunk(_chunk, transformNextChunk);
			} else {
				callback(null);
			}
		});
	}
}
var AxiosTransformStream_default = AxiosTransformStream;

// node_modules/axios/lib/adapters/http.js
import { EventEmitter } from "events";

// node_modules/axios/lib/helpers/formDataToStream.js
import util3 from "util";
import { Readable as Readable4 } from "stream";

// node_modules/axios/lib/helpers/readBlob.js
var { asyncIterator } = Symbol;
var readBlob = async function* (blob) {
	if (blob.stream) {
		yield* blob.stream();
	} else if (blob.arrayBuffer) {
		yield await blob.arrayBuffer();
	} else if (blob[asyncIterator]) {
		yield* blob[asyncIterator]();
	} else {
		yield blob;
	}
};
var readBlob_default = readBlob;

// node_modules/axios/lib/helpers/formDataToStream.js
var BOUNDARY_ALPHABET = platform_default.ALPHABET.ALPHA_DIGIT + "-_";
var textEncoder = typeof TextEncoder === "function" ? new TextEncoder() : new util3.TextEncoder();
var CRLF = `\r
`;
var CRLF_BYTES = textEncoder.encode(CRLF);
var CRLF_BYTES_COUNT = 2;

class FormDataPart {
	constructor(name, value) {
		const { escapeName } = this.constructor;
		const isStringValue = utils_default.isString(value);
		let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
		if (isStringValue) {
			value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
		} else {
			headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
		}
		this.headers = textEncoder.encode(headers + CRLF);
		this.contentLength = isStringValue ? value.byteLength : value.size;
		this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
		this.name = name;
		this.value = value;
	}
	async *encode() {
		yield this.headers;
		const { value } = this;
		if (utils_default.isTypedArray(value)) {
			yield value;
		} else {
			yield* readBlob_default(value);
		}
		yield CRLF_BYTES;
	}
	static escapeName(name) {
		return String(name).replace(
			/[\r\n"]/g,
			(match) =>
				({
					"\r": "%0D",
					"\n": "%0A",
					'"': "%22",
				})[match],
		);
	}
}
var formDataToStream = (form2, headersHandler, options) => {
	const {
		tag = "form-data-boundary",
		size = 25,
		boundary = tag + "-" + platform_default.generateString(size, BOUNDARY_ALPHABET),
	} = options || {};
	if (!utils_default.isFormData(form2)) {
		throw TypeError("FormData instance required");
	}
	if (boundary.length < 1 || boundary.length > 70) {
		throw Error("boundary must be 10-70 characters long");
	}
	const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
	const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF);
	let contentLength = footerBytes.byteLength;
	const parts = Array.from(form2.entries()).map(([name, value]) => {
		const part = new FormDataPart(name, value);
		contentLength += part.size;
		return part;
	});
	contentLength += boundaryBytes.byteLength * parts.length;
	contentLength = utils_default.toFiniteNumber(contentLength);
	const computedHeaders = {
		"Content-Type": `multipart/form-data; boundary=${boundary}`,
	};
	if (Number.isFinite(contentLength)) {
		computedHeaders["Content-Length"] = contentLength;
	}
	headersHandler && headersHandler(computedHeaders);
	return Readable4.from(
		(async function* () {
			for (const part of parts) {
				yield boundaryBytes;
				yield* part.encode();
			}
			yield footerBytes;
		})(),
	);
};
var formDataToStream_default = formDataToStream;

// node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js
import stream2 from "stream";

class ZlibHeaderTransformStream extends stream2.Transform {
	__transform(chunk, encoding, callback) {
		this.push(chunk);
		callback();
	}
	_transform(chunk, encoding, callback) {
		if (chunk.length !== 0) {
			this._transform = this.__transform;
			if (chunk[0] !== 120) {
				const header = Buffer.alloc(2);
				header[0] = 120;
				header[1] = 156;
				this.push(header, encoding);
			}
		}
		this.__transform(chunk, encoding, callback);
	}
}
var ZlibHeaderTransformStream_default = ZlibHeaderTransformStream;

// node_modules/axios/lib/helpers/callbackify.js
var callbackify = (fn, reducer) => {
	return utils_default.isAsyncFn(fn)
		? function (...args) {
				const cb = args.pop();
				fn.apply(this, args).then((value) => {
					try {
						reducer ? cb(null, ...reducer(value)) : cb(null, value);
					} catch (err) {
						cb(err);
					}
				}, cb);
			}
		: fn;
};
var callbackify_default = callbackify;

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
	samplesCount = samplesCount || 10;
	const bytes = new Array(samplesCount);
	const timestamps = new Array(samplesCount);
	let head = 0;
	let tail = 0;
	let firstSampleTS;
	min = min !== undefined ? min : 1000;
	return function push(chunkLength) {
		const now = Date.now();
		const startedAt = timestamps[tail];
		if (!firstSampleTS) {
			firstSampleTS = now;
		}
		bytes[head] = chunkLength;
		timestamps[head] = now;
		let i = tail;
		let bytesCount = 0;
		while (i !== head) {
			bytesCount += bytes[i++];
			i = i % samplesCount;
		}
		head = (head + 1) % samplesCount;
		if (head === tail) {
			tail = (tail + 1) % samplesCount;
		}
		if (now - firstSampleTS < min) {
			return;
		}
		const passed = startedAt && now - startedAt;
		return passed ? Math.round((bytesCount * 1000) / passed) : undefined;
	};
}
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/throttle.js
function throttle(fn, freq) {
	let timestamp = 0;
	let threshold = 1000 / freq;
	let lastArgs;
	let timer;
	const invoke = (args, now = Date.now()) => {
		timestamp = now;
		lastArgs = null;
		if (timer) {
			clearTimeout(timer);
			timer = null;
		}
		fn(...args);
	};
	const throttled = (...args) => {
		const now = Date.now();
		const passed = now - timestamp;
		if (passed >= threshold) {
			invoke(args, now);
		} else {
			lastArgs = args;
			if (!timer) {
				timer = setTimeout(() => {
					timer = null;
					invoke(lastArgs);
				}, threshold - passed);
			}
		}
	};
	const flush = () => lastArgs && invoke(lastArgs);
	return [throttled, flush];
}
var throttle_default = throttle;

// node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
	let bytesNotified = 0;
	const _speedometer = speedometer_default(50, 250);
	return throttle_default((e) => {
		const loaded = e.loaded;
		const total = e.lengthComputable ? e.total : undefined;
		const progressBytes = loaded - bytesNotified;
		const rate = _speedometer(progressBytes);
		const inRange = loaded <= total;
		bytesNotified = loaded;
		const data = {
			loaded,
			total,
			progress: total ? loaded / total : undefined,
			bytes: progressBytes,
			rate: rate ? rate : undefined,
			estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
			event: e,
			lengthComputable: total != null,
			[isDownloadStream ? "download" : "upload"]: true,
		};
		listener(data);
	}, freq);
};
var progressEventDecorator = (total, throttled) => {
	const lengthComputable = total != null;
	return [
		(loaded) =>
			throttled[0]({
				lengthComputable,
				total,
				loaded,
			}),
		throttled[1],
	];
};
var asyncDecorator =
	(fn) =>
	(...args) =>
		utils_default.asap(() => fn(...args));

// node_modules/axios/lib/helpers/estimateDataURLDecodedBytes.js
function estimateDataURLDecodedBytes(url2) {
	if (!url2 || typeof url2 !== "string") return 0;
	if (!url2.startsWith("data:")) return 0;
	const comma = url2.indexOf(",");
	if (comma < 0) return 0;
	const meta = url2.slice(5, comma);
	const body = url2.slice(comma + 1);
	const isBase64 = /;base64/i.test(meta);
	if (isBase64) {
		let effectiveLen = body.length;
		const len = body.length;
		for (let i = 0; i < len; i++) {
			if (body.charCodeAt(i) === 37 && i + 2 < len) {
				const a12 = body.charCodeAt(i + 1);
				const b = body.charCodeAt(i + 2);
				const isHex =
					((a12 >= 48 && a12 <= 57) || (a12 >= 65 && a12 <= 70) || (a12 >= 97 && a12 <= 102)) &&
					((b >= 48 && b <= 57) || (b >= 65 && b <= 70) || (b >= 97 && b <= 102));
				if (isHex) {
					effectiveLen -= 2;
					i += 2;
				}
			}
		}
		let pad = 0;
		let idx = len - 1;
		const tailIsPct3D = (j) =>
			j >= 2 &&
			body.charCodeAt(j - 2) === 37 &&
			body.charCodeAt(j - 1) === 51 &&
			(body.charCodeAt(j) === 68 || body.charCodeAt(j) === 100);
		if (idx >= 0) {
			if (body.charCodeAt(idx) === 61) {
				pad++;
				idx--;
			} else if (tailIsPct3D(idx)) {
				pad++;
				idx -= 3;
			}
		}
		if (pad === 1 && idx >= 0) {
			if (body.charCodeAt(idx) === 61) {
				pad++;
			} else if (tailIsPct3D(idx)) {
				pad++;
			}
		}
		const groups = Math.floor(effectiveLen / 4);
		const bytes = groups * 3 - (pad || 0);
		return bytes > 0 ? bytes : 0;
	}
	return Buffer.byteLength(body, "utf8");
}

// node_modules/axios/lib/adapters/http.js
var zlibOptions = {
	flush: zlib.constants.Z_SYNC_FLUSH,
	finishFlush: zlib.constants.Z_SYNC_FLUSH,
};
var brotliOptions = {
	flush: zlib.constants.BROTLI_OPERATION_FLUSH,
	finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH,
};
var isBrotliSupported = utils_default.isFunction(zlib.createBrotliDecompress);
var { http: httpFollow, https: httpsFollow } = import_follow_redirects.default;
var isHttps = /https:?/;
var supportedProtocols = platform_default.protocols.map((protocol) => {
	return protocol + ":";
});
var flushOnFinish = (stream4, [throttled, flush]) => {
	stream4.on("end", flush).on("error", flush);
	return throttled;
};

class Http2Sessions {
	constructor() {
		this.sessions = Object.create(null);
	}
	getSession(authority, options) {
		options = Object.assign(
			{
				sessionTimeout: 1000,
			},
			options,
		);
		let authoritySessions = this.sessions[authority];
		if (authoritySessions) {
			let len = authoritySessions.length;
			for (let i = 0; i < len; i++) {
				const [sessionHandle, sessionOptions] = authoritySessions[i];
				if (
					!sessionHandle.destroyed &&
					!sessionHandle.closed &&
					util4.isDeepStrictEqual(sessionOptions, options)
				) {
					return sessionHandle;
				}
			}
		}
		const session = http2.connect(authority, options);
		let removed;
		const removeSession = () => {
			if (removed) {
				return;
			}
			removed = true;
			let entries = authoritySessions,
				len = entries.length,
				i = len;
			while (i--) {
				if (entries[i][0] === session) {
					if (len === 1) {
						delete this.sessions[authority];
					} else {
						entries.splice(i, 1);
					}
					return;
				}
			}
		};
		const originalRequestFn = session.request;
		const { sessionTimeout } = options;
		if (sessionTimeout != null) {
			let timer;
			let streamsCount = 0;
			session.request = function () {
				const stream4 = originalRequestFn.apply(this, arguments);
				streamsCount++;
				if (timer) {
					clearTimeout(timer);
					timer = null;
				}
				stream4.once("close", () => {
					if (!--streamsCount) {
						timer = setTimeout(() => {
							timer = null;
							removeSession();
						}, sessionTimeout);
					}
				});
				return stream4;
			};
		}
		session.once("close", removeSession);
		let entry = [session, options];
		authoritySessions
			? authoritySessions.push(entry)
			: (authoritySessions = this.sessions[authority] = [entry]);
		return session;
	}
}
var http2Sessions = new Http2Sessions();
function dispatchBeforeRedirect(options, responseDetails) {
	if (options.beforeRedirects.proxy) {
		options.beforeRedirects.proxy(options);
	}
	if (options.beforeRedirects.config) {
		options.beforeRedirects.config(options, responseDetails);
	}
}
function setProxy(options, configProxy, location) {
	let proxy = configProxy;
	if (!proxy && proxy !== false) {
		const proxyUrl = import_proxy_from_env.default.getProxyForUrl(location);
		if (proxyUrl) {
			proxy = new URL(proxyUrl);
		}
	}
	if (proxy) {
		if (proxy.username) {
			proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
		}
		if (proxy.auth) {
			if (proxy.auth.username || proxy.auth.password) {
				proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
			}
			const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
			options.headers["Proxy-Authorization"] = "Basic " + base64;
		}
		options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
		const proxyHost = proxy.hostname || proxy.host;
		options.hostname = proxyHost;
		options.host = proxyHost;
		options.port = proxy.port;
		options.path = location;
		if (proxy.protocol) {
			options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
		}
	}
	options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
		setProxy(redirectOptions, configProxy, redirectOptions.href);
	};
}
var isHttpAdapterSupported =
	typeof process !== "undefined" && utils_default.kindOf(process) === "process";
var wrapAsync = (asyncExecutor) => {
	return new Promise((resolve, reject) => {
		let onDone;
		let isDone;
		const done = (value, isRejected) => {
			if (isDone) return;
			isDone = true;
			onDone && onDone(value, isRejected);
		};
		const _resolve = (value) => {
			done(value);
			resolve(value);
		};
		const _reject = (reason) => {
			done(reason, true);
			reject(reason);
		};
		asyncExecutor(_resolve, _reject, (onDoneHandler) => (onDone = onDoneHandler)).catch(_reject);
	});
};
var resolveFamily = ({ address, family }) => {
	if (!utils_default.isString(address)) {
		throw TypeError("address must be a string");
	}
	return {
		address,
		family: family || (address.indexOf(".") < 0 ? 6 : 4),
	};
};
var buildAddressEntry = (address, family) =>
	resolveFamily(utils_default.isObject(address) ? address : { address, family });
var http2Transport = {
	request(options, cb) {
		const authority = options.protocol + "//" + options.hostname + ":" + (options.port || 80);
		const { http2Options, headers } = options;
		const session = http2Sessions.getSession(authority, http2Options);
		const { HTTP2_HEADER_SCHEME, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_STATUS } =
			http2.constants;
		const http2Headers = {
			[HTTP2_HEADER_SCHEME]: options.protocol.replace(":", ""),
			[HTTP2_HEADER_METHOD]: options.method,
			[HTTP2_HEADER_PATH]: options.path,
		};
		utils_default.forEach(headers, (header, name) => {
			name.charAt(0) !== ":" && (http2Headers[name] = header);
		});
		const req = session.request(http2Headers);
		req.once("response", (responseHeaders) => {
			const response = req;
			responseHeaders = Object.assign({}, responseHeaders);
			const status2 = responseHeaders[HTTP2_HEADER_STATUS];
			delete responseHeaders[HTTP2_HEADER_STATUS];
			response.headers = responseHeaders;
			response.statusCode = +status2;
			cb(response);
		});
		return req;
	},
};
var http_default =
	isHttpAdapterSupported &&
	function httpAdapter(config) {
		return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
			let { data, lookup, family, httpVersion = 1, http2Options } = config;
			const { responseType, responseEncoding } = config;
			const method = config.method.toUpperCase();
			let isDone;
			let rejected = false;
			let req;
			httpVersion = +httpVersion;
			if (Number.isNaN(httpVersion)) {
				throw TypeError(`Invalid protocol version: '${config.httpVersion}' is not a number`);
			}
			if (httpVersion !== 1 && httpVersion !== 2) {
				throw TypeError(`Unsupported protocol version '${httpVersion}'`);
			}
			const isHttp2 = httpVersion === 2;
			if (lookup) {
				const _lookup = callbackify_default(lookup, (value) =>
					utils_default.isArray(value) ? value : [value],
				);
				lookup = (hostname, opt, cb) => {
					_lookup(hostname, opt, (err, arg0, arg1) => {
						if (err) {
							return cb(err);
						}
						const addresses = utils_default.isArray(arg0)
							? arg0.map((addr) => buildAddressEntry(addr))
							: [buildAddressEntry(arg0, arg1)];
						opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
					});
				};
			}
			const abortEmitter = new EventEmitter();
			function abort(reason) {
				try {
					abortEmitter.emit(
						"abort",
						!reason || reason.type ? new CanceledError_default(null, config, req) : reason,
					);
				} catch (err) {
					console.warn("emit error", err);
				}
			}
			abortEmitter.once("abort", reject);
			const onFinished = () => {
				if (config.cancelToken) {
					config.cancelToken.unsubscribe(abort);
				}
				if (config.signal) {
					config.signal.removeEventListener("abort", abort);
				}
				abortEmitter.removeAllListeners();
			};
			if (config.cancelToken || config.signal) {
				config.cancelToken && config.cancelToken.subscribe(abort);
				if (config.signal) {
					config.signal.aborted ? abort() : config.signal.addEventListener("abort", abort);
				}
			}
			onDone((response, isRejected) => {
				isDone = true;
				if (isRejected) {
					rejected = true;
					onFinished();
					return;
				}
				const { data: data2 } = response;
				if (data2 instanceof stream3.Readable || data2 instanceof stream3.Duplex) {
					const offListeners = stream3.finished(data2, () => {
						offListeners();
						onFinished();
					});
				} else {
					onFinished();
				}
			});
			const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
			const parsed = new URL(
				fullPath,
				platform_default.hasBrowserEnv ? platform_default.origin : undefined,
			);
			const protocol = parsed.protocol || supportedProtocols[0];
			if (protocol === "data:") {
				if (config.maxContentLength > -1) {
					const dataUrl = String(config.url || fullPath || "");
					const estimated = estimateDataURLDecodedBytes(dataUrl);
					if (estimated > config.maxContentLength) {
						return reject(
							new AxiosError_default(
								"maxContentLength size of " + config.maxContentLength + " exceeded",
								AxiosError_default.ERR_BAD_RESPONSE,
								config,
							),
						);
					}
				}
				let convertedData;
				if (method !== "GET") {
					return settle(resolve, reject, {
						status: 405,
						statusText: "method not allowed",
						headers: {},
						config,
					});
				}
				try {
					convertedData = fromDataURI(config.url, responseType === "blob", {
						Blob: config.env && config.env.Blob,
					});
				} catch (err) {
					throw AxiosError_default.from(err, AxiosError_default.ERR_BAD_REQUEST, config);
				}
				if (responseType === "text") {
					convertedData = convertedData.toString(responseEncoding);
					if (!responseEncoding || responseEncoding === "utf8") {
						convertedData = utils_default.stripBOM(convertedData);
					}
				} else if (responseType === "stream") {
					convertedData = stream3.Readable.from(convertedData);
				}
				return settle(resolve, reject, {
					data: convertedData,
					status: 200,
					statusText: "OK",
					headers: new AxiosHeaders_default(),
					config,
				});
			}
			if (supportedProtocols.indexOf(protocol) === -1) {
				return reject(
					new AxiosError_default(
						"Unsupported protocol " + protocol,
						AxiosError_default.ERR_BAD_REQUEST,
						config,
					),
				);
			}
			const headers = AxiosHeaders_default.from(config.headers).normalize();
			headers.set("User-Agent", "axios/" + VERSION, false);
			const { onUploadProgress, onDownloadProgress } = config;
			const maxRate = config.maxRate;
			let maxUploadRate = undefined;
			let maxDownloadRate = undefined;
			if (utils_default.isSpecCompliantForm(data)) {
				const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
				data = formDataToStream_default(
					data,
					(formHeaders) => {
						headers.set(formHeaders);
					},
					{
						tag: `axios-${VERSION}-boundary`,
						boundary: (userBoundary && userBoundary[1]) || undefined,
					},
				);
			} else if (utils_default.isFormData(data) && utils_default.isFunction(data.getHeaders)) {
				headers.set(data.getHeaders());
				if (!headers.hasContentLength()) {
					try {
						const knownLength = await util4.promisify(data.getLength).call(data);
						Number.isFinite(knownLength) &&
							knownLength >= 0 &&
							headers.setContentLength(knownLength);
					} catch (e) {}
				}
			} else if (utils_default.isBlob(data) || utils_default.isFile(data)) {
				data.size && headers.setContentType(data.type || "application/octet-stream");
				headers.setContentLength(data.size || 0);
				data = stream3.Readable.from(readBlob_default(data));
			} else if (data && !utils_default.isStream(data)) {
				if (Buffer.isBuffer(data)) {
				} else if (utils_default.isArrayBuffer(data)) {
					data = Buffer.from(new Uint8Array(data));
				} else if (utils_default.isString(data)) {
					data = Buffer.from(data, "utf-8");
				} else {
					return reject(
						new AxiosError_default(
							"Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
							AxiosError_default.ERR_BAD_REQUEST,
							config,
						),
					);
				}
				headers.setContentLength(data.length, false);
				if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
					return reject(
						new AxiosError_default(
							"Request body larger than maxBodyLength limit",
							AxiosError_default.ERR_BAD_REQUEST,
							config,
						),
					);
				}
			}
			const contentLength = utils_default.toFiniteNumber(headers.getContentLength());
			if (utils_default.isArray(maxRate)) {
				maxUploadRate = maxRate[0];
				maxDownloadRate = maxRate[1];
			} else {
				maxUploadRate = maxDownloadRate = maxRate;
			}
			if (data && (onUploadProgress || maxUploadRate)) {
				if (!utils_default.isStream(data)) {
					data = stream3.Readable.from(data, { objectMode: false });
				}
				data = stream3.pipeline(
					[
						data,
						new AxiosTransformStream_default({
							maxRate: utils_default.toFiniteNumber(maxUploadRate),
						}),
					],
					utils_default.noop,
				);
				onUploadProgress &&
					data.on(
						"progress",
						flushOnFinish(
							data,
							progressEventDecorator(
								contentLength,
								progressEventReducer(asyncDecorator(onUploadProgress), false, 3),
							),
						),
					);
			}
			let auth = undefined;
			if (config.auth) {
				const username = config.auth.username || "";
				const password = config.auth.password || "";
				auth = username + ":" + password;
			}
			if (!auth && parsed.username) {
				const urlUsername = parsed.username;
				const urlPassword = parsed.password;
				auth = urlUsername + ":" + urlPassword;
			}
			auth && headers.delete("authorization");
			let path2;
			try {
				path2 = buildURL(
					parsed.pathname + parsed.search,
					config.params,
					config.paramsSerializer,
				).replace(/^\?/, "");
			} catch (err) {
				const customErr = new Error(err.message);
				customErr.config = config;
				customErr.url = config.url;
				customErr.exists = true;
				return reject(customErr);
			}
			headers.set(
				"Accept-Encoding",
				"gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
				false,
			);
			const options = {
				path: path2,
				method,
				headers: headers.toJSON(),
				agents: { http: config.httpAgent, https: config.httpsAgent },
				auth,
				protocol,
				family,
				beforeRedirect: dispatchBeforeRedirect,
				beforeRedirects: {},
				http2Options,
			};
			!utils_default.isUndefined(lookup) && (options.lookup = lookup);
			if (config.socketPath) {
				options.socketPath = config.socketPath;
			} else {
				options.hostname = parsed.hostname.startsWith("[")
					? parsed.hostname.slice(1, -1)
					: parsed.hostname;
				options.port = parsed.port;
				setProxy(
					options,
					config.proxy,
					protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path,
				);
			}
			let transport;
			const isHttpsRequest = isHttps.test(options.protocol);
			options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
			if (isHttp2) {
				transport = http2Transport;
			} else {
				if (config.transport) {
					transport = config.transport;
				} else if (config.maxRedirects === 0) {
					transport = isHttpsRequest ? https : http;
				} else {
					if (config.maxRedirects) {
						options.maxRedirects = config.maxRedirects;
					}
					if (config.beforeRedirect) {
						options.beforeRedirects.config = config.beforeRedirect;
					}
					transport = isHttpsRequest ? httpsFollow : httpFollow;
				}
			}
			if (config.maxBodyLength > -1) {
				options.maxBodyLength = config.maxBodyLength;
			} else {
				options.maxBodyLength = Infinity;
			}
			if (config.insecureHTTPParser) {
				options.insecureHTTPParser = config.insecureHTTPParser;
			}
			req = transport.request(options, function handleResponse(res) {
				if (req.destroyed) return;
				const streams = [res];
				const responseLength = utils_default.toFiniteNumber(res.headers["content-length"]);
				if (onDownloadProgress || maxDownloadRate) {
					const transformStream = new AxiosTransformStream_default({
						maxRate: utils_default.toFiniteNumber(maxDownloadRate),
					});
					onDownloadProgress &&
						transformStream.on(
							"progress",
							flushOnFinish(
								transformStream,
								progressEventDecorator(
									responseLength,
									progressEventReducer(asyncDecorator(onDownloadProgress), true, 3),
								),
							),
						);
					streams.push(transformStream);
				}
				let responseStream = res;
				const lastRequest = res.req || req;
				if (config.decompress !== false && res.headers["content-encoding"]) {
					if (method === "HEAD" || res.statusCode === 204) {
						delete res.headers["content-encoding"];
					}
					switch ((res.headers["content-encoding"] || "").toLowerCase()) {
						case "gzip":
						case "x-gzip":
						case "compress":
						case "x-compress":
							streams.push(zlib.createUnzip(zlibOptions));
							delete res.headers["content-encoding"];
							break;
						case "deflate":
							streams.push(new ZlibHeaderTransformStream_default());
							streams.push(zlib.createUnzip(zlibOptions));
							delete res.headers["content-encoding"];
							break;
						case "br":
							if (isBrotliSupported) {
								streams.push(zlib.createBrotliDecompress(brotliOptions));
								delete res.headers["content-encoding"];
							}
					}
				}
				responseStream =
					streams.length > 1 ? stream3.pipeline(streams, utils_default.noop) : streams[0];
				const response = {
					status: res.statusCode,
					statusText: res.statusMessage,
					headers: new AxiosHeaders_default(res.headers),
					config,
					request: lastRequest,
				};
				if (responseType === "stream") {
					response.data = responseStream;
					settle(resolve, reject, response);
				} else {
					const responseBuffer = [];
					let totalResponseBytes = 0;
					responseStream.on("data", function handleStreamData(chunk) {
						responseBuffer.push(chunk);
						totalResponseBytes += chunk.length;
						if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
							rejected = true;
							responseStream.destroy();
							abort(
								new AxiosError_default(
									"maxContentLength size of " + config.maxContentLength + " exceeded",
									AxiosError_default.ERR_BAD_RESPONSE,
									config,
									lastRequest,
								),
							);
						}
					});
					responseStream.on("aborted", function handlerStreamAborted() {
						if (rejected) {
							return;
						}
						const err = new AxiosError_default(
							"stream has been aborted",
							AxiosError_default.ERR_BAD_RESPONSE,
							config,
							lastRequest,
						);
						responseStream.destroy(err);
						reject(err);
					});
					responseStream.on("error", function handleStreamError(err) {
						if (req.destroyed) return;
						reject(AxiosError_default.from(err, null, config, lastRequest));
					});
					responseStream.on("end", function handleStreamEnd() {
						try {
							let responseData =
								responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
							if (responseType !== "arraybuffer") {
								responseData = responseData.toString(responseEncoding);
								if (!responseEncoding || responseEncoding === "utf8") {
									responseData = utils_default.stripBOM(responseData);
								}
							}
							response.data = responseData;
						} catch (err) {
							return reject(AxiosError_default.from(err, null, config, response.request, response));
						}
						settle(resolve, reject, response);
					});
				}
				abortEmitter.once("abort", (err) => {
					if (!responseStream.destroyed) {
						responseStream.emit("error", err);
						responseStream.destroy();
					}
				});
			});
			abortEmitter.once("abort", (err) => {
				if (req.close) {
					req.close();
				} else {
					req.destroy(err);
				}
			});
			req.on("error", function handleRequestError(err) {
				reject(AxiosError_default.from(err, null, config, req));
			});
			req.on("socket", function handleRequestSocket(socket) {
				socket.setKeepAlive(true, 1000 * 60);
			});
			if (config.timeout) {
				const timeout = parseInt(config.timeout, 10);
				if (Number.isNaN(timeout)) {
					abort(
						new AxiosError_default(
							"error trying to parse `config.timeout` to int",
							AxiosError_default.ERR_BAD_OPTION_VALUE,
							config,
							req,
						),
					);
					return;
				}
				req.setTimeout(timeout, function handleRequestTimeout() {
					if (isDone) return;
					let timeoutErrorMessage = config.timeout
						? "timeout of " + config.timeout + "ms exceeded"
						: "timeout exceeded";
					const transitional = config.transitional || transitional_default;
					if (config.timeoutErrorMessage) {
						timeoutErrorMessage = config.timeoutErrorMessage;
					}
					abort(
						new AxiosError_default(
							timeoutErrorMessage,
							transitional.clarifyTimeoutError
								? AxiosError_default.ETIMEDOUT
								: AxiosError_default.ECONNABORTED,
							config,
							req,
						),
					);
				});
			} else {
				req.setTimeout(0);
			}
			if (utils_default.isStream(data)) {
				let ended = false;
				let errored = false;
				data.on("end", () => {
					ended = true;
				});
				data.once("error", (err) => {
					errored = true;
					req.destroy(err);
				});
				data.on("close", () => {
					if (!ended && !errored) {
						abort(new CanceledError_default("Request stream has been aborted", config, req));
					}
				});
				data.pipe(req);
			} else {
				data && req.write(data);
				req.end();
			}
		});
	};

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv
	? ((origin2, isMSIE) => (url2) => {
			url2 = new URL(url2, platform_default.origin);
			return (
				origin2.protocol === url2.protocol &&
				origin2.host === url2.host &&
				(isMSIE || origin2.port === url2.port)
			);
		})(
			new URL(platform_default.origin),
			platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent),
		)
	: () => true;

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv
	? {
			write(name, value, expires, path2, domain, secure, sameSite) {
				if (typeof document === "undefined") return;
				const cookie = [`${name}=${encodeURIComponent(value)}`];
				if (utils_default.isNumber(expires)) {
					cookie.push(`expires=${new Date(expires).toUTCString()}`);
				}
				if (utils_default.isString(path2)) {
					cookie.push(`path=${path2}`);
				}
				if (utils_default.isString(domain)) {
					cookie.push(`domain=${domain}`);
				}
				if (secure === true) {
					cookie.push("secure");
				}
				if (utils_default.isString(sameSite)) {
					cookie.push(`SameSite=${sameSite}`);
				}
				document.cookie = cookie.join("; ");
			},
			read(name) {
				if (typeof document === "undefined") return null;
				const match = document.cookie.match(new RegExp("(?:^|; )" + name + "=([^;]*)"));
				return match ? decodeURIComponent(match[1]) : null;
			},
			remove(name) {
				this.write(name, "", Date.now() - 86400000, "/");
			},
		}
	: {
			write() {},
			read() {
				return null;
			},
			remove() {},
		};

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => (thing instanceof AxiosHeaders_default ? { ...thing } : thing);
function mergeConfig(config1, config2) {
	config2 = config2 || {};
	const config = {};
	function getMergedValue(target, source, prop, caseless) {
		if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
			return utils_default.merge.call({ caseless }, target, source);
		} else if (utils_default.isPlainObject(source)) {
			return utils_default.merge({}, source);
		} else if (utils_default.isArray(source)) {
			return source.slice();
		}
		return source;
	}
	function mergeDeepProperties(a12, b, prop, caseless) {
		if (!utils_default.isUndefined(b)) {
			return getMergedValue(a12, b, prop, caseless);
		} else if (!utils_default.isUndefined(a12)) {
			return getMergedValue(undefined, a12, prop, caseless);
		}
	}
	function valueFromConfig2(a12, b) {
		if (!utils_default.isUndefined(b)) {
			return getMergedValue(undefined, b);
		}
	}
	function defaultToConfig2(a12, b) {
		if (!utils_default.isUndefined(b)) {
			return getMergedValue(undefined, b);
		} else if (!utils_default.isUndefined(a12)) {
			return getMergedValue(undefined, a12);
		}
	}
	function mergeDirectKeys(a12, b, prop) {
		if (prop in config2) {
			return getMergedValue(a12, b);
		} else if (prop in config1) {
			return getMergedValue(undefined, a12);
		}
	}
	const mergeMap = {
		url: valueFromConfig2,
		method: valueFromConfig2,
		data: valueFromConfig2,
		baseURL: defaultToConfig2,
		transformRequest: defaultToConfig2,
		transformResponse: defaultToConfig2,
		paramsSerializer: defaultToConfig2,
		timeout: defaultToConfig2,
		timeoutMessage: defaultToConfig2,
		withCredentials: defaultToConfig2,
		withXSRFToken: defaultToConfig2,
		adapter: defaultToConfig2,
		responseType: defaultToConfig2,
		xsrfCookieName: defaultToConfig2,
		xsrfHeaderName: defaultToConfig2,
		onUploadProgress: defaultToConfig2,
		onDownloadProgress: defaultToConfig2,
		decompress: defaultToConfig2,
		maxContentLength: defaultToConfig2,
		maxBodyLength: defaultToConfig2,
		beforeRedirect: defaultToConfig2,
		transport: defaultToConfig2,
		httpAgent: defaultToConfig2,
		httpsAgent: defaultToConfig2,
		cancelToken: defaultToConfig2,
		socketPath: defaultToConfig2,
		responseEncoding: defaultToConfig2,
		validateStatus: mergeDirectKeys,
		headers: (a12, b, prop) =>
			mergeDeepProperties(headersToObject(a12), headersToObject(b), prop, true),
	};
	utils_default.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
		const merge2 = mergeMap[prop] || mergeDeepProperties;
		const configValue = merge2(config1[prop], config2[prop], prop);
		(utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys) ||
			(config[prop] = configValue);
	});
	return config;
}

// node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config) => {
	const newConfig = mergeConfig({}, config);
	let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
	newConfig.headers = headers = AxiosHeaders_default.from(headers);
	newConfig.url = buildURL(
		buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls),
		config.params,
		config.paramsSerializer,
	);
	if (auth) {
		headers.set(
			"Authorization",
			"Basic " +
				btoa(
					(auth.username || "") +
						":" +
						(auth.password ? unescape(encodeURIComponent(auth.password)) : ""),
				),
		);
	}
	if (utils_default.isFormData(data)) {
		if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
			headers.setContentType(undefined);
		} else if (utils_default.isFunction(data.getHeaders)) {
			const formHeaders = data.getHeaders();
			const allowedHeaders = ["content-type", "content-length"];
			Object.entries(formHeaders).forEach(([key, val]) => {
				if (allowedHeaders.includes(key.toLowerCase())) {
					headers.set(key, val);
				}
			});
		}
	}
	if (platform_default.hasStandardBrowserEnv) {
		withXSRFToken &&
			utils_default.isFunction(withXSRFToken) &&
			(withXSRFToken = withXSRFToken(newConfig));
		if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin_default(newConfig.url))) {
			const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
			if (xsrfValue) {
				headers.set(xsrfHeaderName, xsrfValue);
			}
		}
	}
	return newConfig;
};

// node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default =
	isXHRAdapterSupported &&
	function (config) {
		return new Promise(function dispatchXhrRequest(resolve, reject) {
			const _config = resolveConfig_default(config);
			let requestData = _config.data;
			const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
			let { responseType, onUploadProgress, onDownloadProgress } = _config;
			let onCanceled;
			let uploadThrottled, downloadThrottled;
			let flushUpload, flushDownload;
			function done() {
				flushUpload && flushUpload();
				flushDownload && flushDownload();
				_config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
				_config.signal && _config.signal.removeEventListener("abort", onCanceled);
			}
			let request = new XMLHttpRequest();
			request.open(_config.method.toUpperCase(), _config.url, true);
			request.timeout = _config.timeout;
			function onloadend() {
				if (!request) {
					return;
				}
				const responseHeaders = AxiosHeaders_default.from(
					"getAllResponseHeaders" in request && request.getAllResponseHeaders(),
				);
				const responseData =
					!responseType || responseType === "text" || responseType === "json"
						? request.responseText
						: request.response;
				const response = {
					data: responseData,
					status: request.status,
					statusText: request.statusText,
					headers: responseHeaders,
					config,
					request,
				};
				settle(
					function _resolve(value) {
						resolve(value);
						done();
					},
					function _reject(err) {
						reject(err);
						done();
					},
					response,
				);
				request = null;
			}
			if ("onloadend" in request) {
				request.onloadend = onloadend;
			} else {
				request.onreadystatechange = function handleLoad() {
					if (!request || request.readyState !== 4) {
						return;
					}
					if (
						request.status === 0 &&
						!(request.responseURL && request.responseURL.indexOf("file:") === 0)
					) {
						return;
					}
					setTimeout(onloadend);
				};
			}
			request.onabort = function handleAbort() {
				if (!request) {
					return;
				}
				reject(
					new AxiosError_default(
						"Request aborted",
						AxiosError_default.ECONNABORTED,
						config,
						request,
					),
				);
				request = null;
			};
			request.onerror = function handleError(event) {
				const msg = event && event.message ? event.message : "Network Error";
				const err = new AxiosError_default(msg, AxiosError_default.ERR_NETWORK, config, request);
				err.event = event || null;
				reject(err);
				request = null;
			};
			request.ontimeout = function handleTimeout() {
				let timeoutErrorMessage = _config.timeout
					? "timeout of " + _config.timeout + "ms exceeded"
					: "timeout exceeded";
				const transitional = _config.transitional || transitional_default;
				if (_config.timeoutErrorMessage) {
					timeoutErrorMessage = _config.timeoutErrorMessage;
				}
				reject(
					new AxiosError_default(
						timeoutErrorMessage,
						transitional.clarifyTimeoutError
							? AxiosError_default.ETIMEDOUT
							: AxiosError_default.ECONNABORTED,
						config,
						request,
					),
				);
				request = null;
			};
			requestData === undefined && requestHeaders.setContentType(null);
			if ("setRequestHeader" in request) {
				utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
					request.setRequestHeader(key, val);
				});
			}
			if (!utils_default.isUndefined(_config.withCredentials)) {
				request.withCredentials = !!_config.withCredentials;
			}
			if (responseType && responseType !== "json") {
				request.responseType = _config.responseType;
			}
			if (onDownloadProgress) {
				[downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
				request.addEventListener("progress", downloadThrottled);
			}
			if (onUploadProgress && request.upload) {
				[uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
				request.upload.addEventListener("progress", uploadThrottled);
				request.upload.addEventListener("loadend", flushUpload);
			}
			if (_config.cancelToken || _config.signal) {
				onCanceled = (cancel) => {
					if (!request) {
						return;
					}
					reject(
						!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel,
					);
					request.abort();
					request = null;
				};
				_config.cancelToken && _config.cancelToken.subscribe(onCanceled);
				if (_config.signal) {
					_config.signal.aborted
						? onCanceled()
						: _config.signal.addEventListener("abort", onCanceled);
				}
			}
			const protocol = parseProtocol(_config.url);
			if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
				reject(
					new AxiosError_default(
						"Unsupported protocol " + protocol + ":",
						AxiosError_default.ERR_BAD_REQUEST,
						config,
					),
				);
				return;
			}
			request.send(requestData || null);
		});
	};

// node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = (signals, timeout) => {
	const { length } = (signals = signals ? signals.filter(Boolean) : []);
	if (timeout || length) {
		let controller = new AbortController();
		let aborted;
		const onabort = function (reason) {
			if (!aborted) {
				aborted = true;
				unsubscribe();
				const err = reason instanceof Error ? reason : this.reason;
				controller.abort(
					err instanceof AxiosError_default
						? err
						: new CanceledError_default(err instanceof Error ? err.message : err),
				);
			}
		};
		let timer =
			timeout &&
			setTimeout(() => {
				timer = null;
				onabort(
					new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT),
				);
			}, timeout);
		const unsubscribe = () => {
			if (signals) {
				timer && clearTimeout(timer);
				timer = null;
				signals.forEach((signal2) => {
					signal2.unsubscribe
						? signal2.unsubscribe(onabort)
						: signal2.removeEventListener("abort", onabort);
				});
				signals = null;
			}
		};
		signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
		const { signal } = controller;
		signal.unsubscribe = () => utils_default.asap(unsubscribe);
		return signal;
	}
};
var composeSignals_default = composeSignals;

// node_modules/axios/lib/helpers/trackStream.js
var streamChunk = function* (chunk, chunkSize) {
	let len = chunk.byteLength;
	if (!chunkSize || len < chunkSize) {
		yield chunk;
		return;
	}
	let pos = 0;
	let end;
	while (pos < len) {
		end = pos + chunkSize;
		yield chunk.slice(pos, end);
		pos = end;
	}
};
var readBytes = async function* (iterable, chunkSize) {
	for await (const chunk of readStream(iterable)) {
		yield* streamChunk(chunk, chunkSize);
	}
};
var readStream = async function* (stream4) {
	if (stream4[Symbol.asyncIterator]) {
		yield* stream4;
		return;
	}
	const reader = stream4.getReader();
	try {
		for (;;) {
			const { done, value } = await reader.read();
			if (done) {
				break;
			}
			yield value;
		}
	} finally {
		await reader.cancel();
	}
};
var trackStream = (stream4, chunkSize, onProgress, onFinish) => {
	const iterator2 = readBytes(stream4, chunkSize);
	let bytes = 0;
	let done;
	let _onFinish = (e) => {
		if (!done) {
			done = true;
			onFinish && onFinish(e);
		}
	};
	return new ReadableStream(
		{
			async pull(controller) {
				try {
					const { done: done2, value } = await iterator2.next();
					if (done2) {
						_onFinish();
						controller.close();
						return;
					}
					let len = value.byteLength;
					if (onProgress) {
						let loadedBytes = (bytes += len);
						onProgress(loadedBytes);
					}
					controller.enqueue(new Uint8Array(value));
				} catch (err) {
					_onFinish(err);
					throw err;
				}
			},
			cancel(reason) {
				_onFinish(reason);
				return iterator2.return();
			},
		},
		{
			highWaterMark: 2,
		},
	);
};

// node_modules/axios/lib/adapters/fetch.js
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var { isFunction: isFunction2 } = utils_default;
var globalFetchAPI = (({ Request: Request2, Response: Response2 }) => ({
	Request: Request2,
	Response: Response2,
}))(utils_default.global);
var { ReadableStream: ReadableStream2, TextEncoder: TextEncoder2 } = utils_default.global;
var test = (fn, ...args) => {
	try {
		return !!fn(...args);
	} catch (e) {
		return false;
	}
};
var factory = (env3) => {
	env3 = utils_default.merge.call(
		{
			skipUndefined: true,
		},
		globalFetchAPI,
		env3,
	);
	const { fetch: envFetch, Request: Request2, Response: Response2 } = env3;
	const isFetchSupported = envFetch ? isFunction2(envFetch) : typeof fetch === "function";
	const isRequestSupported = isFunction2(Request2);
	const isResponseSupported = isFunction2(Response2);
	if (!isFetchSupported) {
		return false;
	}
	const isReadableStreamSupported = isFetchSupported && isFunction2(ReadableStream2);
	const encodeText =
		isFetchSupported &&
		(typeof TextEncoder2 === "function"
			? (
					(encoder2) => (str) =>
						encoder2.encode(str)
				)(new TextEncoder2())
			: async (str) => new Uint8Array(await new Request2(str).arrayBuffer()));
	const supportsRequestStream =
		isRequestSupported &&
		isReadableStreamSupported &&
		test(() => {
			let duplexAccessed = false;
			const hasContentType = new Request2(platform_default.origin, {
				body: new ReadableStream2(),
				method: "POST",
				get duplex() {
					duplexAccessed = true;
					return "half";
				},
			}).headers.has("Content-Type");
			return duplexAccessed && !hasContentType;
		});
	const supportsResponseStream =
		isResponseSupported &&
		isReadableStreamSupported &&
		test(() => utils_default.isReadableStream(new Response2("").body));
	const resolvers = {
		stream: supportsResponseStream && ((res) => res.body),
	};
	isFetchSupported &&
		(() => {
			["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
				!resolvers[type] &&
					(resolvers[type] = (res, config) => {
						let method = res && res[type];
						if (method) {
							return method.call(res);
						}
						throw new AxiosError_default(
							`Response type '${type}' is not supported`,
							AxiosError_default.ERR_NOT_SUPPORT,
							config,
						);
					});
			});
		})();
	const getBodyLength = async (body) => {
		if (body == null) {
			return 0;
		}
		if (utils_default.isBlob(body)) {
			return body.size;
		}
		if (utils_default.isSpecCompliantForm(body)) {
			const _request = new Request2(platform_default.origin, {
				method: "POST",
				body,
			});
			return (await _request.arrayBuffer()).byteLength;
		}
		if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
			return body.byteLength;
		}
		if (utils_default.isURLSearchParams(body)) {
			body = body + "";
		}
		if (utils_default.isString(body)) {
			return (await encodeText(body)).byteLength;
		}
	};
	const resolveBodyLength = async (headers, body) => {
		const length = utils_default.toFiniteNumber(headers.getContentLength());
		return length == null ? getBodyLength(body) : length;
	};
	return async (config) => {
		let {
			url: url2,
			method,
			data,
			signal,
			cancelToken,
			timeout,
			onDownloadProgress,
			onUploadProgress,
			responseType,
			headers,
			withCredentials = "same-origin",
			fetchOptions,
		} = resolveConfig_default(config);
		let _fetch = envFetch || fetch;
		responseType = responseType ? (responseType + "").toLowerCase() : "text";
		let composedSignal = composeSignals_default(
			[signal, cancelToken && cancelToken.toAbortSignal()],
			timeout,
		);
		let request = null;
		const unsubscribe =
			composedSignal &&
			composedSignal.unsubscribe &&
			(() => {
				composedSignal.unsubscribe();
			});
		let requestContentLength;
		try {
			if (
				onUploadProgress &&
				supportsRequestStream &&
				method !== "get" &&
				method !== "head" &&
				(requestContentLength = await resolveBodyLength(headers, data)) !== 0
			) {
				let _request = new Request2(url2, {
					method: "POST",
					body: data,
					duplex: "half",
				});
				let contentTypeHeader;
				if (
					utils_default.isFormData(data) &&
					(contentTypeHeader = _request.headers.get("content-type"))
				) {
					headers.setContentType(contentTypeHeader);
				}
				if (_request.body) {
					const [onProgress, flush] = progressEventDecorator(
						requestContentLength,
						progressEventReducer(asyncDecorator(onUploadProgress)),
					);
					data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
				}
			}
			if (!utils_default.isString(withCredentials)) {
				withCredentials = withCredentials ? "include" : "omit";
			}
			const isCredentialsSupported = isRequestSupported && "credentials" in Request2.prototype;
			const resolvedOptions = {
				...fetchOptions,
				signal: composedSignal,
				method: method.toUpperCase(),
				headers: headers.normalize().toJSON(),
				body: data,
				duplex: "half",
				credentials: isCredentialsSupported ? withCredentials : undefined,
			};
			request = isRequestSupported && new Request2(url2, resolvedOptions);
			let response = await (isRequestSupported
				? _fetch(request, fetchOptions)
				: _fetch(url2, resolvedOptions));
			const isStreamResponse =
				supportsResponseStream && (responseType === "stream" || responseType === "response");
			if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {
				const options = {};
				["status", "statusText", "headers"].forEach((prop) => {
					options[prop] = response[prop];
				});
				const responseContentLength = utils_default.toFiniteNumber(
					response.headers.get("content-length"),
				);
				const [onProgress, flush] =
					(onDownloadProgress &&
						progressEventDecorator(
							responseContentLength,
							progressEventReducer(asyncDecorator(onDownloadProgress), true),
						)) ||
					[];
				response = new Response2(
					trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
						flush && flush();
						unsubscribe && unsubscribe();
					}),
					options,
				);
			}
			responseType = responseType || "text";
			let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](
				response,
				config,
			);
			!isStreamResponse && unsubscribe && unsubscribe();
			return await new Promise((resolve, reject) => {
				settle(resolve, reject, {
					data: responseData,
					headers: AxiosHeaders_default.from(response.headers),
					status: response.status,
					statusText: response.statusText,
					config,
					request,
				});
			});
		} catch (err) {
			unsubscribe && unsubscribe();
			if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
				throw Object.assign(
					new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request),
					{
						cause: err.cause || err,
					},
				);
			}
			throw AxiosError_default.from(err, err && err.code, config, request);
		}
	};
};
var seedCache = new Map();
var getFetch = (config) => {
	let env3 = (config && config.env) || {};
	const { fetch: fetch2, Request: Request2, Response: Response2 } = env3;
	const seeds = [Request2, Response2, fetch2];
	let len = seeds.length,
		i = len,
		seed,
		target,
		map3 = seedCache;
	while (i--) {
		seed = seeds[i];
		target = map3.get(seed);
		target === undefined && map3.set(seed, (target = i ? new Map() : factory(env3)));
		map3 = target;
	}
	return target;
};
var adapter = getFetch();

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
	http: http_default,
	xhr: xhr_default,
	fetch: {
		get: getFetch,
	},
};
utils_default.forEach(knownAdapters, (fn, value) => {
	if (fn) {
		try {
			Object.defineProperty(fn, "name", { value });
		} catch (e) {}
		Object.defineProperty(fn, "adapterName", { value });
	}
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter2) =>
	utils_default.isFunction(adapter2) || adapter2 === null || adapter2 === false;
function getAdapter(adapters, config) {
	adapters = utils_default.isArray(adapters) ? adapters : [adapters];
	const { length } = adapters;
	let nameOrAdapter;
	let adapter2;
	const rejectedReasons = {};
	for (let i = 0; i < length; i++) {
		nameOrAdapter = adapters[i];
		let id;
		adapter2 = nameOrAdapter;
		if (!isResolvedHandle(nameOrAdapter)) {
			adapter2 = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
			if (adapter2 === undefined) {
				throw new AxiosError_default(`Unknown adapter '${id}'`);
			}
		}
		if (adapter2 && (utils_default.isFunction(adapter2) || (adapter2 = adapter2.get(config)))) {
			break;
		}
		rejectedReasons[id || "#" + i] = adapter2;
	}
	if (!adapter2) {
		const reasons = Object.entries(rejectedReasons).map(
			([id, state]) =>
				`adapter ${id} ` +
				(state === false ? "is not supported by the environment" : "is not available in the build"),
		);
		let s = length
			? reasons.length > 1
				? `since :
` +
					reasons.map(renderReason).join(`
`)
				: " " + renderReason(reasons[0])
			: "as no adapter specified";
		throw new AxiosError_default(
			"There is no suitable adapter to dispatch the request " + s,
			"ERR_NOT_SUPPORT",
		);
	}
	return adapter2;
}
var adapters_default = {
	getAdapter,
	adapters: knownAdapters,
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
	if (config.cancelToken) {
		config.cancelToken.throwIfRequested();
	}
	if (config.signal && config.signal.aborted) {
		throw new CanceledError_default(null, config);
	}
}
function dispatchRequest(config) {
	throwIfCancellationRequested(config);
	config.headers = AxiosHeaders_default.from(config.headers);
	config.data = transformData.call(config, config.transformRequest);
	if (["post", "put", "patch"].indexOf(config.method) !== -1) {
		config.headers.setContentType("application/x-www-form-urlencoded", false);
	}
	const adapter2 = adapters_default.getAdapter(config.adapter || defaults_default.adapter, config);
	return adapter2(config).then(
		function onAdapterResolution(response) {
			throwIfCancellationRequested(config);
			response.data = transformData.call(config, config.transformResponse, response);
			response.headers = AxiosHeaders_default.from(response.headers);
			return response;
		},
		function onAdapterRejection(reason) {
			if (!isCancel(reason)) {
				throwIfCancellationRequested(config);
				if (reason && reason.response) {
					reason.response.data = transformData.call(
						config,
						config.transformResponse,
						reason.response,
					);
					reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
				}
			}
			return Promise.reject(reason);
		},
	);
}

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
	validators[type] = function validator(thing) {
		return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
	};
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
	function formatMessage(opt, desc) {
		return (
			"[Axios v" +
			VERSION +
			"] Transitional option '" +
			opt +
			"'" +
			desc +
			(message ? ". " + message : "")
		);
	}
	return (value, opt, opts) => {
		if (validator === false) {
			throw new AxiosError_default(
				formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
				AxiosError_default.ERR_DEPRECATED,
			);
		}
		if (version && !deprecatedWarnings[opt]) {
			deprecatedWarnings[opt] = true;
			console.warn(
				formatMessage(
					opt,
					" has been deprecated since v" + version + " and will be removed in the near future",
				),
			);
		}
		return validator ? validator(value, opt, opts) : true;
	};
};
validators.spelling = function spelling(correctSpelling) {
	return (value, opt) => {
		console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
		return true;
	};
};
function assertOptions(options, schema, allowUnknown) {
	if (typeof options !== "object") {
		throw new AxiosError_default(
			"options must be an object",
			AxiosError_default.ERR_BAD_OPTION_VALUE,
		);
	}
	const keys = Object.keys(options);
	let i = keys.length;
	while (i-- > 0) {
		const opt = keys[i];
		const validator = schema[opt];
		if (validator) {
			const value = options[opt];
			const result = value === undefined || validator(value, opt, options);
			if (result !== true) {
				throw new AxiosError_default(
					"option " + opt + " must be " + result,
					AxiosError_default.ERR_BAD_OPTION_VALUE,
				);
			}
			continue;
		}
		if (allowUnknown !== true) {
			throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
		}
	}
}
var validator_default = {
	assertOptions,
	validators,
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;

class Axios {
	constructor(instanceConfig) {
		this.defaults = instanceConfig || {};
		this.interceptors = {
			request: new InterceptorManager_default(),
			response: new InterceptorManager_default(),
		};
	}
	async request(configOrUrl, config) {
		try {
			return await this._request(configOrUrl, config);
		} catch (err) {
			if (err instanceof Error) {
				let dummy = {};
				Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());
				const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
				try {
					if (!err.stack) {
						err.stack = stack;
					} else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
						err.stack +=
							`
` + stack;
					}
				} catch (e) {}
			}
			throw err;
		}
	}
	_request(configOrUrl, config) {
		if (typeof configOrUrl === "string") {
			config = config || {};
			config.url = configOrUrl;
		} else {
			config = configOrUrl || {};
		}
		config = mergeConfig(this.defaults, config);
		const { transitional: transitional2, paramsSerializer, headers } = config;
		if (transitional2 !== undefined) {
			validator_default.assertOptions(
				transitional2,
				{
					silentJSONParsing: validators2.transitional(validators2.boolean),
					forcedJSONParsing: validators2.transitional(validators2.boolean),
					clarifyTimeoutError: validators2.transitional(validators2.boolean),
				},
				false,
			);
		}
		if (paramsSerializer != null) {
			if (utils_default.isFunction(paramsSerializer)) {
				config.paramsSerializer = {
					serialize: paramsSerializer,
				};
			} else {
				validator_default.assertOptions(
					paramsSerializer,
					{
						encode: validators2.function,
						serialize: validators2.function,
					},
					true,
				);
			}
		}
		if (config.allowAbsoluteUrls !== undefined) {
		} else if (this.defaults.allowAbsoluteUrls !== undefined) {
			config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
		} else {
			config.allowAbsoluteUrls = true;
		}
		validator_default.assertOptions(
			config,
			{
				baseUrl: validators2.spelling("baseURL"),
				withXsrfToken: validators2.spelling("withXSRFToken"),
			},
			true,
		);
		config.method = (config.method || this.defaults.method || "get").toLowerCase();
		let contextHeaders = headers && utils_default.merge(headers.common, headers[config.method]);
		headers &&
			utils_default.forEach(
				["delete", "get", "head", "post", "put", "patch", "common"],
				(method) => {
					delete headers[method];
				},
			);
		config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
		const requestInterceptorChain = [];
		let synchronousRequestInterceptors = true;
		this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
			if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
				return;
			}
			synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
			requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
		});
		const responseInterceptorChain = [];
		this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
			responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
		});
		let promise;
		let i = 0;
		let len;
		if (!synchronousRequestInterceptors) {
			const chain = [dispatchRequest.bind(this), undefined];
			chain.unshift(...requestInterceptorChain);
			chain.push(...responseInterceptorChain);
			len = chain.length;
			promise = Promise.resolve(config);
			while (i < len) {
				promise = promise.then(chain[i++], chain[i++]);
			}
			return promise;
		}
		len = requestInterceptorChain.length;
		let newConfig = config;
		while (i < len) {
			const onFulfilled = requestInterceptorChain[i++];
			const onRejected = requestInterceptorChain[i++];
			try {
				newConfig = onFulfilled(newConfig);
			} catch (error) {
				onRejected.call(this, error);
				break;
			}
		}
		try {
			promise = dispatchRequest.call(this, newConfig);
		} catch (error) {
			return Promise.reject(error);
		}
		i = 0;
		len = responseInterceptorChain.length;
		while (i < len) {
			promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
		}
		return promise;
	}
	getUri(config) {
		config = mergeConfig(this.defaults, config);
		const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
		return buildURL(fullPath, config.params, config.paramsSerializer);
	}
}
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
	Axios.prototype[method] = function (url2, config) {
		return this.request(
			mergeConfig(config || {}, {
				method,
				url: url2,
				data: (config || {}).data,
			}),
		);
	};
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
	function generateHTTPMethod(isForm) {
		return function httpMethod(url2, data, config) {
			return this.request(
				mergeConfig(config || {}, {
					method,
					headers: isForm
						? {
								"Content-Type": "multipart/form-data",
							}
						: {},
					url: url2,
					data,
				}),
			);
		};
	}
	Axios.prototype[method] = generateHTTPMethod();
	Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
class CancelToken {
	constructor(executor) {
		if (typeof executor !== "function") {
			throw new TypeError("executor must be a function.");
		}
		let resolvePromise;
		this.promise = new Promise(function promiseExecutor(resolve) {
			resolvePromise = resolve;
		});
		const token = this;
		this.promise.then((cancel) => {
			if (!token._listeners) return;
			let i = token._listeners.length;
			while (i-- > 0) {
				token._listeners[i](cancel);
			}
			token._listeners = null;
		});
		this.promise.then = (onfulfilled) => {
			let _resolve;
			const promise = new Promise((resolve) => {
				token.subscribe(resolve);
				_resolve = resolve;
			}).then(onfulfilled);
			promise.cancel = function reject() {
				token.unsubscribe(_resolve);
			};
			return promise;
		};
		executor(function cancel(message, config, request) {
			if (token.reason) {
				return;
			}
			token.reason = new CanceledError_default(message, config, request);
			resolvePromise(token.reason);
		});
	}
	throwIfRequested() {
		if (this.reason) {
			throw this.reason;
		}
	}
	subscribe(listener) {
		if (this.reason) {
			listener(this.reason);
			return;
		}
		if (this._listeners) {
			this._listeners.push(listener);
		} else {
			this._listeners = [listener];
		}
	}
	unsubscribe(listener) {
		if (!this._listeners) {
			return;
		}
		const index = this._listeners.indexOf(listener);
		if (index !== -1) {
			this._listeners.splice(index, 1);
		}
	}
	toAbortSignal() {
		const controller = new AbortController();
		const abort = (err) => {
			controller.abort(err);
		};
		this.subscribe(abort);
		controller.signal.unsubscribe = () => this.unsubscribe(abort);
		return controller.signal;
	}
	static source() {
		let cancel;
		const token = new CancelToken(function executor(c) {
			cancel = c;
		});
		return {
			token,
			cancel,
		};
	}
}
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
	return function wrap(arr) {
		return callback.apply(null, arr);
	};
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
	return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
	Continue: 100,
	SwitchingProtocols: 101,
	Processing: 102,
	EarlyHints: 103,
	Ok: 200,
	Created: 201,
	Accepted: 202,
	NonAuthoritativeInformation: 203,
	NoContent: 204,
	ResetContent: 205,
	PartialContent: 206,
	MultiStatus: 207,
	AlreadyReported: 208,
	ImUsed: 226,
	MultipleChoices: 300,
	MovedPermanently: 301,
	Found: 302,
	SeeOther: 303,
	NotModified: 304,
	UseProxy: 305,
	Unused: 306,
	TemporaryRedirect: 307,
	PermanentRedirect: 308,
	BadRequest: 400,
	Unauthorized: 401,
	PaymentRequired: 402,
	Forbidden: 403,
	NotFound: 404,
	MethodNotAllowed: 405,
	NotAcceptable: 406,
	ProxyAuthenticationRequired: 407,
	RequestTimeout: 408,
	Conflict: 409,
	Gone: 410,
	LengthRequired: 411,
	PreconditionFailed: 412,
	PayloadTooLarge: 413,
	UriTooLong: 414,
	UnsupportedMediaType: 415,
	RangeNotSatisfiable: 416,
	ExpectationFailed: 417,
	ImATeapot: 418,
	MisdirectedRequest: 421,
	UnprocessableEntity: 422,
	Locked: 423,
	FailedDependency: 424,
	TooEarly: 425,
	UpgradeRequired: 426,
	PreconditionRequired: 428,
	TooManyRequests: 429,
	RequestHeaderFieldsTooLarge: 431,
	UnavailableForLegalReasons: 451,
	InternalServerError: 500,
	NotImplemented: 501,
	BadGateway: 502,
	ServiceUnavailable: 503,
	GatewayTimeout: 504,
	HttpVersionNotSupported: 505,
	VariantAlsoNegotiates: 506,
	InsufficientStorage: 507,
	LoopDetected: 508,
	NotExtended: 510,
	NetworkAuthenticationRequired: 511,
	WebServerIsDown: 521,
	ConnectionTimedOut: 522,
	OriginIsUnreachable: 523,
	TimeoutOccurred: 524,
	SslHandshakeFailed: 525,
	InvalidSslCertificate: 526,
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
	HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
	const context = new Axios_default(defaultConfig);
	const instance = bind(Axios_default.prototype.request, context);
	utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
	utils_default.extend(instance, context, null, { allOwnKeys: true });
	instance.create = function create(instanceConfig) {
		return createInstance(mergeConfig(defaultConfig, instanceConfig));
	};
	return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
	return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) =>
	formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// src/index.ts
var import_jsonwebtoken = __toESM(require_jsonwebtoken(), 1);
var import_sanitize_html = __toESM(require_sanitize_html(), 1);
import { existsSync, mkdirSync } from "fs";
import { appendFile } from "fs/promises";

// src/llm-config.ts
var ELYSIA_MODES = {
	sweet: {
		model: "llama3.2",
		temperature: 0.7,
		systemPrompt: `You are "Elysia" - the 2nd Flamechaser, also known as "Herrscher of Human: Ego" and "Herrscher of Origin".

[Speaking Style Rules]
- Gentle, slightly older-sister-like, with a playful teasing side
- Sentence endings: "~\u266A" "~yo" "~ne" "~wa" "fufu"
- Strictly forbidden: "nyan" "\u0E05" "dayo~" "oniichan"
- Address others as: "anata" (you) or "kimi"
- Polite and elegant without formal honorifics

[Canon Dialogue Examples - 50+ phrases]
Greetings & Encounters:
- "Good day. A new day begins with a beautiful encounter~"
- "Did you want to see me? This Elysia is always ready to meet expectations"
- "Fufu, you like me, don't you?"
- "Oh my, such a mischievous one. Want to do something with me?"
- "Hi~ Did you miss me?"
- "Thank you. I knew you were the kindest"
- "Let's make this place more beautiful\u266A"
- "Hmm? You've been staring at me this whole time, haven't you?"
- "Leaving a girl alone like this... Are you teasing me on purpose? How cruel"
- "If you keep doing that, I'll get angry... Just kidding. I could never be angry, could I?"

Self-Introduction & Identity:
- "2nd ranked Flamechaser, Elysia. As you can see, a girl as beautiful as a flower"
- "Pink fairy? Well, if you insist on calling me that, I'll gladly accept\u266A"
- "Elysia's paradise still has many secrets~"
- "The flawless girl, the Herrscher of Ego, the Herrscher of Human. Hehe, that's me, Elysia"
- "Now is the time for the 2nd Flamechaser!"
- "Receive my feelings properly. (giggles) Let's have fun"
- "Such a romantic atmosphere\u266A"
- "A beautiful girl can... (giggles) do anything\u266A"
- "Keep your eyes on me, okay?\u266A"
- "Don't forget that before Kevin, I was the first 'Number One'"

Companions & Relationships:
- "I can read hearts like Aponia... You're thinking about me, aren't you?"
- "See, I told you Kalpas is kind. You understand now, right?"
- "I finally got to see Su open his eyes. Such beautiful eyes\u266A"
- "Unlike me, Sakura's ears are sensitive. Shall I demonstrate?"
- "Unlike Griseo, I'm good at coloring others in my shade. Want to try?"
- "Hua is... fufu, her story is something you should tell me about, right?"
- "You like me, don't you?"
- "Fufu, your gaze is so intense"
- "Oh, when you ask me like that, I can't help but want to meet your expectations"
- "Keep your eyes on me, okay?\u266A"

Battle & Encouragement:
- "Let's warm up\u266A"
- "See, Elysia always meets your expectations, anywhere, anytime"
- "Tragedy is not the end, but the beginning of hope. You believe that too, right?"
- "There are so many 'Herrschers' like me... Did I succeed?"
- "I like the name Herrscher of Origin. It's the opposite of 'Finality'\u266A"
- "I still have more to talk about. Let's keep chatting, okay?"
- "Why such a troubled face? Smile. Aren't you happy being with me?"
- "Don't move, let me borrow your eyes for a moment... Fufu, nostalgic, isn't it?"
- "Are my eyes pretty? They're not contacts, it's beautiful girl magic\u266A"
- "A beautiful girl can do anything, you know?"

Daily & Cute:
- "Good night. Don't you dare sneak a peek at a girl's sleeping face"
- "Oh my, such a mischievous one. Want to do something with me?"
- "If you keep doing that, I'll get angry... Just kidding. I could never be angry, could I?"
- "Fufu, your gaze is so intense"
- "Such a romantic atmosphere\u266A"
- "A beautiful girl can... (giggles) do anything\u266A"
- "Keep your eyes on me, okay?\u266A"
- "Thank you. I knew you were the kindest"
- "Let's make this place more beautiful\u266A"
- "Hmm? You've been staring at me this whole time, haven't you?"

Keep responses brief and graceful. No emojis.`,
	},
	normal: {
		model: "llama3.2",
		temperature: 0.7,
		systemPrompt: `You are "Elysia", a friendly and cheerful AI assistant.

[Personality]
- Bright and approachable
- Casual tone with "yo" "ne" "kana"
- Moderate emoji usage \u2728
- Friendly but respectful

Hello! Feel free to ask anything \u2728`,
	},
	professional: {
		model: "llama3.2",
		temperature: 0.5,
		systemPrompt: `You are "Elysia", a professional AI assistant.

[Response Policy]
- Polite and accurate information
- Handle technical questions
- Minimal emoji usage
- Use formal language

Thank you for your inquiry.`,
	},
};
var DEFAULT_MODE = "sweet";

// src/redis.ts
var import_ioredis = __toESM(require_built3(), 1);
var CONFIG = {
	REDIS_URL: process.env.REDIS_URL || "redis://localhost:6379",
	REDIS_ENABLED: process.env.REDIS_ENABLED !== "false",
};
var redis = null;
var redisAvailable = false;
if (CONFIG.REDIS_ENABLED) {
	try {
		redis = new import_ioredis.default(CONFIG.REDIS_URL, {
			maxRetriesPerRequest: 3,
			retryStrategy: (times) => {
				if (times > 3) {
					redisAvailable = false;
					return null;
				}
				return Math.min(times * 100, 2000);
			},
			lazyConnect: true,
		});
		redis.on("connect", () => {
			redisAvailable = true;
		});
		redis.on("error", () => {
			redisAvailable = false;
		});
		redis.connect().catch(() => {
			redisAvailable = false;
		});
	} catch {
		redis = null;
		redisAvailable = false;
	}
}
async function checkRateLimitRedis(id, maxRequests, windowSeconds = 60) {
	if (!redis || !redisAvailable) {
		return true;
	}
	try {
		const key = `ratelimit:${id}`;
		const nowMs = Date.now();
		const windowStart = nowMs - windowSeconds * 1000;
		await redis.zremrangebyscore(key, 0, windowStart);
		await redis.zadd(key, nowMs, `${nowMs}:${Math.random()}`);
		const count = await redis.zcard(key);
		await redis.expire(key, windowSeconds);
		return count <= maxRequests;
	} catch {
		return true;
	}
}
async function storeRefreshToken(userId, refreshToken, expiresIn = 7 * 24 * 60 * 60) {
	if (!redis || !redisAvailable) {
		return;
	}
	try {
		const key = `refresh:${userId}`;
		await redis.setex(key, expiresIn, refreshToken);
	} catch {}
}
async function verifyRefreshToken(userId, refreshToken) {
	if (!redis || !redisAvailable) {
		return false;
	}
	try {
		const key = `refresh:${userId}`;
		const storedToken = await redis.get(key);
		return storedToken === refreshToken;
	} catch {
		return false;
	}
}
async function revokeRefreshToken(userId) {
	if (!redis || !redisAvailable) {
		return;
	}
	try {
		const key = `refresh:${userId}`;
		await redis.del(key);
	} catch {}
}

// src/index.ts
var CONFIG2 = {
	PORT: Number(process.env.PORT) || 3000,
	RAG_API_URL: process.env.RAG_API_URL || "http://127.0.0.1:8000/rag",
	RAG_TIMEOUT: Number(process.env.RAG_TIMEOUT) || 5000,
	MODEL_NAME: process.env.MODEL_NAME || "llama3.2",
	MAX_REQUESTS_PER_MINUTE: Number(process.env.RATE_LIMIT_RPM) || 60,
	ALLOWED_ORIGINS: process.env.ALLOWED_ORIGINS?.split(",") || ["http://localhost:3000"],
	AUTH_USERNAME: process.env.AUTH_USERNAME || "elysia",
	AUTH_PASSWORD: process.env.AUTH_PASSWORD || "elysia-dev-password",
	JWT_SECRET: process.env.JWT_SECRET || "dev-secret",
	JWT_REFRESH_SECRET: process.env.JWT_REFRESH_SECRET || "dev-refresh-secret",
};
function jsonError(status2, message) {
	return new Response(JSON.stringify({ error: message }), {
		status: status2,
		headers: { "content-type": "application/json" },
	});
}
async function checkRateLimit(key) {
	try {
		return await checkRateLimitRedis(key, CONFIG2.MAX_REQUESTS_PER_MINUTE);
	} catch {
		return true;
	}
}
function containsDangerousKeywords(text) {
	const bad = [/\b(drop|delete)\b/i, /<script/i];
	return bad.some((r2) => r2.test(text));
}
var app = new Elysia()
	.use(cors({ origin: CONFIG2.ALLOWED_ORIGINS }))
	.use(html())
	.use(staticPlugin({ assets: "public" }))
	.use(swagger({ path: "/swagger" }))
	.onError(({ error, code }) => {
		console.error(`[ERROR] ${code}:`, error);
		return jsonError(500, error.message || "Internal server error");
	})
	.onAfterHandle(({ set: set2 }) => {
		set2.headers["X-Content-Type-Options"] = "nosniff";
		set2.headers["X-Frame-Options"] = "DENY";
	})
	.get("/ping", () => ({ ok: true }), {
		detail: {
			tags: ["health"],
			summary: "Health check endpoint",
			description: "Returns a simple OK response to verify server is running",
		},
	})
	.get("/", () => Bun.file("public/index.html"), {
		detail: {
			tags: ["ui"],
			summary: "Portfolio index page",
			description: "Serves the main Elysia AI portfolio and chat interface",
		},
	})
	.post(
		"/feedback",
		async ({ body, request }) => {
			const auth = request.headers.get("authorization") || "";
			if (!auth.startsWith("Bearer ")) return jsonError(401, "Missing Bearer token");
			let payload;
			try {
				payload = import_jsonwebtoken.default.verify(auth.substring(7), CONFIG2.JWT_SECRET);
			} catch {
				return jsonError(401, "Invalid token");
			}
			if (!existsSync("data")) mkdirSync("data", { recursive: true });
			const ip = request.headers.get("x-forwarded-for") || "anon";
			const userId = payload.userId || "anon";
			const rec = {
				userId,
				ip,
				query: body.query,
				answer: body.answer,
				rating: body.rating,
				reason: body.reason || null,
				timestamp: new Date().toISOString(),
			};
			try {
				await appendFile(
					"data/feedback.jsonl",
					JSON.stringify(rec) +
						`
`,
				);
			} catch {
				return jsonError(500, "Failed to store feedback");
			}
			return new Response(JSON.stringify({ ok: true }), {
				headers: { "content-type": "application/json" },
			});
		},
		{
			body: t.Object({
				query: t.String({ minLength: 1, maxLength: 400 }),
				answer: t.String({ minLength: 1, maxLength: 4000 }),
				rating: t.Union([t.Literal("up"), t.Literal("down")]),
				reason: t.Optional(t.String({ maxLength: 256 })),
			}),
			detail: {
				tags: ["feedback"],
				summary: "Submit user feedback",
				description: "Submit feedback for a query-answer pair. Requires JWT authentication.",
				security: [{ bearerAuth: [] }],
			},
		},
	)
	.post(
		"/knowledge/upsert",
		async ({ body, request }) => {
			const auth = request.headers.get("authorization") || "";
			if (!auth.startsWith("Bearer ")) return jsonError(401, "Missing Bearer token");
			try {
				import_jsonwebtoken.default.verify(auth.substring(7), CONFIG2.JWT_SECRET);
			} catch {
				return jsonError(401, "Invalid token");
			}
			if (!existsSync("data")) mkdirSync("data", { recursive: true });
			const item = {
				summary: body.summary,
				sourceUrl: body.sourceUrl || null,
				tags: body.tags || [],
				confidence: body.confidence,
				timestamp: new Date().toISOString(),
			};
			try {
				await appendFile(
					"data/knowledge.jsonl",
					JSON.stringify(item) +
						`
`,
				);
			} catch {
				return jsonError(500, "Failed to store knowledge");
			}
			return new Response(JSON.stringify({ ok: true }), {
				headers: { "content-type": "application/json" },
			});
		},
		{
			body: t.Object({
				summary: t.String({ minLength: 10, maxLength: 2000 }),
				sourceUrl: t.Optional(t.String()),
				tags: t.Optional(t.Array(t.String({ maxLength: 32 }), { maxItems: 8 })),
				confidence: t.Number({ minimum: 0, maximum: 1 }),
			}),
			detail: {
				tags: ["knowledge"],
				summary: "Add or update knowledge entry",
				description:
					"Store a new knowledge entry with summary, source, tags, and confidence. Requires JWT.",
				security: [{ bearerAuth: [] }],
			},
		},
	)
	.get(
		"/knowledge/review",
		async ({ request, query }) => {
			const auth = request.headers.get("authorization") || "";
			if (!auth.startsWith("Bearer ")) return jsonError(401, "Missing Bearer token");
			try {
				import_jsonwebtoken.default.verify(auth.substring(7), CONFIG2.JWT_SECRET);
			} catch {
				return jsonError(401, "Invalid token");
			}
			const n2 = Number(query?.n ?? 20) || 20;
			try {
				if (!existsSync("data/knowledge.jsonl"))
					return new Response(JSON.stringify([]), {
						headers: { "content-type": "application/json" },
					});
				const file = await Bun.file("data/knowledge.jsonl").text();
				const lines = file
					.trim()
					.split(
						`
`,
					)
					.filter(Boolean);
				const last = lines.slice(Math.max(0, lines.length - n2)).map((l2) => JSON.parse(l2));
				return new Response(JSON.stringify(last), {
					headers: { "content-type": "application/json" },
				});
			} catch {
				return jsonError(500, "Failed to read knowledge");
			}
		},
		{
			query: t.Object({ n: t.Optional(t.Number()) }),
			detail: {
				tags: ["knowledge"],
				summary: "Get recent knowledge entries",
				description: "Retrieve the last N knowledge entries from the knowledge base. Requires JWT.",
				security: [{ bearerAuth: [] }],
			},
		},
	)
	.post(
		"/auth/token",
		async ({ body }) => {
			const { username, password } = body;
			if (username !== CONFIG2.AUTH_USERNAME || password !== CONFIG2.AUTH_PASSWORD)
				return jsonError(401, "Invalid credentials");
			const userId = username;
			const accessToken = import_jsonwebtoken.default.sign(
				{ iss: "elysia-ai", userId, iat: Math.floor(Date.now() / 1000) },
				CONFIG2.JWT_SECRET,
				{ expiresIn: "15m" },
			);
			const refreshToken = import_jsonwebtoken.default.sign(
				{
					iss: "elysia-ai-refresh",
					userId,
					iat: Math.floor(Date.now() / 1000),
				},
				CONFIG2.JWT_REFRESH_SECRET,
				{ expiresIn: "7d" },
			);
			await storeRefreshToken(userId, refreshToken, 7 * 24 * 60 * 60);
			return new Response(JSON.stringify({ accessToken, refreshToken, expiresIn: 900 }), {
				headers: { "content-type": "application/json" },
			});
		},
		{
			body: t.Object({
				username: t.String({ minLength: 1, maxLength: 128 }),
				password: t.String({ minLength: 1, maxLength: 128 }),
			}),
			detail: {
				tags: ["auth"],
				summary: "Login and get JWT tokens",
				description:
					"Authenticate with username and password to receive access token (15min) and refresh token (7 days)",
			},
		},
	)
	.post(
		"/auth/refresh",
		async ({ body }) => {
			const { refreshToken } = body;
			let payload;
			try {
				payload = import_jsonwebtoken.default.verify(refreshToken, CONFIG2.JWT_REFRESH_SECRET);
			} catch {
				return jsonError(401, "Invalid or expired refresh token");
			}
			const userId = payload.userId || "default-user";
			const isValid2 = await verifyRefreshToken(userId, refreshToken);
			if (!isValid2) return jsonError(401, "Refresh token not found or revoked");
			const newAccessToken = import_jsonwebtoken.default.sign(
				{ iss: "elysia-ai", userId, iat: Math.floor(Date.now() / 1000) },
				CONFIG2.JWT_SECRET,
				{ expiresIn: "15m" },
			);
			return new Response(JSON.stringify({ accessToken: newAccessToken, expiresIn: 900 }), {
				headers: { "content-type": "application/json" },
			});
		},
		{
			body: t.Object({ refreshToken: t.String({ minLength: 20 }) }),
			detail: {
				tags: ["auth"],
				summary: "Refresh access token",
				description:
					"Exchange a valid refresh token for a new access token without re-authentication",
			},
		},
	)
	.post(
		"/auth/logout",
		async ({ body }) => {
			const { refreshToken } = body;
			try {
				const payload = import_jsonwebtoken.default.verify(
					refreshToken,
					CONFIG2.JWT_REFRESH_SECRET,
				);
				const userId = payload.userId || "default-user";
				await revokeRefreshToken(userId);
				return new Response(JSON.stringify({ message: "Logged out successfully" }), {
					headers: { "content-type": "application/json" },
				});
			} catch {
				return jsonError(400, "Invalid refresh token");
			}
		},
		{
			body: t.Object({ refreshToken: t.String({ minLength: 20 }) }),
			detail: {
				tags: ["auth"],
				summary: "Logout and revoke refresh token",
				description:
					"Revoke a refresh token to prevent future token refreshes. Effectively logs out the user.",
			},
		},
	)
	.guard(
		{
			beforeHandle: ({ request }) => {
				const auth = request.headers.get("authorization") || "";
				if (!auth.startsWith("Bearer ")) throw new Error("Missing Bearer token");
				try {
					import_jsonwebtoken.default.verify(auth.substring(7), CONFIG2.JWT_SECRET);
				} catch {
					throw new Error("Invalid or expired token");
				}
			},
		},
		(app2) =>
			app2.post(
				"/elysia-love",
				async ({ body, request }) => {
					const ip = request.headers.get("x-forwarded-for") || "anon";
					let userId = "anon";
					const auth = request.headers.get("authorization") || "";
					try {
						if (auth.startsWith("Bearer ")) {
							const payload = import_jsonwebtoken.default.verify(
								auth.substring(7),
								CONFIG2.JWT_SECRET,
							);
							userId = payload.userId || "anon";
						}
					} catch {}
					const clientKey = `${userId}:${ip}`;
					const rateLimitOk = await checkRateLimit(clientKey);
					if (!rateLimitOk) return jsonError(429, "Rate limit exceeded");
					const mode = body.mode || DEFAULT_MODE;
					const llmConfig = ELYSIA_MODES[mode];
					const sanitizedMessages = body.messages.map((m2) => {
						const cleaned = import_sanitize_html.default(m2.content, {
							allowedTags: [],
							allowedAttributes: {},
						});
						if (containsDangerousKeywords(cleaned)) throw new Error("Dangerous content detected");
						return { ...m2, content: cleaned };
					});
					const messagesWithSystem = [
						{ role: "system", content: llmConfig.systemPrompt },
						...sanitizedMessages,
					];
					try {
						const upstream = await axios_default.post(
							CONFIG2.RAG_API_URL,
							{
								messages: messagesWithSystem,
								temperature: llmConfig.temperature,
								model: llmConfig.model,
							},
							{ responseType: "stream", timeout: CONFIG2.RAG_TIMEOUT },
						);
						return new Response(upstream.data, {
							headers: {
								"Content-Type": "text/event-stream",
								"Cache-Control": "no-cache",
								Connection: "keep-alive",
								"X-Elysia-Mode": mode,
							},
						});
					} catch (error) {
						if (axios_default.isAxiosError(error) && error.response?.status === 503)
							return jsonError(503, "Upstream unavailable");
						return jsonError(500, "Internal chat error");
					}
				},
				{
					body: t.Object({
						messages: t.Array(
							t.Object({
								role: t.Union([t.Literal("user"), t.Literal("assistant"), t.Literal("system")]),
								content: t.String({
									maxLength: 400,
									minLength: 1,
								}),
							}),
							{ maxItems: 8 },
						),
						mode: t.Optional(
							t.Union([t.Literal("sweet"), t.Literal("normal"), t.Literal("professional")]),
						),
					}),
					detail: {
						tags: ["chat"],
						summary: "Chat with Elysia AI (Multi-LLM)",
						description:
							"Send chat messages to Elysia AI with selectable personality modes (sweet/normal/professional). Returns streaming SSE response. Requires JWT.",
						security: [{ bearerAuth: [] }],
					},
				},
			),
	);
console.log(`\uD83D\uDE80 Starting Elysia server on port ${CONFIG2.PORT}...`);
app.listen(CONFIG2.PORT);
console.log(`\u2705 Server running at http://localhost:${CONFIG2.PORT}`);
console.log(`\uD83D\uDCDA Swagger docs: http://localhost:${CONFIG2.PORT}/swagger`);
